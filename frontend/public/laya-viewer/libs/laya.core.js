window.Laya = (function (exports) {
    'use strict';

    class Config {
    }
    Config.isAntialias = true;
    Config.useWebGL2 = true;
    Config.useSPRIV = false;
    Config.matUseUBO = true;
    Config.enableUniformBufferObject = true;
    Config.FPS = 60;
    Config.useRetinalCanvas = false;
    Config.animationInterval = 50;
    Config.webGL2D_MeshAllocMaxMem = true;
    Config.defaultFontSize = 12;
    Config.defaultFont = "Arial";
    Config.isAlpha = false;
    Config.isDepth = false;
    Config.isfailIfMajorPerformanceCaveat = false;
    Config.powerPreference = "default";
    Config.premultipliedAlpha = true;
    Config.isStencil = true;
    Config.preserveDrawingBuffer = false;
    Config.printWebglOrder = false;
    Config.fontFamilyMap = { "报隶": "报隶-简", "黑体": "黑体-简", "楷体": "楷体-简", "兰亭黑": "兰亭黑-简", "隶变": "隶变-简", "凌慧体": "凌慧体-简", "翩翩体": "翩翩体-简", "苹方": "苹方-简", "手札体": "手札体-简", "宋体": "宋体-简", "娃娃体": "娃娃体-简", "魏碑": "魏碑-简", "行楷": "行楷-简", "雅痞": "雅痞-简", "圆体": "圆体-简" };
    Config.fixedFrames = true;
    Config.destroyResourceImmediatelyDefault = true;
    Config.audioBufferCacheMaxSize = 5 * 1024 * 1024;
    const PlayerConfig = {};

    class MathUtils3D {
        static isZero(v) {
            return Math.abs(v) < MathUtils3D.zeroTolerance;
        }
        static nearEqual(n1, n2) {
            return MathUtils3D.isZero(n1 - n2);
        }
        static fastInvSqrt(value) {
            if (MathUtils3D.isZero(value))
                return value;
            return 1.0 / Math.sqrt(value);
        }
    }
    MathUtils3D.zeroTolerance = 1e-6;
    MathUtils3D.MaxValue = 3.40282347e+38;
    MathUtils3D.MinValue = -3.40282347e+38;
    MathUtils3D.Deg2Rad = Math.PI / 180;

    class Vector4 {
        constructor(x = 0, y = 0, z = 0, w = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        setValue(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        }
        fromArray(arr, offset = 0) {
            this.x = arr[offset + 0];
            this.y = arr[offset + 1];
            this.z = arr[offset + 2];
            this.w = arr[offset + 3];
            return this;
        }
        toArray() {
            return [this.x, this.y, this.z, this.w];
        }
        writeTo(arr, offset = 0) {
            arr[offset + 0] = this.x;
            arr[offset + 1] = this.y;
            arr[offset + 2] = this.z;
            arr[offset + 3] = this.w;
            return this;
        }
        cloneTo(destObject) {
            destObject.x = this.x;
            destObject.y = this.y;
            destObject.z = this.z;
            destObject.w = this.w;
            return destObject;
        }
        clone() {
            var destVector4 = new Vector4();
            this.cloneTo(destVector4);
            return destVector4;
        }
        static lerp(a, b, t, out) {
            var ax = a.x, ay = a.y, az = a.z, aw = a.w;
            out.x = ax + t * (b.x - ax);
            out.y = ay + t * (b.y - ay);
            out.z = az + t * (b.z - az);
            out.w = aw + t * (b.w - aw);
        }
        static transformByM4x4(vector4, m4x4, out) {
            var vx = vector4.x;
            var vy = vector4.y;
            var vz = vector4.z;
            var vw = vector4.w;
            var me = m4x4.elements;
            out.x = vx * me[0] + vy * me[4] + vz * me[8] + vw * me[12];
            out.y = vx * me[1] + vy * me[5] + vz * me[9] + vw * me[13];
            out.z = vx * me[2] + vy * me[6] + vz * me[10] + vw * me[14];
            out.w = vx * me[3] + vy * me[7] + vz * me[11] + vw * me[15];
        }
        static equals(a, b) {
            return MathUtils3D.nearEqual(a.x, b.x) && MathUtils3D.nearEqual(a.y, b.y) && MathUtils3D.nearEqual(a.z, b.z) && MathUtils3D.nearEqual(a.w, b.w);
        }
        equal(value) {
            return Vector4.equals(this, value);
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        lengthSquared() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        static normalize(s, out) {
            var len = s.length();
            if (len > 0) {
                var inverse = 1.0 / len;
                out.x = s.x * inverse;
                out.y = s.y * inverse;
                out.z = s.z * inverse;
                out.w = s.w * inverse;
            }
        }
        static add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
            out.z = a.z + b.z;
            out.w = a.w + b.w;
        }
        static subtract(a, b, out) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
            out.z = a.z - b.z;
            out.w = a.w - b.w;
        }
        static multiply(a, b, out) {
            out.x = a.x * b.x;
            out.y = a.y * b.y;
            out.z = a.z * b.z;
            out.w = a.w * b.w;
        }
        static scale(a, b, out) {
            out.x = a.x * b;
            out.y = a.y * b;
            out.z = a.z * b;
            out.w = a.w * b;
        }
        static Clamp(value, min, max, out) {
            var x = value.x;
            var y = value.y;
            var z = value.z;
            var w = value.w;
            var mineX = min.x;
            var mineY = min.y;
            var mineZ = min.z;
            var mineW = min.w;
            var maxeX = max.x;
            var maxeY = max.y;
            var maxeZ = max.z;
            var maxeW = max.w;
            x = (x > maxeX) ? maxeX : x;
            x = (x < mineX) ? mineX : x;
            y = (y > maxeY) ? maxeY : y;
            y = (y < mineY) ? mineY : y;
            z = (z > maxeZ) ? maxeZ : z;
            z = (z < mineZ) ? mineZ : z;
            w = (w > maxeW) ? maxeW : w;
            w = (w < mineW) ? mineW : w;
            out.x = x;
            out.y = y;
            out.z = z;
            out.w = w;
        }
        static distanceSquared(value1, value2) {
            var x = value1.x - value2.x;
            var y = value1.y - value2.y;
            var z = value1.z - value2.z;
            var w = value1.w - value2.w;
            return (x * x) + (y * y) + (z * z) + (w * w);
        }
        static distance(value1, value2) {
            var x = value1.x - value2.x;
            var y = value1.y - value2.y;
            var z = value1.z - value2.z;
            var w = value1.w - value2.w;
            return Math.sqrt((x * x) + (y * y) + (z * z) + (w * w));
        }
        static dot(a, b) {
            return (a.x * b.x) + (a.y * b.y) + (a.z * b.z) + (a.w * b.w);
        }
        static min(a, b, out) {
            out.x = Math.min(a.x, b.x);
            out.y = Math.min(a.y, b.y);
            out.z = Math.min(a.z, b.z);
            out.w = Math.min(a.w, b.w);
        }
        static max(a, b, out) {
            out.x = Math.max(a.x, b.x);
            out.y = Math.max(a.y, b.y);
            out.z = Math.max(a.z, b.z);
            out.w = Math.max(a.w, b.w);
        }
    }
    Vector4.ZERO = new Vector4();
    Vector4.ONE = new Vector4(1.0, 1.0, 1.0, 1.0);
    Vector4.UnitX = new Vector4(1.0, 0.0, 0.0, 0.0);
    Vector4.UnitY = new Vector4(0.0, 1.0, 0.0, 0.0);
    Vector4.UnitZ = new Vector4(0.0, 0.0, 1.0, 0.0);
    Vector4.UnitW = new Vector4(0.0, 0.0, 0.0, 1.0);
    Vector4.TEMP = new Vector4(0.0, 0.0, 0.0, 0.0);

    class Vector3 {
        static distanceSquared(value1, value2) {
            var x = value1.x - value2.x;
            var y = value1.y - value2.y;
            var z = value1.z - value2.z;
            return (x * x) + (y * y) + (z * z);
        }
        static distance(value1, value2) {
            var x = value1.x - value2.x;
            var y = value1.y - value2.y;
            var z = value1.z - value2.z;
            return Math.sqrt((x * x) + (y * y) + (z * z));
        }
        static min(a, b, out) {
            out.x = Math.min(a.x, b.x);
            out.y = Math.min(a.y, b.y);
            out.z = Math.min(a.z, b.z);
        }
        static max(a, b, out) {
            out.x = Math.max(a.x, b.x);
            out.y = Math.max(a.y, b.y);
            out.z = Math.max(a.z, b.z);
        }
        static transformQuat(source, rotation, out) {
            var x = source.x, y = source.y, z = source.z, qx = rotation.x, qy = rotation.y, qz = rotation.z, qw = rotation.w, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
            out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        }
        static scalarLength(a) {
            var x = a.x, y = a.y, z = a.z;
            return Math.sqrt(x * x + y * y + z * z);
        }
        static scalarLengthSquared(a) {
            var x = a.x, y = a.y, z = a.z;
            return x * x + y * y + z * z;
        }
        static normalize(s, out) {
            var x = s.x, y = s.y, z = s.z;
            var len = x * x + y * y + z * z;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out.x = x * len;
                out.y = y * len;
                out.z = z * len;
            }
        }
        static multiply(a, b, out) {
            out.x = a.x * b.x;
            out.y = a.y * b.y;
            out.z = a.z * b.z;
        }
        static scale(a, b, out) {
            out.x = a.x * b;
            out.y = a.y * b;
            out.z = a.z * b;
        }
        static lerp(a, b, t, out) {
            var ax = a.x, ay = a.y, az = a.z;
            out.x = ax + t * (b.x - ax);
            out.y = ay + t * (b.y - ay);
            out.z = az + t * (b.z - az);
        }
        static transformV3ToV3(vector, transform, result) {
            Vector3.transformV3ToV4(vector, transform, _tempVector4);
            result.x = _tempVector4.x;
            result.y = _tempVector4.y;
            result.z = _tempVector4.z;
        }
        static transformV3ToV4(vector, transform, result) {
            var vectorX = vector.x;
            var vectorY = vector.y;
            var vectorZ = vector.z;
            var transformElem = transform.elements;
            result.x = (vectorX * transformElem[0]) + (vectorY * transformElem[4]) + (vectorZ * transformElem[8]) + transformElem[12];
            result.y = (vectorX * transformElem[1]) + (vectorY * transformElem[5]) + (vectorZ * transformElem[9]) + transformElem[13];
            result.z = (vectorX * transformElem[2]) + (vectorY * transformElem[6]) + (vectorZ * transformElem[10]) + transformElem[14];
            result.w = (vectorX * transformElem[3]) + (vectorY * transformElem[7]) + (vectorZ * transformElem[11]) + transformElem[15];
        }
        static TransformNormal(normal, transform, result) {
            var normalX = normal.x;
            var normalY = normal.y;
            var normalZ = normal.z;
            var transformElem = transform.elements;
            result.x = (normalX * transformElem[0]) + (normalY * transformElem[4]) + (normalZ * transformElem[8]);
            result.y = (normalX * transformElem[1]) + (normalY * transformElem[5]) + (normalZ * transformElem[9]);
            result.z = (normalX * transformElem[2]) + (normalY * transformElem[6]) + (normalZ * transformElem[10]);
        }
        static transformCoordinate(coordinate, transform, result) {
            var coordinateX = coordinate.x;
            var coordinateY = coordinate.y;
            var coordinateZ = coordinate.z;
            var transformElem = transform.elements;
            var w = coordinateX * transformElem[3] + coordinateY * transformElem[7] + coordinateZ * transformElem[11] + transformElem[15];
            result.x = (coordinateX * transformElem[0] + coordinateY * transformElem[4] + coordinateZ * transformElem[8] + transformElem[12]) / w;
            result.y = (coordinateX * transformElem[1] + coordinateY * transformElem[5] + coordinateZ * transformElem[9] + transformElem[13]) / w;
            result.z = (coordinateX * transformElem[2] + coordinateY * transformElem[6] + coordinateZ * transformElem[10] + transformElem[14]) / w;
        }
        static Clamp(value, min, max, out) {
            var x = value.x;
            var y = value.y;
            var z = value.z;
            var mineX = min.x;
            var mineY = min.y;
            var mineZ = min.z;
            var maxeX = max.x;
            var maxeY = max.y;
            var maxeZ = max.z;
            x = (x > maxeX) ? maxeX : x;
            x = (x < mineX) ? mineX : x;
            y = (y > maxeY) ? maxeY : y;
            y = (y < mineY) ? mineY : y;
            z = (z > maxeZ) ? maxeZ : z;
            z = (z < mineZ) ? mineZ : z;
            out.x = x;
            out.y = y;
            out.z = z;
        }
        static add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
            out.z = a.z + b.z;
        }
        static subtract(a, b, o) {
            o.x = a.x - b.x;
            o.y = a.y - b.y;
            o.z = a.z - b.z;
        }
        static cross(a, b, o) {
            var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
            o.x = ay * bz - az * by;
            o.y = az * bx - ax * bz;
            o.z = ax * by - ay * bx;
        }
        static dot(a, b) {
            return (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
        }
        static equals(a, b) {
            return MathUtils3D.nearEqual(a.x, b.x) && MathUtils3D.nearEqual(a.y, b.y) && MathUtils3D.nearEqual(a.z, b.z);
        }
        constructor(x = 0, y = 0, z = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
        equal(value) {
            return Vector3.equals(this, value);
        }
        setValue(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        set(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        fromArray(arr, offset = 0) {
            this.x = arr[offset + 0];
            this.y = arr[offset + 1];
            this.z = arr[offset + 2];
        }
        toArray() {
            return [this.x, this.y, this.z];
        }
        writeTo(arr, offset = 0) {
            arr[offset + 0] = this.x;
            arr[offset + 1] = this.y;
            arr[offset + 2] = this.z;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        lengthSquared() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        vsub(b, out) {
            out.x = this.x - b.x;
            out.y = this.y - b.y;
            out.z = this.z - b.z;
            return out;
        }
        vadd(b, out) {
            out.x = this.x + b.x;
            out.y = this.y + b.y;
            out.z = this.z + b.z;
            return out;
        }
        scale(s, out) {
            out.x = this.x * s;
            out.y = this.y * s;
            out.z = this.z * s;
            return out;
        }
        normalize() {
            let x = this.x, y = this.y, z = this.z;
            var len = x * x + y * y + z * z;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                this.x = x * len;
                this.y = y * len;
                this.z = z * len;
            }
            return this;
        }
        dot(b) {
            return (this.x * b.x) + (this.y * b.y) + (this.z * b.z);
        }
        cross(b, o) {
            var ax = this.x, ay = this.y, az = this.z, bx = b.x, by = b.y, bz = b.z;
            o.x = ay * bz - az * by;
            o.y = az * bx - ax * bz;
            o.z = ax * by - ay * bx;
            return o;
        }
        cloneTo(destObject) {
            destObject.x = this.x;
            destObject.y = this.y;
            destObject.z = this.z;
            return destObject;
        }
        clone() {
            var destVector3 = new Vector3();
            this.cloneTo(destVector3);
            return destVector3;
        }
        toDefault() {
            this.x = 0;
            this.y = 0;
            this.z = 0;
        }
    }
    Vector3.ZERO = new Vector3(0.0, 0.0, 0.0);
    Vector3.ONE = new Vector3(1.0, 1.0, 1.0);
    Vector3.NegativeUnitX = new Vector3(-1, 0, 0);
    Vector3.UnitX = new Vector3(1, 0, 0);
    Vector3.UnitY = new Vector3(0, 1, 0);
    Vector3.UnitZ = new Vector3(0, 0, 1);
    Vector3.ForwardRH = new Vector3(0, 0, -1);
    Vector3.ForwardLH = new Vector3(0, 0, 1);
    Vector3.Up = new Vector3(0, 1, 0);
    Vector3.TEMP = new Vector3();
    const _tempVector4 = new Vector4();

    class Config3D {
        static setResolution(width, height) {
            Config3D.customResolution = true;
            Config3D._resoluWidth = width;
            Config3D._resoluHeight = height;
        }
    }
    Config3D.enableDynamicBatch = true;
    Config3D.enableStaticBatch = true;
    Config3D.pixelRatio = 1;
    Config3D.customResolution = false;
    Config3D.defaultCacheRTMemory = 256;
    Config3D.defaultPhysicsMemory = 16;
    Config3D.enableMultiLight = true;
    Config3D.maxLightCount = 32;
    Config3D.lightClusterCount = new Vector3(12, 12, 12);
    Config3D.maxMorphTargetCount = 32;
    Config3D.useBVHCull = false;
    Config3D.BVH_max_SpatialCount = 7;
    Config3D.BVH_limit_size = 32;
    Config3D.BVH_Min_Build_nums = 10;
    Config3D._resoluWidth = -1;
    Config3D._resoluHeight = -1;
    Config3D.debugFrustumCulling = false;

    class ILaya {
    }
    ILaya.Laya = null;
    ILaya.Loader = null;
    ILaya.InputManager = null;
    ILaya.Scene3D = null;
    ILaya.Laya3D = null;
    ILaya.loader = null;
    ILaya.timer = null;
    ILaya.systemTimer = null;
    ILaya.physicsTimer = null;
    ILaya.stage = null;

    class Pool {
        static getPoolBySign(sign) {
            return Pool._poolDic[sign] || (Pool._poolDic[sign] = []);
        }
        static clearBySign(sign) {
            if (Pool._poolDic[sign])
                Pool._poolDic[sign].length = 0;
        }
        static recover(sign, item) {
            if (item[Pool.POOLSIGN])
                return;
            item[Pool.POOLSIGN] = true;
            Pool.getPoolBySign(sign).push(item);
        }
        static recoverByClass(instance) {
            if (instance) {
                var className = instance["__className"] || instance.constructor._$gid;
                if (className)
                    Pool.recover(className, instance);
            }
        }
        static _getClassSign(cla) {
            var className = cla["__className"] || cla["_$gid"];
            if (!className) {
                cla["_$gid"] = className = Pool._CLSID + "";
                Pool._CLSID++;
            }
            return className;
        }
        static createByClass(cls) {
            return Pool.getItemByClass(Pool._getClassSign(cls), cls);
        }
        static getItemByClass(sign, cls) {
            let rst;
            let pool = Pool.getPoolBySign(sign);
            if (pool.length)
                rst = pool.pop();
            else
                rst = new cls();
            rst[Pool.POOLSIGN] = false;
            return rst;
        }
        static getItemByCreateFun(sign, createFun, caller = null) {
            var pool = Pool.getPoolBySign(sign);
            var rst = pool.length ? pool.pop() : createFun.call(caller);
            rst[Pool.POOLSIGN] = false;
            return rst;
        }
        static getItem(sign) {
            var pool = Pool.getPoolBySign(sign);
            var rst = pool.length ? pool.pop() : null;
            if (rst) {
                rst[Pool.POOLSIGN] = false;
            }
            return rst;
        }
        static createPool(type, init, reset) {
            let p = new SimplePool();
            p._ct = type;
            p._init = init;
            p._reset = reset;
            return p;
        }
        static createPool2(create, init, reset) {
            let p = new SimplePool();
            p._create = create;
            p._init = init;
            p._reset = reset;
            return p;
        }
    }
    Pool._CLSID = 0;
    Pool.POOLSIGN = "__InPool";
    Pool._poolDic = {};
    class SimplePool {
        constructor() {
            this.pool = [];
        }
        take(...args) {
            let ret;
            if (this.pool.length > 0)
                ret = this.pool.pop();
            else if (this._create)
                ret = this._create();
            else
                ret = new this._ct();
            if (this._init)
                this._init(ret, ...args);
            return ret;
        }
        recover(element) {
            if (Array.isArray(element)) {
                for (let i = 0, n = element.length; i < n; i++) {
                    let e = element[i];
                    if (this._reset)
                        this._reset(e);
                    this.pool.push(e);
                }
                element.length = 0;
            }
            else {
                if (this._reset)
                    this._reset(element);
                this.pool.push(element);
            }
        }
    }

    class Point {
        constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }
        static create() {
            return Pool.getItemByClass("Point", Point);
        }
        setTo(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }
        reset() {
            this.x = this.y = 0;
            return this;
        }
        recover() {
            Pool.recover("Point", this.reset());
        }
        distance(x, y) {
            return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y) * (this.y - y));
        }
        toString() {
            return this.x + "," + this.y;
        }
        normalize() {
            var d = Math.sqrt(this.x * this.x + this.y * this.y);
            if (d > 0) {
                var id = 1.0 / d;
                this.x *= id;
                this.y *= id;
            }
        }
        copy(point) {
            return this.setTo(point.x, point.y);
        }
    }
    Point.TEMP = new Point();
    Point.EMPTY = new Point();

    class Event {
        static isMouseEvent(type) {
            return MOUSE_EVENTS.has(type);
        }
        constructor() {
            this.touchId = 0;
            this.delta = 0;
            this.button = 0;
            this.touchPos = new Point();
        }
        setTo(type, currentTarget, target) {
            this.type = type;
            this.currentTarget = currentTarget;
            this.target = target;
            return this;
        }
        stopPropagation() {
            this._stopped = true;
        }
        preventDefault() {
            this._defaultPrevented = true;
        }
        get touches() {
            return this._touches;
        }
        get altKey() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.altKey;
        }
        get ctrlKey() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.ctrlKey;
        }
        get shiftKey() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.shiftKey;
        }
        get metaKey() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.metaKey;
        }
        get key() {
            return this.nativeEvent.key;
        }
        get keyCode() {
            return this.nativeEvent.keyCode;
        }
        get charCode() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.code;
        }
        get keyLocation() {
            if (this.nativeEvent)
                return this.nativeEvent.location || this.nativeEvent.keyLocation;
            else
                return 0;
        }
        get stageX() {
            return this.touchPos.x;
        }
        get stageY() {
            return this.touchPos.y;
        }
    }
    Event.EMPTY = new Event();
    Event.MOUSE_DOWN = "mousedown";
    Event.MOUSE_UP = "mouseup";
    Event.RIGHT_MOUSE_DOWN = "rightmousedown";
    Event.RIGHT_MOUSE_UP = "rightmouseup";
    Event.CLICK = "click";
    Event.RIGHT_CLICK = "rightclick";
    Event.MOUSE_MOVE = "mousemove";
    Event.MOUSE_OVER = "mouseover";
    Event.MOUSE_OUT = "mouseout";
    Event.MOUSE_WHEEL = "mousewheel";
    Event.ROLL_OVER = "mouseover";
    Event.ROLL_OUT = "mouseout";
    Event.DOUBLE_CLICK = "doubleclick";
    Event.MOUSE_DRAG = "mousedrag";
    Event.MOUSE_DRAG_END = "mousedragend";
    Event.DRAG_START = "dragstart";
    Event.DRAG_MOVE = "dragmove";
    Event.DRAG_END = "dragend";
    Event.DROP = "drop";
    Event.KEY_DOWN = "keydown";
    Event.KEY_PRESS = "keypress";
    Event.KEY_UP = "keyup";
    Event.CHANGE = "change";
    Event.CHANGED = "changed";
    Event.MOVED = "moved";
    Event.WILL_RESIZE = "willResize";
    Event.RESIZE = "resize";
    Event.ADDED = "added";
    Event.REMOVED = "removed";
    Event.DISPLAY = "display";
    Event.UNDISPLAY = "undisplay";
    Event.ERROR = "error";
    Event.COMPLETE = "complete";
    Event.LOADED = "loaded";
    Event.READY = "ready";
    Event.PROGRESS = "progress";
    Event.INPUT = "input";
    Event.RENDER = "render";
    Event.OPEN = "open";
    Event.MESSAGE = "message";
    Event.CLOSE = "close";
    Event.FRAME = "enterframe";
    Event.ENTER = "enter";
    Event.SELECT = "select";
    Event.BLUR = "blur";
    Event.FOCUS = "focus";
    Event.VISIBILITY_CHANGE = "visibilitychange";
    Event.ORIENTATION_CHANGE = "orientationchange";
    Event.FOCUS_CHANGE = "focuschange";
    Event.PLAYED = "played";
    Event.PAUSED = "paused";
    Event.STOPPED = "stopped";
    Event.START = "start";
    Event.END = "end";
    Event.LINK = "link";
    Event.LABEL = "label";
    Event.FULL_SCREEN_CHANGE = "fullscreenchange";
    Event.DEVICE_LOST = "devicelost";
    Event.TRANSFORM_CHANGED = "transformchanged";
    Event.LAYER_CHANGE = "layerChange";
    Event.STATIC_MASK = "staticMask";
    Event.TRIGGER_ENTER = "triggerenter";
    Event.TRIGGER_STAY = "triggerstay";
    Event.TRIGGER_EXIT = "triggerexit";
    Event.COLLISION_ENTER = "collisionenter";
    Event.COLLISION_STAY = "collisionstay";
    Event.COLLISION_EXIT = "collisionexit";
    Event.JOINT_BREAK = "jointbreak";
    Event.UPDATE_PHY_EVENT_FILTER = "physics3dEventFilter";
    const MOUSE_EVENTS = new Set([
        Event.MOUSE_DOWN, Event.MOUSE_UP, Event.MOUSE_MOVE, Event.CLICK, Event.DOUBLE_CLICK,
        Event.RIGHT_CLICK, Event.RIGHT_MOUSE_DOWN, Event.RIGHT_MOUSE_UP,
        Event.MOUSE_OVER, Event.MOUSE_OUT, Event.MOUSE_WHEEL, Event.MOUSE_DRAG, Event.MOUSE_DRAG_END
    ]);

    class LayaEnv {
    }
    LayaEnv.version = "3.3.4";
    LayaEnv.isPlaying = true;
    LayaEnv.isPreview = false;
    LayaEnv.isConch = window ? (window.conch != null) : false;
    LayaEnv.isEditor = false;

    exports.StatElement = void 0;
    (function (StatElement) {
        StatElement[StatElement["CT_FPS"] = 0] = "CT_FPS";
        StatElement[StatElement["T_Frame_Time"] = 1] = "T_Frame_Time";
        StatElement[StatElement["T_AllRender3D"] = 2] = "T_AllRender3D";
        StatElement[StatElement["T_DepthPass"] = 3] = "T_DepthPass";
        StatElement[StatElement["T_ShadowPass"] = 4] = "T_ShadowPass";
        StatElement[StatElement["T_3DMainPass"] = 5] = "T_3DMainPass";
        StatElement[StatElement["T_3DContextPre"] = 6] = "T_3DContextPre";
        StatElement[StatElement["T_3DContextRender"] = 7] = "T_3DContextRender";
        StatElement[StatElement["T_3DMainPass_Opaque"] = 8] = "T_3DMainPass_Opaque";
        StatElement[StatElement["T_3DMainPass_Trans"] = 9] = "T_3DMainPass_Trans";
        StatElement[StatElement["T_3DBatchTime"] = 10] = "T_3DBatchTime";
        StatElement[StatElement["T_CullMain"] = 11] = "T_CullMain";
        StatElement[StatElement["T_CullShadow"] = 12] = "T_CullShadow";
        StatElement[StatElement["T_Render_PostProcess"] = 13] = "T_Render_PostProcess";
        StatElement[StatElement["T_AllRender2D"] = 14] = "T_AllRender2D";
        StatElement[StatElement["T_2DPass"] = 15] = "T_2DPass";
        StatElement[StatElement["T_2DContextPre"] = 16] = "T_2DContextPre";
        StatElement[StatElement["T_2DContextRender"] = 17] = "T_2DContextRender";
        StatElement[StatElement["T_ScriptUpdateTime"] = 18] = "T_ScriptUpdateTime";
        StatElement[StatElement["T_ScriptLateUpdateTime"] = 19] = "T_ScriptLateUpdateTime";
        StatElement[StatElement["CT_OpaqueDrawCall"] = 20] = "CT_OpaqueDrawCall";
        StatElement[StatElement["CT_TransDrawCall"] = 21] = "CT_TransDrawCall";
        StatElement[StatElement["CT_DepthCastDrawCall"] = 22] = "CT_DepthCastDrawCall";
        StatElement[StatElement["CT_ShadowDrawCall"] = 23] = "CT_ShadowDrawCall";
        StatElement[StatElement["CT_2DDrawCall"] = 24] = "CT_2DDrawCall";
        StatElement[StatElement["CT_3DDrawCall"] = 25] = "CT_3DDrawCall";
        StatElement[StatElement["CT_DrawCall"] = 26] = "CT_DrawCall";
        StatElement[StatElement["CT_IndirectDrawCall"] = 27] = "CT_IndirectDrawCall";
        StatElement[StatElement["CT_Instancing_DrawCall"] = 28] = "CT_Instancing_DrawCall";
        StatElement[StatElement["M_GPUBuffer"] = 29] = "M_GPUBuffer";
        StatElement[StatElement["C_GPUBuffer"] = 30] = "C_GPUBuffer";
        StatElement[StatElement["M_VertexBuffer"] = 31] = "M_VertexBuffer";
        StatElement[StatElement["C_VertexBuffer"] = 32] = "C_VertexBuffer";
        StatElement[StatElement["M_IndexBuffer"] = 33] = "M_IndexBuffer";
        StatElement[StatElement["C_IndexBuffer"] = 34] = "C_IndexBuffer";
        StatElement[StatElement["M_UBOBuffer"] = 35] = "M_UBOBuffer";
        StatElement[StatElement["C_UBOBuffer"] = 36] = "C_UBOBuffer";
        StatElement[StatElement["M_DeviceBuffer"] = 37] = "M_DeviceBuffer";
        StatElement[StatElement["C_DeviceBuffer"] = 38] = "C_DeviceBuffer";
        StatElement[StatElement["M_AllTexture"] = 39] = "M_AllTexture";
        StatElement[StatElement["C_AllTexture"] = 40] = "C_AllTexture";
        StatElement[StatElement["M_Texture2D"] = 41] = "M_Texture2D";
        StatElement[StatElement["C_Texture2D"] = 42] = "C_Texture2D";
        StatElement[StatElement["M_TextureCube"] = 43] = "M_TextureCube";
        StatElement[StatElement["C_TextureCube"] = 44] = "C_TextureCube";
        StatElement[StatElement["M_Texture3D"] = 45] = "M_Texture3D";
        StatElement[StatElement["C_Texture3D"] = 46] = "C_Texture3D";
        StatElement[StatElement["M_Texture2DArray"] = 47] = "M_Texture2DArray";
        StatElement[StatElement["C_Texture2DArray"] = 48] = "C_Texture2DArray";
        StatElement[StatElement["M_RenderTexture"] = 49] = "M_RenderTexture";
        StatElement[StatElement["C_RenderTexture"] = 50] = "C_RenderTexture";
        StatElement[StatElement["M_GPUMemory"] = 51] = "M_GPUMemory";
        StatElement[StatElement["CT_ShaderChange"] = 52] = "CT_ShaderChange";
        StatElement[StatElement["CT_Triangle"] = 53] = "CT_Triangle";
        StatElement[StatElement["CT_BufferUploadCount"] = 54] = "CT_BufferUploadCount";
        StatElement[StatElement["CT_GeometryBufferUploadCount"] = 55] = "CT_GeometryBufferUploadCount";
        StatElement[StatElement["CT_UBOBufferUploadCount"] = 56] = "CT_UBOBufferUploadCount";
        StatElement[StatElement["CT_UBOBufferUploadMemory"] = 57] = "CT_UBOBufferUploadMemory";
        StatElement[StatElement["C_Sprite2DCount"] = 58] = "C_Sprite2DCount";
        StatElement[StatElement["C_Sprite3DCount"] = 59] = "C_Sprite3DCount";
        StatElement[StatElement["C_BaseRenderCount"] = 60] = "C_BaseRenderCount";
        StatElement[StatElement["C_MeshRenderCount"] = 61] = "C_MeshRenderCount";
        StatElement[StatElement["C_SkinnedMeshRenderCount"] = 62] = "C_SkinnedMeshRenderCount";
        StatElement[StatElement["C_ShurikenParticleRenderCount"] = 63] = "C_ShurikenParticleRenderCount";
        StatElement[StatElement["T_AnimatorUpdate"] = 64] = "T_AnimatorUpdate";
        StatElement[StatElement["T_SkinBoneUpdate"] = 65] = "T_SkinBoneUpdate";
        StatElement[StatElement["T_ShurikenUpdate"] = 66] = "T_ShurikenUpdate";
        StatElement[StatElement["T_Physics_Simulation"] = 67] = "T_Physics_Simulation";
        StatElement[StatElement["T_Physics_UpdateNode"] = 68] = "T_Physics_UpdateNode";
        StatElement[StatElement["T_PhysicsEvent"] = 69] = "T_PhysicsEvent";
        StatElement[StatElement["C_PhysicsEventCount"] = 70] = "C_PhysicsEventCount";
        StatElement[StatElement["T_PhysicsCollider"] = 71] = "T_PhysicsCollider";
        StatElement[StatElement["T_PhysicsTrigger"] = 72] = "T_PhysicsTrigger";
        StatElement[StatElement["T_PhysicsColliderEnter"] = 73] = "T_PhysicsColliderEnter";
        StatElement[StatElement["T_PhysicsColliderExit"] = 74] = "T_PhysicsColliderExit";
        StatElement[StatElement["T_PhysicsColliderStay"] = 75] = "T_PhysicsColliderStay";
        StatElement[StatElement["T_PhysicsTriggerEnter"] = 76] = "T_PhysicsTriggerEnter";
        StatElement[StatElement["T_PhysicsTriggerExit"] = 77] = "T_PhysicsTriggerExit";
        StatElement[StatElement["T_PhysicsTriggerStay"] = 78] = "T_PhysicsTriggerStay";
        StatElement[StatElement["C_PhysicaDynamicRigidBody"] = 79] = "C_PhysicaDynamicRigidBody";
        StatElement[StatElement["C_PhysicaStaticRigidBody"] = 80] = "C_PhysicaStaticRigidBody";
        StatElement[StatElement["C_PhysicaKinematicRigidBody"] = 81] = "C_PhysicaKinematicRigidBody";
        StatElement[StatElement["C_PhysicaCharacterController"] = 82] = "C_PhysicaCharacterController";
        StatElement[StatElement["C_PhysicsJoint"] = 83] = "C_PhysicsJoint";
        StatElement[StatElement["T_LoadResourceTime"] = 84] = "T_LoadResourceTime";
        StatElement[StatElement["C_LoadResourceCount"] = 85] = "C_LoadResourceCount";
        StatElement[StatElement["C_LoadRequestCount"] = 86] = "C_LoadRequestCount";
        StatElement[StatElement["T_LoadRequestTime"] = 87] = "T_LoadRequestTime";
        StatElement[StatElement["StatEnd"] = 88] = "StatEnd";
    })(exports.StatElement || (exports.StatElement = {}));
    class DefaultStaticsContext {
        constructor() {
            this._tQueue = new Set();
            this._ctQueue = new Set();
            this._cacheCount = 0;
            this._cacheTime = 0;
            this._cacheTime = performance.now();
            this._createStatBuffer();
            for (let i = 0; i < exports.StatElement.StatEnd; i++) {
                const elementName = exports.StatElement[i];
                if (!elementName)
                    continue;
                if (elementName.startsWith("T_")) {
                    this._tQueue.add(i);
                }
                if (elementName.startsWith("CT_"))
                    this._ctQueue.add(i);
            }
        }
        _createStatBuffer() {
            this._statArray = new Float32Array(exports.StatElement.StatEnd);
            this._timeArray = new Float32Array(exports.StatElement.StatEnd);
        }
        cloneTo(context) {
            for (let i = 0; i < exports.StatElement.StatEnd; i++) {
                const elementName = exports.StatElement[i];
                if (!elementName)
                    continue;
                if (elementName.startsWith("C_")) {
                    (context).recordCountData(i, this._statArray[i]);
                }
                else if (elementName.startsWith("M_")) {
                    (context).recordMemoryData(i, this._statArray[i] * 1024 * 1024);
                }
            }
        }
        recordCountData(element, data) {
            this._statArray[element] += data;
        }
        recordTimeData(element, data) {
            this._timeArray[element] += data;
        }
        recordCTData(element, data) {
            this._timeArray[element] += data;
        }
        recordMemoryData(element, data) {
            this._statArray[element] += data / 1024 / 1024;
        }
        getElementData(element) {
            return this._statArray[element];
        }
        startFrameLogic() {
        }
        endFrameLogic(timestamp) {
            this._cacheCount++;
            let deltaTime = timestamp - this._cacheTime;
            if (deltaTime < 1000)
                return;
            let fps = Math.round(this._cacheCount * 1000) / deltaTime;
            for (let element of this._tQueue) {
                this._statArray[element] = this._timeArray[element] / this._cacheCount;
                this._timeArray[element] = 0;
            }
            for (let element of this._ctQueue) {
                this._statArray[element] = this._timeArray[element] / this._cacheCount;
                this._timeArray[element] = 0;
            }
            this._statArray[exports.StatElement.CT_FPS] = Math.round(fps);
            this._statArray[exports.StatElement.T_Frame_Time] = fps > 0 ? Math.floor(1000 / fps) : 0;
            this._cacheTime = timestamp;
            this._cacheCount = 0;
        }
    }

    class LayaGL {
    }
    LayaGL.statAgent = new DefaultStaticsContext();

    const ColorMap = {
        "purple": 0x800080,
        "orange": 0xffa500,
        "white": 0xFFFFFF,
        "red": 0xFF0000,
        "green": 0x00FF00,
        "blue": 0x0000FF,
        "black": 0x000000,
        "yellow": 0xFFFF00,
        "gray": 0x808080
    };
    class Color {
        static hexToString(color) {
            tmpColor$2.parse(color);
            return tmpColor$2.toString();
        }
        static stringToHex(value) {
            tmpColor$2.parse(value);
            return tmpColor$2.getRGB();
        }
        static gammaToLinearSpace(value) {
            if (value <= 0.04045)
                return value / 12.92;
            else if (value < 1.0)
                return Math.pow((value + 0.055) / 1.055, 2.4);
            else
                return Math.pow(value, 2.4);
        }
        static linearToGammaSpace(value) {
            if (value <= 0.0)
                return 0.0;
            else if (value <= 0.0031308)
                return 12.92 * value;
            else if (value <= 1.0)
                return 1.055 * Math.pow(value, 0.41666) - 0.055;
            else
                return Math.pow(value, 0.41666);
        }
        constructor(r = 1, g = 1, b = 1, a = 1) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        equal(c) {
            if (!c)
                return false;
            const toFIxed = (a, b) => {
                var delta = 1e-5;
                return -delta < a - b && a - b < delta;
            };
            return toFIxed(c.r, this.r) && toFIxed(c.g, this.g) && toFIxed(c.b, this.b) && toFIxed(c.a, this.a);
        }
        parse(value) {
            if (value == null)
                value = 0;
            if (typeof value === 'number') {
                if (value < 0 || isNaN(value))
                    value = 0;
                this.setRGB(value);
            }
            else if (value.indexOf("rgba(") >= 0 || value.indexOf("rgb(") >= 0) {
                let p1 = value.indexOf("(");
                let p2 = value.indexOf(")");
                if (p1 == -1 || p2 == -1) {
                    this.setValue(0, 0, 0, 1);
                    return this;
                }
                value = value.substring(p1 + 1, p2);
                let arr = value.split(",");
                let len = arr.length;
                for (let i = 0; i < len; i++) {
                    arr[i] = parseFloat(arr[i]);
                    if (isNaN(arr[i]))
                        arr[i] = 0;
                }
                this.r = arr[0] / 255;
                this.g = arr[1] / 255;
                this.b = arr[2] / 255;
                if (arr.length == 4)
                    this.a = arr[3];
                else
                    this.a = 1;
            }
            else {
                if (value.charAt(0) === '#')
                    value = value.substring(1);
                else {
                    let rgb = ColorMap[value];
                    if (rgb) {
                        this.setRGB(rgb);
                        return this;
                    }
                }
                let len = value.length;
                if (len === 3 || len === 4) {
                    let temp = "";
                    for (let i = 0; i < len; i++) {
                        temp += (value[i] + value[i]);
                    }
                    value = temp;
                }
                let rgb;
                let a = 1;
                if (len == 8) {
                    rgb = parseInt(value.substring(0, 6), 16);
                    a = parseInt(value.substring(6, 8), 16) / 255;
                }
                else {
                    rgb = parseInt(value, 16);
                    a = 1;
                }
                this.setRGB(rgb);
                this.a = a;
            }
            return this;
        }
        toLinear(out) {
            out.r = Color.gammaToLinearSpace(this.r);
            out.g = Color.gammaToLinearSpace(this.g);
            out.b = Color.gammaToLinearSpace(this.b);
            out.a = this.a;
        }
        toGamma(out) {
            out.r = Color.linearToGammaSpace(this.r);
            out.g = Color.linearToGammaSpace(this.g);
            out.b = Color.linearToGammaSpace(this.b);
            out.a = this.a;
        }
        cloneTo(destObject) {
            destObject.r = this.r;
            destObject.g = this.g;
            destObject.b = this.b;
            destObject.a = this.a;
        }
        scale(value) {
            this.r = this.r * value;
            this.g = this.g * value;
            this.b = this.b * value;
            return this;
        }
        setValue(r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
            return this;
        }
        fromArray(array, offset = 0) {
            this.r = array[offset + 0];
            this.g = array[offset + 1];
            this.b = array[offset + 2];
            this.a = array[offset + 3];
        }
        toArray() {
            return [this.r, this.g, this.b, this.a];
        }
        writeTo(arr, offset = 0) {
            arr[offset + 0] = this.r;
            arr[offset + 1] = this.g;
            arr[offset + 2] = this.b;
            arr[offset + 3] = this.a;
        }
        clone() {
            var dest = new Color();
            this.cloneTo(dest);
            return dest;
        }
        getRGB() {
            return (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255);
        }
        setRGB(value) {
            this.r = ((value >> 16) & 0xFF) / 255;
            this.g = ((value >> 8) & 0xFF) / 255;
            this.b = (value & 0xFF) / 255;
            this.a = 1;
        }
        getARGB() {
            return (Math.round(this.a * 255) << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255);
        }
        getABGR() {
            return (Math.round(this.a * 255) << 24) + (Math.round(this.b * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.r * 255);
        }
        setABGR(value) {
            this.a = ((value >> 24) & 0xFF) / 255;
            this.b = ((value >> 16) & 0xFF) / 255;
            this.g = ((value >> 8) & 0xFF) / 255;
            this.r = (value & 0xFF) / 255;
        }
        toString() {
            let str = this.getRGB().toString(16);
            while (str.length < 6)
                str = "0" + str;
            return "#" + str;
        }
        getStyleString() {
            if (this.a == 1)
                return this.toString();
            else
                return "rgba(" + Math.round(this.r * 255) + "," + Math.round(this.g * 255) + "," + Math.round(this.b * 255) + "," + this.a + ")";
        }
    }
    Color.RED = new Color(1, 0, 0, 1);
    Color.GREEN = new Color(0, 1, 0, 1);
    Color.BLUE = new Color(0, 0, 1, 1);
    Color.CYAN = new Color(0, 1, 1, 1);
    Color.YELLOW = new Color(1, 0.92, 0.016, 1);
    Color.MAGENTA = new Color(1, 0, 1, 1);
    Color.GRAY = new Color(0.5, 0.5, 0.5, 1);
    Color.WHITE = new Color(1, 1, 1, 1);
    Color.BLACK = new Color(0, 0, 0, 1);
    Color.CLEAR = new Color(0, 0, 0, 0);
    const tmpColor$2 = new Color();

    exports.RenderTargetFormat = void 0;
    (function (RenderTargetFormat) {
        RenderTargetFormat[RenderTargetFormat["None"] = -1] = "None";
        RenderTargetFormat[RenderTargetFormat["R8G8B8"] = 0] = "R8G8B8";
        RenderTargetFormat[RenderTargetFormat["R8G8B8A8"] = 1] = "R8G8B8A8";
        RenderTargetFormat[RenderTargetFormat["R16G16B16A16"] = 17] = "R16G16B16A16";
        RenderTargetFormat[RenderTargetFormat["R32G32B32"] = 30] = "R32G32B32";
        RenderTargetFormat[RenderTargetFormat["R32G32B32A32"] = 15] = "R32G32B32A32";
        RenderTargetFormat[RenderTargetFormat["R16G16B16"] = 31] = "R16G16B16";
        RenderTargetFormat[RenderTargetFormat["DEPTH_16"] = 35] = "DEPTH_16";
        RenderTargetFormat[RenderTargetFormat["STENCIL_8"] = 36] = "STENCIL_8";
        RenderTargetFormat[RenderTargetFormat["DEPTHSTENCIL_24_8"] = 37] = "DEPTHSTENCIL_24_8";
        RenderTargetFormat[RenderTargetFormat["DEPTH_32"] = 38] = "DEPTH_32";
        RenderTargetFormat[RenderTargetFormat["DEPTHSTENCIL_24_Plus"] = 39] = "DEPTHSTENCIL_24_Plus";
    })(exports.RenderTargetFormat || (exports.RenderTargetFormat = {}));

    exports.TextureDimension = void 0;
    (function (TextureDimension) {
        TextureDimension[TextureDimension["Tex2D"] = 0] = "Tex2D";
        TextureDimension[TextureDimension["Cube"] = 1] = "Cube";
        TextureDimension[TextureDimension["Tex3D"] = 2] = "Tex3D";
        TextureDimension[TextureDimension["Texture2DArray"] = 3] = "Texture2DArray";
        TextureDimension[TextureDimension["CubeArray"] = 4] = "CubeArray";
        TextureDimension[TextureDimension["Unkonw"] = 5] = "Unkonw";
        TextureDimension[TextureDimension["None"] = 6] = "None";
    })(exports.TextureDimension || (exports.TextureDimension = {}));

    exports.HDREncodeFormat = void 0;
    (function (HDREncodeFormat) {
        HDREncodeFormat[HDREncodeFormat["NONE"] = 0] = "NONE";
        HDREncodeFormat[HDREncodeFormat["RGBM"] = 1] = "RGBM";
        HDREncodeFormat[HDREncodeFormat["RGBD"] = 2] = "RGBD";
    })(exports.HDREncodeFormat || (exports.HDREncodeFormat = {}));

    exports.RenderCapable = void 0;
    (function (RenderCapable) {
        RenderCapable[RenderCapable["Element_Index_Uint32"] = 0] = "Element_Index_Uint32";
        RenderCapable[RenderCapable["Element_Index_Uint8"] = 1] = "Element_Index_Uint8";
        RenderCapable[RenderCapable["TextureFormat_R32G32B32A32"] = 2] = "TextureFormat_R32G32B32A32";
        RenderCapable[RenderCapable["TextureFormat_R16G16B16A16"] = 3] = "TextureFormat_R16G16B16A16";
        RenderCapable[RenderCapable["Texture_anisotropic"] = 4] = "Texture_anisotropic";
        RenderCapable[RenderCapable["RenderTextureFormat_R16G16B16A16"] = 5] = "RenderTextureFormat_R16G16B16A16";
        RenderCapable[RenderCapable["RenderTextureFormat_R32G32B32A32"] = 6] = "RenderTextureFormat_R32G32B32A32";
        RenderCapable[RenderCapable["RenderTextureFormat_Depth"] = 7] = "RenderTextureFormat_Depth";
        RenderCapable[RenderCapable["RenderTextureFormat_ShadowMap"] = 8] = "RenderTextureFormat_ShadowMap";
        RenderCapable[RenderCapable["Vertex_VAO"] = 9] = "Vertex_VAO";
        RenderCapable[RenderCapable["DrawElement_Instance"] = 10] = "DrawElement_Instance";
        RenderCapable[RenderCapable["Shader_TextureLod"] = 11] = "Shader_TextureLod";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_S3TC"] = 12] = "COMPRESS_TEXTURE_S3TC";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_S3TC_SRGB"] = 13] = "COMPRESS_TEXTURE_S3TC_SRGB";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_PVRTC"] = 14] = "COMPRESS_TEXTURE_PVRTC";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_ETC1"] = 15] = "COMPRESS_TEXTURE_ETC1";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_ETC"] = 16] = "COMPRESS_TEXTURE_ETC";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_ASTC"] = 17] = "COMPRESS_TEXTURE_ASTC";
        RenderCapable[RenderCapable["Texture_SRGB"] = 18] = "Texture_SRGB";
        RenderCapable[RenderCapable["MSAA"] = 19] = "MSAA";
        RenderCapable[RenderCapable["UnifromBufferObject"] = 20] = "UnifromBufferObject";
        RenderCapable[RenderCapable["Texture3D"] = 21] = "Texture3D";
        RenderCapable[RenderCapable["Texture_FloatLinearFiltering"] = 22] = "Texture_FloatLinearFiltering";
        RenderCapable[RenderCapable["Texture_HalfFloatLinearFiltering"] = 23] = "Texture_HalfFloatLinearFiltering";
        RenderCapable[RenderCapable["StorageBuffer"] = 24] = "StorageBuffer";
        RenderCapable[RenderCapable["ComputeShader"] = 25] = "ComputeShader";
        RenderCapable[RenderCapable["IndirectDraw"] = 26] = "IndirectDraw";
    })(exports.RenderCapable || (exports.RenderCapable = {}));

    exports.TextureFormat = void 0;
    (function (TextureFormat) {
        TextureFormat[TextureFormat["R8G8B8"] = 0] = "R8G8B8";
        TextureFormat[TextureFormat["R8G8B8A8"] = 1] = "R8G8B8A8";
        TextureFormat[TextureFormat["R5G6B5"] = 16] = "R5G6B5";
        TextureFormat[TextureFormat["Alpha8"] = 2] = "Alpha8";
        TextureFormat[TextureFormat["DXT1"] = 3] = "DXT1";
        TextureFormat[TextureFormat["DXT3"] = 29] = "DXT3";
        TextureFormat[TextureFormat["DXT5"] = 4] = "DXT5";
        TextureFormat[TextureFormat["ETC1RGB"] = 5] = "ETC1RGB";
        TextureFormat[TextureFormat["ETC2RGB"] = 6] = "ETC2RGB";
        TextureFormat[TextureFormat["ETC2RGBA"] = 7] = "ETC2RGBA";
        TextureFormat[TextureFormat["ETC2SRGB_Alpha8"] = 8] = "ETC2SRGB_Alpha8";
        TextureFormat[TextureFormat["ETC2SRGB"] = 28] = "ETC2SRGB";
        TextureFormat[TextureFormat["ETC2RGB_Alpha1"] = 32] = "ETC2RGB_Alpha1";
        TextureFormat[TextureFormat["ETC2SRGB_Alpha1"] = 33] = "ETC2SRGB_Alpha1";
        TextureFormat[TextureFormat["PVRTCRGB_2BPPV"] = 9] = "PVRTCRGB_2BPPV";
        TextureFormat[TextureFormat["PVRTCRGBA_2BPPV"] = 10] = "PVRTCRGBA_2BPPV";
        TextureFormat[TextureFormat["PVRTCRGB_4BPPV"] = 11] = "PVRTCRGB_4BPPV";
        TextureFormat[TextureFormat["PVRTCRGBA_4BPPV"] = 12] = "PVRTCRGBA_4BPPV";
        TextureFormat[TextureFormat["R32G32B32A32"] = 15] = "R32G32B32A32";
        TextureFormat[TextureFormat["R32G32B32"] = 30] = "R32G32B32";
        TextureFormat[TextureFormat["R16G16B16A16"] = 17] = "R16G16B16A16";
        TextureFormat[TextureFormat["R16G16B16"] = 31] = "R16G16B16";
        TextureFormat[TextureFormat["ASTC4x4"] = 18] = "ASTC4x4";
        TextureFormat[TextureFormat["ASTC4x4SRGB"] = 23] = "ASTC4x4SRGB";
        TextureFormat[TextureFormat["ASTC6x6"] = 19] = "ASTC6x6";
        TextureFormat[TextureFormat["ASTC6x6SRGB"] = 24] = "ASTC6x6SRGB";
        TextureFormat[TextureFormat["ASTC8x8"] = 20] = "ASTC8x8";
        TextureFormat[TextureFormat["ASTC8x8SRGB"] = 25] = "ASTC8x8SRGB";
        TextureFormat[TextureFormat["ASTC10x10"] = 21] = "ASTC10x10";
        TextureFormat[TextureFormat["ASTC10x10SRGB"] = 26] = "ASTC10x10SRGB";
        TextureFormat[TextureFormat["ASTC12x12"] = 22] = "ASTC12x12";
        TextureFormat[TextureFormat["ASTC12x12SRGB"] = 27] = "ASTC12x12SRGB";
        TextureFormat[TextureFormat["KTXTEXTURE"] = -1] = "KTXTEXTURE";
        TextureFormat[TextureFormat["PVRTEXTURE"] = -2] = "PVRTEXTURE";
    })(exports.TextureFormat || (exports.TextureFormat = {}));
    function getCompressTextureRenderCapable(format) {
        switch (format) {
            case exports.TextureFormat.ASTC4x4:
            case exports.TextureFormat.ASTC4x4SRGB:
            case exports.TextureFormat.ASTC6x6:
            case exports.TextureFormat.ASTC6x6SRGB:
            case exports.TextureFormat.ASTC8x8:
            case exports.TextureFormat.ASTC8x8SRGB:
            case exports.TextureFormat.ASTC10x10:
            case exports.TextureFormat.ASTC10x10SRGB:
            case exports.TextureFormat.ASTC12x12:
            case exports.TextureFormat.ASTC12x12SRGB:
                return exports.RenderCapable.COMPRESS_TEXTURE_ASTC;
            case exports.TextureFormat.DXT1:
            case exports.TextureFormat.DXT3:
            case exports.TextureFormat.DXT5:
                return exports.RenderCapable.COMPRESS_TEXTURE_S3TC;
            case exports.TextureFormat.PVRTCRGB_2BPPV:
            case exports.TextureFormat.PVRTCRGBA_2BPPV:
            case exports.TextureFormat.PVRTCRGB_4BPPV:
            case exports.TextureFormat.PVRTCRGBA_4BPPV:
                return exports.RenderCapable.COMPRESS_TEXTURE_PVRTC;
            case exports.TextureFormat.ETC2RGB:
            case exports.TextureFormat.ETC2RGBA:
            case exports.TextureFormat.ETC2SRGB_Alpha8:
            case exports.TextureFormat.ETC2SRGB:
            case exports.TextureFormat.ETC2RGB_Alpha1:
            case exports.TextureFormat.ETC2SRGB_Alpha1:
                return exports.RenderCapable.COMPRESS_TEXTURE_ETC;
            case exports.TextureFormat.ETC1RGB:
                return exports.RenderCapable.COMPRESS_TEXTURE_ETC1;
            default:
                return null;
        }
    }

    class NotImplementedError extends Error {
        constructor() {
            super('Not implemented.');
        }
    }
    class OutOfRangeError extends Error {
        constructor(index) {
            super(`Index out of range: ${index}`);
        }
    }
    class NotReadableError extends Error {
        constructor() {
            super("readable flag need to be true.");
        }
    }
    function getErrorMsg(err) {
        if (err != null && typeof err === "object") {
            let str;
            for (let k in errorFields) {
                str = err[errorFields[k]];
                if (str != null)
                    return parseError(str);
            }
        }
        return parseError(err);
    }
    function parseError(err) {
        if (typeof (err) === "number")
            return `error code=${err}`;
        else if (typeof (err) !== "string")
            return "error! " + err;
        else
            return err;
    }
    const errorFields = ["errMsg", "errorMessage", "message", "reason", "error", "errCode", "statusCode"];

    const ITEM_LAYOUT = 4;
    class Delegate {
        constructor() {
            this._flag = 0;
            this._items = [];
        }
        add(callback, target, args) {
            target = target || null;
            let arr = this._items;
            let index = arr.findIndex((value, index, arr) => value === callback && arr[index + 1] === target);
            if (index != -1) {
                arr[index + 2] = args;
                arr[index + 3] = 1;
            }
            else
                arr.push(callback, target, args, 1);
        }
        once(callback, target, args) {
            target = target || null;
            let arr = this._items;
            let index = arr.findIndex((value, index, arr) => value === callback && arr[index + 1] === target);
            if (index != -1) {
                arr[index + 2] = args;
                arr[index + 3] = 2;
            }
            else
                arr.push(callback, target, args, 2);
        }
        remove(callback, target) {
            target = target || null;
            let arr = this._items;
            let index = arr.findIndex((value, index, arr) => value === callback && arr[index + 1] === target);
            if (index != -1) {
                if (this._flag != 0) {
                    arr[index + 3] = 0;
                    this._flag = 2;
                }
                else
                    arr.splice(index, ITEM_LAYOUT);
            }
        }
        clear() {
            let arr = this._items;
            if (this._flag != 0) {
                arr.forEach((value, index, arr) => { if (index % ITEM_LAYOUT === 3)
                    arr[index] = 0; });
                this._flag = 2;
            }
            else {
                arr.length = 0;
            }
        }
        clearForTarget(target) {
            if (!target)
                return;
            let arr = this._items;
            if (this._flag != 0) {
                arr.forEach((value, index, arr) => { if ((index % ITEM_LAYOUT === 1) && arr[index] === target)
                    arr[index + 2] = 0; });
                this._flag = 2;
            }
            else {
                let i = arr.length - ITEM_LAYOUT;
                while (i >= 0) {
                    if (arr[i + 1] === target)
                        arr.splice(i, ITEM_LAYOUT);
                    i -= ITEM_LAYOUT;
                }
            }
        }
        get count() {
            return this._items.length / ITEM_LAYOUT;
        }
        invoke(...args) {
            if (this._flag != 0)
                return;
            this._flag = 1;
            let arr = this._items;
            let cnt = arr.length;
            for (let i = 0; i < cnt; i += ITEM_LAYOUT) {
                if (arr[i + 3] === 0)
                    continue;
                let fixedArgs = arr[i + 2];
                try {
                    if (fixedArgs != null)
                        arr[i].call(arr[i + 1], ...fixedArgs, ...args);
                    else
                        arr[i].call(arr[i + 1], ...args);
                }
                catch (err) {
                    console.error(err);
                }
                if (arr[i + 3] === 2) {
                    arr[i + 3] = 0;
                    this._flag = 2;
                }
            }
            if (this._flag === 2) {
                let cnt = arr.length;
                let i = 0;
                while (i < cnt) {
                    if (arr[i + 3] === 0) {
                        arr.splice(i, ITEM_LAYOUT);
                        cnt -= ITEM_LAYOUT;
                        continue;
                    }
                    else
                        i += ITEM_LAYOUT;
                }
            }
            this._flag = 0;
        }
    }

    const eventPool = [];
    class EventDispatcher {
        onStartListeningToType(type) {
        }
        hasListener(type) {
            let listeners = this._events && this._events[type];
            return !!listeners && listeners.count > 0;
        }
        event(type, data) {
            let listeners = this._events && this._events[type];
            if (!listeners)
                return false;
            let ret = listeners.count > 0;
            if (Array.isArray(data))
                listeners.invoke(...data);
            else if (data !== undefined)
                listeners.invoke(data);
            else if (data === Event.EMPTY) {
                let ev = eventPool.length > 0 ? eventPool.pop() : new Event();
                listeners.invoke(ev.setTo(type, this, this));
                ev.target = ev.currentTarget = null;
                eventPool.push(ev);
            }
            else
                listeners.invoke();
            return ret;
        }
        on(type, caller, listener, args) {
            if (arguments.length == 2) {
                listener = caller;
                caller = null;
            }
            if (!this._events)
                this._events = {};
            let listeners = this._events[type];
            if (!listeners) {
                this.onStartListeningToType(type);
                this._events[type] = listeners = new Delegate();
            }
            listeners.add(listener, caller, args);
            return this;
        }
        once(type, caller, listener, args) {
            if (arguments.length == 2) {
                listener = caller;
                caller = null;
            }
            if (!this._events)
                this._events = {};
            let listeners = this._events[type];
            if (!listeners) {
                this.onStartListeningToType(type);
                this._events[type] = listeners = new Delegate();
            }
            listeners.once(listener, caller, args);
            return this;
        }
        off(type, caller, listener) {
            if (arguments.length == 2) {
                listener = caller;
                caller = null;
            }
            let listeners = this._events && this._events[type];
            if (listeners)
                listeners.remove(listener, caller);
            return this;
        }
        offAll(type) {
            if (!this._events)
                return this;
            if (type == null) {
                for (let type in this._events)
                    this._events[type].clear();
            }
            else {
                let listeners = this._events[type];
                if (listeners)
                    listeners.clear();
            }
            return this;
        }
        offAllCaller(caller) {
            if (caller && this._events) {
                for (let type in this._events)
                    this._events[type].clearForTarget(caller);
            }
            return this;
        }
    }

    var _idCounter$2 = 0;
    var _disposingCounter = 0;
    var _clearRetry = 0;
    class Resource extends EventDispatcher {
        static get cpuMemory() {
            return Resource._cpuMemory;
        }
        static get gpuMemory() {
            return Resource._gpuMemory;
        }
        static _addCPUMemory(size) {
            Resource._cpuMemory += size;
        }
        static _addGPUMemory(size) {
            Resource._gpuMemory += size;
        }
        static _addMemory(cpuSize, gpuSize) {
            Resource._cpuMemory += cpuSize;
            Resource._gpuMemory += gpuSize;
        }
        static destroyUnusedResources() {
            _disposingCounter = 0;
            _clearRetry = 0;
            if (!ILaya.loader.loading)
                Resource._destroyUnusedResources(true);
            else
                ILaya.timer.frameLoop(1, Resource, Resource._destroyUnusedResources);
        }
        static _destroyUnusedResources(force) {
            if (!force && ILaya.loader.loading)
                return;
            ILaya.timer.clear(Resource, Resource._destroyUnusedResources);
            let destroyCnt = 0;
            for (let k in Resource._idResourcesMap) {
                let res = Resource._idResourcesMap[k];
                if (!res.lock && res._referenceCount === 0) {
                    res.destroy();
                    destroyCnt++;
                }
            }
            if (Resource.DEBUG && destroyCnt > 0)
                console.debug(`destroyUnusedResources(${destroyCnt})`);
            if (destroyCnt > 0 && _clearRetry < 5) {
                _clearRetry++;
                ILaya.timer.frameLoop(1, Resource, Resource._destroyUnusedResources);
            }
        }
        get id() {
            return this._id;
        }
        get cpuMemory() {
            return this._cpuMemory;
        }
        get gpuMemory() {
            return this._gpuMemory;
        }
        get destroyed() {
            return this._destroyed;
        }
        get obsolute() {
            return this._obsolute;
        }
        set obsolute(value) {
            if (this._obsolute != value) {
                this._obsolute = value;
                if (value && !LayaEnv.isPlaying)
                    this.event("obsolute");
            }
        }
        get deps() {
            return this._deps;
        }
        get referenceCount() {
            return this._referenceCount;
        }
        constructor(managed) {
            super();
            this._cpuMemory = 0;
            this._gpuMemory = 0;
            this._id = 0;
            this._referenceCount = 0;
            this._id = ++_idCounter$2;
            this._destroyed = false;
            this._referenceCount = 0;
            if (managed == null || managed)
                Resource._idResourcesMap[this._id] = this;
            this.lock = false;
            this.destroyedImmediately = true;
            this._deps = [];
            this._traceDeps = false;
        }
        _setCPUMemory(value) {
            var offsetValue = value - this._cpuMemory;
            this._cpuMemory = value;
            Resource._addCPUMemory(offsetValue);
        }
        _setGPUMemory(value) {
            var offsetValue = value - this._gpuMemory;
            this._gpuMemory = value;
            Resource._addGPUMemory(offsetValue);
        }
        _setCreateURL(url, uuid) {
            this.url = url;
            this.uuid = uuid;
        }
        isCreateFromURL(url) {
            return this.uuid && url.length === this.uuid.length + 6 && url.endsWith(this.uuid)
                || this.url === url;
        }
        _addReference(count = 1) {
            this._referenceCount += count;
        }
        _removeReference(count = 1) {
            this._referenceCount -= count;
            if (_disposingCounter > 0 && this._referenceCount <= 0 && !this.lock && this.destroyedImmediately) {
                this.destroy();
            }
        }
        _clearReference() {
            this._referenceCount = 0;
        }
        addDep(res) {
            if (res instanceof Resource) {
                res._addReference();
                this._deps.push(res);
                if (!LayaEnv.isPlaying && res._traceDeps)
                    res.on("obsolute", this, this.onDepObsolute);
            }
        }
        addDeps(resArr) {
            for (let res of resArr) {
                if (res instanceof Resource) {
                    res._addReference();
                    this._deps.push(res);
                    if (!LayaEnv.isPlaying && res._traceDeps)
                        res.on("obsolute", this, this.onDepObsolute);
                }
            }
        }
        onDepObsolute() {
            this.obsolute = true;
        }
        _disposeResource() {
        }
        destroy() {
            if (this._destroyed)
                return;
            this._destroyed = true;
            this.lock = false;
            _disposingCounter++;
            this._disposeResource();
            for (let res of this._deps) {
                res._removeReference();
                if (!LayaEnv.isPlaying && res._traceDeps)
                    res.off("obsolute", this, this.onDepObsolute);
            }
            _disposingCounter--;
            this.offAll();
            delete Resource._idResourcesMap[this.id];
            if (this.url) {
                if (Resource.DEBUG)
                    console.debug(`destroy ${Object.getPrototypeOf(this).constructor.name} ${this.url}`);
                ILaya.loader.clearRes(this.url, this);
            }
        }
    }
    Resource._idResourcesMap = {};
    Resource._cpuMemory = 0;
    Resource._gpuMemory = 0;
    Resource.DEBUG = false;

    class BaseTexture extends Resource {
        get width() {
            return this._width;
        }
        set width(width) {
            this._width = width;
        }
        get height() {
            return this._height;
        }
        set height(height) {
            this._height = height;
        }
        get dimension() {
            return this._dimension;
        }
        get format() {
            return this._format;
        }
        get mipmap() {
            return this._texture.mipmap;
        }
        get mipmapCount() {
            return this._texture.mipmapCount;
        }
        get anisoLevel() {
            return this._texture.anisoLevel;
        }
        set anisoLevel(value) {
            this._texture.anisoLevel = value;
        }
        get filterMode() {
            return this._texture.filterMode;
        }
        set filterMode(value) {
            this._texture.filterMode = value;
        }
        get wrapModeU() {
            return this._texture.wrapU;
        }
        set wrapModeU(value) {
            this._texture.wrapU = value;
        }
        get wrapModeV() {
            return this._texture.wrapV;
        }
        set wrapModeV(value) {
            this._texture.wrapV = value;
        }
        get wrapModeW() {
            return this._texture.wrapW;
        }
        set wrapModeW(value) {
            this._texture.wrapW = value;
        }
        get compareMode() {
            return this._texture.compareMode;
        }
        set compareMode(value) {
            this._texture.compareMode = LayaGL.textureContext.setTextureCompareMode(this._texture, value);
        }
        get gammaCorrection() {
            return this._texture.gammaCorrection;
        }
        get baseMipmapLevel() {
            return this._texture.baseMipmapLevel;
        }
        set baseMipmapLevel(value) {
            this._texture.baseMipmapLevel = value;
        }
        get maxMipmapLevel() {
            return this._texture.maxMipmapLevel;
        }
        set maxMipmapLevel(value) {
            this._texture.maxMipmapLevel = value;
        }
        get gammaSpace() {
            return this._texture.useSRGBLoad || this._texture.gammaCorrection > 1;
        }
        constructor(width, height, format) {
            super();
            this._gammaSpace = false;
            this._width = width;
            this._height = height;
            this._format = format;
            this.destroyedImmediately = Config.destroyResourceImmediatelyDefault;
            this.hdrEncodeFormat = exports.HDREncodeFormat.NONE;
        }
        gpuCompressFormat() {
            let format = this._format;
            switch (format) {
                case exports.TextureFormat.R8G8B8:
                case exports.TextureFormat.R8G8B8A8:
                case exports.TextureFormat.R16G16B16:
                case exports.TextureFormat.R16G16B16A16:
                case exports.TextureFormat.R32G32B32:
                case exports.TextureFormat.R32G32B32A32:
                case exports.TextureFormat.R5G6B5:
                case exports.TextureFormat.Alpha8:
                    return false;
                case exports.TextureFormat.DXT1:
                case exports.TextureFormat.DXT3:
                case exports.TextureFormat.DXT5:
                case exports.TextureFormat.ETC1RGB:
                case exports.TextureFormat.ETC2RGB:
                case exports.TextureFormat.ETC2RGBA:
                case exports.TextureFormat.ETC2SRGB_Alpha8:
                case exports.TextureFormat.ETC2SRGB:
                case exports.TextureFormat.ETC2RGB_Alpha1:
                case exports.TextureFormat.ETC2SRGB_Alpha1:
                case exports.TextureFormat.PVRTCRGB_2BPPV:
                case exports.TextureFormat.PVRTCRGBA_2BPPV:
                case exports.TextureFormat.PVRTCRGB_4BPPV:
                case exports.TextureFormat.PVRTCRGBA_4BPPV:
                case exports.TextureFormat.ASTC4x4:
                case exports.TextureFormat.ASTC4x4SRGB:
                case exports.TextureFormat.ASTC6x6:
                case exports.TextureFormat.ASTC6x6SRGB:
                case exports.TextureFormat.ASTC8x8:
                case exports.TextureFormat.ASTC8x8SRGB:
                case exports.TextureFormat.ASTC10x10:
                case exports.TextureFormat.ASTC10x10SRGB:
                case exports.TextureFormat.ASTC12x12:
                case exports.TextureFormat.ASTC12x12SRGB:
                    return true;
                default:
                    return false;
            }
        }
        _getFormatByteCount() {
            switch (this._format) {
                case exports.TextureFormat.R8G8B8:
                    return 3;
                case exports.TextureFormat.R8G8B8A8:
                    return 4;
                case exports.TextureFormat.R5G6B5:
                    return 1;
                case exports.TextureFormat.Alpha8:
                    return 1;
                case exports.TextureFormat.R16G16B16A16:
                    return 2;
                case exports.TextureFormat.R32G32B32A32:
                    return 4;
                default:
                    throw new Error("unknown format.");
            }
        }
        _getSource() {
            return this._texture.resource;
        }
        get defaultTexture() {
            throw new NotImplementedError();
        }
        _disposeResource() {
            this._texture && this._texture.dispose();
        }
    }

    exports.DepthTextureMode = void 0;
    (function (DepthTextureMode) {
        DepthTextureMode[DepthTextureMode["None"] = 0] = "None";
        DepthTextureMode[DepthTextureMode["Depth"] = 1] = "Depth";
        DepthTextureMode[DepthTextureMode["DepthNormals"] = 2] = "DepthNormals";
        DepthTextureMode[DepthTextureMode["DepthAndDepthNormals"] = 3] = "DepthAndDepthNormals";
        DepthTextureMode[DepthTextureMode["MotionVectors"] = 4] = "MotionVectors";
    })(exports.DepthTextureMode || (exports.DepthTextureMode = {}));
    class RenderTexture extends BaseTexture {
        static createFromPool(width, height, colorFormat, depthFormat, mipmap = false, multiSamples = 1, depthTexture = false, sRGB = false, storage = false) {
            mipmap = mipmap && (width & (width - 1)) === 0 && (height & (height - 1)) === 0;
            let n = RenderTexture._pool.length;
            for (let index = 0; index < n; index++) {
                let rt = RenderTexture._pool[index];
                if (rt.width == width && rt.height == height && rt.colorFormat == colorFormat && rt.depthStencilFormat == depthFormat && rt._generateMipmap == mipmap && rt.multiSamples == multiSamples && rt.generateDepthTexture == depthTexture && rt._gammaSpace == sRGB && rt._storage == storage) {
                    rt._inPool = false;
                    let end = RenderTexture._pool[n - 1];
                    RenderTexture._pool[index] = end;
                    RenderTexture._pool.length -= 1;
                    RenderTexture._poolMemory -= (rt._renderTarget.gpuMemory / 1024 / 1024);
                    return rt;
                }
            }
            let rt = new RenderTexture(width, height, colorFormat, depthFormat, mipmap, multiSamples, depthTexture, sRGB, storage);
            rt.lock = true;
            return rt;
        }
        static recoverToPool(rt) {
            if (rt._inPool || rt.destroyed)
                return;
            RenderTexture._pool.push(rt);
            RenderTexture._poolMemory += (rt._renderTarget.gpuMemory / 1024 / 1024);
            rt._inPool = true;
        }
        static clearPool() {
            if (RenderTexture._poolMemory < Config3D.defaultCacheRTMemory) {
                return;
            }
            for (var i in RenderTexture._pool) {
                RenderTexture._pool[i].destroy();
            }
            RenderTexture._pool = [];
            RenderTexture._poolMemory = 0;
        }
        static get bindCanvasRender() {
            return RenderTexture._bindCanvasRender;
        }
        static set bindCanvasRender(value) {
            if (value != this._bindCanvasRender)
                this._bindCanvasRender = value;
        }
        get generateDepthTexture() {
            return this._generateDepthTexture;
        }
        set generateDepthTexture(value) {
            if (this.depthStencilFormat == exports.RenderTargetFormat.None) {
                this._generateDepthTexture = false;
                return;
            }
            if (value && !this._depthStencilTexture) {
                this._depthStencilTexture = new BaseTexture(this.width, this.height, this.depthStencilFormat);
                this._depthStencilTexture._dimension = exports.TextureDimension.Tex2D;
                this._depthStencilTexture._texture = LayaGL.textureContext.createRenderTargetDepthTexture(this._renderTarget, exports.TextureDimension.Tex2D, this.width, this.height);
            }
            this._generateDepthTexture = value;
        }
        get depthStencilTexture() {
            return this._depthStencilTexture;
        }
        get colorFormat() {
            return this._renderTarget.colorFormat;
        }
        get depthStencilFormat() {
            return this._renderTarget.depthStencilFormat;
        }
        get multiSamples() {
            return this._renderTarget._samples;
        }
        get isCube() {
            return this._renderTarget._isCube;
        }
        get samples() {
            return this._renderTarget._samples;
        }
        get generateMipmap() {
            return this._renderTarget._generateMipmap;
        }
        constructor(width, height, colorFormat, depthFormat, generateMipmap = false, multiSamples = 1, generateDepthTexture = false, sRGB = false, stroage = false) {
            super(width, height, colorFormat);
            this._inPool = false;
            this._isCameraTarget = false;
            this._generateDepthTexture = false;
            this._storage = false;
            this._gammaSpace = sRGB;
            this._depthStencilFormat = (depthFormat == null ? exports.RenderTargetFormat.None : depthFormat);
            this._generateMipmap = generateMipmap;
            this._multiSamples = multiSamples;
            this._generateDepthTexture = generateDepthTexture;
            this._storage = stroage;
            this._createRenderTarget();
        }
        _createRenderTarget() {
            this._dimension = exports.TextureDimension.Tex2D;
            this._renderTarget = LayaGL.textureContext.createRenderTargetInternal(this.width, this.height, this._format, this._depthStencilFormat, this._generateMipmap, this._gammaSpace, this._multiSamples, this._storage);
            this._generateMipmap = this._renderTarget._generateMipmap;
            if (this._renderTarget._texturesResolve)
                this._texture = this._renderTarget._texturesResolve[0];
            else
                this._texture = this._renderTarget._textures[0];
            this.generateDepthTexture = this._generateDepthTexture;
        }
        recreate(width, height, colorFormat, depthFormat, generateMipmap = false, multiSamples = 1, generateDepthTexture = false, sRGB = false, storage = false) {
            this._width = width;
            this._height = height;
            this._format = colorFormat;
            this._gammaSpace = sRGB;
            this._depthStencilFormat = (depthFormat == null ? exports.RenderTargetFormat.None : depthFormat);
            this._generateMipmap = generateMipmap;
            this._multiSamples = multiSamples;
            this._generateDepthTexture = generateDepthTexture;
            this._storage = storage;
            this._disposeResource();
            this._createRenderTarget();
        }
        getData(xOffset, yOffset, width, height, out) {
            LayaGL.textureContext.readRenderTargetPixelData(this._renderTarget, xOffset, yOffset, width, height, out);
            return out;
        }
        getDataAsync(xOffset, yOffset, width, height, out) {
            return LayaGL.textureContext.readRenderTargetPixelDataAsync(this._renderTarget, xOffset, yOffset, width, height, out);
        }
        _disposeResource() {
            var _a;
            this._renderTarget.dispose();
            this._renderTarget = null;
            (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.destroy();
            this._depthStencilTexture = null;
        }
    }
    RenderTexture._pool = [];
    RenderTexture._poolMemory = 0;

    const PlatformAdapterNames = ["browser", "fs", "storage", "font", "textInput", "media", "device"];
    class PAL {
        static __init__() {
            for (let key of PlatformAdapterNames) {
                let cls = PAL._classes[key];
                if (cls)
                    PAL[key] = new cls();
            }
        }
        static register(name, cls) {
            if (LayaEnv.isPlaying)
                PAL._classes[name] = cls;
        }
        static warnIncompatibility(name) {
            if (!warned.has(name)) {
                warned.add(name);
                console.warn(`${name} is not supported in this platform.`);
            }
        }
        static hasAPI(arg0, arg1) {
            let g = arg1 ? (arg0 || PAL.g) : PAL.g;
            let name = arg1 || arg0;
            if (g.willGenerateUndefinedAPIs)
                return Object.getOwnPropertyDescriptor(g, name) != null;
            else
                return g[name] != null;
        }
    }
    PAL.g = null;
    PAL._classes = {};
    const warned = new Set();

    class Browser {
        static createElement(tagName) {
            return PAL.browser.createElement(tagName);
        }
        static getElementById(id) {
            return Browser.document.getElementById(id);
        }
        static removeElement(ele) {
            if (ele && ele.parentNode)
                ele.parentNode.removeChild(ele);
        }
        static now() {
            return performance.now();
        }
        static get clientWidth() {
            if (this._clientWidth != null)
                return this._clientWidth;
            else
                return PAL.browser.getClientWidth();
        }
        static set clientWidth(value) {
            Browser._clientWidth = value;
        }
        static get clientHeight() {
            if (this._clientHeight != null)
                return this._clientHeight;
            else
                return PAL.browser.getClientHeight();
        }
        static set clientHeight(value) {
            Browser._clientHeight = value;
        }
        static get width() {
            return ((ILaya.stage && ILaya.stage.canvasRotation) ? Browser.clientHeight : Browser.clientWidth) * Browser.pixelRatio;
        }
        static get height() {
            return ((ILaya.stage && ILaya.stage.canvasRotation) ? Browser.clientWidth : Browser.clientHeight) * Browser.pixelRatio;
        }
        static get pixelRatio() {
            return PAL.browser.getPixelRatio();
        }
        static get container() {
            return Browser.mainCanvas.source.parentElement || document.body;
        }
        static getQueryString(name) {
            if (!Browser.window.location || !Browser.window.location.search)
                return null;
            let reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
            let r = Browser.window.location.search.substring(1).match(reg);
            if (r != null)
                return unescape(r[2]);
            return null;
        }
        static loadLib(src, async) {
            return new Promise((resolve, reject) => {
                let script = document.createElement('script');
                script.onload = function () {
                    resolve();
                };
                script.onerror = function () {
                    reject(`load ${src} failed`);
                };
                if (async != null)
                    script.async = async;
                script.src = URL.postFormatURL(URL.formatURL(src));
                Browser.document.body.appendChild(script);
            });
        }
    }
    Browser.platform = 0;
    Browser.platformName = "";
    Browser.PLATFORM_PC = 0;
    Browser.PLATFORM_ANDROID = 1;
    Browser.PLATFORM_IOS = 2;
    Browser.isDomSupported = true;
    Browser.systemVersion = "";
    Browser.SDKVersion = "";
    Browser.bundles = new Map();
    Browser.window = typeof window !== undefined ? window : null;
    Browser.document = typeof document !== undefined ? document : null;
    let win = window;
    win.__getBundle_ = function (bundleId) {
        let bun = Browser.bundles.get(bundleId);
        if (!bun)
            Browser.bundles.set(bundleId, bun = {});
        return bun;
    };
    win.__setBundle_ = function (bundleId, bun, globalName) {
        let existing = Browser.bundles.get(bundleId);
        if (existing)
            copyProps(existing, bun, "default");
        Browser.bundles.set(bundleId, bun);
        if (globalName)
            win[globalName] = bun;
    };
    function copyProps(to, from, except) {
        var desc;
        if (from && typeof from === "object" || typeof from === "function") {
            for (let key of Object.getOwnPropertyNames(from))
                if (!to.hasOwnProperty(key) && key !== except)
                    Object.defineProperty(to, key, { get: () => from[key], enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable });
        }
        return to;
    }

    var _gid = 1;
    const _pi = 180 / Math.PI;
    const _pi2 = Math.PI / 180;
    class Utils {
        static toRadian(angle) {
            return angle * _pi2;
        }
        static toAngle(radian) {
            return radian * _pi;
        }
        static toHexColor(color) {
            return Color.hexToString(color);
        }
        static fromStringColor(value) {
            return Color.stringToHex(value);
        }
        static getGID(target, method) {
            let cid = target ? (target[objUidKey] || (target[objUidKey] = _gid++)) : 0;
            let mid = method ? (typeof (method) === "string" ? method : (method[objUidKey] || (method[objUidKey] = _gid++))) : 0;
            return cid + "_" + mid;
        }
        static copyArray(source, array) {
            source || (source = []);
            if (!array)
                return source;
            source.length = array.length;
            var len = array.length;
            for (let i = 0; i < len; i++) {
                source[i] = array[i];
            }
            return source;
        }
        static parseInt(str, radix = 0) {
            var result = parseInt(str, radix);
            if (isNaN(result))
                return 0;
            return result;
        }
        static getBaseName(path, withoutExtension) {
            let i = path.lastIndexOf("/");
            if (i != -1)
                path = path.substring(i + 1);
            i = path.indexOf("?");
            if (i != -1)
                path = path.substring(0, i);
            if (withoutExtension) {
                i = path.lastIndexOf(".");
                if (i != -1)
                    path = path.substring(0, i);
            }
            return path;
        }
        static getFileExtension(path) {
            let i = path.lastIndexOf(".");
            if (i != -1) {
                let ext = path.substring(i + 1).toLowerCase();
                let j = ext.indexOf("?");
                if (j != -1)
                    ext = ext.substring(0, j);
                if (ext === "ls") {
                    let k = path.lastIndexOf(".", i - 1);
                    if (k != -1) {
                        let ext2 = path.substring(k + 1, i + 1) + ext;
                        if (ext2 === "lanit.ls" || ext2 === "ltcb.ls")
                            return ext2;
                    }
                }
                return ext;
            }
            else
                return "";
        }
        static replaceFileExtension(path, newExt, excludeDot) {
            if (!path)
                return path;
            let i = path.lastIndexOf(".");
            if (newExt.length > 0 && !excludeDot)
                newExt = "." + newExt;
            if (i != -1) {
                let j = path.indexOf("?", i);
                if (j != -1)
                    return path.substring(0, i) + newExt + path.substring(j);
                else
                    return path.substring(0, i) + newExt;
            }
            else
                return path + newExt;
        }
        static isUUID(str) {
            return str && str.length >= 36 && str.charCodeAt(8) === 45 && str.charCodeAt(13) === 45;
        }
        static uint8ArrayToArrayBuffer(rendertexture) {
            let pixelArray;
            const width = rendertexture.width;
            const height = rendertexture.height;
            const pixelCount = width * height * 4;
            const colorFormat = (rendertexture instanceof RenderTexture) ? rendertexture.colorFormat : rendertexture.getColorFormat();
            switch (colorFormat) {
                case exports.RenderTargetFormat.R8G8B8:
                case exports.RenderTargetFormat.R8G8B8A8:
                    pixelArray = new Uint8Array(pixelCount);
                    break;
                case exports.RenderTargetFormat.R16G16B16A16:
                    pixelArray = new Float32Array(pixelCount);
                    break;
                default:
                    throw new Error("uint8ArrayToArrayBuffer is not supported for " + rendertexture.format.toString() + "format");
            }
            LayaGL.textureContext.readRenderTargetPixelData(rendertexture._renderTarget, 0, 0, width, height, pixelArray);
            if (colorFormat === exports.RenderTargetFormat.R16G16B16A16) {
                const ori = pixelArray;
                const trans = new Uint8Array(pixelCount);
                for (let i = 0, n = ori.length; i < n; i++) {
                    trans[i] = Math.min(Math.floor(ori[i] * 255), 255);
                }
                pixelArray = trans;
            }
            const pixels = pixelArray;
            const canvas = Browser.createElement("canvas");
            canvas.height = height;
            canvas.width = width;
            const ctx2d = canvas.getContext('2d');
            const imgdata = ctx2d.createImageData(width, height);
            imgdata.data.set(new Uint8ClampedArray(pixels));
            ctx2d.putImageData(imgdata, 0, 0);
            const base64String = canvas.toDataURL();
            canvas.remove();
            return base64String;
        }
        static uint8ArrayToArrayBufferAsync(rendertexture) {
            let pixelArray;
            const width = rendertexture.width;
            const height = rendertexture.height;
            const pixelCount = width * height * 4;
            const colorFormat = (rendertexture instanceof RenderTexture) ? rendertexture.colorFormat : rendertexture.getColorFormat();
            switch (colorFormat) {
                case exports.RenderTargetFormat.R8G8B8:
                case exports.RenderTargetFormat.R8G8B8A8:
                    pixelArray = new Uint8Array(pixelCount);
                    break;
                case exports.RenderTargetFormat.R16G16B16A16:
                    pixelArray = new Float32Array(pixelCount);
                    break;
                default:
                    throw "this function is not supported " + rendertexture.format.toString() + "format Material";
            }
            return rendertexture.getDataAsync(0, 0, width, height, pixelArray).then(() => {
                if (colorFormat === exports.RenderTargetFormat.R16G16B16A16) {
                    const ori = pixelArray;
                    const trans = new Uint8Array(pixelCount);
                    for (let i = 0, n = ori.length; i < n; i++) {
                        trans[i] = Math.min(Math.floor(ori[i] * 255), 255);
                    }
                    pixelArray = trans;
                }
                const pixels = pixelArray;
                const canvas = Browser.createElement("canvas");
                canvas.height = height;
                canvas.width = width;
                const ctx2d = canvas.getContext('2d');
                const imgdata = ctx2d.createImageData(width, height);
                imgdata.data.set(new Uint8ClampedArray(pixels));
                ctx2d.putImageData(imgdata, 0, 0);
                const base64String = canvas.toDataURL();
                canvas.remove();
                return Promise.resolve(base64String);
            });
        }
        static parseTemplate(template, vars) {
            let pos1 = 0, pos2, pos3;
            let tag;
            let value;
            let result = "";
            while ((pos2 = template.indexOf("{", pos1)) != -1) {
                if (pos2 > 0 && template.charCodeAt(pos2 - 1) == 92) {
                    result += template.substring(pos1, pos2 - 1);
                    result += "{";
                    pos1 = pos2 + 1;
                    continue;
                }
                result += template.substring(pos1, pos2);
                pos1 = pos2;
                pos2 = template.indexOf("}", pos1);
                if (pos2 == -1)
                    break;
                if (pos2 == pos1 + 1) {
                    result += template.substring(pos1, pos1 + 2);
                    pos1 = pos2 + 1;
                    continue;
                }
                tag = template.substring(pos1 + 1, pos2);
                pos3 = tag.indexOf("=");
                if (pos3 != -1) {
                    value = vars[tag.substring(0, pos3)];
                    if (value == null)
                        result += tag.substring(pos3 + 1);
                    else
                        result += value;
                }
                else {
                    value = vars[tag];
                    if (value != null)
                        result += value;
                }
                pos1 = pos2 + 1;
            }
            if (pos1 < template.length)
                result += template.substring(pos1);
            return result;
        }
        static sleep(timeout) {
            if (timeout < 1)
                return Promise.resolve();
            else
                return new Promise((resolve) => setTimeout(resolve, timeout));
        }
        static until(predicate, timeout) {
            if (predicate())
                return Promise.resolve();
            return new Promise((resolve) => {
                let start = performance.now();
                function timer() {
                    if (predicate())
                        resolve();
                    else if (timeout != null && performance.now() - start > timeout)
                        resolve();
                    else
                        setTimeout(timer, 10);
                }
                setTimeout(timer, 10);
            });
        }
        static runTasks(datas, numParallelTasks, taskFunc, abortToken) {
            let limitFunc;
            if (typeof (numParallelTasks) !== "number") {
                limitFunc = numParallelTasks;
                numParallelTasks = 0;
            }
            let total = datas.length;
            if (numParallelTasks >= total) {
                return Promise.all(datas.map((value, index) => {
                    if (abortToken && abortToken.aborted)
                        return Promise.reject("aborted");
                    else
                        return taskFunc(value, index);
                }));
            }
            const results = new Array(total);
            const executing = [];
            let i = 0;
            function processNext() {
                if (i >= total || (abortToken === null || abortToken === void 0 ? void 0 : abortToken.aborted)) {
                    return Promise.resolve();
                }
                const j = i++;
                const item = datas[j];
                const p = Promise.resolve().then(() => {
                    if (abortToken === null || abortToken === void 0 ? void 0 : abortToken.aborted) {
                        return Promise.reject("aborted");
                    }
                    return taskFunc(item, j);
                }).then((result) => {
                    results[j] = result;
                    executing.splice(executing.indexOf(p), 1);
                });
                executing.push(p);
                if (limitFunc ? limitFunc(executing.length) : executing.length >= numParallelTasks) {
                    return Promise.race(executing).then(processNext);
                }
                else {
                    return processNext();
                }
            }
            const initialPromises = [];
            const initialCount = Math.min(numParallelTasks, total);
            for (let i = 0; i < initialCount; i++) {
                initialPromises.push(processNext());
            }
            return Promise.all(initialPromises)
                .then(() => {
                if (executing.length > 0)
                    return Promise.all(executing);
                else
                    return null;
            }).then(() => results);
        }
        static runAllTasks(datas, numParallelTasks, taskFunc, abortToken) {
            let limitFunc;
            if (typeof (numParallelTasks) !== "number") {
                limitFunc = numParallelTasks;
                numParallelTasks = 0;
            }
            let total = datas.length;
            if (numParallelTasks >= total) {
                return Promise.allSettled(datas.map((value, index) => Promise.resolve().then(() => {
                    if (abortToken && abortToken.aborted)
                        return Promise.reject("aborted");
                    else
                        return taskFunc(value, index);
                })));
            }
            const results = new Array(total);
            const executing = [];
            let i = 0;
            function processNext() {
                if (i >= total || (abortToken === null || abortToken === void 0 ? void 0 : abortToken.aborted)) {
                    return Promise.resolve();
                }
                const j = i++;
                const item = datas[j];
                const p = Promise.resolve().then(() => {
                    if (abortToken && abortToken.aborted)
                        return Promise.reject("aborted");
                    else
                        return taskFunc(item, j);
                }).then((result) => {
                    results[j] = { status: "fulfilled", value: result };
                    executing.splice(executing.indexOf(p), 1);
                }).catch((reason) => {
                    results[j] = { status: "rejected", reason };
                    executing.splice(executing.indexOf(p), 1);
                });
                executing.push(p);
                if (limitFunc ? limitFunc(executing.length) : executing.length >= numParallelTasks) {
                    return Promise.race(executing).then(processNext);
                }
                else {
                    return processNext();
                }
            }
            const initialPromises = [];
            const initialCount = Math.min(numParallelTasks, total);
            for (let i = 0; i < initialCount; i++) {
                initialPromises.push(processNext());
            }
            return Promise.allSettled(initialPromises)
                .then(() => {
                if (executing.length > 0)
                    return Promise.allSettled(executing);
                else
                    return null;
            }).then(() => results);
        }
        static compareVersion(ver1, ver2) {
            let v1 = ver1.split('.');
            let v2 = ver2.split('.');
            const len = Math.max(v1.length, v2.length);
            while (v1.length < len) {
                v1.push('0');
            }
            while (v2.length < len) {
                v2.push('0');
            }
            for (let i = 0; i < len; i++) {
                const num1 = parseInt(v1[i]);
                const num2 = parseInt(v2[i]);
                if (num1 > num2) {
                    return 1;
                }
                else if (num1 < num2) {
                    return -1;
                }
            }
            return 0;
        }
        static testPointInPolygon(x, y, areaPoints) {
            var nCross = 0;
            var p1x, p1y, p2x, p2y;
            var len;
            len = areaPoints.length;
            for (var i = 0; i < len; i += 2) {
                p1x = areaPoints[i];
                p1y = areaPoints[i + 1];
                p2x = areaPoints[(i + 2) % len];
                p2y = areaPoints[(i + 3) % len];
                if (p1y == p2y)
                    continue;
                if (y < Math.min(p1y, p2y))
                    continue;
                if (y >= Math.max(p1y, p2y))
                    continue;
                var tx = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x;
                if (tx > x)
                    nCross++;
            }
            return (nCross % 2 == 1);
        }
    }
    const objUidKey = Symbol();

    class AssetDb {
        constructor() {
            this.uuidMap = {};
            this.shaderNameMap = {};
            this.metaMap = {};
            this.i18nUrlMap = {};
        }
        UUID_to_URL(uuid) {
            return this.uuidMap[uuid];
        }
        UUID_to_URL_async(uuid) {
            return Promise.resolve(null);
        }
        URL_to_UUID_async(url) {
            return Promise.resolve(null);
        }
        resolveURL(url, onResolve) {
            if (url.startsWith("res://")) {
                let uuid = url.substring(6);
                return AssetDb.inst.UUID_to_URL_async(uuid).then(url => {
                    if (onResolve)
                        onResolve(url);
                    return url;
                });
            }
            else {
                if (onResolve)
                    onResolve(url);
                return Promise.resolve(url);
            }
        }
        shaderName_to_URL(shaderName) {
            return this.shaderNameMap[shaderName];
        }
        shaderName_to_URL_async(shaderName) {
            return Promise.resolve(null);
        }
        getMeta(url, uuid) {
            return Promise.resolve(null);
        }
        getSubAssetURL(url, uuid, subAssetName, subAssetExt) {
            if (subAssetName)
                return `${Utils.replaceFileExtension(url, "")}@${subAssetName}.${subAssetExt}`;
            else
                return url;
        }
        getI18nSettingsURL(id) {
            return this.i18nUrlMap[id];
        }
    }
    AssetDb.inst = new AssetDb();

    class URL {
        static initMiniGameExtensionOverrides() {
            if (LayaEnv.isPreview)
                return;
            Object.assign(this.overrideFileExts, this.safeFileExtConversionMap, PlayerConfig.safeFileExtConversionMap);
            this.hasExtOverrides = true;
            this.usingSafeFileExts = true;
        }
        constructor(url) {
            this._url = URL.formatURL(url);
            this._path = URL.getPath(url);
        }
        get url() {
            return this._url;
        }
        get path() {
            return this._path;
        }
        static get rootPath() {
            return URL.basePaths["~/"];
        }
        static set rootPath(value) {
            URL.basePaths["~/"] = value;
        }
        static formatURL(url, base) {
            if (!url)
                return base || URL.basePath || "";
            if (url.startsWith("res://")) {
                let uuid = url.substring(6);
                let url2 = AssetDb.inst.UUID_to_URL(uuid);
                if (!url2)
                    return url;
                url = url2;
            }
            if (url.indexOf(":") == -1 && url.charCodeAt(0) !== 47) {
                let url2 = URL.urlMapping[url];
                if (url2)
                    url = url2;
                if (URL.customFormat != null)
                    url = URL.customFormat(url);
                let ver = URL.version[url];
                if (ver != null) {
                    let i = url.lastIndexOf(".");
                    url = url.substring(0, i) + "-" + ver + url.substring(i);
                }
                if (base == null) {
                    base = URL.basePath;
                    for (let k in URL.basePaths) {
                        if (url.startsWith(k)) {
                            if (k.charCodeAt(0) === 126)
                                url = url.substring(k.length);
                            base = URL.basePaths[k];
                            break;
                        }
                    }
                }
                url = URL.join(base, url);
            }
            return url;
        }
        static postFormatURL(url) {
            if (URL.hasExtOverrides) {
                let extold = Utils.getFileExtension(url);
                let ext = URL.overrideFileExts[extold];
                if (ext != null)
                    url = Utils.replaceFileExtension(url, ext);
            }
            return url;
        }
        static normalize(url) {
            if (url.indexOf("./") == -1)
                return url;
            let parts = url.split("/");
            let len = parts.length;
            let i = 0;
            while (i < len) {
                if (parts[i] == ".") {
                    parts.splice(i, 1);
                    len--;
                    continue;
                }
                else if (parts[i] == '..') {
                    let index = i - 1;
                    if (index >= 0 && parts[index] !== '..') {
                        parts.splice(index, 2);
                        len -= 2;
                        i--;
                        continue;
                    }
                }
                i++;
            }
            parts.length = len;
            return parts.join('/');
        }
        static getResURLByUUID(url) {
            if (Utils.isUUID(url))
                return "res://" + url;
            else
                return url;
        }
        static join(base, path) {
            if (!path)
                return "";
            if (path.indexOf(":") > 0)
                return path;
            if (base) {
                let char1 = path.charCodeAt(0);
                if (char1 !== 126 && char1 !== 47) {
                    if (base.charCodeAt(base.length - 1) !== 47)
                        path = base + "/" + path;
                    else
                        path = base + path;
                }
            }
            return URL.normalize(path);
        }
        static getPath(url) {
            var ofs = url.lastIndexOf('/');
            return ofs > 0 ? url.substring(0, ofs + 1) : "";
        }
        static getFileName(url) {
            var ofs = url.lastIndexOf('/');
            return ofs > 0 ? url.substring(ofs + 1) : url;
        }
        static getURLVerion(url) {
            var index = url.indexOf("?");
            return index >= 0 ? url.substring(index) : null;
        }
        static overrideExtension(originalExts, targetExt, miniGameOnly) {
            if (miniGameOnly) {
                if (!URL.usingSafeFileExts) {
                    for (let ext of originalExts)
                        URL.safeFileExtConversionMap[ext] = targetExt;
                    return;
                }
            }
            for (let ext of originalExts)
                URL.overrideFileExts[ext] = targetExt;
            URL.hasExtOverrides = true;
        }
    }
    URL.version = {};
    URL.basePath = "";
    URL.basePaths = {};
    URL.urlMapping = {};
    URL.overrideFileExts = {};
    URL.hasExtOverrides = false;
    URL.usingSafeFileExts = false;
    URL.safeFileExtConversionMap = {
        "rendertexture": "rt.json",
        "videotexture": "rt.json",
        "controller": "controller.json",
        "mc": "mc.bin",
        "mcc": "mcc.json",
        "shader": "shader.txt",
        "fui": "fui.json",
        "glsl": "glsl.txt",
        "skel": "skel.bin",
        "lavm": "lavm.json",
        "bp": "bp.json",
        "tres": "tres.json"
    };

    class Rectangle {
        constructor(x = 0, y = 0, width = 0, height = 0) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        get right() {
            return this.x + this.width;
        }
        set right(value) {
            this.width = value - this.x;
        }
        get bottom() {
            return this.y + this.height;
        }
        set bottom(value) {
            this.height = value - this.y;
        }
        setTo(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            return this;
        }
        reset() {
            this.x = this.y = this.width = this.height = 0;
            return this;
        }
        recover() {
            if (this == Rectangle.TEMP || this == Rectangle.EMPTY) {
                return;
            }
            Pool.recover("Rectangle", this.reset());
        }
        static create() {
            return Pool.getItemByClass("Rectangle", Rectangle);
        }
        copyFrom(source) {
            this.x = source.x;
            this.y = source.y;
            this.width = source.width;
            this.height = source.height;
            return this;
        }
        contains(x, y) {
            if (this.width <= 0 || this.height <= 0)
                return false;
            if (x >= this.x && x < this.right) {
                if (y >= this.y && y < this.bottom) {
                    return true;
                }
            }
            return false;
        }
        intersects(rect) {
            return !(rect.x > (this.x + this.width) || (rect.x + rect.width) < this.x || rect.y > (this.y + this.height) || (rect.y + rect.height) < this.y);
        }
        intersection(rect, out) {
            if (!this.intersects(rect))
                return null;
            let x = Math.max(this.x, rect.x);
            let y = Math.max(this.y, rect.y);
            let width = Math.min(this.right, rect.right) - x;
            let height = Math.min(this.bottom, rect.bottom) - y;
            out || (out = new Rectangle());
            return out.setTo(x, y, width, height);
        }
        union(source, out) {
            let x = source.x;
            let y = source.y;
            let width = source.width;
            let height = source.height;
            out || (out = new Rectangle());
            this.cloneTo(out);
            if (width <= 0 || height <= 0)
                return out;
            if (this.width <= 0 || this.height <= 0)
                return out.setTo(x, y, width, height);
            out.addPoint(x, y);
            out.addPoint(x + width, y + height);
            return out;
        }
        scale(scaleX, scaleY) {
            this.x *= scaleX;
            this.y *= scaleY;
            this.width *= scaleX;
            this.height *= scaleY;
            return this;
        }
        transform(mat, out) {
            let a = mat.a, b = mat.b, c = mat.c, d = mat.d;
            let tx = mat.tx, ty = mat.ty;
            let x1 = this.x;
            let y1 = this.y;
            let x2 = x1 + this.width;
            let y2 = y1 + this.height;
            let tx1 = x1 * a;
            let tx2 = x2 * a;
            let ty1 = y1 * c;
            let ty2 = y2 * c;
            let px1 = x1 * b;
            let px2 = x2 * b;
            let py1 = y1 * d;
            let py2 = y2 * d;
            let minX = Math.min(tx1 + ty1, tx1 + ty2, tx2 + ty1, tx2 + ty2);
            let maxX = Math.max(tx1 + ty1, tx1 + ty2, tx2 + ty1, tx2 + ty2);
            let minY = Math.min(px1 + py1, px1 + py2, px2 + py1, px2 + py2);
            let maxY = Math.max(px1 + py1, px1 + py2, px2 + py1, px2 + py2);
            if (!out)
                out = new Rectangle();
            return out.setTo(minX + tx, minY + ty, maxX - minX, maxY - minY);
        }
        toString() {
            return this.x + "," + this.y + "," + this.width + "," + this.height;
        }
        equals(rect) {
            if (!rect || rect.x !== this.x || rect.y !== this.y || rect.width !== this.width || rect.height !== this.height)
                return false;
            return true;
        }
        addPoint(x, y) {
            this.x > x && (this.width += this.x - x, this.x = x);
            this.y > y && (this.height += this.y - y, this.y = y);
            if (this.width < x - this.x)
                this.width = x - this.x;
            if (this.height < y - this.y)
                this.height = y - this.y;
            return this;
        }
        getBoundPoints(out) {
            out = out || [];
            if (this.width == 0 || this.height == 0)
                return out;
            out.push(this.x, this.y, this.x + this.width, this.y, this.x, this.y + this.height, this.x + this.width, this.y + this.height);
            return out;
        }
        static _getWrapRec(points, out) {
            out = out || new Rectangle();
            if (!points || points.length < 1)
                return out.setTo(0, 0, 0, 0);
            let i, len = points.length, minX, maxX, minY, maxY;
            minX = minY = 99999;
            maxX = maxY = -minX;
            for (i = 0; i < len; i += 2) {
                let tx = points[i];
                let ty = points[i + 1];
                minX = minX < tx ? minX : tx;
                minY = minY < ty ? minY : ty;
                maxX = maxX > tx ? maxX : tx;
                maxY = maxY > ty ? maxY : ty;
            }
            return out.setTo(minX, minY, maxX - minX, maxY - minY);
        }
        static minMaxRect(minX, minY, maxX, maxY, out) {
            out = out || new Rectangle();
            return out.setTo(minX, minY, maxX - minX, maxY - minY);
        }
        isEmpty() {
            return this.width <= 0 || this.height <= 0;
        }
        clone(out) {
            out || (out = new Rectangle());
            this.cloneTo(out);
            return out;
        }
        cloneTo(destObject) {
            destObject.x = this.x;
            destObject.y = this.y;
            destObject.width = this.width;
            destObject.height = this.height;
        }
    }
    Rectangle.EMPTY = new Rectangle();
    Rectangle.TEMP = new Rectangle();

    const _rect1 = new Rectangle();
    const _rect2 = new Rectangle();
    class Texture extends Resource {
        static create(source, x, y, width, height, offsetX = 0, offsetY = 0, sourceWidth = 0, sourceHeight = 0) {
            return Texture._create(source, x, y, width, height, offsetX, offsetY, sourceWidth, sourceHeight);
        }
        static _create(source, x, y, width, height, offsetX = 0, offsetY = 0, sourceWidth = 0, sourceHeight = 0, outTexture = null) {
            var btex = source instanceof Texture;
            var uv = btex ? source.uv : Texture.DEF_UV;
            var bitmap = btex ? source.bitmap : source;
            if (bitmap.width && (x + width) > bitmap.width)
                width = bitmap.width - x;
            if (bitmap.height && (y + height) > bitmap.height)
                height = bitmap.height - y;
            var tex;
            if (outTexture) {
                tex = outTexture;
                tex.setTo(bitmap, null, sourceWidth || width, sourceHeight || height);
            }
            else {
                tex = new Texture(bitmap, null, sourceWidth || width, sourceHeight || height);
            }
            tex.width = width;
            tex.height = height;
            tex.offsetX = offsetX;
            tex.offsetY = offsetY;
            var dwidth = 1 / bitmap.width;
            var dheight = 1 / bitmap.height;
            x *= dwidth;
            y *= dheight;
            width *= dwidth;
            height *= dheight;
            var u1 = tex.uv[0], v1 = tex.uv[1], u2 = tex.uv[4], v2 = tex.uv[5];
            var inAltasUVWidth = (u2 - u1), inAltasUVHeight = (v2 - v1);
            var oriUV = moveUV(uv[0], uv[1], [x, y, x + width, y, x + width, y + height, x, y + height]);
            tex.uv = new Float32Array([u1 + oriUV[0] * inAltasUVWidth, v1 + oriUV[1] * inAltasUVHeight,
                u2 - (1 - oriUV[2]) * inAltasUVWidth, v1 + oriUV[3] * inAltasUVHeight,
                u2 - (1 - oriUV[4]) * inAltasUVWidth, v2 - (1 - oriUV[5]) * inAltasUVHeight,
                u1 + oriUV[6] * inAltasUVWidth, v2 - (1 - oriUV[7]) * inAltasUVHeight]);
            var bitmapScale = source.scaleRate;
            if (bitmapScale && bitmapScale != 1) {
                tex.sourceWidth /= bitmapScale;
                tex.sourceHeight /= bitmapScale;
                tex.width /= bitmapScale;
                tex.height /= bitmapScale;
                tex.scaleRate = bitmapScale;
                tex.offsetX /= bitmapScale;
                tex.offsetY /= bitmapScale;
            }
            else {
                tex.scaleRate = 1;
            }
            return tex;
        }
        static createFromTexture(texture, x, y, width, height) {
            var texScaleRate = texture.scaleRate;
            if (texScaleRate != 1) {
                x *= texScaleRate;
                y *= texScaleRate;
                width *= texScaleRate;
                height *= texScaleRate;
            }
            var rect = Rectangle.TEMP.setTo(x - texture.offsetX, y - texture.offsetY, width, height);
            var result = rect.intersection(_rect1.setTo(0, 0, texture.width, texture.height), _rect2);
            if (result) {
                let newTex = Texture.create(texture, result.x, result.y, result.width, result.height, result.x - rect.x, result.y - rect.y, width, height);
                newTex._sizeGrid = texture._sizeGrid;
                newTex._atlas = texture._atlas;
                return newTex;
            }
            else
                return null;
        }
        get uv() {
            return this._uv;
        }
        set uv(value) {
            this.uvrect[0] = Math.min(value[0], value[2], value[4], value[6]);
            this.uvrect[1] = Math.min(value[1], value[3], value[5], value[7]);
            this.uvrect[2] = Math.max(value[0], value[2], value[4], value[6]) - this.uvrect[0];
            this.uvrect[3] = Math.max(value[1], value[3], value[5], value[7]) - this.uvrect[1];
            this._uv = value;
        }
        get width() {
            if (this._w)
                return this._w;
            if (!this.bitmap)
                return 0;
            return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[2] - this.uv[0]) * this.bitmap.width : this.bitmap.width;
        }
        set width(value) {
            this._w = value;
            this.sourceWidth || (this.sourceWidth = value);
        }
        get height() {
            if (this._h)
                return this._h;
            if (!this.bitmap)
                return 0;
            return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[5] - this.uv[1]) * this.bitmap.height : this.bitmap.height;
        }
        set height(value) {
            this._h = value;
            this.sourceHeight || (this.sourceHeight = value);
        }
        get bitmap() {
            return this._bitmap;
        }
        set bitmap(value) {
            if (this._bitmap == value)
                return;
            this._bitmap && this._bitmap._removeReference(this._referenceCount);
            this._bitmap = value;
            value && (value._addReference(this._referenceCount));
        }
        constructor(source = null, uv = null, sourceWidth = 0, sourceHeight = 0) {
            super(false);
            this.uvrect = [0, 0, 1, 1];
            this._w = 0;
            this._h = 0;
            this.offsetX = 0;
            this.offsetY = 0;
            this.sourceWidth = 0;
            this.sourceHeight = 0;
            this.scaleRate = 1;
            let bitmap = (source instanceof Texture) ? source.bitmap : source;
            this.setTo(bitmap, uv, sourceWidth, sourceHeight);
        }
        _addReference(count = 1) {
            var _a, _b;
            super._addReference(count);
            (_a = this._bitmap) === null || _a === void 0 ? void 0 : _a._addReference(count);
            (_b = this._atlas) === null || _b === void 0 ? void 0 : _b._addReference(count);
        }
        _removeReference(count = 1) {
            var _a, _b;
            (_a = this._bitmap) === null || _a === void 0 ? void 0 : _a._removeReference(count);
            (_b = this._atlas) === null || _b === void 0 ? void 0 : _b._removeReference(count);
            super._removeReference(count);
        }
        _getSource(cb = null) {
            if (this._destroyed || !this._bitmap)
                return null;
            this.recoverBitmap(cb);
            return this._bitmap.destroyed ? null : this.bitmap._getSource();
        }
        setTo(bitmap = null, uv = null, sourceWidth = 0, sourceHeight = 0) {
            this.bitmap = bitmap;
            this.sourceWidth = sourceWidth;
            this.sourceHeight = sourceHeight;
            if (bitmap) {
                this._w = bitmap.width;
                this._h = bitmap.height;
                this.sourceWidth = this.sourceWidth || bitmap.width;
                this.sourceHeight = this.sourceHeight || bitmap.height;
            }
            this.uv = uv || Texture.DEF_UV;
        }
        load(url, complete) {
            if (this._destroyed)
                return Promise.resolve();
            return ILaya.loader.load(url).then((tex) => {
                let bit = tex.bitmap;
                this.bitmap = bit;
                this.sourceWidth = this._w = bit.width;
                this.sourceHeight = this._h = bit.height;
                complete && complete.run();
                this.event(Event.READY, this);
            });
        }
        getTexturePixels(x, y, width, height) {
            var st, dst, i;
            var tex2d = this.bitmap;
            var texw = this._w;
            var texh = this._h;
            var sourceWidth = this.sourceWidth;
            var sourceHeight = this.sourceHeight;
            var tex2dw = tex2d.width;
            var tex2dh = tex2d.height;
            var offsetX = this.offsetX;
            var offsetY = this.offsetY;
            let draww = width;
            let drawh = height;
            if (x + width > texw + offsetX)
                draww -= (x + width) - texw - offsetX;
            if (x + width > sourceWidth)
                width -= (x + width) - sourceWidth;
            if (y + height > texh + offsetY)
                drawh -= (y + height) - texh - offsetY;
            if (y + height > sourceHeight)
                height -= (y + height) - sourceHeight;
            if (width <= 0 || height <= 0)
                return null;
            let marginL = offsetX > x ? offsetX - x : 0;
            let marginT = offsetY > y ? offsetY - y : 0;
            let rePosX = x > offsetX ? x - offsetX : 0;
            let rePosY = y > offsetY ? y - offsetY : 0;
            draww -= marginL;
            drawh -= marginT;
            var wstride = width * 4;
            var pix = null;
            try {
                pix = tex2d.getPixels();
            }
            catch (e) {
            }
            if (pix) {
                if (x == 0 && y == 0 && width == tex2dw && height == tex2dh)
                    return pix;
                let uv = this._uv.slice();
                let atlasPosX = Math.round(uv[0] * tex2dw);
                let atlasPosY = Math.round(uv[1] * tex2dh);
                var ret = new Uint8Array(width * height * 4);
                wstride = tex2dw * 4;
                dst = (atlasPosY + rePosY) * wstride;
                st = atlasPosX * 4 + rePosX * 4 + dst;
                for (i = 0; i < drawh; i++) {
                    ret.set(pix.slice(st, st + draww * 4), width * 4 * (i + marginT) + marginL * 4);
                    st += wstride;
                }
                return ret;
            }
            return ret;
        }
        getPixels(x, y, width, height) {
            return this.getTexturePixels(x, y, width, height);
        }
        recoverBitmap(callback) {
            var url = this._bitmap.url;
            if (!this._destroyed && (!this._bitmap || this._bitmap.destroyed) && url) {
                ILaya.loader.load(url, "image").then((tex) => {
                    this.bitmap = tex.bitmap;
                    callback && callback();
                });
            }
        }
        disposeBitmap() {
            if (!this._destroyed && this._bitmap) {
                this._bitmap.destroy();
                this.event("dispose");
            }
        }
        get valid() {
            return !this._destroyed && this._bitmap && !this._bitmap.destroyed;
        }
        get obsolute() {
            return this._obsolute || !this._bitmap || this._bitmap.destroyed || this._bitmap.obsolute;
        }
        set obsolute(value) {
            this._obsolute = value;
        }
        _disposeResource() {
            let bit = this._bitmap;
            this._bitmap = null;
            if (bit)
                bit._removeReference(this._referenceCount);
            let atlas = this._atlas;
            this._atlas = null;
            if (atlas)
                atlas._removeReference(this._referenceCount);
        }
        getCachedClip(x, y, width, height) {
            if (this.destroyed)
                return null;
            let key = `${x}_${y}_${width}_${height}`;
            if (!this._clipCache)
                this._clipCache = new Map();
            let tex = this._clipCache.get(key);
            if (tex)
                return tex;
            tex = Texture.createFromTexture(this, x, y, width, height);
            if (this._clipCache.size > 100)
                this._clipCache.clear();
            this._clipCache.set(key, tex);
            return tex;
        }
    }
    Texture.DEF_UV = new Float32Array([0, 0, 1.0, 0, 1.0, 1.0, 0, 1.0]);
    Texture.NO_UV = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0]);
    Texture.INV_UV = new Float32Array([0, 1, 1.0, 1, 1.0, 0.0, 0, 0.0]);
    function moveUV(offsetX, offsetY, uv) {
        for (var i = 0; i < 8; i += 2) {
            uv[i] += offsetX;
            uv[i + 1] += offsetY;
        }
        return uv;
    }

    class AtlasInfoManager {
        static enable(infoFile, callback = null) {
            ILaya.loader.fetch(infoFile, "json").then(data => {
                if (!data)
                    return;
                AtlasInfoManager.addAtlases(data);
                callback && callback.run();
            });
        }
        static addAtlases(data) {
            let dic = AtlasInfoManager._fileLoadDic;
            for (let key in data) {
                let arr = data[key];
                let prefix = URL.formatURL(arr[0]);
                let frames = arr[1];
                let len = frames.length;
                let entry = { url: key };
                for (let i = 0; i < len; i++) {
                    dic[prefix + frames[i]] = entry;
                }
            }
        }
        static addAtlas(atlasUrl, prefix, frames, allowOverride) {
            prefix = URL.formatURL(prefix);
            if (allowOverride == null)
                allowOverride = true;
            let dic = AtlasInfoManager._fileLoadDic;
            let entry = { url: atlasUrl };
            for (let i of frames) {
                let j = prefix + i;
                if (allowOverride || !dic[j])
                    dic[j] = entry;
            }
        }
        static getFileLoadPath(file) {
            return AtlasInfoManager._fileLoadDic[file];
        }
    }
    AtlasInfoManager._fileLoadDic = {};

    class WorkerLoader {
        static workerSupported() {
            return Worker ? true : false;
        }
        static get enable() {
            return WorkerLoader._enable;
        }
        static set enable(value) {
            if (WorkerLoader._enable != value) {
                if (value) {
                    if (!Worker)
                        return;
                    if (!WorkerLoader._worker) {
                        WorkerLoader._worker = new Worker(PlayerConfig.workerLoaderLib || WorkerLoader.workerPath);
                        WorkerLoader._worker.onmessage = WorkerLoader.workerMessage;
                    }
                }
                WorkerLoader._enable = value;
            }
        }
        static load(url, options) {
            let callbacks = WorkerLoader._queue[url];
            if (callbacks) {
                return new Promise((resolve, reject) => {
                    callbacks.push(resolve, reject);
                });
            }
            else {
                WorkerLoader._queue[url] = callbacks = [];
                return new Promise((resolve, reject) => {
                    callbacks.push(resolve, reject);
                    WorkerLoader._worker.postMessage({ url, options });
                });
            }
        }
        static workerMessage(evt) {
            let data = evt.data;
            if (data) {
                switch (data.type) {
                    case "Image":
                        let callbacks = WorkerLoader._queue[data.url];
                        if (callbacks) {
                            delete WorkerLoader._queue[data.url];
                            let param = data.imageBitmap ? data.imageBitmap : data.msg;
                            for (let i = data.imageBitmap ? 0 : 1; i < callbacks.length; i += 2) {
                                callbacks[i](param);
                            }
                        }
                        break;
                }
            }
        }
    }
    WorkerLoader.workerPath = "libs/laya.workerloader.js";
    WorkerLoader._enable = false;
    WorkerLoader._queue = {};

    class AtlasResource extends Resource {
        constructor(dir, textures, frames) {
            super();
            this.dir = dir;
            this.textures = textures;
            this.frames = frames;
            for (let tex of frames) {
                tex._addReference();
                tex._atlas = this;
            }
            for (let tex of textures) {
                tex._addReference();
                tex._atlas = this;
            }
        }
        update(textures, frames) {
            this._disposeResource();
            this.textures.push(...textures);
            this.frames.push(...frames);
            for (let tex of frames) {
                tex._addReference();
                tex._atlas = this;
            }
            for (let tex of textures) {
                tex._addReference();
                tex._atlas = this;
            }
        }
        _disposeResource() {
            for (let tex of this.textures) {
                tex._atlas = null;
                tex._removeReference();
            }
            for (let tex of this.frames) {
                tex._atlas = null;
                tex._removeReference();
            }
            this.frames.length = 0;
            this.textures.length = 0;
        }
    }

    class BatchProgress {
        constructor(callback) {
            this._callback = callback;
            this._items = [];
            this._weights = [];
            this._progress = 0;
        }
        get itemCount() {
            return this._items.length;
        }
        reset() {
            this._items.length = 0;
            this._weights.length = 0;
            this._progress = 0;
        }
        createCallback(weight) {
            let index = this._items.length;
            this._items.push(0);
            if (weight == null)
                this._weights.push(null);
            else
                this._weights.push(Math.max(0, Math.min(weight, 1)));
            return (progress) => this.update(index, progress);
        }
        update(index, value) {
            if (index != -1) {
                this._items[index] = Math.max(0, Math.min(value, 1));
                let np = 0;
                let col = this._items;
                let ws = this._weights;
                let perc = 1 / col.length;
                for (let i = 0; i < col.length; i++) {
                    let p = col[i];
                    let w = ws[i];
                    if (p != null)
                        np += p * (w != null ? w : perc);
                }
                value = np;
                if (value > 1)
                    value = 1;
            }
            if (value > this._progress) {
                this._progress = value;
                this._callback(value);
            }
        }
    }

    class Handler {
        constructor(caller = null, method = null, args = null, once = false) {
            this.once = false;
            this._id = 0;
            this.setTo(caller, method, args, once);
        }
        setTo(caller, method, args, once = false) {
            this._id = Handler._gid++;
            this.caller = caller;
            this.method = method;
            this.args = args;
            this.once = once;
            return this;
        }
        run() {
            if (this.method == null)
                return null;
            var id = this._id;
            var result = this.method.apply(this.caller, this.args);
            this._id === id && this.once && this.recover();
            return result;
        }
        runWith(data) {
            if (this.method == null)
                return null;
            var id = this._id;
            if (data == null)
                var result = this.method.apply(this.caller, this.args);
            else if (!this.args && !data.unshift)
                result = this.method.call(this.caller, data);
            else if (this.args)
                result = this.method.apply(this.caller, this.args.concat(data));
            else
                result = this.method.apply(this.caller, data);
            this._id === id && this.once && this.recover();
            return result;
        }
        clear() {
            this.caller = null;
            this.method = null;
            this.args = null;
            return this;
        }
        recover() {
            if (this._id > 0) {
                this._id = 0;
                Handler._pool.push(this.clear());
            }
        }
        static create(caller, method, args = null, once = true) {
            if (Handler._pool.length)
                return Handler._pool.pop().setTo(caller, method, args, once);
            return new Handler(caller, method, args, once);
        }
    }
    Handler._pool = [];
    Handler._gid = 1;

    class XMLUtils {
        static decodeString(aSource) {
            let len = aSource.length;
            let sb = "";
            let pos1 = 0, pos2 = 0;
            while (true) {
                pos2 = aSource.indexOf('&', pos1);
                if (pos2 == -1) {
                    sb += aSource.substring(pos1);
                    break;
                }
                sb += aSource.substring(pos1, pos2);
                pos1 = pos2 + 1;
                pos2 = pos1;
                let end = Math.min(len, pos2 + 10);
                for (; pos2 < end; pos2++) {
                    if (aSource[pos2] == ';')
                        break;
                }
                if (pos2 < end && pos2 > pos1) {
                    let entity = aSource.substring(pos1, pos2);
                    let u = 0;
                    if (entity[0] == '#') {
                        if (entity.length > 1) {
                            if (entity[1] == 'x')
                                u = parseInt(entity.substring(2), 16);
                            else
                                u = parseInt(entity.substring(1));
                            sb += String.fromCharCode(u);
                            pos1 = pos2 + 1;
                        }
                        else
                            sb += '&';
                    }
                    else {
                        switch (entity) {
                            case "amp":
                                u = 38;
                                break;
                            case "apos":
                                u = 39;
                                break;
                            case "gt":
                                u = 62;
                                break;
                            case "lt":
                                u = 60;
                                break;
                            case "nbsp":
                                u = 32;
                                break;
                            case "quot":
                                u = 34;
                                break;
                        }
                        if (u > 0) {
                            sb += String.fromCharCode(u);
                            pos1 = pos2 + 1;
                        }
                        else
                            sb += '&';
                    }
                }
                else {
                    sb += '&';
                }
            }
            return sb;
        }
        static encodeString(str) {
            return str.replace(/&/g, "&amp;").replace(/</g, "&lt;")
                .replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;");
        }
        static getString(attrs, attrName, defValue) {
            if (attrs == null)
                return defValue == null ? null : defValue;
            let ret = attrs[attrName];
            if (ret != null)
                return "" + ret;
            else
                return defValue == null ? null : defValue;
        }
        static getInt(attrs, attrName, defValue) {
            let value = this.getString(attrs, attrName);
            if (value != null && value.length > 0) {
                if (value[value.length - 1] == '%') {
                    let ret = parseInt(value.substring(0, value.length - 1));
                    if (!isNaN(ret))
                        return Math.ceil(ret / 100.0 * defValue);
                }
                else {
                    let ret = parseInt(value);
                    if (!isNaN(ret))
                        return ret;
                }
            }
            return defValue == null ? 0 : defValue;
        }
        static getFloat(attrs, attrName, defValue) {
            let value = this.getString(attrs, attrName);
            if (value == null || value.length == 0)
                return defValue == null ? 0 : defValue;
            let ret = parseFloat(value);
            if (isNaN(ret))
                return defValue == null ? 0 : defValue;
            else
                return ret;
        }
        static getBool(attrs, attrName, defValue) {
            let value = this.getString(attrs, attrName);
            if (value == null || value.length == 0)
                return defValue == null ? false : defValue;
            if (value == "true" || value == "1")
                return true;
            else if (value == "false" || value == "0")
                return false;
            else
                return defValue == null ? false : defValue;
        }
    }

    exports.XMLTagType = void 0;
    (function (XMLTagType) {
        XMLTagType[XMLTagType["Start"] = 0] = "Start";
        XMLTagType[XMLTagType["End"] = 1] = "End";
        XMLTagType[XMLTagType["Void"] = 2] = "Void";
        XMLTagType[XMLTagType["CDATA"] = 3] = "CDATA";
        XMLTagType[XMLTagType["Comment"] = 4] = "Comment";
        XMLTagType[XMLTagType["Instruction"] = 5] = "Instruction";
    })(exports.XMLTagType || (exports.XMLTagType = {}));
    const CDATA_START = "<![CDATA[";
    const CDATA_END = "]]>";
    const COMMENT_START = "<!--";
    const COMMENT_END = "-->";
    class XMLIterator {
        static begin(source, lowerCaseName) {
            XMLIterator.source = source;
            XMLIterator.lowerCaseName = lowerCaseName;
            this.sourceLen = source.length;
            this.parsePos = 0;
            this.lastTagEnd = 0;
            this.tagPos = 0;
            this.tagLength = 0;
            this.tagName = null;
        }
        static nextTag() {
            let pos;
            let c;
            let buffer = "";
            this.tagType = exports.XMLTagType.Start;
            this.lastTagEnd = this.parsePos;
            this.attrParsed = false;
            this.lastTagName = this.tagName;
            while ((pos = this.source.indexOf('<', this.parsePos)) != -1) {
                this.parsePos = pos;
                pos++;
                if (pos == this.sourceLen)
                    break;
                c = this.source[pos];
                if (c == '!') {
                    if (this.sourceLen > pos + 7 && this.source.substring(pos - 1, pos + 8) == CDATA_START) {
                        pos = this.source.indexOf(CDATA_END, pos);
                        this.tagType = exports.XMLTagType.CDATA;
                        this.tagName = "";
                        this.tagPos = this.parsePos;
                        if (pos == -1)
                            this.tagLength = this.sourceLen - this.parsePos;
                        else
                            this.tagLength = pos + 3 - this.parsePos;
                        this.parsePos += this.tagLength;
                        return true;
                    }
                    else if (this.sourceLen > pos + 2 && this.source.substring(pos - 1, pos + 3) == COMMENT_START) {
                        pos = this.source.indexOf(COMMENT_END, pos);
                        this.tagType = exports.XMLTagType.Comment;
                        this.tagName = "";
                        this.tagPos = this.parsePos;
                        if (pos == -1)
                            this.tagLength = this.sourceLen - this.parsePos;
                        else
                            this.tagLength = pos + 3 - this.parsePos;
                        this.parsePos += this.tagLength;
                        return true;
                    }
                    else {
                        pos++;
                        this.tagType = exports.XMLTagType.Instruction;
                    }
                }
                else if (c == '/') {
                    pos++;
                    this.tagType = exports.XMLTagType.End;
                }
                else if (c == '?') {
                    pos++;
                    this.tagType = exports.XMLTagType.Instruction;
                }
                for (; pos < this.sourceLen; pos++) {
                    c = this.source[pos];
                    if (' \t\n\r\v'.indexOf(c) != -1 || c == '>' || c == '/')
                        break;
                }
                if (pos == this.sourceLen)
                    break;
                buffer += this.source.substring(this.parsePos + 1, pos);
                if (buffer.length > 0 && buffer[0] == '/')
                    buffer = buffer.substring(1);
                let singleQuoted = false, doubleQuoted = false;
                let possibleEnd = -1;
                for (; pos < this.sourceLen; pos++) {
                    c = this.source[pos];
                    if (c == '"') {
                        if (!singleQuoted)
                            doubleQuoted = !doubleQuoted;
                    }
                    else if (c == '\'') {
                        if (!doubleQuoted)
                            singleQuoted = !singleQuoted;
                    }
                    if (c == '>') {
                        if (!(singleQuoted || doubleQuoted)) {
                            possibleEnd = -1;
                            break;
                        }
                        possibleEnd = pos;
                    }
                    else if (c == '<')
                        break;
                }
                if (possibleEnd != -1)
                    pos = possibleEnd;
                if (pos == this.sourceLen)
                    break;
                if (this.source[pos - 1] == '/')
                    this.tagType = exports.XMLTagType.Void;
                this.tagName = buffer;
                if (this.lowerCaseName)
                    this.tagName = this.tagName.toLowerCase();
                this.tagPos = this.parsePos;
                this.tagLength = pos + 1 - this.parsePos;
                this.parsePos += this.tagLength;
                return true;
            }
            this.tagPos = this.sourceLen;
            this.tagLength = 0;
            this.tagName = null;
            return false;
        }
        static getTagSource() {
            return this.source.substring(this.tagPos, this.tagPos + this.tagLength);
        }
        static getRawText(trim) {
            if (this.lastTagEnd == this.tagPos)
                return "";
            else if (trim) {
                let i = this.lastTagEnd;
                for (; i < this.tagPos; i++) {
                    let c = this.source[i];
                    if (' \t\n\r\v'.indexOf(c) == -1)
                        break;
                }
                if (i == this.tagPos)
                    return "";
                else
                    return this.source.substring(i, this.tagPos).trim();
            }
            else
                return this.source.substring(this.lastTagEnd, this.tagPos);
        }
        static getText(trim) {
            if (this.lastTagEnd == this.tagPos)
                return "";
            else if (trim) {
                let i = this.lastTagEnd;
                for (; i < this.tagPos; i++) {
                    let c = this.source[i];
                    if (' \t\n\r\v'.indexOf(c) == -1)
                        break;
                }
                if (i == this.tagPos)
                    return "";
                else
                    return XMLUtils.decodeString(this.source.substring(i, this.tagPos)).trimEnd();
            }
            else
                return XMLUtils.decodeString(this.source.substring(this.lastTagEnd, this.tagPos));
        }
        static get attributes() {
            if (!this.attrParsed) {
                for (let key in this._attrs) {
                    delete this._attrs[key];
                }
                this.parseAttributes(this._attrs);
                this.attrParsed = true;
            }
            return this._attrs;
        }
        static getAttribute(attrName) {
            return this.attributes[attrName];
        }
        static parseAttributes(attrs) {
            let attrName;
            let valueStart = 0;
            let valueEnd = 0;
            let waitValue = false;
            let quoted = 0;
            let buffer = "";
            let i = this.tagPos;
            let attrEnd = this.tagPos + this.tagLength;
            if (i < attrEnd && this.source[i] == '<') {
                for (; i < attrEnd; i++) {
                    let c = this.source[i];
                    if (' \t\n\r\v'.indexOf(c) != -1 || c == '>' || c == '/')
                        break;
                }
            }
            for (; i < attrEnd; i++) {
                let c = this.source[i];
                if (c == '=') {
                    valueStart = -1;
                    valueEnd = -1;
                    quoted = 0;
                    for (let j = i + 1; j < attrEnd; j++) {
                        let c2 = this.source[j];
                        if (' \t\n\r\v'.indexOf(c2) != -1) {
                            if (valueStart != -1 && quoted == 0) {
                                valueEnd = j - 1;
                                break;
                            }
                        }
                        else if (c2 == '>') {
                            if (quoted == 0) {
                                valueEnd = j - 1;
                                break;
                            }
                        }
                        else if (c2 == '"') {
                            if (valueStart != -1) {
                                if (quoted != 1) {
                                    valueEnd = j - 1;
                                    break;
                                }
                            }
                            else {
                                quoted = 2;
                                valueStart = j + 1;
                            }
                        }
                        else if (c2 == '\'') {
                            if (valueStart != -1) {
                                if (quoted != 2) {
                                    valueEnd = j - 1;
                                    break;
                                }
                            }
                            else {
                                quoted = 1;
                                valueStart = j + 1;
                            }
                        }
                        else if (valueStart == -1) {
                            valueStart = j;
                        }
                    }
                    if (valueStart != -1 && valueEnd != -1) {
                        attrName = buffer;
                        if (this.lowerCaseName)
                            attrName = attrName.toLowerCase();
                        buffer = "";
                        attrs[attrName] = XMLUtils.decodeString(this.source.substring(valueStart, valueEnd + 1));
                        i = valueEnd + 1;
                    }
                    else
                        break;
                }
                else if (' \t\n\r\v'.indexOf(c) == -1) {
                    if (waitValue || c == '/' || c == '>') {
                        if (buffer.length > 0) {
                            attrName = buffer;
                            if (this.lowerCaseName)
                                attrName = attrName.toLowerCase();
                            attrs[attrName] = "";
                            buffer = "";
                        }
                        waitValue = false;
                    }
                    if (c != '/' && c != '>')
                        buffer += c;
                }
                else {
                    if (buffer.length > 0)
                        waitValue = true;
                }
            }
        }
    }
    XMLIterator._attrs = {};
    if (!String.prototype.trimEnd) {
        String.prototype.trimEnd = function () {
            return this.replace(/\s+$/g, "");
        };
    }

    class XML {
        constructor(XmlString) {
            if (XmlString)
                this.parse(XmlString);
        }
        get attributes() {
            if (!this._attrs)
                this._attrs = {};
            return this._attrs;
        }
        getAttrString(attrName, defValue) {
            return XMLUtils.getString(this._attrs, attrName, defValue);
        }
        getAttrInt(attrName, defValue) {
            return XMLUtils.getInt(this._attrs, attrName, defValue);
        }
        getAttrFloat(attrName, defValue) {
            return XMLUtils.getFloat(this._attrs, attrName, defValue);
        }
        getAttrBool(attrName, defValue) {
            return XMLUtils.getBool(this._attrs, attrName, defValue);
        }
        setAttribute(attrName, attrValue) {
            if (!this._attrs)
                this._attrs = {};
            this._attrs[attrName] = attrValue;
        }
        getNode(selector) {
            if (!this._children)
                return null;
            else
                return this._children.find(value => {
                    return value.name == selector;
                });
        }
        elements(selector) {
            if (!this._children)
                this._children = new Array();
            if (selector)
                return this._children.filter(value => {
                    return value.name == selector;
                });
            else
                return this._children;
        }
        parse(aSource) {
            this.reset();
            let lastOpenNode;
            let nodeStack = new Array();
            XMLIterator.begin(aSource);
            while (XMLIterator.nextTag()) {
                if (XMLIterator.tagType == exports.XMLTagType.Start || XMLIterator.tagType == exports.XMLTagType.Void) {
                    let childNode;
                    if (lastOpenNode)
                        childNode = new XML();
                    else {
                        if (this.name != null) {
                            this.reset();
                            throw new Error("Invalid xml format - no root node.");
                        }
                        childNode = this;
                    }
                    childNode.name = XMLIterator.tagName;
                    childNode._attrs = Object.assign({}, XMLIterator.attributes);
                    if (lastOpenNode) {
                        if (XMLIterator.tagType != exports.XMLTagType.Void)
                            nodeStack.push(lastOpenNode);
                        if (lastOpenNode._children == null)
                            lastOpenNode._children = new Array();
                        lastOpenNode._children.push(childNode);
                    }
                    if (XMLIterator.tagType != exports.XMLTagType.Void)
                        lastOpenNode = childNode;
                }
                else if (XMLIterator.tagType == exports.XMLTagType.End) {
                    if (lastOpenNode == null || lastOpenNode.name != XMLIterator.tagName) {
                        this.reset();
                        throw new Error("Invalid xml format - <" + XMLIterator.tagName + "> dismatched.");
                    }
                    if (lastOpenNode._children == null || lastOpenNode._children.length == 0) {
                        lastOpenNode.text = XMLIterator.getText();
                    }
                    if (nodeStack.length > 0)
                        lastOpenNode = nodeStack.pop();
                    else
                        lastOpenNode = null;
                }
            }
        }
        reset() {
            this._attrs = null;
            if (this._children != null)
                this._children.length == 0;
            this.text = null;
        }
    }

    class HttpRequest extends EventDispatcher {
        constructor() {
            super(...arguments);
            this._http = new XMLHttpRequest();
        }
        send(url, data = null, method = "get", responseType = "text", headers) {
            this._responseType = responseType;
            this._data = null;
            this._url = url;
            let http = this._http;
            http.open(method, url, true);
            let hasContentType = headers && headers.indexOf("Content-Type") !== -1;
            if (data) {
                if (typeof (data) == 'string') {
                    if (!hasContentType)
                        http.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                }
                else {
                    if (!hasContentType)
                        http.setRequestHeader("Content-Type", "application/json");
                    if (!(data instanceof ArrayBuffer))
                        data = JSON.stringify(data);
                }
            }
            else if (Browser.onBLMiniGame && Browser.onAndroid)
                data = {};
            if (headers) {
                for (let i = 0; i < headers.length; i++) {
                    http.setRequestHeader(headers[i++], headers[i]);
                }
            }
            let restype = responseType !== "arraybuffer" ? "text" : "arraybuffer";
            http.responseType = restype;
            if (http.dataType) {
                http.dataType = restype;
            }
            http.onerror = e => this._onError(e);
            http.onabort = e => this._onAbort(e);
            http.onprogress = e => this._onProgress(e);
            http.onload = e => this._onLoad(e);
            http.send(data);
        }
        _onProgress(e) {
            if (e && e.lengthComputable)
                this.event(Event.PROGRESS, e.loaded / e.total);
        }
        _onAbort(e) {
            this.error("Request was aborted by user");
        }
        _onError(e) {
            this.error("Request failed Status:" + this._http.status + " text:" + this._http.statusText);
        }
        _onLoad(e) {
            var http = this._http;
            var status = http.status !== undefined ? http.status : 200;
            if (status === 200 || status === 204 || status === 0) {
                this.complete();
            }
            else {
                this.error("[" + http.status + "]" + http.statusText + ":" + http.responseURL);
            }
        }
        error(message) {
            this.clear();
            this.event(Event.ERROR, message);
        }
        complete() {
            this.clear();
            var flag = true;
            try {
                if (this._responseType === "json") {
                    this._data = JSON.parse(this._http.responseText);
                }
                else if (this._responseType === "xml") {
                    this._data = new XML(this._http.responseText);
                }
                else {
                    this._data = this._http.response || this._http.responseText;
                }
            }
            catch (e) {
                flag = false;
                this.error(e.message);
            }
            flag && this.event(Event.COMPLETE, this._data instanceof Array ? [this._data] : this._data);
        }
        clear() {
            var http = this._http;
            http.onerror = http.onabort = http.onprogress = http.onload = null;
        }
        get url() {
            return this._url;
        }
        get data() {
            return this._data;
        }
        get http() {
            return this._http;
        }
        reset() {
            this.offAll();
            this._data = null;
        }
    }

    class Downloader {
        constructor() {
            this.httpRequestPool = [];
        }
        common(owner, url, originalUrl, contentType, onProgress, onComplete) {
            let http = this.getRequestInst();
            http.on(Event.COMPLETE, () => {
                let data = http.data;
                this.returnRequestInst(http);
                onComplete(data);
            });
            http.on(Event.ERROR, null, (error) => {
                this.returnRequestInst(http);
                onComplete(null, error);
            });
            if (onProgress)
                http.on(Event.PROGRESS, onProgress);
            http.send(url, null, "get", contentType);
            owner.$ref = http;
        }
        image(owner, url, originalUrl, onProgress, onComplete) {
            let image = new Browser.window.Image();
            image.crossOrigin = "";
            image.onload = () => {
                image.onload = null;
                image.onerror = null;
                onComplete(image);
            };
            image.onerror = () => {
                image.onload = null;
                image.onerror = null;
                onComplete(null, "");
            };
            image.src = url;
            owner.$ref = image;
        }
        imageWithBlob(owner, blob, originalUrl, onProgress, onComplete) {
            let url = PAL.browser.createBufferURL(blob);
            if (url)
                this.image(owner, url, originalUrl, onProgress, onComplete);
            else
                onComplete(null, "Blob URL creation not supported.");
        }
        imageWithWorker(owner, url, originalUrl, onProgress, onComplete) {
            WorkerLoader.enable = true;
            if (WorkerLoader.enable) {
                WorkerLoader.load(url, owner.workerLoaderOptions)
                    .then(onComplete)
                    .catch((error) => onComplete(null, error));
            }
            else
                this.image(owner, url, originalUrl, onProgress, onComplete);
        }
        audio(owner, url, originalUrl, onProgress, onComplete) {
            let audio = Browser.createElement("audio");
            audio.crossOrigin = "";
            audio.oncanplaythrough = () => {
                audio.oncanplaythrough = null;
                audio.onerror = null;
                onComplete(audio);
            };
            audio.onerror = () => {
                audio.oncanplaythrough = null;
                audio.onerror = null;
                onComplete(null, "");
            };
            audio.src = url;
            owner.$ref = audio;
        }
        package(path, onProgress, onComplete) {
            onComplete(null);
        }
        getRequestInst() {
            if (this.httpRequestPool.length == 0
                || Browser.onVVMiniGame || Browser.onHWMiniGame) {
                return new HttpRequest();
            }
            else {
                return this.httpRequestPool.pop();
            }
        }
        returnRequestInst(inst) {
            inst.reset();
            if (this.httpRequestPool.length < 10)
                this.httpRequestPool.push(inst);
        }
    }

    var typeIdCounter = 0;
    const NullURLInfo = { ext: null, typeId: null, main: false, loaderType: null };
    class Loader extends EventDispatcher {
        static registerLoader(exts, cls, type, hotReloadable) {
            let typeEntry;
            if (type) {
                typeEntry = Loader.typeMap[type];
                if (!typeEntry)
                    Loader.typeMap[type] = typeEntry = { typeId: typeIdCounter++, loaderType: cls };
                else if (typeEntry.loaderType != cls)
                    typeEntry = { typeId: typeEntry.typeId, loaderType: cls };
            }
            else
                typeEntry = { typeId: typeIdCounter++, loaderType: cls };
            if (hotReloadable)
                Loader.hotReloadableFlags[typeEntry.typeId] = true;
            for (let ext of exts) {
                let entry = Loader.extMap[ext];
                if (entry && type) {
                    let i = entry.findIndex(e => e.typeId == typeEntry.typeId);
                    if (i === -1)
                        entry.push(typeEntry);
                    else
                        entry[i].loaderType = cls;
                }
                else {
                    Loader.extMap[ext] = [typeEntry];
                }
            }
        }
        constructor() {
            super();
            this.retryNum = 1;
            this.retryDelay = 0;
            this.maxLoader = 5;
            this._loadings = new Map();
            this._queue = [];
            this._downloadings = new Set();
        }
        get loading() {
            return this._loadings.size > 0;
        }
        load(url, arg1, arg2, arg3, priority, cache, group, ignoreCache, useWorkerLoader) {
            let complete;
            let type;
            let options = dummyOptions;
            if (arg1 instanceof Handler) {
                complete = arg1;
                type = arg3;
            }
            else if (typeof (arg1) === "string")
                type = arg1;
            else if (arg1 != null) {
                type = arg1.type;
                options = arg1;
            }
            if (priority != null || cache != null || ignoreCache != null || group != null || useWorkerLoader != null) {
                if (options === dummyOptions)
                    options = { priority, cache, ignoreCache, group, useWorkerLoader };
                else
                    options = Object.assign(options, { priority, cache, ignoreCache, group, useWorkerLoader });
            }
            if (options.cache === false)
                options.ignoreCache = true;
            let onProgress;
            if (arg2 instanceof Handler)
                onProgress = (value) => arg2.runWith(value);
            else
                onProgress = arg2;
            let promise;
            if (Array.isArray(url)) {
                let pd;
                if (onProgress)
                    pd = new BatchProgress(onProgress);
                let promises = [];
                for (let i = 0; i < url.length; i++) {
                    let url2 = url[i];
                    if (!url2)
                        continue;
                    if (typeof (url2) === "string") {
                        promises.push(this._load1(url2, type, options, pd === null || pd === void 0 ? void 0 : pd.createCallback()));
                    }
                    else {
                        promises.push(this._load1(url2.url, url2.type || type, options !== dummyOptions ? Object.assign({}, options, url2) : url2, pd === null || pd === void 0 ? void 0 : pd.createCallback()));
                    }
                }
                promise = Promise.all(promises);
            }
            else if (typeof (url) === "string")
                promise = this._load1(url, type, options, onProgress);
            else
                promise = this._load1(url.url, url.type || type, options !== dummyOptions ? Object.assign({}, options, url) : url, onProgress);
            if (complete)
                return promise.then(result => {
                    complete.runWith(result);
                    return result;
                });
            else
                return promise;
        }
        _load1(url, type, options, onProgress) {
            if (LayaEnv.isPreview) {
                if (url.startsWith("res://")) {
                    let uuid = url.substring(6);
                    return AssetDb.inst.UUID_to_URL_async(uuid).then(url2 => {
                        var _a;
                        if (url2)
                            return this._load2(url2, uuid, type, options, onProgress);
                        else {
                            !options.silent && Loader.warnFailed(url, undefined, (_a = options.initiator) === null || _a === void 0 ? void 0 : _a.url);
                            return Promise.resolve(null);
                        }
                    });
                }
                else {
                    return AssetDb.inst.URL_to_UUID_async(url).then(uuid => {
                        return this._load2(url, uuid, type, options, onProgress);
                    });
                }
            }
            else
                return this._load2(url, null, type, options, onProgress);
        }
        _load2(url, uuid, type, options, onProgress) {
            var _a, _b;
            let { ext, typeId, main, loaderType } = Loader.getURLInfo(url, type, options.maybeType);
            if (!loaderType) {
                !options.silent && Loader.warnFailed(url, type ? `unsupported load type:${type}` : !url.startsWith("res://") ? `unsupported suffix` : "", (_a = options.initiator) === null || _a === void 0 ? void 0 : _a.url);
                return Promise.resolve(null);
            }
            let formattedUrl = URL.formatURL(url);
            if (options.group) {
                let set = Loader.groupMap[options.group];
                if (!set)
                    set = Loader.groupMap[options.group] = new Set();
                set.add(formattedUrl);
            }
            let obsoluteRes;
            if (!options.ignoreCache) {
                let cacheRes = Loader._getRes(formattedUrl, type);
                if (cacheRes !== undefined) {
                    if (cacheRes == null)
                        return Promise.resolve(null);
                    else {
                        if (!(cacheRes instanceof Resource))
                            return Promise.resolve(cacheRes);
                        if (cacheRes.obsolute)
                            obsoluteRes = cacheRes;
                        if (!obsoluteRes && (!cacheRes.uuid || !uuid || uuid == cacheRes.uuid))
                            return Promise.resolve(cacheRes);
                    }
                }
            }
            let loadingKey = formattedUrl;
            if (!main)
                loadingKey += "@" + typeId;
            let task = this._loadings.get(loadingKey);
            if (task) {
                let p = options.initiator;
                while (p) {
                    if (p === task)
                        return Promise.resolve();
                    p = p.options.initiator;
                }
                if (task.result != null)
                    return task.result;
                if (onProgress)
                    task.onProgress.add(onProgress);
                return new Promise((resolve) => task.onComplete.add(resolve));
            }
            let atlasInfo = AtlasInfoManager.getFileLoadPath(formattedUrl);
            if (atlasInfo) {
                return this.load(atlasInfo.url, { type: Loader.ATLAS, baseUrl: atlasInfo.baseUrl }).then(() => {
                    return Loader.getRes(url, type);
                });
            }
            if (loadTaskPool.length > 0)
                task = loadTaskPool.pop();
            else
                task = new LoadTask();
            task.type = type;
            task.url = url;
            task.uuid = uuid;
            task.ext = ext;
            options = Object.assign(task.options, options);
            delete options.type;
            if (options.priority == null)
                options.priority = 0;
            if (options.useWorkerLoader == null)
                options.useWorkerLoader = WorkerLoader.enable;
            if (onProgress)
                task.onProgress.add(onProgress);
            task.loader = this;
            task.obsoluteInst = obsoluteRes;
            let assetLoader = new loaderType();
            this._loadings.set(loadingKey, task);
            let promise;
            let now = performance.now();
            try {
                LayaGL.statAgent.recordCountData(exports.StatElement.C_LoadResourceCount, 1);
                promise = assetLoader.load(task);
            }
            catch (err) {
                !options.silent && Loader.warnFailed(url, err, (_b = options.initiator) === null || _b === void 0 ? void 0 : _b.url);
                promise = Promise.resolve(null);
            }
            return promise.then(content => {
                LayaGL.statAgent.recordTimeData(exports.StatElement.T_LoadResourceTime, performance.now() - now);
                if (content instanceof Resource) {
                    content.obsolute = false;
                    content._setCreateURL(url, uuid);
                }
                if (task.options.cache !== false)
                    Loader._cacheRes(formattedUrl, content, typeId, main);
                if (content != null && assetLoader.postLoad != null) {
                    task.result = content;
                    return assetLoader.postLoad(task, content).then(() => {
                        task.progress.update(-1, 1);
                        task.onComplete.invoke(content);
                        return content;
                    });
                }
                else {
                    task.progress.update(-1, 1);
                    task.onComplete.invoke(content);
                    return content;
                }
            }).catch(error => {
                var _a;
                !options.silent && Loader.warnFailed(url, error, (_a = options.initiator) === null || _a === void 0 ? void 0 : _a.url);
                if (task.options.cache !== false)
                    Loader._cacheRes(formattedUrl, null, typeId, main);
                task.onComplete.invoke(null);
                return null;
            }).then(content => {
                this._loadings.delete(loadingKey);
                task.reset();
                loadTaskPool.push(task);
                if (this._loadings.size == 0)
                    this.event(Event.COMPLETE);
                return content;
            });
        }
        fetch(url, contentType, onProgress, options) {
            var _a;
            options = options || dummyOptions;
            let task = {
                originalUrl: url,
                url: url,
                contentType: contentType,
                priority: (_a = options.priority) !== null && _a !== void 0 ? _a : 1,
                retryCnt: 0,
                onProgress: onProgress,
                onComplete: null,
            };
            if (options.useWorkerLoader) {
                task.useWorkerLoader = true;
                task.workerLoaderOptions = options.workerLoaderOptions;
            }
            if (options.blob)
                task.blob = options.blob;
            if (options.noRetry)
                task.retryCnt = -1;
            if (options.silent)
                task.silent = true;
            return AssetDb.inst.resolveURL(url).then(url => {
                if (url)
                    return new Promise((resolve) => {
                        task.url = URL.formatURL(url);
                        task.onComplete = resolve;
                        this.queueToDownload(task);
                    });
                else
                    return null;
            });
        }
        queueToDownload(item) {
            if (this._downloadings.size < this.maxLoader) {
                this.download(item);
                return;
            }
            let priority = item.priority;
            if (priority == 0)
                this._queue.push(item);
            else {
                let i = this._queue.findIndex(e => e.priority < priority);
                if (i != -1)
                    this._queue.splice(i, 0, item);
                else
                    this._queue.push(item);
            }
        }
        download(item) {
            this._downloadings.add(item);
            LayaGL.statAgent.recordCountData(exports.StatElement.C_LoadRequestCount, 1);
            item.startTime = performance.now();
            let url = URL.postFormatURL(item.url);
            if (item.contentType == "image") {
                let preloadedContent = Loader.preLoadedMap[item.url];
                if (preloadedContent) {
                    if (!(preloadedContent instanceof ArrayBuffer)) {
                        this.completeItem(item, preloadedContent);
                        return;
                    }
                    item.blob = preloadedContent;
                }
                if (item.blob) {
                    Loader.downloader.imageWithBlob(item, item.blob, item.originalUrl, item.onProgress, (data, error) => {
                        if (!data)
                            item.retryCnt = -1;
                        this.completeItem(item, data, error);
                    });
                }
                else if (item.useWorkerLoader) {
                    Loader.downloader.imageWithWorker(item, url, item.originalUrl, item.onProgress, (data, error) => {
                        if (!data) {
                            item.useWorkerLoader = false;
                            if (!item.silent)
                                Loader.warnFailed(item.url, error);
                        }
                        this.completeItem(item, data, error);
                    });
                }
                else {
                    Loader.downloader.image(item, url, item.originalUrl, item.onProgress, (data, error) => this.completeItem(item, data, error));
                }
            }
            else if (item.contentType == "sound") {
                Loader.downloader.audio(item, url, item.originalUrl, item.onProgress, (data, error) => this.completeItem(item, data, error));
            }
            else {
                let preloadedContent = Loader.preLoadedMap[item.url];
                if (preloadedContent) {
                    this.completeItem(item, preloadedContent);
                    return;
                }
                Loader.downloader.common(item, url, item.originalUrl, item.contentType, item.onProgress, (data, error) => this.completeItem(item, data, error));
            }
        }
        completeItem(item, content, error) {
            this._downloadings.delete(item);
            LayaGL.statAgent.recordTimeData(exports.StatElement.T_LoadRequestTime, performance.now() - item.startTime);
            if (content) {
                if (this._downloadings.size < this.maxLoader && this._queue.length > 0)
                    this.download(this._queue.shift());
                if (item.onProgress)
                    item.onProgress(1);
                item.onComplete(content);
            }
            else if (item.retryCnt != -1 && item.retryCnt < this.retryNum) {
                item.retryCnt++;
                if (!item.silent)
                    console.debug(`Retry to load ${item.url} (${item.retryCnt})`);
                ILaya.systemTimer.once(this.retryDelay, this, this.queueToDownload, [item], false);
            }
            else {
                !item.silent && Loader.warnFailed(item.url, error);
                if (item.onProgress)
                    item.onProgress(1);
                if (this._downloadings.size < this.maxLoader && this._queue.length > 0)
                    this.download(this._queue.shift());
                item.onComplete(null);
            }
        }
        static getURLInfo(url, type, maybeType) {
            let ext = url.startsWith("data:") ? "png" : Utils.getFileExtension(url);
            let extEntry;
            if (ext.length > 0)
                extEntry = Loader.extMap[ext];
            if (!extEntry && !type)
                type = maybeType;
            let typeId;
            let main;
            let loaderType;
            if (type) {
                let typeEntry = Loader.typeMap[type];
                if (!typeEntry)
                    return NullURLInfo;
                typeId = typeEntry.typeId;
                let i = 0;
                if (extEntry) {
                    if (extEntry[0].typeId === typeId
                        || (i = extEntry.findIndex(e => e.typeId === typeId)) != -1) {
                        main = i === 0;
                        loaderType = extEntry[i].loaderType;
                    }
                    else {
                        main = false;
                        loaderType = typeEntry.loaderType;
                    }
                }
                else {
                    main = type != Loader.TEXTURE2D;
                    loaderType = typeEntry.loaderType;
                }
            }
            else {
                if (!extEntry)
                    return NullURLInfo;
                main = true;
                typeId = extEntry[0].typeId;
                loaderType = extEntry[0].loaderType;
            }
            return { ext, main, typeId, loaderType };
        }
        static warnFailed(url, err, initiatorUrl) {
            if (initiatorUrl)
                this.warn(`Failed to load '${url}' (in '${initiatorUrl}')`, err);
            else
                this.warn(`Failed to load '${url}'`, err);
        }
        static warn(msg, err) {
            if (err)
                console.warn(msg, err);
            else
                console.warn(msg);
        }
        static getRes(url, type) {
            url = URL.formatURL(url);
            let ret = Loader._getRes(url, type);
            return ret || null;
        }
        static _getRes(url, type) {
            let resArr = Loader.loadedMap[url];
            if (!resArr)
                return undefined;
            let ret;
            if (type) {
                let typeEntry = Loader.typeMap[type];
                if (!typeEntry)
                    return undefined;
                if (resArr.length == 2) {
                    if (resArr[0] == typeEntry.typeId)
                        ret = resArr[1];
                }
                else {
                    let i = resArr.indexOf(typeEntry.typeId);
                    if (i != -1)
                        ret = resArr[i + 1];
                }
            }
            else
                ret = resArr[1];
            if ((ret instanceof Resource) && ret.destroyed)
                return undefined;
            else
                return ret;
        }
        static getTexture2D(url) {
            return Loader.getRes(url, Loader.TEXTURE2D);
        }
        static getBaseTexture(url) {
            return Loader.getRes(url, Loader.TEXTURE2D);
        }
        static getAtlas(url) {
            return Loader.getRes(url, Loader.ATLAS);
        }
        getRes(url, type) {
            return Loader.getRes(url, type);
        }
        static createNodes(url) {
            var _a;
            return (_a = Loader.getRes(url)) === null || _a === void 0 ? void 0 : _a.create();
        }
        static cacheRes(url, data, type) {
            url = URL.formatURL(url);
            let urlInfo = Loader.getURLInfo(url, type);
            if (urlInfo.typeId != null)
                Loader._cacheRes(url, data, urlInfo.typeId, urlInfo.main);
        }
        static _cacheRes(url, data, typeId, main) {
            let entry = Loader.loadedMap[url];
            if (main) {
                if (entry) {
                    entry[0] = typeId;
                    entry[1] = data;
                }
                else
                    entry = Loader.loadedMap[url] = [typeId, data];
            }
            else {
                if (entry) {
                    let i = entry.findIndex(e => e === typeId);
                    if (i != -1)
                        entry[i + 1] = data;
                    else
                        entry.push(typeId, data);
                }
                else
                    entry = Loader.loadedMap[url] = [null, undefined, typeId, data];
            }
        }
        cacheRes(url, data, type) {
            Loader.cacheRes(url, data, type);
        }
        static clearRes(url, checkObj) {
            url = URL.formatURL(url);
            Loader._clearRes(url, checkObj);
        }
        clearRes(url, checkObj) {
            url = URL.formatURL(url);
            Loader._clearRes(url, checkObj);
        }
        static _clearRes(url, checkObj) {
            let entry = Loader.loadedMap[url];
            if (!entry)
                return;
            if (checkObj) {
                if (entry[1] == checkObj) {
                    if (entry.length == 2)
                        delete Loader.loadedMap[url];
                    else
                        entry[1] = undefined;
                }
                else {
                    let i = entry.indexOf(checkObj);
                    if (i === -1)
                        return;
                    if (entry.length == 4 && entry[0] == null)
                        delete Loader.loadedMap[url];
                    else
                        entry.splice(i - 1, 2);
                }
                if ((checkObj instanceof Resource) && !checkObj.destroyed) {
                    checkObj.destroy();
                }
            }
            else {
                delete Loader.loadedMap[url];
                if (entry.length > 2) {
                    for (let i = 1; i < entry.length; i += 2) {
                        let obj = entry[i];
                        if ((obj instanceof Resource) && !obj.destroyed) {
                            obj.destroy();
                        }
                    }
                }
                else {
                    let obj = entry[1];
                    if ((obj instanceof Resource) && !obj.destroyed) {
                        obj.destroy();
                    }
                }
            }
        }
        clearTextureRes(url) {
            url = URL.formatURL(url);
            let entry = Loader.loadedMap[url];
            if (!entry)
                return;
            let res = entry[1];
            if (res instanceof Texture) {
                res.disposeBitmap();
            }
            else if (res instanceof AtlasResource) {
                for (let tex of res.textures)
                    tex.disposeBitmap();
            }
        }
        static setGroup(url, group) {
            url = URL.formatURL(url);
            let set = Loader.groupMap[group];
            if (!set)
                set = Loader.groupMap[group] = new Set();
            set.add(url);
        }
        static clearResByGroup(group) {
            let set = Loader.groupMap[group];
            if (set) {
                for (let k of set)
                    Loader._clearRes(k);
            }
        }
        clearUnLoaded() {
            if (this._queue.length == 0)
                return;
            let arr = this._queue.concat();
            this._queue.length = 0;
            for (let item of arr)
                item.onComplete(null);
        }
        cancelLoadByUrls(urls) {
            if (!urls)
                return;
            for (var i = 0, n = urls.length; i < n; i++) {
                this.cancelLoadByUrl(urls[i]);
            }
        }
        cancelLoadByUrl(url) {
            url = URL.formatURL(url);
            let i = this._queue.findIndex(item => item.url == url);
            if (i != -1) {
                let item = this._queue[i];
                this._queue.splice(i, 1);
                item.onComplete(null);
            }
        }
        loadPackage(path, arg2, arg3) {
            let progress;
            let remoteUrl;
            if (typeof (arg2) === "string") {
                remoteUrl = arg2;
                progress = arg3;
            }
            else {
                progress = arg3 || arg2;
            }
            if (remoteUrl) {
                if (!remoteUrl.endsWith("/"))
                    remoteUrl += "/";
                URL.basePaths[path.length > 0 ? (path + "/") : path] = remoteUrl;
                return this._loadFileConfig(path, true, progress);
            }
            else {
                if (LayaEnv.isPreview)
                    return Promise.resolve(true);
                if (path.length === 0)
                    return this._loadFileConfig(path, true, progress);
                else
                    return new Promise((resolve) => {
                        Loader.downloader.package(path, progress, (data, error) => {
                            var _a;
                            if (error != null) {
                                Loader.warn(`Failed to load package '${path}'`, error);
                                resolve(false);
                                return;
                            }
                            this._loadFileConfig(path, (_a = data === null || data === void 0 ? void 0 : data.loadScript) !== null && _a !== void 0 ? _a : true, progress).then(() => resolve(true));
                        });
                    });
            }
        }
        _loadFileConfig(path, loadScript, onProgress) {
            if (path.length > 0)
                path += "/";
            return this.fetch(path + "fileconfig.json", "json", onProgress).then(fileConfig => {
                if (fileConfig == null)
                    return false;
                this._parseFileConfig(fileConfig);
                if (loadScript && fileConfig.entry)
                    return Browser.loadLib(path + fileConfig.entry).then(() => true);
                else
                    return true;
            });
        }
        _parseFileConfig(fileConfig) {
            let files = [];
            let col = fileConfig.files;
            for (let k in col) {
                if (k.length > 0) {
                    for (let file of col[k])
                        files.push(k + "/" + file);
                }
                else {
                    for (let file of col[k])
                        files.push(file);
                }
            }
            if (fileConfig.hash) {
                let i = 0;
                let version = URL.version;
                for (let k of fileConfig.hash) {
                    if (k != null)
                        version[files[i]] = k;
                    i++;
                }
            }
            let configs = fileConfig.config;
            let len = configs.length;
            let i = 0, j = 0, m = 0, k = 0, n = 0;
            let indice;
            let c;
            let metaMap = AssetDb.inst.metaMap;
            while (true) {
                if (indice == null) {
                    if (i >= len)
                        break;
                    c = configs[i];
                    indice = c.i;
                    if (Array.isArray(indice))
                        n = indice.length;
                    else {
                        m = indice;
                        n = 0;
                        k = 1;
                    }
                    j = 0;
                }
                if (k == 0) {
                    if (j >= n) {
                        i++;
                        indice = null;
                        continue;
                    }
                    k = indice[j++];
                    if (k > 0) {
                        m = k;
                        k = 0;
                    }
                    else
                        k = -k;
                }
                else
                    k--;
                let file = files[m + k];
                switch (c.t) {
                    case 0:
                        metaMap[file] = c;
                        break;
                    case 1:
                        AtlasInfoManager.addAtlas(file, c.prefix, c.frames);
                        break;
                    case 2:
                        AssetDb.inst.shaderNameMap[c.shaderName] = file;
                        break;
                    case 3:
                        Loader.preLoadedMap[URL.formatURL(file)] = c;
                        break;
                    case 4:
                        URL.urlMapping[Utils.getBaseName(file)] = file;
                        break;
                }
            }
        }
    }
    Loader.TEXT = "text";
    Loader.JSON = "json";
    Loader.XML = "xml";
    Loader.BUFFER = "arraybuffer";
    Loader.IMAGE = "image";
    Loader.SOUND = "sound";
    Loader.VIDEO = "video";
    Loader.ATLAS = "atlas";
    Loader.FONT = "font";
    Loader.TTF = "ttf";
    Loader.HIERARCHY = "HIERARCHY";
    Loader.MESH = "MESH";
    Loader.MATERIAL = "MATERIAL";
    Loader.TEXTURE2D = "TEXTURE2D";
    Loader.TEXTURECUBE = "TEXTURE2D";
    Loader.TEXTURE2DARRAY = "TEXTURE2D";
    Loader.ANIMATIONCLIP = "ANIMATIONCLIP";
    Loader.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA";
    Loader.TERRAINRES = "TERRAIN";
    Loader.SPINE = "SPINE";
    Loader.extMap = {};
    Loader.typeMap = {};
    Loader.hotReloadableFlags = {};
    Loader.assetTypeToLoadType = {
        "Image": Loader.IMAGE,
        "Texture2D": Loader.TEXTURE2D,
        "RenderTexture": Loader.TEXTURE2D,
        "TextureCube": Loader.TEXTURECUBE,
        "Prefab": Loader.HIERARCHY,
        "Material": Loader.MATERIAL,
        "Mesh": Loader.MESH,
        "Spine": Loader.SPINE,
    };
    Loader.downloader = new Downloader();
    Loader.groupMap = {};
    Loader.loadedMap = {};
    Loader.preLoadedMap = {};
    class LoadTask {
        constructor() {
            this.options = {};
            this.onProgress = new Delegate();
            this.onComplete = new Delegate();
            this.progress = new BatchProgress((progress) => this.onProgress.invoke(progress));
        }
        reset() {
            for (let k in this.options)
                delete this.options[k];
            this.onProgress.clear();
            this.onComplete.clear();
            this.progress.reset();
            this.obsoluteInst = null;
            this.result = null;
        }
    }
    const loadTaskPool = [];
    const dummyOptions = {};

    class ClassUtils {
        static regClass(className, classDef) {
            ClassUtils._classMap[className] = classDef;
        }
        static getClass(className) {
            return ClassUtils._classMap[className];
        }
        static regRuntime(url, cls) {
            ClassUtils._runtimeMap[url] = cls;
        }
        static getRuntime(url) {
            return ClassUtils._runtimeMap[url];
        }
    }
    ClassUtils._classMap = {};
    ClassUtils._runtimeMap = {};

    function dummy$1() { }
    function regClass(assetId) {
        return function (constructor) {
            ClassUtils.regClass(assetId, constructor);
        };
    }
    function classInfo(info) { return dummy$1; }
    function runInEditor(constructor) { }
    function allowMultiple(constructor) {
        constructor.prototype._$singleton = false;
    }
    function property(info) { return dummy$1; }
    function regLoader(fileExtensions, type, hotReloadable) {
        return function (constructor) {
            Loader.registerLoader(fileExtensions, constructor, type, hotReloadable);
        };
    }

    class Const {
    }
    Const.MAX_CLIP_SIZE = 99999999;
    class NodeFlags {
    }
    NodeFlags.ACTIVE = 0x1;
    NodeFlags.ACTIVE_INHIERARCHY = 0x2;
    NodeFlags.AWAKED = 0x4;
    NodeFlags.DISPLAY = 0x10;
    NodeFlags.HAS_ZORDER = 0x20;
    NodeFlags.DISPLAYED_INSTAGE = 0x80;
    NodeFlags.CHECK_INPUT = 0x200;
    NodeFlags.DEMAND_TRANS_EVENT = 0x400;
    NodeFlags.HAS_SCRIPT = 0x800;
    NodeFlags.ESCAPE_DRAWING_TO_TEXTURE = 0x1000;
    NodeFlags.DISABLE_INNER_CLIPPING = 0x2000;
    NodeFlags.DISABLE_OUTER_CLIPPING = 0x4000;
    NodeFlags.FORCE_VISIBLE = 0x8000;
    NodeFlags.EDITING_NODE = 0x10000;
    NodeFlags.HIDE_BY_EDITOR = 0x20000;
    NodeFlags.LOCK_BY_EDITOR = 0x40000;
    NodeFlags.EDITING_ROOT_NODE = 0x80000;
    NodeFlags.FORCE_HIDDEN = 0x100000;
    NodeFlags.NOT_IN_PAGE = 0x200000;
    NodeFlags.ESCAPE_LAYOUT = 0x400000;
    class HideFlags {
    }
    HideFlags.HideInHierarchy = 0x1;
    HideFlags.HideInInspector = 0x2;
    HideFlags.DontSave = 0x4;
    HideFlags.HideAndDontSave = 0x7;

    class Matrix {
        static equals(a, b) {
            return MathUtils3D.nearEqual(a.a, b.a)
                && MathUtils3D.nearEqual(a.b, b.b)
                && MathUtils3D.nearEqual(a.c, b.c)
                && MathUtils3D.nearEqual(a.d, b.d)
                && MathUtils3D.nearEqual(a.tx, b.tx)
                && MathUtils3D.nearEqual(a.ty, b.ty);
        }
        static extractTransformInfo(matrix) {
            let { a, b, c, d, tx, ty } = matrix;
            let x = tx;
            let y = ty;
            const det = a * d - b * c;
            const sign = det < 0 ? -1 : 1;
            let scaleX = Math.sqrt(a * a + b * b);
            let scaleY = sign * Math.sqrt(c * c + d * d);
            let rotation = Utils.toAngle(Math.atan2(b, a));
            let skewX = 0;
            let skewY = 0;
            if (scaleX !== 0 && scaleY !== 0) {
                const norm_a = a / scaleX;
                const norm_b = b / scaleX;
                const norm_c = c / scaleY;
                const norm_d = d / scaleY;
                const cos = norm_a;
                const sin = norm_b;
                const derot_c = norm_c * cos + norm_d * sin;
                const derot_d = -norm_c * sin + norm_d * cos;
                skewX = Utils.toAngle(Math.atan2(derot_c, derot_d));
                const dotProduct = a * c + b * d;
                const len1 = Math.sqrt(a * a + b * b);
                const len2 = Math.sqrt(c * c + d * d);
                if (len1 !== 0 && len2 !== 0) {
                    const cosTheta = dotProduct / (len1 * len2);
                    const clampedCosTheta = Math.max(-1, Math.min(1, cosTheta));
                    skewY = Utils.toAngle(Math.PI / 2 - Math.acos(clampedCosTheta));
                }
            }
            return {
                x, y,
                scaleX, scaleY,
                rotation,
                skewX, skewY
            };
        }
        constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0, nums = 0) {
            this._bTransform = false;
            if (Matrix._createFun != null) {
                return Matrix._createFun(a, b, c, d, tx, ty, nums);
            }
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
            this._checkTransform();
        }
        identity() {
            this.a = this.d = 1;
            this.b = this.tx = this.ty = this.c = 0;
            this._bTransform = false;
            return this;
        }
        _checkTransform() {
            return this._bTransform = (this.a !== 1 || this.b !== 0 || this.c !== 0 || this.d !== 1);
        }
        setTranslate(x, y) {
            this.tx = x;
            this.ty = y;
            return this;
        }
        translate(x, y) {
            this.tx += x;
            this.ty += y;
            return this;
        }
        scale(x, y) {
            this.a *= x;
            this.d *= y;
            this.c *= x;
            this.b *= y;
            this.tx *= x;
            this.ty *= y;
            this._bTransform = true;
            return this;
        }
        rotate(angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var a1 = this.a;
            var c1 = this.c;
            var tx1 = this.tx;
            this.a = a1 * cos - this.b * sin;
            this.b = a1 * sin + this.b * cos;
            this.c = c1 * cos - this.d * sin;
            this.d = c1 * sin + this.d * cos;
            this.tx = tx1 * cos - this.ty * sin;
            this.ty = tx1 * sin + this.ty * cos;
            this._bTransform = true;
            return this;
        }
        skew(x, y) {
            var sinx = Math.sin(x);
            var cosx = Math.cos(x);
            var siny = Math.sin(y);
            var cosy = Math.cos(y);
            var a = this.a;
            var c = this.c;
            var tx = this.tx;
            this.a = cosy * a + sinx * this.b;
            this.b = siny * a + cosx * this.b;
            this.c = cosy * c + sinx * this.d;
            this.d = siny * c + cosx * this.d;
            this.tx = cosy * tx + sinx * this.ty;
            this.ty = siny * tx + cosx * this.ty;
            this._bTransform = true;
            return this;
        }
        invertTransformPoint(out) {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;
            var a2 = d1 / n;
            var b2 = -b1 / n;
            var c2 = -c1 / n;
            var d2 = a1 / n;
            var tx2 = (c1 * this.ty - d1 * tx1) / n;
            var ty2 = -(a1 * this.ty - b1 * tx1) / n;
            return out.setTo(a2 * out.x + c2 * out.y + tx2, b2 * out.x + d2 * out.y + ty2);
        }
        transformPoint(out) {
            return out.setTo(this.a * out.x + this.c * out.y + this.tx, this.b * out.x + this.d * out.y + this.ty);
        }
        transformPointN(out) {
            return out.setTo(this.a * out.x + this.c * out.y, this.b * out.x + this.d * out.y);
        }
        getScaleX() {
            return this.b === 0 ? this.a : Math.sqrt(this.a * this.a + this.b * this.b);
        }
        getScaleY() {
            return this.c === 0 ? this.d : Math.sqrt(this.c * this.c + this.d * this.d);
        }
        invert() {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;
            this.a = d1 / n;
            this.b = -b1 / n;
            this.c = -c1 / n;
            this.d = a1 / n;
            this.tx = (c1 * this.ty - d1 * tx1) / n;
            this.ty = -(a1 * this.ty - b1 * tx1) / n;
            return this;
        }
        setTo(a, b, c, d, tx, ty) {
            this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty;
            return this;
        }
        concat(matrix) {
            var a = this.a;
            var c = this.c;
            var tx = this.tx;
            this.a = a * matrix.a + this.b * matrix.c;
            this.b = a * matrix.b + this.b * matrix.d;
            this.c = c * matrix.a + this.d * matrix.c;
            this.d = c * matrix.b + this.d * matrix.d;
            this.tx = tx * matrix.a + this.ty * matrix.c + matrix.tx;
            this.ty = tx * matrix.b + this.ty * matrix.d + matrix.ty;
            return this;
        }
        static mul(m1, m2, out) {
            var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
            var ba = m2.a, bb = m2.b, bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
            if (bb !== 0 || bc !== 0) {
                out.a = aa * ba + ab * bc;
                out.b = aa * bb + ab * bd;
                out.c = ac * ba + ad * bc;
                out.d = ac * bb + ad * bd;
                out.tx = ba * atx + bc * aty + btx;
                out.ty = bb * atx + bd * aty + bty;
            }
            else {
                out.a = aa * ba;
                out.b = ab * bd;
                out.c = ac * ba;
                out.d = ad * bd;
                out.tx = ba * atx + btx;
                out.ty = bd * aty + bty;
            }
            return out;
        }
        static mul16(m1, m2, out) {
            var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
            var ba = m2.a, bb = m2.b, bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
            if (bb !== 0 || bc !== 0) {
                out[0] = aa * ba + ab * bc;
                out[1] = aa * bb + ab * bd;
                out[4] = ac * ba + ad * bc;
                out[5] = ac * bb + ad * bd;
                out[12] = ba * atx + bc * aty + btx;
                out[13] = bb * atx + bd * aty + bty;
            }
            else {
                out[0] = aa * ba;
                out[1] = ab * bd;
                out[4] = ac * ba;
                out[5] = ad * bd;
                out[12] = ba * atx + btx;
                out[13] = bd * aty + bty;
            }
            return out;
        }
        scaleEx(x, y) {
            var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
            if (bb !== 0 || bc !== 0) {
                this.a = x * ba;
                this.b = x * bb;
                this.c = y * bc;
                this.d = y * bd;
            }
            else {
                this.a = x * ba;
                this.b = 0 * bd;
                this.c = 0 * ba;
                this.d = y * bd;
            }
            this._bTransform = true;
        }
        rotateEx(angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
            if (bb !== 0 || bc !== 0) {
                this.a = cos * ba + sin * bc;
                this.b = cos * bb + sin * bd;
                this.c = -sin * ba + cos * bc;
                this.d = -sin * bb + cos * bd;
            }
            else {
                this.a = cos * ba;
                this.b = sin * bd;
                this.c = -sin * ba;
                this.d = cos * bd;
            }
            this._bTransform = true;
        }
        clone() {
            var dec = new Matrix();
            dec.a = this.a;
            dec.b = this.b;
            dec.c = this.c;
            dec.d = this.d;
            dec.tx = this.tx;
            dec.ty = this.ty;
            dec._bTransform = this._bTransform;
            return dec;
        }
        cloneTo(dec) {
            dec.a = this.a;
            dec.b = this.b;
            dec.c = this.c;
            dec.d = this.d;
            dec.tx = this.tx;
            dec.ty = this.ty;
            dec._bTransform = this._bTransform;
            return dec;
        }
        copyTo(dec) {
            dec.a = this.a;
            dec.b = this.b;
            dec.c = this.c;
            dec.d = this.d;
            dec.tx = this.tx;
            dec.ty = this.ty;
            dec._bTransform = this._bTransform;
            return dec;
        }
        setMatrix(x, y, sx, sy, rotation, skewX, skewY, pivotx, pivoty) {
            rotation = Utils.toRadian(rotation);
            skewX = Utils.toRadian(skewX);
            skewY = Utils.toRadian(skewY);
            const cosr = Math.cos(rotation);
            const sinr = Math.sin(rotation);
            const coskx = Math.cos(skewX);
            const sinkx = Math.sin(skewX);
            const cosky = Math.cos(skewY);
            const sinky = Math.sin(skewY);
            this.a = (cosr * cosky - sinr * sinky) * sx;
            this.b = (sinr * cosky + cosr * sinky) * sx;
            this.c = (cosr * sinkx - sinr * coskx) * sy;
            this.d = (sinr * sinkx + cosr * coskx) * sy;
            this.tx = x - this.a * pivotx - this.c * pivoty;
            this.ty = y - this.b * pivotx - this.d * pivoty;
            this._checkTransform();
            return this;
        }
        toString() {
            return this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.tx + "," + this.ty;
        }
        destroy() {
            this.recover();
        }
        recover() {
            Pool.recover("Matrix", this.identity());
        }
        static create() {
            return Pool.getItemByClass("Matrix", Matrix);
        }
    }
    Matrix.EMPTY = new Matrix();
    Matrix.TEMP = new Matrix();
    Matrix._createFun = null;

    class HTMLCanvas {
        constructor(createCanvas) {
            if (createCanvas == null || createCanvas)
                this.source = Browser.createElement("canvas");
        }
        clear() {
            if (this.source)
                this.context.clearRect(0, 0, this.source.width, this.source.height);
        }
        get context() {
            return this._ctx || (this._ctx = this.source.getContext('2d'));
        }
        set context(value) {
            this._ctx = value;
        }
        size(w, h) {
            if (this.source) {
                this.source.height = h;
                this.source.width = w;
            }
        }
    }

    const className$o = "RestoreCmd";
    class RestoreCmd {
        static create() {
            return Pool.getItemByClass(className$o, RestoreCmd);
        }
        recover() {
            Pool.recover(className$o, this);
        }
        run(runner) {
            runner.restore();
        }
        get cmdID() {
            return RestoreCmd.ID;
        }
    }
    RestoreCmd.ID = className$o;

    class GrahamScan {
        static scanPList(pList, out) {
            let len = Math.floor(pList.length / 2);
            _tmpPoints.length = len;
            if (len > _pointPool.length)
                _pointPool.length = len;
            for (let i = 0; i < len; i++) {
                let pt = _pointPool[i] || (_pointPool[i] = new Point());
                pt.setTo(pList[i + i], pList[i + i + 1]);
                _tmpPoints[i] = pt;
            }
            let res = GrahamScan.scan(_tmpPoints, _tmpPoints);
            out = out || [];
            out.length = 0;
            for (let i = 0, n = res.length; i < n; i++) {
                out.push(res[i].x, res[i].y);
            }
            return out;
        }
        static scan(points, out) {
            let pts = removeDuplicatePoints(points);
            let len = pts.length;
            let k = 0;
            for (let i = 1; i < len; i++) {
                if ((pts[i].y < pts[k].y) || ((pts[i].y == pts[k].y) && (pts[i].x < pts[k].x)))
                    k = i;
            }
            let tmp = pts[0];
            pts[0] = pts[k];
            pts[k] = tmp;
            for (let i = 1; i < len - 1; i++) {
                k = i;
                for (let j = i + 1; j < len; j++) {
                    if ((multiply(pts[j], pts[k], pts[0]) > 0) || ((multiply(pts[j], pts[k], pts[0]) == 0)
                        && (dis(pts[0], pts[j]) < dis(pts[0], pts[k]))))
                        k = j;
                }
                let tmp = pts[i];
                pts[i] = pts[k];
                pts[k] = tmp;
            }
            out = out || [];
            out.length = 0;
            if (pts.length < 3) {
                out.push(...pts);
                return out;
            }
            out.push(pts[0], pts[1], pts[2]);
            for (let i = 3; i < len; i++) {
                while (out.length >= 2 && multiply(pts[i], out[out.length - 1], out[out.length - 2]) >= 0)
                    out.pop();
                out.push(pts[i]);
            }
            return out;
        }
    }
    const _tmpPoints = [];
    const _tmpPoints2 = [];
    const _pointPool = [];
    const _test = new Set();
    function removeDuplicatePoints(points) {
        _test.clear();
        _tmpPoints2.length = 0;
        for (let i = points.length - 1; i >= 0; i--) {
            let tmp = points[i];
            let key = tmp.x + "_" + tmp.y;
            if (!_test.has(key)) {
                _test.add(key);
                _tmpPoints2.push(tmp);
            }
        }
        return _tmpPoints2;
    }
    function multiply(p1, p2, p0) {
        return ((p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y));
    }
    function dis(p1, p2) {
        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
    }

    const className$n = "SaveCmd";
    class SaveCmd {
        static create() {
            return Pool.getItemByClass(className$n, SaveCmd);
        }
        recover() {
            Pool.recover(className$n, this);
        }
        run(runner) {
            runner.save();
        }
        get cmdID() {
            return SaveCmd.ID;
        }
    }
    SaveCmd.ID = className$n;

    class GraphicsBounds {
        destroy() {
            this._cached = false;
            this._bounds = null;
            this._bound2 = null;
            Pool.recover("GraphicsBounds", this);
        }
        static create() {
            return Pool.getItemByClass("GraphicsBounds", GraphicsBounds);
        }
        reset() {
            this._cached = false;
        }
        getBounds(g) {
            if (!this._cached) {
                if (g._useSpriteRect) {
                    this._bounds = (this._bounds || new Rectangle()).setTo(0, 0, g.owner.width, g.owner.height);
                    this._bound2 = this._bounds.getBoundPoints(this._bound2);
                }
                else {
                    this._bound2 = this._getCmdPoints(g);
                    this._bounds = Rectangle._getWrapRec(this._bound2, this._bounds);
                }
                this._cached = true;
            }
            return this._bounds;
        }
        getBoundPoints(g) {
            this.getBounds(g);
            return this._bound2;
        }
        _getCmdPoints(g) {
            let points = this._bound2 || (this._bound2 = []);
            points.length = 0;
            let cmds = g.cmds;
            let sp = g.owner;
            if (cmds.length == 0)
                return points;
            _assembler.allPoints = points;
            _assembler.width = sp._width;
            _assembler.height = sp._height;
            _assembler.matrix.identity();
            let matrixs = _tempMatrixArrays;
            matrixs.length = 0;
            for (let i = 0, n = cmds.length; i < n; i++) {
                let cmd = cmds[i];
                switch (cmd.cmdID) {
                    case SaveCmd.ID:
                        matrixs.push(_assembler.matrix);
                        _assembler.matrix = _assembler.matrix.clone();
                        break;
                    case RestoreCmd.ID:
                        _assembler.matrix = matrixs.pop();
                        break;
                    default:
                        _assembler.points.length = 0;
                        if (cmd.getBounds)
                            cmd.getBounds(_assembler);
                        else
                            _tempRect$1.setTo(sp.x, sp.y, sp._width, sp._height).getBoundPoints(_assembler.points);
                        if (_assembler.points.length > 0)
                            _assembler.flushPoints();
                        break;
                }
            }
            if (points.length > 200) {
                let rect = Rectangle._getWrapRec(points, _tempRect$1);
                points.length = 0;
                rect.getBoundPoints(points);
            }
            else if (points.length > 8)
                GrahamScan.scanPList(points, points);
            return points;
        }
    }
    class GraphicsBoundsAssembler {
        constructor() {
            this.points = [];
            this.matrix = new Matrix();
        }
        flushPoints(dx, dy, matrix) {
            if (dx == null)
                dx = 0;
            if (dy == null)
                dy = 0;
            if (matrix) {
                this.matrix.copyTo(_tempMatrix$1);
                _tempMatrix$1.concat(matrix);
                matrix = _tempMatrix$1;
            }
            else
                matrix = this.matrix;
            let len = this.points.length;
            let _tempPoint = Point.TEMP;
            for (let i = 0; i < len; i += 2) {
                _tempPoint.setTo(this.points[i] + dx, this.points[i + 1] + dy);
                if (_tempPoint.x == null)
                    _tempPoint.x = 0;
                if (_tempPoint.y == null)
                    _tempPoint.y = 0;
                matrix.transformPoint(_tempPoint);
                this.allPoints.push(_tempPoint.x, _tempPoint.y);
            }
            this.points.length = 0;
        }
        concatMatrix(matrix) {
            matrix.copyTo(_tempMatrix$1);
            _tempMatrix$1.concat(this.matrix);
            _tempMatrix$1.copyTo(this.matrix);
        }
    }
    const _assembler = new GraphicsBoundsAssembler();
    const _tempMatrix$1 = new Matrix();
    const _tempMatrixArrays = [];
    const _tempRect$1 = new Rectangle();

    var _a;
    class SpriteConst {
    }
    _a = SpriteConst;
    SpriteConst.TEXT = 0x01;
    SpriteConst.AREA2D = 0x02;
    SpriteConst.CANVAS = 0x08;
    SpriteConst.POSTPROCESS = 0x10;
    SpriteConst.MASK = 0x20;
    SpriteConst.CLIP = 0x40;
    SpriteConst.GRAPHICS = 0x100;
    SpriteConst.RENDERNODE2D = 0x800;
    SpriteConst.DRAW2RT = _a.CANVAS | _a.POSTPROCESS | _a.MASK;
    SpriteConst.UPDATETRANS = _a.CANVAS | _a.POSTPROCESS | _a.MASK | _a.CLIP | _a.GRAPHICS | _a.RENDERNODE2D;
    exports.RepaintFlag = void 0;
    (function (RepaintFlag) {
        RepaintFlag[RepaintFlag["Normal"] = 0] = "Normal";
        RepaintFlag[RepaintFlag["Size"] = 1] = "Size";
        RepaintFlag[RepaintFlag["Graphics"] = 2] = "Graphics";
        RepaintFlag[RepaintFlag["ChildChange"] = 4] = "ChildChange";
        RepaintFlag[RepaintFlag["UpdateRT"] = 7] = "UpdateRT";
    })(exports.RepaintFlag || (exports.RepaintFlag = {}));
    exports.TransformKind = void 0;
    (function (TransformKind) {
        TransformKind[TransformKind["Pos"] = 1] = "Pos";
        TransformKind[TransformKind["Width"] = 2] = "Width";
        TransformKind[TransformKind["Height"] = 4] = "Height";
        TransformKind[TransformKind["Anchor"] = 8] = "Anchor";
        TransformKind[TransformKind["Scale"] = 16] = "Scale";
        TransformKind[TransformKind["Skew"] = 32] = "Skew";
        TransformKind[TransformKind["Rotation"] = 64] = "Rotation";
        TransformKind[TransformKind["Matrix"] = 128] = "Matrix";
        TransformKind[TransformKind["Size"] = 6] = "Size";
        TransformKind[TransformKind["Layout"] = 30] = "Layout";
        TransformKind[TransformKind["TRS"] = 113] = "TRS";
    })(exports.TransformKind || (exports.TransformKind = {}));
    exports.BaseRender2DType = void 0;
    (function (BaseRender2DType) {
        BaseRender2DType[BaseRender2DType["empty"] = -1] = "empty";
        BaseRender2DType[BaseRender2DType["baseRenderNode"] = 0] = "baseRenderNode";
        BaseRender2DType[BaseRender2DType["spine"] = 1] = "spine";
        BaseRender2DType[BaseRender2DType["particle"] = 2] = "particle";
        BaseRender2DType[BaseRender2DType["spineSimple"] = 3] = "spineSimple";
        BaseRender2DType[BaseRender2DType["graphics"] = 4] = "graphics";
    })(exports.BaseRender2DType || (exports.BaseRender2DType = {}));
    exports.SubPassFlag = void 0;
    (function (SubPassFlag) {
        SubPassFlag[SubPassFlag["PostProcess"] = 1] = "PostProcess";
        SubPassFlag[SubPassFlag["CacheAsBitmap"] = 2] = "CacheAsBitmap";
        SubPassFlag[SubPassFlag["Mask"] = 4] = "Mask";
        SubPassFlag[SubPassFlag["RenderTexture"] = 8] = "RenderTexture";
        SubPassFlag[SubPassFlag["UPDATE_POSTPROCESS"] = 9] = "UPDATE_POSTPROCESS";
    })(exports.SubPassFlag || (exports.SubPassFlag = {}));

    const className$m = "AlphaCmd";
    class AlphaCmd {
        static create(alpha) {
            var cmd = Pool.getItemByClass(className$m, AlphaCmd);
            cmd.alpha = alpha;
            return cmd;
        }
        recover() {
            Pool.recover(className$m, this);
        }
        run(runner, gx, gy) {
            runner.alpha(this.alpha);
        }
        getBounds(assembler) {
        }
        get cmdID() {
            return AlphaCmd.ID;
        }
    }
    AlphaCmd.ID = className$m;

    const className$l = "ClipRectCmd";
    class ClipRectCmd {
        static create(x, y, width, height) {
            var cmd = Pool.getItemByClass(className$l, ClipRectCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            return cmd;
        }
        recover() {
            Pool.recover(className$l, this);
        }
        run(runner, gx, gy) {
            runner.clipRect(this.x + gx, this.y + gy, this.width, this.height);
        }
        get cmdID() {
            return ClipRectCmd.ID;
        }
    }
    ClipRectCmd.ID = className$l;

    const gridTileIndice = [-1, 0, -1, 2, 4, 3, -1, 1, -1];
    const TRIANGLES_9_GRID = [
        4, 0, 1, 1, 5, 4,
        5, 1, 2, 2, 6, 5,
        6, 2, 3, 3, 7, 6,
        8, 4, 5, 5, 9, 8,
        9, 5, 6, 6, 10, 9,
        10, 6, 7, 7, 11, 10,
        12, 8, 9, 9, 13, 12,
        13, 9, 10, 10, 14, 13,
        14, 10, 11,
        11, 15, 14
    ];
    const gridTexX = [0, 0, 0, 0];
    const gridTexY = [0, 0, 0, 0];
    const gridX = [0, 0, 0, 0];
    const gridY = [0, 0, 0, 0];
    function genSliceMesh(vb, contentRect, uvRect, gridRect, tileGridIndice) {
        const sourceW = vb.mainTex.sourceWidth;
        const sourceH = vb.mainTex.sourceHeight;
        const sx = uvRect.width / sourceW;
        const sy = uvRect.height / sourceH;
        const xMax = gridRect.right;
        const yMax = gridRect.bottom;
        gridTexX.length = 0;
        gridTexX.push(uvRect.x, uvRect.x + gridRect.x * sx, uvRect.x + xMax * sx, uvRect.right);
        gridTexY.length = 0;
        gridTexY.push(uvRect.y, uvRect.y + gridRect.y * sy, uvRect.y + yMax * sy, uvRect.bottom);
        gridX[0] = contentRect.x;
        if (contentRect.width >= (sourceW - gridRect.width)) {
            gridX[1] = gridX[0] + gridRect.x;
            gridX[2] = contentRect.right - (sourceW - xMax);
            gridX[3] = contentRect.right;
        }
        else {
            const tmp = gridRect.x / (sourceW - xMax);
            const adjustedTmp = gridX[0] + contentRect.width * tmp / (1 + tmp);
            gridX[1] = adjustedTmp;
            gridX[2] = adjustedTmp;
            gridX[3] = contentRect.right;
        }
        gridY[0] = contentRect.y;
        if (contentRect.height >= (sourceH - gridRect.height)) {
            gridY[1] = gridY[0] + gridRect.y;
            gridY[2] = contentRect.bottom - (sourceH - yMax);
            gridY[3] = contentRect.bottom;
        }
        else {
            const tmp = gridRect.y / (sourceH - yMax);
            const adjustedTmp = gridY[0] + contentRect.height * tmp / (1 + tmp);
            gridY[1] = adjustedTmp;
            gridY[2] = adjustedTmp;
            gridY[3] = contentRect.bottom;
        }
        if (tileGridIndice === 0) {
            for (let cy = 0; cy < 4; cy++) {
                for (let cx = 0; cx < 4; cx++) {
                    vb.addVert(gridX[cx], gridY[cy], null, gridTexX[cx], gridTexY[cy]);
                }
            }
            vb.addTriangles(TRIANGLES_9_GRID);
        }
        else {
            const drawRect = Rectangle.create();
            const uvRect = Rectangle.create();
            let qi = vb.vertCount;
            for (let pi = 0; pi < 9; pi++) {
                const col = pi % 3;
                const row = Math.floor(pi / 3);
                const part = gridTileIndice[pi];
                Rectangle.minMaxRect(gridX[col], gridY[row], gridX[col + 1], gridY[row + 1], drawRect);
                Rectangle.minMaxRect(gridTexX[col], gridTexY[row], gridTexX[col + 1], gridTexY[row + 1], uvRect);
                if (part !== -1 && (tileGridIndice & (1 << part)) !== 0) {
                    if (qi !== vb.vertCount)
                        vb.triangulateQuad(qi);
                    genTileMesh(vb, drawRect, uvRect, (part === 0 || part === 1 || part === 4) ? gridRect.width : drawRect.width, (part === 2 || part === 3 || part === 4) ? gridRect.height : drawRect.height, true, true);
                    qi = vb.vertCount;
                }
                else {
                    vb.addQuad(drawRect, null, uvRect);
                }
            }
            if (qi !== vb.vertCount)
                vb.triangulateQuad(qi);
            drawRect.recover();
            uvRect.recover();
        }
    }
    function genTileMesh(vb, drawRect, uvRect, sourceW, sourceH, repeatX, repeatY) {
        let hc = repeatX ? (Math.ceil(drawRect.width / sourceW) - 1) : 0;
        let vc = repeatY ? (Math.ceil(drawRect.height / sourceH) - 1) : 0;
        let tailWidth = drawRect.width - hc * sourceW;
        let tailHeight = drawRect.height - vc * sourceH;
        const tmpRect = Rectangle.create();
        const tmpUV = Rectangle.create();
        let qi = vb.vertCount;
        for (let i = 0; i <= hc; i++) {
            for (let j = 0; j <= vc; j++) {
                tmpRect.setTo(drawRect.x + i * sourceW, drawRect.y + j * sourceH, (i < hc) ? sourceW : tailWidth, (j < vc) ? sourceH : tailHeight);
                tmpUV.setTo(uvRect.x, uvRect.y, (i < hc || !repeatX) ? uvRect.width : uvRect.width * tailWidth / sourceW, (j < vc || !repeatY) ? uvRect.height : uvRect.height * tailHeight / sourceH);
                vb.addQuad(tmpRect, null, tmpUV);
            }
        }
        vb.triangulateQuad(qi);
        tmpRect.recover();
        tmpUV.recover();
    }

    class ColorUtils {
        constructor(value) {
            this.arrColor = [];
            if (value == null || value == 'none') {
                this.strColor = "#00000000";
                this.numColor = 0;
                this.arrColor = [0, 0, 0, 0];
                return;
            }
            tmpColor$1.parse(value);
            if (typeof (value) == 'string')
                this.strColor = value;
            else
                this.strColor = tmpColor$1.getStyleString();
            tmpColor$1.writeTo(this.arrColor);
            this.numColor = tmpColor$1.getABGR();
        }
        static _initSaveMap() {
            ColorUtils._SAVE_SIZE = 0;
            ColorUtils._SAVE = {};
        }
        static create(value) {
            let key = value + "";
            let color = ColorUtils._SAVE[key];
            if (color != null)
                return color;
            if (ColorUtils._SAVE_SIZE > 500)
                ColorUtils._initSaveMap();
            ColorUtils._SAVE_SIZE++;
            return ColorUtils._SAVE[key] = new ColorUtils(value);
        }
    }
    ColorUtils._SAVE = {};
    ColorUtils._SAVE_SIZE = 0;
    const tmpColor$1 = new Color();

    class MathUtil {
        static lerp(left, right, amount) {
            return left * (1 - amount) + right * amount;
        }
        static repeat(t, length) {
            return t - Math.floor(t / length) * length;
        }
        static distance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        }
        static clamp(value, min, max) {
            if (value < min)
                value = min;
            else if (value > max)
                value = max;
            return value;
        }
        static clamp01(value) {
            if (isNaN(value))
                value = 0;
            else if (value > 1)
                value = 1;
            else if (value < 0)
                value = 0;
            return value;
        }
        static slerpQuaternionArray(a, Offset1, b, Offset2, t, out, Offset3) {
            var ax = a[Offset1 + 0], ay = a[Offset1 + 1], az = a[Offset1 + 2], aw = a[Offset1 + 3], bx = b[Offset2 + 0], by = b[Offset2 + 1], bz = b[Offset2 + 2], bw = b[Offset2 + 3];
            var omega, cosom, sinom, scale0, scale1;
            cosom = ax * bx + ay * by + az * bz + aw * bw;
            if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
            }
            if ((1.0 - cosom) > 0.000001) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            }
            else {
                scale0 = 1.0 - t;
                scale1 = t;
            }
            out[Offset3 + 0] = scale0 * ax + scale1 * bx;
            out[Offset3 + 1] = scale0 * ay + scale1 * by;
            out[Offset3 + 2] = scale0 * az + scale1 * bz;
            out[Offset3 + 3] = scale0 * aw + scale1 * bw;
            return out;
        }
        static getRotation(x0, y0, x1, y1) {
            return Math.atan2(y1 - y0, x1 - x0) / Math.PI * 180;
        }
        static sortBigFirst(a, b) {
            if (a == b)
                return 0;
            return b > a ? 1 : -1;
        }
        static sortSmallFirst(a, b) {
            if (a == b)
                return 0;
            return b > a ? -1 : 1;
        }
        static sortNumBigFirst(a, b) {
            return parseFloat(b) - parseFloat(a);
        }
        static sortNumSmallFirst(a, b) {
            return parseFloat(a) - parseFloat(b);
        }
        static sortByKey(key, bigFirst = false, forceNum = true) {
            var _sortFun;
            if (bigFirst) {
                _sortFun = forceNum ? MathUtil.sortNumBigFirst : MathUtil.sortBigFirst;
            }
            else {
                _sortFun = forceNum ? MathUtil.sortNumSmallFirst : MathUtil.sortSmallFirst;
            }
            return function (a, b) {
                return _sortFun(a[key], b[key]);
            };
        }
        static roundTo(value, decimals = 3, epsilon = 1e-6) {
            if (!isFinite(value))
                return value;
            const factor = Math.pow(10, decimals);
            const rounded = Math.round(value * factor) / factor;
            return Math.abs(rounded) < epsilon ? 0 : rounded;
        }
    }

    class Vector2 {
        constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }
        setValue(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }
        static scale(a, b, out) {
            out.x = a.x * b;
            out.y = a.y * b;
        }
        static equals(a, b) {
            return MathUtils3D.nearEqual(a.x, b.x) && MathUtils3D.nearEqual(a.y, b.y);
        }
        fromArray(array, offset = 0) {
            this.x = array[offset + 0];
            this.y = array[offset + 1];
        }
        toArray() {
            return [this.x, this.y];
        }
        writeTo(array, offset = 0) {
            array[offset + 0] = this.x;
            array[offset + 1] = this.y;
        }
        cloneTo(destObject) {
            destObject.x = this.x;
            destObject.y = this.y;
            return destObject;
        }
        static dot(a, b) {
            return (a.x * b.x) + (a.y * b.y);
        }
        static normalize(s, out) {
            var x = s.x, y = s.y;
            var len = x * x + y * y;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out.x = x * len;
                out.y = y * len;
            }
        }
        static scalarLength(a) {
            var x = a.x, y = a.y;
            return Math.sqrt(x * x + y * y);
        }
        static distance(a, b) {
            let x = a.x - b.x;
            let y = a.y - b.y;
            return Math.sqrt(x * x + y * y);
        }
        clone() {
            var destVector2 = new Vector2();
            this.cloneTo(destVector2);
            return destVector2;
        }
    }
    Vector2.ZERO = new Vector2(0.0, 0.0);
    Vector2.ONE = new Vector2(1.0, 1.0);
    Vector2.TEMP = new Vector2();

    class VertexStream {
        constructor() {
            this._vp = 0;
            this._ip = 0;
            this.contentRect = new Rectangle();
            this.uvRect = new Rectangle();
            this.color = new Color();
            this._vertices = this.resizeBuf(Float32Array, 20);
            this._uvs = this.resizeBuf(Float32Array, 20);
            this._colors = this.resizeBuf(Float32Array, 40);
            this._indices = this.resizeBuf(Uint16Array, 30);
            this._vec = new Vector2();
        }
        init(mainTex) {
            this.mainTex = mainTex;
            if (mainTex) {
                let uv = mainTex.uvrect;
                if (mainTex.width === mainTex.sourceWidth && mainTex.height === mainTex.sourceHeight)
                    this.uvRect.setTo(uv[0], uv[1], uv[2], uv[3]);
                else {
                    let sx = uv[2] / mainTex.width;
                    let sy = uv[3] / mainTex.height;
                    this.uvRect.setTo(uv[0] - mainTex.offsetX * sx, uv[1] - mainTex.offsetY * sy, mainTex.sourceWidth * sx, mainTex.sourceHeight * sy);
                }
            }
            else
                this.uvRect.setTo(0, 0, 1, 1);
            this.color.setValue(1, 1, 1, 1);
            this._vp = 0;
            this._ip = 0;
        }
        addVert(x, y, color, u, v) {
            this.checkVBuf(2);
            let idx = this._vp;
            this._vp += 2;
            this._vertices[idx] = x;
            this._vertices[idx + 1] = y;
            if (u != null)
                this._uvs[idx] = u;
            else
                this._uvs[idx] = MathUtil.lerp(this.uvRect.x, this.uvRect.right, (x - this.contentRect.x) / (this.contentRect.width || 1));
            if (v != null)
                this._uvs[idx + 1] = v;
            else
                this._uvs[idx + 1] = MathUtil.lerp(this.uvRect.y, this.uvRect.bottom, (y - this.contentRect.y) / (this.contentRect.height || 1));
            (color || this.color).writeTo(this._colors, idx * 2);
        }
        addQuad(rect, color, uvRect) {
            if (uvRect) {
                this.addVert(rect.x, rect.y, color, uvRect.x, uvRect.y);
                this.addVert(rect.right, rect.y, color, uvRect.right, uvRect.y);
                this.addVert(rect.right, rect.bottom, color, uvRect.right, uvRect.bottom);
                this.addVert(rect.x, rect.bottom, color, uvRect.x, uvRect.bottom);
            }
            else {
                this.addVert(rect.x, rect.y, color);
                this.addVert(rect.right, rect.y, color);
                this.addVert(rect.right, rect.bottom, color);
                this.addVert(rect.x, rect.bottom, color);
            }
        }
        addTriangle(idx0, idx1, idx2) {
            this.checkIBuf(3);
            let idx = this._ip;
            this._ip += 3;
            this._indices[idx] = idx0;
            this._indices[idx + 1] = idx1;
            this._indices[idx + 2] = idx2;
        }
        addTriangles(indices) {
            this.checkIBuf(indices.length);
            let arr = this._indices;
            let idx = this._ip;
            let n = indices.length;
            this._ip += n;
            for (let i = 0; i < n; i++)
                arr[idx + i] = indices[i];
        }
        triangulateQuad(baseIndex) {
            let cnt = this._vp / 2;
            if (baseIndex < 0)
                baseIndex = cnt + baseIndex;
            let icnt = (cnt - baseIndex) / 4 * 6;
            this.checkIBuf(icnt);
            let arr = this._indices;
            for (let i = baseIndex, j = this._ip; i < cnt; i += 4, j += 6) {
                arr[j] = i;
                arr[j + 1] = i + 1;
                arr[j + 2] = i + 2;
                arr[j + 3] = i + 2;
                arr[j + 4] = i + 3;
                arr[j + 5] = i;
            }
            this._ip += icnt;
        }
        getPos(index) {
            if (index < 0)
                index = this._vp / 2 + index;
            index *= 2;
            this._vec.setValue(this._vertices[index], this._vertices[index + 1]);
            return this._vec;
        }
        get vertCount() {
            return this._vp / 2;
        }
        getVertices() {
            return new Float32Array(this._vertices.buffer, 0, this._vp);
        }
        getUVs() {
            return new Float32Array(this._uvs.buffer, 0, this._vp);
        }
        getColors() {
            return new Float32Array(this._colors.buffer, 0, this._vp * 2);
        }
        getIndices() {
            return new Uint16Array(this._indices.buffer, 0, this._ip);
        }
        checkVBuf(addCount) {
            if (this._vp + addCount < this._vertices.length)
                return;
            let vp = this._vp + Math.max(20, addCount);
            this._vertices = this.resizeBuf(Float32Array, vp, this._vertices);
            this._uvs = this.resizeBuf(Float32Array, vp, this._uvs);
            this._colors = this.resizeBuf(Float32Array, vp * 2, this._colors);
        }
        checkIBuf(addCount) {
            if (this._ip + addCount < this._indices.length)
                return;
            let ip = this._ip + Math.max(30, addCount);
            this._indices = this.resizeBuf(Uint16Array, ip, this._indices);
        }
        resizeBuf(type, sz, oldData) {
            let newBuf = new ArrayBuffer(type.BYTES_PER_ELEMENT * sz);
            let newDataView = new type(newBuf);
            oldData && newDataView.set(oldData);
            return newDataView;
        }
    }
    VertexStream.pool = Pool.createPool(VertexStream, (e, mainTex) => e.init(mainTex));

    const className$k = "Draw9GridTextureCmd";
    class Draw9GridTextureCmd {
        constructor() {
            this.x = 0;
            this.y = 0;
            this.width = 1;
            this.height = 1;
            this.color = 0xffffffff;
            this.percent = true;
        }
        static create(texture, x, y, width, height, sizeGrid, percent, color) {
            let cmd = Pool.getItemByClass(className$k, Draw9GridTextureCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.sizeGrid = sizeGrid;
            cmd.percent = percent;
            cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
            return cmd;
        }
        recover() {
            var _a;
            (_a = this.texture) === null || _a === void 0 ? void 0 : _a._removeReference();
            this.texture = null;
            Pool.recover(className$k, this);
        }
        run(runner, gx, gy) {
            if (this.texture) {
                let sizeGrid = this.sizeGrid || this.texture._sizeGrid || EMPTY_SIZE_GRID;
                let x = this.x;
                let y = this.y;
                let w = this.width;
                let h = this.height;
                if (this.percent && runner.sprite) {
                    x *= runner.sprite.width;
                    y *= runner.sprite.height;
                    w *= runner.sprite.width;
                    h *= runner.sprite.height;
                }
                let vb = VertexStream.pool.take(this.texture);
                vb.contentRect.setTo(0, 0, w, h);
                if (this.color)
                    vb.color.setABGR(this.color);
                let gridRect = Rectangle.create();
                let sourceWidth = vb.mainTex.sourceWidth;
                let sourceHeight = vb.mainTex.sourceHeight;
                gridRect.setTo(sizeGrid[3], sizeGrid[0], sourceWidth - sizeGrid[1] - sizeGrid[3], sourceHeight - sizeGrid[0] - sizeGrid[2]);
                genSliceMesh(vb, vb.contentRect, vb.uvRect, gridRect, sizeGrid[4] === 1 ? 0xff : 0);
                runner.drawTriangles(this.texture, x + gx, y + gy, vb.getVertices(), vb.getUVs(), vb.getIndices(), null, 1, null, null, vb.getColors(), this.texture.uvrect);
                VertexStream.pool.recover(vb);
            }
        }
        get cmdID() {
            return Draw9GridTextureCmd.ID;
        }
        getBounds(assembler) {
            let rect = Rectangle.TEMP.setTo(this.x, this.y, this.width, this.height);
            if (this.percent) {
                rect.scale(assembler.width, assembler.height);
            }
            rect.getBoundPoints(assembler.points);
        }
    }
    Draw9GridTextureCmd.ID = className$k;
    const EMPTY_SIZE_GRID = [0, 0, 0, 0, 0];
    ClassUtils.regClass(className$k, Draw9GridTextureCmd);

    const className$j = "DrawCircleCmd";
    class DrawCircleCmd {
        constructor() {
            this.lineWidth = 0;
        }
        static create(x, y, radius, fillColor, lineColor, lineWidth, percent) {
            var cmd = Pool.getItemByClass(className$j, DrawCircleCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.radius = radius;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            cmd.percent = percent;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover(className$j, this);
        }
        run(runner, gx, gy) {
            let offset = (this.lineWidth >= 1 && this.lineColor) ? this.lineWidth / 2 : 0;
            if (this.percent && runner.sprite) {
                let w = runner.sprite.width;
                let h = runner.sprite.height;
                runner._drawCircle(this.x * w + gx, this.y * h + gy, this.radius * Math.min(w, h) - offset, this.fillColor, this.lineColor, this.lineWidth, 0);
            }
            else
                runner._drawCircle(this.x + gx, this.y + gy, this.radius - offset, this.fillColor, this.lineColor, this.lineWidth, 0);
        }
        get cmdID() {
            return DrawCircleCmd.ID;
        }
        getBounds(assembler) {
            let rect = Rectangle.TEMP.setTo(this.x - this.radius, this.y - this.radius, this.radius + this.radius, this.radius + this.radius);
            if (this.percent) {
                rect.scale(assembler.width, assembler.height);
            }
            rect.getBoundPoints(assembler.points);
        }
    }
    DrawCircleCmd.ID = className$j;
    ClassUtils.regClass(className$j, DrawCircleCmd);

    class Bezier {
        static getPoints(pList, inSertCount = 5, count = 2, out) {
            out = out || [];
            let len = pList.length;
            if (len < (count + 1) * 2)
                return out;
            switch (count) {
                case 2:
                    _calFun = getPoint2;
                    break;
                case 3:
                    _calFun = getPoint3;
                    break;
                default:
                    return [];
            }
            while (tmpPoints$1.length <= count) {
                tmpPoints$1.push(new Point());
            }
            for (let i = 0; i < count * 2; i += 2) {
                _switchPoint(pList[i], pList[i + 1]);
            }
            for (let i = count * 2; i < len; i += 2) {
                _switchPoint(pList[i], pList[i + 1]);
                if ((i / 2) % count == 0)
                    insertPoints(inSertCount, out);
            }
            return out;
        }
        static getRate(t, px0, py0, px1, py1) {
            let key = _getBezierParamKey(px0, py0, px1, py1);
            let vKey = key * 100 + t;
            if (_bezierResultCache[vKey])
                return _bezierResultCache[vKey];
            let points;
            if (_bezierPointsCache[key])
                points = _bezierPointsCache[key];
            else {
                var controlPoints;
                controlPoints = [0, 0, px0, py0, px1, py1, 1, 1];
                points = Bezier.getPoints(controlPoints, 100, 3);
                _bezierPointsCache[key] = points;
            }
            let len = points.length;
            for (let i = 0; i < len; i += 2) {
                if (t <= points[i]) {
                    _bezierResultCache[vKey] = points[i + 1];
                    return points[i + 1];
                }
            }
            _bezierResultCache[vKey] = 1;
            return 1;
        }
    }
    const tmpPoints$1 = [new Point(), new Point(), new Point()];
    var _calFun = getPoint2;
    const _bezierResultCache = {};
    const _bezierPointsCache = {};
    function _switchPoint(x, y) {
        let tPoint = tmpPoints$1.pop();
        tPoint.setTo(x, y);
        tmpPoints$1.unshift(tPoint);
    }
    function getPoint2(t, rst) {
        var p1 = tmpPoints$1[2];
        var p2 = tmpPoints$1[1];
        var p3 = tmpPoints$1[0];
        var lineX = Math.pow((1 - t), 2) * p1.x + 2 * t * (1 - t) * p2.x + Math.pow(t, 2) * p3.x;
        var lineY = Math.pow((1 - t), 2) * p1.y + 2 * t * (1 - t) * p2.y + Math.pow(t, 2) * p3.y;
        rst.push(lineX, lineY);
    }
    function getPoint3(t, rst) {
        var p1 = tmpPoints$1[3];
        var p2 = tmpPoints$1[2];
        var p3 = tmpPoints$1[1];
        var p4 = tmpPoints$1[0];
        var lineX = Math.pow((1 - t), 3) * p1.x + 3 * p2.x * t * (1 - t) * (1 - t) + 3 * p3.x * t * t * (1 - t) + p4.x * Math.pow(t, 3);
        var lineY = Math.pow((1 - t), 3) * p1.y + 3 * p2.y * t * (1 - t) * (1 - t) + 3 * p3.y * t * t * (1 - t) + p4.y * Math.pow(t, 3);
        rst.push(lineX, lineY);
    }
    function insertPoints(count, rst) {
        var i;
        count = count > 0 ? count : 5;
        var dLen;
        dLen = 1 / count;
        for (i = 0; i <= 1; i += dLen) {
            _calFun(i, rst);
        }
    }
    function _getBezierParamKey(px0, py0, px1, py1) {
        return (((px0 * 100 + py0) * 100 + px1) * 100 + py1) * 100;
    }

    const className$i = "DrawCurvesCmd";
    class DrawCurvesCmd {
        static create(x, y, points, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass(className$i, DrawCurvesCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.points = points;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.points = null;
            this.lineColor = null;
            Pool.recover(className$i, this);
        }
        run(runner, gx, gy) {
            if (this.points)
                runner.drawCurves(this.x + gx, this.y + gy, this.points, this.lineColor, this.lineWidth);
        }
        get cmdID() {
            return DrawCurvesCmd.ID;
        }
        getBounds(assembler) {
            Bezier.getPoints(this.points, 5, 2, assembler.points);
            assembler.flushPoints(this.x, this.y);
        }
    }
    DrawCurvesCmd.ID = className$i;
    ClassUtils.regClass(className$i, DrawCurvesCmd);

    const className$h = "DrawImageCmd";
    class DrawImageCmd {
        constructor() {
            this.color = 0xffffffff;
        }
        static create(texture, x, y, width, height, color) {
            let cmd = Pool.getItemByClass(className$h, DrawImageCmd);
            cmd.texture = texture;
            texture && texture._addReference();
            cmd.x = x !== null && x !== void 0 ? x : 0;
            cmd.y = y !== null && y !== void 0 ? y : 0;
            cmd.width = width !== null && width !== void 0 ? width : texture.sourceWidth;
            cmd.height = height !== null && height !== void 0 ? height : texture.sourceHeight;
            cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
            return cmd;
        }
        recover() {
            this.texture && this.texture._removeReference();
            this.texture = null;
            Pool.recover(className$h, this);
        }
        run(runner, gx, gy) {
            let tex = this.texture;
            if (!tex)
                return;
            let x = this.x, y = this.y, w = this.width, h = this.height;
            let wRate = w / tex.sourceWidth;
            let hRate = h / tex.sourceHeight;
            w = tex.width * wRate;
            h = tex.height * hRate;
            x += tex.offsetX * wRate;
            y += tex.offsetY * hRate;
            runner.drawTexture(this.texture, x + gx, y + gy, w, h, this.color);
        }
        getBounds(assembler) {
            Rectangle.TEMP.setTo(this.x, this.y, this.width, this.height).getBoundPoints(assembler.points);
        }
        get cmdID() {
            return DrawImageCmd.ID;
        }
    }
    DrawImageCmd.ID = className$h;

    const className$g = "DrawLineCmd";
    class DrawLineCmd {
        constructor() {
            this.lineWidth = 0;
        }
        static create(fromX, fromY, toX, toY, lineColor, lineWidth, percent) {
            var cmd = Pool.getItemByClass(className$g, DrawLineCmd);
            cmd.fromX = fromX;
            cmd.fromY = fromY;
            cmd.toX = toX;
            cmd.toY = toY;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            cmd.percent = percent;
            return cmd;
        }
        recover() {
            Pool.recover(className$g, this);
        }
        run(runner, gx, gy) {
            let offset = (this.lineWidth < 1 || this.lineWidth % 2 === 0) ? 0 : 0.5;
            if (this.percent && runner.sprite) {
                let w = runner.sprite.width;
                let h = runner.sprite.height;
                runner._drawLine(gx, gy, this.fromX * w + offset, this.fromY * h + offset, this.toX * w + offset, this.toY * h + offset, this.lineColor, this.lineWidth, 0);
            }
            else
                runner._drawLine(gx, gy, this.fromX + offset, this.fromY + offset, this.toX + offset, this.toY + offset, this.lineColor, this.lineWidth, 0);
        }
        get cmdID() {
            return DrawLineCmd.ID;
        }
        getBounds(assembler) {
            let lineWidth;
            lineWidth = this.lineWidth * 0.5;
            let fromX = this.fromX, fromY = this.fromY, toX = this.toX, toY = this.toY;
            if (this.percent) {
                fromX *= assembler.width;
                fromY *= assembler.height;
                toX *= assembler.width;
                toY *= assembler.height;
            }
            if (fromX == toX) {
                assembler.points.push(fromX + lineWidth, fromY, toX + lineWidth, toY, fromX - lineWidth, fromY, toX - lineWidth, toY);
            }
            else if (fromY == toY) {
                assembler.points.push(fromX, fromY + lineWidth, toX, toY + lineWidth, fromX, fromY - lineWidth, toX, toY - lineWidth);
            }
            else {
                assembler.points.push(fromX, fromY, toX, toY);
            }
        }
    }
    DrawLineCmd.ID = className$g;
    ClassUtils.regClass(className$g, DrawLineCmd);

    const className$f = "DrawLinesCmd";
    class DrawLinesCmd {
        constructor() {
            this.lineWidth = 0;
        }
        static create(x, y, points, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass(className$f, DrawLinesCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.points = points;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.points = null;
            this.lineColor = null;
            Pool.recover(className$f, this);
        }
        run(runner, gx, gy) {
            let offset = (this.lineWidth < 1 || this.lineWidth % 2 === 0) ? 0 : 0.5;
            this.points && runner._drawLines(this.x + offset + gx, this.y + offset + gy, this.points, this.lineColor, this.lineWidth, 0);
        }
        getBounds(assembler) {
            assembler.points.push(...this.points);
            assembler.flushPoints(this.x, this.y);
        }
        get cmdID() {
            return DrawLinesCmd.ID;
        }
    }
    DrawLinesCmd.ID = className$f;
    ClassUtils.regClass(className$f, DrawLinesCmd);

    const className$e = "DrawPathCmd";
    class DrawPathCmd {
        static create(x, y, paths, brush, pen) {
            var cmd = Pool.getItemByClass(className$e, DrawPathCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.paths = paths;
            cmd.brush = brush;
            cmd.pen = pen;
            return cmd;
        }
        recover() {
            this.paths = null;
            this.brush = null;
            this.pen = null;
            Pool.recover(className$e, this);
        }
        run(runner, gx, gy) {
            this.paths && runner._drawPath(this.x + gx, this.y + gy, this.paths, this.brush, this.pen);
        }
        get cmdID() {
            return DrawPathCmd.ID;
        }
        getBounds(assembler) {
            let paths = this.paths;
            let len = paths.length;
            for (let i = 0; i < len; i++) {
                let tCMD = paths[i];
                if (tCMD.length > 1) {
                    assembler.points.push(tCMD[1], tCMD[2]);
                    if (tCMD.length > 3) {
                        assembler.points.push(tCMD[3], tCMD[4]);
                    }
                }
            }
            assembler.flushPoints(this.x, this.y);
        }
    }
    DrawPathCmd.ID = className$e;
    ClassUtils.regClass(className$e, DrawPathCmd);

    const className$d = "DrawPieCmd";
    class DrawPieCmd {
        constructor() {
            this.radius = 0;
            this.lineWidth = 0;
        }
        static create(x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass(className$d, DrawPieCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.radius = radius;
            cmd._startAngle = startAngle;
            cmd._endAngle = endAngle;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover(className$d, this);
        }
        run(runner, gx, gy) {
            let offset = (this.lineWidth >= 1 && this.lineColor) ? this.lineWidth / 2 : 0;
            let lineOffset = this.lineColor ? this.lineWidth : 0;
            runner._drawPie(this.x + offset + gx, this.y + offset + gy, this.radius - lineOffset, this._startAngle, this._endAngle, this.fillColor, this.lineColor, this.lineWidth, 0);
        }
        get cmdID() {
            return DrawPieCmd.ID;
        }
        get startAngle() {
            return this._startAngle * 180 / Math.PI;
        }
        set startAngle(value) {
            this._startAngle = value * Math.PI / 180;
        }
        get endAngle() {
            return this._endAngle * 180 / Math.PI;
        }
        set endAngle(value) {
            this._endAngle = value * Math.PI / 180;
        }
        getBounds(assembler) {
            let rst = assembler.points;
            let k = Math.PI / 180;
            let d1 = this.endAngle - this.startAngle;
            let x = this.x, y = this.y, radius = this.radius;
            if (d1 >= 360 || d1 <= -360) {
                rst.push(x - radius, y - radius);
                rst.push(x + radius, y - radius);
                rst.push(x + radius, y + radius);
                rst.push(x - radius, y + radius);
                return;
            }
            rst.push(x, y);
            var delta = d1 % 360;
            if (delta < 0)
                delta += 360;
            var end1 = this.startAngle + delta;
            var st = this.startAngle * k;
            var ed = end1 * k;
            rst.push(x + radius * Math.cos(st), y + radius * Math.sin(st));
            rst.push(x + radius * Math.cos(ed), y + radius * Math.sin(ed));
            var s1 = Math.ceil(this.startAngle / 90) * 90;
            var s2 = Math.floor(end1 / 90) * 90;
            for (var cs = s1; cs <= s2; cs += 90) {
                var csr = cs * k;
                rst.push(x + radius * Math.cos(csr), y + radius * Math.sin(csr));
            }
        }
    }
    DrawPieCmd.ID = className$d;
    ClassUtils.regClass(className$d, DrawPieCmd);

    const className$c = "DrawPolyCmd";
    class DrawPolyCmd {
        static create(x, y, points, fillColor, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass(className$c, DrawPolyCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.points = points;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.points = null;
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover(className$c, this);
        }
        run(runner, gx, gy) {
            let isConvexPolygon = this.points.length <= 6;
            let offset = (this.lineWidth >= 1 && this.lineColor) ? (this.lineWidth % 2 === 0 ? 0 : 0.5) : 0;
            this.points && runner._drawPoly(this.x + offset + gx, this.y + offset + gy, this.points, this.fillColor, this.lineColor, this.lineWidth, isConvexPolygon, 0);
        }
        getBounds(assembler) {
            assembler.points.push(...this.points);
            assembler.flushPoints(this.x, this.y);
        }
        get cmdID() {
            return DrawPolyCmd.ID;
        }
    }
    DrawPolyCmd.ID = className$c;
    ClassUtils.regClass(className$c, DrawPolyCmd);

    const className$b = "DrawRectCmd";
    class DrawRectCmd {
        constructor() {
            this.x = 0;
            this.y = 0;
            this.width = 1;
            this.height = 1;
            this.lineWidth = 0;
            this.percent = true;
        }
        static create(x, y, width, height, fillColor, lineColor, lineWidth, percent) {
            var cmd = Pool.getItemByClass(className$b, DrawRectCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            cmd.percent = percent;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover(className$b, this);
        }
        run(runner, gx, gy) {
            let offset = (this.lineWidth >= 1 && this.lineColor) ? this.lineWidth / 2 : 0;
            let lineOffset = this.lineColor ? this.lineWidth : 0;
            if (this.percent && runner.sprite) {
                let w = runner.sprite.width;
                let h = runner.sprite.height;
                runner.drawRect(this.x * w + offset + gx, this.y * h + offset + gy, this.width * w - lineOffset, this.height * h - lineOffset, this.fillColor, this.lineColor, this.lineWidth);
            }
            else
                runner.drawRect(this.x + offset + gx, this.y + offset + gy, this.width - lineOffset, this.height - lineOffset, this.fillColor, this.lineColor, this.lineWidth);
        }
        get cmdID() {
            return DrawRectCmd.ID;
        }
        getBounds(assembler) {
            let rect = Rectangle.TEMP.setTo(this.x, this.y, this.width, this.height);
            if (this.percent) {
                rect.scale(assembler.width, assembler.height);
            }
            rect.getBoundPoints(assembler.points);
        }
    }
    DrawRectCmd.ID = className$b;
    ClassUtils.regClass(className$b, DrawRectCmd);

    const className$a = "DrawTextureCmd";
    class DrawTextureCmd {
        constructor() {
            this.x = 0;
            this.y = 0;
            this.width = 1;
            this.height = 1;
            this.percent = true;
            this.alpha = 1;
            this.color = 0xffffffff;
            this.uv = null;
        }
        static create(texture, x, y, width, height, matrix, alpha, color, blendMode, uv, percent) {
            let cmd = Pool.getItemByClass(className$a, DrawTextureCmd);
            cmd.texture = texture;
            texture && texture._addReference();
            cmd.x = x !== null && x !== void 0 ? x : 0;
            cmd.y = y !== null && y !== void 0 ? y : 0;
            cmd.width = width !== null && width !== void 0 ? width : texture.sourceWidth;
            cmd.height = height !== null && height !== void 0 ? height : texture.sourceHeight;
            cmd.percent = percent;
            cmd.matrix = matrix;
            cmd.alpha = alpha !== null && alpha !== void 0 ? alpha : 1;
            cmd.blendMode = blendMode;
            cmd.uv = uv;
            cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
            return cmd;
        }
        recover() {
            this.texture && this.texture._removeReference();
            this.texture = null;
            this.matrix = null;
            Pool.recover(className$a, this);
        }
        run(runner, gx, gy) {
            let tex = this.texture;
            if (!tex)
                return;
            let x = this.x, y = this.y, w = this.width, h = this.height;
            if (this.percent && runner.sprite) {
                x *= runner.sprite.width;
                y *= runner.sprite.height;
                w *= runner.sprite.width;
                h *= runner.sprite.height;
            }
            let wRate = w / tex.sourceWidth;
            let hRate = h / tex.sourceHeight;
            w = tex.width * wRate;
            h = tex.height * hRate;
            x += tex.offsetX * wRate;
            y += tex.offsetY * hRate;
            runner.drawTextureWithTransform(this.texture, x, y, w, h, this.matrix, gx, gy, this.alpha, this.blendMode, this.uv, this.color);
        }
        getBounds(assembler) {
            let rect = Rectangle.TEMP.setTo(this.x, this.y, this.width, this.height);
            if (this.percent) {
                rect.scale(assembler.width, assembler.height);
            }
            rect.getBoundPoints(assembler.points);
        }
        get cmdID() {
            return DrawTextureCmd.ID;
        }
    }
    DrawTextureCmd.ID = className$a;
    ClassUtils.regClass(className$a, DrawTextureCmd);

    const className$9 = "DrawTexturesCmd";
    class DrawTexturesCmd {
        static create(texture, pos, colors) {
            var cmd = Pool.getItemByClass(className$9, DrawTexturesCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.pos = pos;
            cmd.colors = colors || [];
            return cmd;
        }
        recover() {
            this.texture._removeReference();
            this.texture = null;
            this.pos = null;
            Pool.recover(className$9, this);
        }
        run(runner, gx, gy) {
            runner.drawTextures(this.texture, this.pos, gx, gy, this.colors);
        }
        getBounds(assembler) {
            if (this.texture) {
                let w = this.texture.width;
                let h = this.texture.height;
                for (let i = 0, n = this.pos.length; i < n; i += 2) {
                    let x = this.pos[i];
                    let y = this.pos[i + 1];
                    Rectangle.TEMP.setTo(x, y, w, h).getBoundPoints(assembler.points);
                }
            }
        }
        get cmdID() {
            return DrawTexturesCmd.ID;
        }
    }
    DrawTexturesCmd.ID = className$9;

    const className$8 = "DrawTrianglesCmd";
    class DrawTrianglesCmd {
        constructor() {
            this.x = 0;
            this.y = 0;
        }
        static create(texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode) {
            var cmd = Pool.getItemByClass(className$8, DrawTrianglesCmd);
            cmd.texture = texture;
            texture === null || texture === void 0 ? void 0 : texture._addReference();
            cmd.x = x;
            cmd.y = y;
            cmd.vertices = vertices;
            cmd.uvs = uvs;
            cmd.indices = indices;
            cmd.matrix = matrix;
            cmd.alpha = alpha !== null && alpha !== void 0 ? alpha : 1;
            cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
            cmd.blendMode = blendMode;
            return cmd;
        }
        static create2(texture, mesh, color) {
            var cmd = Pool.getItemByClass(className$8, DrawTrianglesCmd);
            cmd.texture = texture;
            texture === null || texture === void 0 ? void 0 : texture._addReference();
            cmd.x = 0;
            cmd.y = 0;
            cmd.mesh = mesh;
            cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
            return cmd;
        }
        recover() {
            var _a;
            (_a = this.texture) === null || _a === void 0 ? void 0 : _a._removeReference();
            this.texture = null;
            this.vertices = null;
            this.uvs = null;
            this.indices = null;
            this.matrix = null;
            this.mesh = null;
            Pool.recover(className$8, this);
        }
        run(runner, gx, gy) {
            var _a;
            if (this.mesh) {
                let vb = VertexStream.pool.take(this.texture);
                vb.contentRect.setTo(0, 0, runner.sprite.width, runner.sprite.height);
                if (this.color)
                    vb.color.setABGR(this.color);
                try {
                    this.mesh.onPopulateMesh(vb);
                }
                catch (e) {
                    console.error(e);
                }
                runner.drawTriangles(this.texture, this.x + gx, this.y + gy, vb.getVertices(), vb.getUVs(), vb.getIndices(), this.matrix, this.alpha, this.blendMode, null, vb.getColors(), (_a = this.texture) === null || _a === void 0 ? void 0 : _a.uvrect);
                VertexStream.pool.recover(vb);
            }
            else if (this.vertices && this.uvs && this.indices) {
                runner.drawTriangles(this.texture, this.x + gx, this.y + gy, this.vertices, this.uvs, this.indices, this.matrix, this.alpha, this.blendMode, this.color);
            }
        }
        get cmdID() {
            return DrawTrianglesCmd.ID;
        }
        getBounds(assembler) {
            Rectangle.TEMP.setTo(0, 0, assembler.width, assembler.height).getBoundPoints(assembler.points);
        }
    }
    DrawTrianglesCmd.ID = className$8;
    ClassUtils.regClass(className$8, DrawTrianglesCmd);

    class Byte {
        static getSystemEndian() {
            if (!Byte._sysEndian) {
                let buffer = new ArrayBuffer(2);
                new DataView(buffer).setInt16(0, 256, true);
                Byte._sysEndian = (new Int16Array(buffer))[0] === 256 ? Byte.LITTLE_ENDIAN : Byte.BIG_ENDIAN;
            }
            return Byte._sysEndian;
        }
        constructor(data) {
            this._xd_ = true;
            this._allocated_ = 8;
            this._pos_ = 0;
            this._length = 0;
            if (data) {
                this._u8d_ = new Uint8Array(data);
                this._d_ = new DataView(this._u8d_.buffer);
                this._length = this._d_.byteLength;
            }
            else {
                this._resizeBuffer(this._allocated_);
            }
        }
        get buffer() {
            let rstBuffer = this._d_.buffer;
            if (rstBuffer.byteLength === this._length)
                return rstBuffer;
            else
                return rstBuffer.slice(0, this._length);
        }
        get rawBuffer() {
            return this._d_.buffer;
        }
        get endian() {
            return this._xd_ ? Byte.LITTLE_ENDIAN : Byte.BIG_ENDIAN;
        }
        set endian(value) {
            this._xd_ = (value === Byte.LITTLE_ENDIAN);
        }
        set length(value) {
            if (this._allocated_ < value)
                this._resizeBuffer(this._allocated_ = Math.floor(Math.max(value, this._allocated_ * 2)));
            else if (this._allocated_ > value)
                this._resizeBuffer(this._allocated_ = value);
            this._length = value;
        }
        get length() {
            return this._length;
        }
        _resizeBuffer(len) {
            try {
                let newByteView = new Uint8Array(len);
                if (this._u8d_ != null) {
                    if (this._u8d_.length <= len)
                        newByteView.set(this._u8d_);
                    else
                        newByteView.set(this._u8d_.subarray(0, len));
                }
                this._u8d_ = newByteView;
                this._d_ = new DataView(newByteView.buffer);
            }
            catch (err) {
                throw new Error("Invalid typed array length:" + len);
            }
        }
        readString() {
            return this._rUTF(this.readUint16());
        }
        readTypedArray(start, len, type) {
            let end = start + len;
            end = (end > this._length) ? this._length : end;
            let v = new type(this._d_.buffer.slice(start, end));
            this._pos_ = end;
            return v;
        }
        readFloat32Array(start, len) {
            return this.readTypedArray(start, len, Float32Array);
        }
        readUint8Array(start, len) {
            return this.readTypedArray(start, len, Uint8Array);
        }
        readInt8Array(start, len) {
            return this.readTypedArray(start, len, Int8Array);
        }
        readInt16Array(start, len) {
            return this.readTypedArray(start, len, Int16Array);
        }
        readFloat32() {
            if (this._pos_ + 4 > this._length)
                throw new OutOfRangeError(this._pos_ + 4);
            var v = this._d_.getFloat32(this._pos_, this._xd_);
            this._pos_ += 4;
            return v;
        }
        readFloat64() {
            if (this._pos_ + 8 > this._length)
                throw new OutOfRangeError(this._pos_ + 8);
            var v = this._d_.getFloat64(this._pos_, this._xd_);
            this._pos_ += 8;
            return v;
        }
        writeFloat32(value) {
            this._ensureWrite(this._pos_ + 4);
            this._d_.setFloat32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        }
        writeFloat64(value) {
            this._ensureWrite(this._pos_ + 8);
            this._d_.setFloat64(this._pos_, value, this._xd_);
            this._pos_ += 8;
        }
        readInt32() {
            if (this._pos_ + 4 > this._length)
                throw new OutOfRangeError(this._pos_ + 4);
            var float = this._d_.getInt32(this._pos_, this._xd_);
            this._pos_ += 4;
            return float;
        }
        readUint32() {
            if (this._pos_ + 4 > this._length)
                throw new OutOfRangeError(this._pos_ + 4);
            var v = this._d_.getUint32(this._pos_, this._xd_);
            this._pos_ += 4;
            return v;
        }
        writeInt32(value) {
            this._ensureWrite(this._pos_ + 4);
            this._d_.setInt32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        }
        writeUint32(value) {
            this._ensureWrite(this._pos_ + 4);
            this._d_.setUint32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        }
        readInt16() {
            if (this._pos_ + 2 > this._length)
                throw new OutOfRangeError(this._pos_ + 2);
            var us = this._d_.getInt16(this._pos_, this._xd_);
            this._pos_ += 2;
            return us;
        }
        readUint16() {
            if (this._pos_ + 2 > this._length)
                throw new OutOfRangeError(this._pos_ + 2);
            var us = this._d_.getUint16(this._pos_, this._xd_);
            this._pos_ += 2;
            return us;
        }
        writeUint16(value) {
            this._ensureWrite(this._pos_ + 2);
            this._d_.setUint16(this._pos_, value, this._xd_);
            this._pos_ += 2;
        }
        writeInt16(value) {
            this._ensureWrite(this._pos_ + 2);
            this._d_.setInt16(this._pos_, value, this._xd_);
            this._pos_ += 2;
        }
        readUint8() {
            if (this._pos_ + 1 > this._length)
                throw new OutOfRangeError(this._pos_ + 1);
            return this._u8d_[this._pos_++];
        }
        writeUint8(value) {
            this._ensureWrite(this._pos_ + 1);
            this._d_.setUint8(this._pos_, value);
            this._pos_++;
        }
        _getMatrix() {
            return this._readMatrix();
        }
        _readMatrix() {
            var rst = new Matrix(this.readFloat32(), this.readFloat32(), this.readFloat32(), this.readFloat32(), this.readFloat32(), this.readFloat32());
            return rst;
        }
        _rUTF(len) {
            let max = this._pos_ + len, c, c2, c3, f = String.fromCharCode;
            let u = this._u8d_;
            let strs = [];
            let n = 0;
            strs.length = 1000;
            while (this._pos_ < max) {
                c = u[this._pos_++];
                if (c < 0x80) {
                    if (c != 0)
                        strs[n++] = f(c);
                }
                else if (c < 0xE0) {
                    strs[n++] = f(((c & 0x3F) << 6) | (u[this._pos_++] & 0x7F));
                }
                else if (c < 0xF0) {
                    c2 = u[this._pos_++];
                    strs[n++] = f(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (u[this._pos_++] & 0x7F));
                }
                else {
                    c2 = u[this._pos_++];
                    c3 = u[this._pos_++];
                    const _code = ((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 & 0x7F) << 6) | (u[this._pos_++] & 0x7F);
                    if (_code >= 0x10000) {
                        const _offset = _code - 0x10000;
                        const _lead = 0xd800 | (_offset >> 10);
                        const _trail = 0xdc00 | (_offset & 0x3ff);
                        strs[n++] = f(_lead);
                        strs[n++] = f(_trail);
                    }
                    else {
                        strs[n++] = f(_code);
                    }
                }
            }
            strs.length = n;
            return strs.join('');
        }
        readCustomString(len) {
            var v = "", ulen = 0, c, c2, f = String.fromCharCode;
            var u = this._u8d_;
            while (len > 0) {
                c = u[this._pos_];
                if (c < 0x80) {
                    v += f(c);
                    this._pos_++;
                    len--;
                }
                else {
                    ulen = c - 0x80;
                    this._pos_++;
                    len -= ulen;
                    while (ulen > 0) {
                        c = u[this._pos_++];
                        c2 = u[this._pos_++];
                        v += f((c2 << 8) | c);
                        ulen--;
                    }
                }
            }
            return v;
        }
        get pos() {
            return this._pos_;
        }
        set pos(value) {
            this._pos_ = value;
        }
        get bytesAvailable() {
            return this._length - this._pos_;
        }
        clear() {
            this._pos_ = 0;
            this.length = 0;
        }
        writeUTFBytes(value) {
            value = value + "";
            for (var i = 0, sz = value.length; i < sz; i++) {
                var c = value.charCodeAt(i);
                if (c <= 0x7F) {
                    this.writeByte(c);
                }
                else if (c <= 0x7FF) {
                    this._ensureWrite(this._pos_ + 2);
                    this._u8d_.set([0xC0 | (c >> 6), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 2;
                }
                else if (c >= 0xD800 && c <= 0xDBFF) {
                    i++;
                    const c2 = value.charCodeAt(i);
                    if (!Number.isNaN(c2) && c2 >= 0xDC00 && c2 <= 0xDFFF) {
                        const _p1 = (c & 0x3FF) + 0x40;
                        const _p2 = c2 & 0x3FF;
                        const _b1 = 0xF0 | ((_p1 >> 8) & 0x3F);
                        const _b2 = 0x80 | ((_p1 >> 2) & 0x3F);
                        const _b3 = 0x80 | ((_p1 & 0x3) << 4) | ((_p2 >> 6) & 0xF);
                        const _b4 = 0x80 | (_p2 & 0x3F);
                        this._ensureWrite(this._pos_ + 4);
                        this._u8d_.set([_b1, _b2, _b3, _b4], this._pos_);
                        this._pos_ += 4;
                    }
                }
                else if (c <= 0xFFFF) {
                    this._ensureWrite(this._pos_ + 3);
                    this._u8d_.set([0xE0 | (c >> 12), 0x80 | ((c >> 6) & 0x3F), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 3;
                }
                else {
                    this._ensureWrite(this._pos_ + 4);
                    this._u8d_.set([0xF0 | (c >> 18), 0x80 | ((c >> 12) & 0x3F), 0x80 | ((c >> 6) & 0x3F), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 4;
                }
            }
        }
        writeUTFString(value) {
            var tPos = this.pos;
            this.writeUint16(1);
            this.writeUTFBytes(value);
            var dPos = this.pos - tPos - 2;
            this._d_.setUint16(tPos, dPos, this._xd_);
        }
        writeUTFString32(value) {
            var tPos = this.pos;
            this.writeUint32(1);
            this.writeUTFBytes(value);
            var dPos = this.pos - tPos - 4;
            this._d_.setUint32(tPos, dPos, this._xd_);
        }
        readUTFString() {
            return this.readUTFBytes(this.readUint16());
        }
        readUTFString32() {
            return this.readUTFBytes(this.readUint32());
        }
        readUTFBytes(len) {
            if (len == null)
                len = -1;
            if (len === 0)
                return "";
            var lastBytes = this.bytesAvailable;
            if (len > lastBytes)
                throw new OutOfRangeError(this._pos_ + len);
            len = len > 0 ? len : lastBytes;
            return this._rUTF(len);
        }
        writeByte(value) {
            this._ensureWrite(this._pos_ + 1);
            this._d_.setInt8(this._pos_, value);
            this._pos_ += 1;
        }
        readByte() {
            if (this._pos_ + 1 > this._length)
                throw new OutOfRangeError(this._pos_ + 1);
            return this._d_.getInt8(this._pos_++);
        }
        _ensureWrite(lengthToEnsure) {
            if (this._length < lengthToEnsure)
                this._length = lengthToEnsure;
            if (this._allocated_ < lengthToEnsure)
                this.length = lengthToEnsure;
        }
        writeArrayBuffer(arraybuffer, offset, length) {
            if (offset == null)
                offset = 0;
            if (length == null)
                length = 0;
            if (offset < 0 || length < 0)
                throw new OutOfRangeError(offset + length);
            if (length == 0)
                length = arraybuffer.byteLength - offset;
            this._ensureWrite(this._pos_ + length);
            let uint8array = new Uint8Array(arraybuffer);
            this._u8d_.set(uint8array.subarray(offset, offset + length), this._pos_);
            this._pos_ += length;
        }
        readArrayBuffer(length) {
            let rst = this._u8d_.buffer.slice(this._pos_, this._pos_ + length);
            this._pos_ = this._pos_ + length;
            return rst;
        }
        __getBuffer() {
            return this._d_.buffer;
        }
        getByte() {
            return this.readByte();
        }
        getUint8() {
            return this.readUint8();
        }
        getInt16() {
            return this.readInt16();
        }
        getUint16() {
            return this.readUint16();
        }
        getInt32() {
            return this.readInt32();
        }
        getUint32() {
            return this.readUint32();
        }
        getFloat32() {
            return this.readFloat32();
        }
        getFloat64() {
            return this.readFloat64();
        }
        getUint8Array(start, len) {
            return this.readUint8Array(start, len);
        }
        getInt16Array(start, len) {
            return this.readInt16Array(start, len);
        }
        getFloat32Array(start, len) {
            return this.readFloat32Array(start, len);
        }
        getUTFString() {
            return this.readUTFString();
        }
        getString() {
            return this.readString();
        }
        getCustomString(len) {
            return this.readCustomString(len);
        }
        getUTFBytes(len = -1) {
            return this.readUTFBytes(len);
        }
    }
    Byte.BIG_ENDIAN = "bigEndian";
    Byte.LITTLE_ENDIAN = "littleEndian";
    Byte._sysEndian = null;

    class HalfFloatUtils {
        static __init__() {
            for (var i = 0; i < 256; ++i) {
                var e = i - 127;
                if (e < -27) {
                    _baseTable[i | 0x000] = 0x0000;
                    _baseTable[i | 0x100] = 0x8000;
                    _shiftTable[i | 0x000] = 24;
                    _shiftTable[i | 0x100] = 24;
                }
                else if (e < -14) {
                    _baseTable[i | 0x000] = 0x0400 >> (-e - 14);
                    _baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;
                    _shiftTable[i | 0x000] = -e - 1;
                    _shiftTable[i | 0x100] = -e - 1;
                }
                else if (e <= 15) {
                    _baseTable[i | 0x000] = (e + 15) << 10;
                    _baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;
                    _shiftTable[i | 0x000] = 13;
                    _shiftTable[i | 0x100] = 13;
                }
                else if (e < 128) {
                    _baseTable[i | 0x000] = 0x7c00;
                    _baseTable[i | 0x100] = 0xfc00;
                    _shiftTable[i | 0x000] = 24;
                    _shiftTable[i | 0x100] = 24;
                }
                else {
                    _baseTable[i | 0x000] = 0x7c00;
                    _baseTable[i | 0x100] = 0xfc00;
                    _shiftTable[i | 0x000] = 13;
                    _shiftTable[i | 0x100] = 13;
                }
            }
            _mantissaTable[0] = 0;
            for (i = 1; i < 1024; ++i) {
                var m = i << 13;
                e = 0;
                while ((m & 0x00800000) === 0) {
                    e -= 0x00800000;
                    m <<= 1;
                }
                m &= ~0x00800000;
                e += 0x38800000;
                _mantissaTable[i] = m | e;
            }
            for (i = 1024; i < 2048; ++i) {
                _mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);
            }
            _exponentTable[0] = 0;
            for (i = 1; i < 31; ++i) {
                _exponentTable[i] = i << 23;
            }
            _exponentTable[31] = 0x47800000;
            _exponentTable[32] = 0x80000000;
            for (i = 33; i < 63; ++i) {
                _exponentTable[i] = 0x80000000 + ((i - 32) << 23);
            }
            _exponentTable[63] = 0xc7800000;
            _offsetTable[0] = 0;
            for (i = 1; i < 64; ++i) {
                if (i === 32) {
                    _offsetTable[i] = 0;
                }
                else {
                    _offsetTable[i] = 1024;
                }
            }
        }
        static roundToFloat16Bits(num) {
            _floatView[0] = num;
            var f = _uint32View[0];
            var e = (f >> 23) & 0x1ff;
            return _baseTable[e] + ((f & 0x007fffff) >> _shiftTable[e]);
        }
        static convertToNumber(float16bits) {
            var m = float16bits >> 10;
            _uint32View[0] = _mantissaTable[_offsetTable[m] + (float16bits & 0x3ff)] + _exponentTable[m];
            return _floatView[0];
        }
    }
    const _buffer = new ArrayBuffer(4);
    const _floatView = new Float32Array(_buffer);
    const _uint32View = new Uint32Array(_buffer);
    const _baseTable = new Uint32Array(512);
    const _shiftTable = new Uint32Array(512);
    const _mantissaTable = new Uint32Array(2048);
    const _exponentTable = new Uint32Array(64);
    const _offsetTable = new Uint32Array(64);

    exports.FilterMode = void 0;
    (function (FilterMode) {
        FilterMode[FilterMode["Point"] = 0] = "Point";
        FilterMode[FilterMode["Bilinear"] = 1] = "Bilinear";
        FilterMode[FilterMode["Trilinear"] = 2] = "Trilinear";
    })(exports.FilterMode || (exports.FilterMode = {}));

    const FOURCC_DXT1 = 827611204;
    const FOURCC_DXT3 = 861165636;
    const FOURCC_DXT4 = 877942852;
    const FOURCC_DXT5 = 894720068;
    const DDPF_FOURCC = 0x4;
    const DDPF_RGB = 0x40;
    const DDSCAPS2_CUBEMAP = 0x200;
    const DDPF_LUMINANCE = 0x20000;
    const DDSD_MIPMAPCOUNT = 0x20000;
    const DDS_MAGIC = 0x20534444;
    const DDS_HEADER_LENGTH = 31;
    const DDS_HEADER_MAGIC = 0;
    const DDS_HEADER_SIZE = 1;
    const DDS_HEADER_FLAGS = 2;
    const DDS_HEADER_HEIGHT = 3;
    const DDS_HEADER_WIDTH = 4;
    const DDS_HEADER_MIPMAPCOUNT = 7;
    const DDS_HEADER_PF_FLAGS = 20;
    const DDS_HEADER_PF_FOURCC = 21;
    const DDS_HEADER_PF_CAPS2 = 28;
    const FOURCC_D3DFMT_R16G16B16A16F = 113;
    const FOURCC_D3DFMT_R32G32B32A32F = 116;
    const Int32ToFourCC = (value) => {
        return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);
    };
    class DDSTextureInfo {
        constructor(width, height, mipmapCount, isCube, bpp, blockBytes, dataOffset, format, compressed, sourceData) {
            this.width = width;
            this.height = height;
            this.mipmapCount = mipmapCount;
            this.isCube = isCube;
            this.blockBytes = blockBytes;
            this.dataOffset = dataOffset;
            this.format = format;
            this.source = sourceData;
            this.bpp = bpp;
            this.compressed = compressed;
        }
        static getDDSTextureInfo(source) {
            let header = new Int32Array(source, 0, DDS_HEADER_LENGTH);
            let width = header[DDS_HEADER_WIDTH];
            let height = header[DDS_HEADER_HEIGHT];
            let mipmapCount = 1;
            if (header[DDS_HEADER_FLAGS] & DDSD_MIPMAPCOUNT) {
                mipmapCount = Math.max(1, header[DDS_HEADER_MIPMAPCOUNT]);
            }
            let fourCC = header[DDS_HEADER_PF_FOURCC];
            let isFourCC = (header[DDS_HEADER_PF_FLAGS] & DDPF_FOURCC) === DDPF_FOURCC;
            let isRGB = (header[DDS_HEADER_PF_FLAGS] & DDPF_RGB) === DDPF_RGB;
            let isLuminance = (header[DDS_HEADER_PF_FLAGS] & DDPF_LUMINANCE) === DDPF_LUMINANCE;
            let isCube = (header[DDS_HEADER_PF_CAPS2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP;
            let isCompressed = (fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5 || fourCC === FOURCC_DXT4);
            let layaTexFormat = exports.TextureFormat.DXT1;
            let dataOffset = header[DDS_HEADER_SIZE] + 4;
            let blockBytes = 1;
            switch (fourCC) {
                case FOURCC_DXT1:
                    layaTexFormat = exports.TextureFormat.DXT1;
                    blockBytes = 8;
                    break;
                case FOURCC_DXT3:
                    layaTexFormat = exports.TextureFormat.DXT3;
                    blockBytes = 16;
                    break;
                case FOURCC_DXT4:
                case FOURCC_DXT5:
                    layaTexFormat = exports.TextureFormat.DXT5;
                    blockBytes = 16;
                    break;
                case FOURCC_D3DFMT_R16G16B16A16F:
                    layaTexFormat = exports.TextureFormat.R16G16B16A16;
                    blockBytes = 4;
                    break;
                case FOURCC_D3DFMT_R32G32B32A32F:
                    layaTexFormat = exports.TextureFormat.R32G32B32A32;
                    blockBytes = 4;
                    break;
                default:
                    throw "Unsupported format " + Int32ToFourCC(fourCC);
            }
            if (header[DDS_HEADER_MAGIC] !== DDS_MAGIC) {
                throw "Invalid magic number in DDS header";
            }
            if (!isFourCC && !isRGB && !isLuminance) {
                throw "Unsupported format, must contain a FourCC, RGB or LUMINANCE code";
            }
            let ext = LayaGL.renderEngine.getCapable(exports.RenderCapable.COMPRESS_TEXTURE_S3TC) || LayaGL.renderEngine.getCapable(exports.RenderCapable.COMPRESS_TEXTURE_S3TC_SRGB);
            if (isCompressed && !ext) {
                throw "Compressed textures are not supported on this platform.";
            }
            return new DDSTextureInfo(width, height, mipmapCount, isCube, 0, blockBytes, dataOffset, layaTexFormat, isCompressed, source);
        }
    }

    const IdentifierByteSize = 12;
    const HeaderSize = 13;
    const COMPRESSED_RGB_ETC1_WEBGL = 36196;
    const COMPRESSED_RGB8_ETC2 = 37492;
    const COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494;
    const COMPRESSED_RGBA8_ETC2_EAC = 37496;
    const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497;
    const COMPRESSED_SRGB8_ETC2 = 37493;
    const COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495;
    const COMPRESSED_RGBA_ASTC_4x4_KHR = 37808;
    const COMPRESSED_RGBA_ASTC_6x6_KHR = 37812;
    const COMPRESSED_RGBA_ASTC_8x8_KHR = 37815;
    const COMPRESSED_RGBA_ASTC_10x10_KHR = 37819;
    const COMPRESSED_RGBA_ASTC_12x12_KHR = 37821;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853;
    const GL_FORMAT_RGBA = 6408;
    const GL_FORMAT_RGB = 6407;
    const GL_FORMAT_RGBA32F = 0x8814;
    const GL_FORMAT_RGB32F = 0x8815;
    const GL_FORMAT_RGBA16F = 0x881A;
    const GL_FORMAT_RGB16F = 0x881B;
    const GL_FORMAT_SRGB8 = 0x8C41;
    const GL_INTERNALFORMAT_RGBA8 = 0x8058;
    const GL_INTERNALFORMAT_RGB8 = 0x8051;
    const GL_INTERNALFORMAT_SRGB8_ALPHA8 = 0x8C43;
    const GL_DATATYPE_UNSIGNED_BYTE = 0x1401;
    const GL_DATATYPE_FLOAT = 0x1406;
    const GL_DATATYPE_HALF_FLOAT = 0x140b;
    class KTXTextureInfo {
        static getLayaFormat(glFormat, glInternalFormat, glType, glTypeSize) {
            if (glFormat == 0) {
                switch (glInternalFormat) {
                    case COMPRESSED_RGB_ETC1_WEBGL:
                        return { format: exports.TextureFormat.ETC1RGB, sRGB: false };
                    case COMPRESSED_RGBA8_ETC2_EAC:
                        return { format: exports.TextureFormat.ETC2RGBA, sRGB: false };
                    case COMPRESSED_RGB8_ETC2:
                        return { format: exports.TextureFormat.ETC2RGB, sRGB: false };
                    case COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
                        return { format: exports.TextureFormat.ETC2SRGB_Alpha8, sRGB: true };
                    case COMPRESSED_SRGB8_ETC2:
                        return { format: exports.TextureFormat.ETC2SRGB, sRGB: true };
                    case COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
                        return { format: exports.TextureFormat.ETC2RGB_Alpha1, sRGB: false };
                    case COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
                        return { format: exports.TextureFormat.ETC2SRGB_Alpha1, sRGB: true };
                    case COMPRESSED_RGBA_ASTC_4x4_KHR:
                        return { format: exports.TextureFormat.ASTC4x4, sRGB: false };
                    case COMPRESSED_RGBA_ASTC_6x6_KHR:
                        return { format: exports.TextureFormat.ASTC6x6, sRGB: false };
                    case COMPRESSED_RGBA_ASTC_8x8_KHR:
                        return { format: exports.TextureFormat.ASTC8x8, sRGB: false };
                    case COMPRESSED_RGBA_ASTC_10x10_KHR:
                        return { format: exports.TextureFormat.ASTC10x10, sRGB: false };
                    case COMPRESSED_RGBA_ASTC_12x12_KHR:
                        return { format: exports.TextureFormat.ASTC12x12, sRGB: false };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:
                        return { format: exports.TextureFormat.ASTC4x4SRGB, sRGB: true };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:
                        return { format: exports.TextureFormat.ASTC6x6SRGB, sRGB: true };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:
                        return { format: exports.TextureFormat.ASTC8x8SRGB, sRGB: true };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:
                        return { format: exports.TextureFormat.ASTC10x10SRGB, sRGB: true };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:
                        return { format: exports.TextureFormat.ASTC12x12SRGB, sRGB: true };
                    default:
                        throw "KTX: UnSupported Compressed format.";
                }
            }
            else {
                if (glFormat == GL_FORMAT_RGBA && glInternalFormat == GL_INTERNALFORMAT_RGBA8 && glType == GL_DATATYPE_UNSIGNED_BYTE) {
                    return { format: exports.TextureFormat.R8G8B8A8, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGBA && glInternalFormat == GL_INTERNALFORMAT_SRGB8_ALPHA8 && glType == GL_DATATYPE_UNSIGNED_BYTE) {
                    return { format: exports.TextureFormat.R8G8B8A8, sRGB: true };
                }
                else if (glFormat == GL_FORMAT_RGBA && glInternalFormat == GL_FORMAT_RGBA32F && glType == GL_DATATYPE_FLOAT) {
                    return { format: exports.TextureFormat.R32G32B32A32, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGBA && glInternalFormat == GL_FORMAT_RGBA16F && glType == GL_DATATYPE_HALF_FLOAT) {
                    return { format: exports.TextureFormat.R16G16B16A16, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGB && glInternalFormat == GL_FORMAT_RGB32F && glType == GL_DATATYPE_FLOAT) {
                    return { format: exports.TextureFormat.R32G32B32, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGB && glInternalFormat == GL_FORMAT_RGB16F && glType == GL_DATATYPE_HALF_FLOAT) {
                    return { format: exports.TextureFormat.R16G16B16, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGB && glInternalFormat == GL_FORMAT_SRGB8 && glType == GL_DATATYPE_UNSIGNED_BYTE) {
                    return { format: exports.TextureFormat.R8G8B8, sRGB: true };
                }
                else if (glFormat == GL_FORMAT_RGB && glInternalFormat == GL_INTERNALFORMAT_RGB8 && glType == GL_DATATYPE_UNSIGNED_BYTE) {
                    return { format: exports.TextureFormat.R8G8B8, sRGB: false };
                }
                else {
                    throw "ktx: Unsupported UnCompressed image data.";
                }
            }
        }
        static getKTXTextureInfo(source) {
            let FileIdentifier = new Uint8Array(source, 0, 12);
            if (FileIdentifier[0] === 0xAB && FileIdentifier[1] === 0x4B && FileIdentifier[2] === 0x54 && FileIdentifier[3] === 0x58 && FileIdentifier[4] === 0x20 && FileIdentifier[5] === 0x32 && FileIdentifier[6] === 0x30 && FileIdentifier[7] === 0xBB && FileIdentifier[8] === 0x0D && FileIdentifier[9] === 0x0A && FileIdentifier[10] === 0x1A && FileIdentifier[11] === 0x0A) {
                throw "ktx2 !";
            }
            else if (FileIdentifier[0] === 0xAB && FileIdentifier[1] === 0x4B && FileIdentifier[2] === 0x54 && FileIdentifier[3] === 0x58 && FileIdentifier[4] === 0x20 && FileIdentifier[5] === 0x31 && FileIdentifier[6] === 0x31 && FileIdentifier[7] === 0xBB && FileIdentifier[8] === 0x0D && FileIdentifier[9] === 0x0A && FileIdentifier[10] === 0x1A && FileIdentifier[11] === 0x0A) {
                return KTXTextureInfo.createKTX1Info(source);
            }
            else {
                throw "ktx data wrong, not ktx1 or ktx2 buffer!";
            }
        }
        static createKTX1Info(source) {
            let dataSize = Uint32Array.BYTES_PER_ELEMENT;
            let headerDataView = new DataView(source, IdentifierByteSize, dataSize * HeaderSize);
            let endianness = headerDataView.getUint32(0, true);
            let littleEndian = endianness == 0x04030201;
            let glType = headerDataView.getUint32(1 * dataSize, littleEndian);
            let glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian);
            let glFormat = headerDataView.getUint32(3 * dataSize, littleEndian);
            let glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian);
            headerDataView.getUint32(5 * dataSize, littleEndian);
            let pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian);
            let pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian);
            headerDataView.getUint32(8 * dataSize, littleEndian);
            let numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian);
            let numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian);
            let numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian);
            let bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian);
            let formatInfo = KTXTextureInfo.getLayaFormat(glFormat, glInternalFormat, glType, glTypeSize);
            let layaFormat = formatInfo.format;
            let sRGBData = formatInfo.sRGB;
            let layaDemision = exports.TextureDimension.Tex2D;
            if (numberOfFaces > 1 && numberOfArrayElements > 1) {
                layaDemision = exports.TextureDimension.CubeArray;
            }
            else if (numberOfFaces > 1 && numberOfArrayElements <= 1) {
                layaDemision = exports.TextureDimension.Cube;
            }
            else if (numberOfFaces <= 1 && numberOfArrayElements > 1) {
                layaDemision = exports.TextureDimension.Texture2DArray;
            }
            let headerOffset = IdentifierByteSize + HeaderSize * 4;
            return new KTXTextureInfo(source, glFormat == 0, sRGBData, layaDemision, pixelWidth, pixelHeight, layaFormat, numberOfMipmapLevels || 1, bytesOfKeyValueData, headerOffset);
        }
        constructor(source, compress, sRGB, dimension, width, height, format, mipmapCount, bytesOfKeyValueData, headerOffset) {
            this.source = source;
            this.compress = compress;
            this.sRGB = sRGB;
            this.dimension = dimension;
            this.width = width;
            this.height = height;
            this.format = format;
            this.mipmapCount = mipmapCount;
            this.bytesOfKeyValueData = bytesOfKeyValueData;
            this.headerOffset = headerOffset;
        }
    }

    class Texture2D extends BaseTexture {
        static __init__() {
            var pixels = new Uint8Array(4);
            pixels[0] = 128;
            pixels[1] = 128;
            pixels[2] = 128;
            pixels[3] = 255;
            Texture2D.grayTexture = new Texture2D(1, 1, exports.TextureFormat.R8G8B8A8, false, false);
            Texture2D.grayTexture.setPixelsData(pixels, false, false);
            Texture2D.grayTexture.lock = true;
            Texture2D.grayTexture.name = "Default_Gray";
            pixels[0] = 255;
            pixels[1] = 255;
            pixels[2] = 255;
            pixels[3] = 255;
            Texture2D.whiteTexture = new Texture2D(1, 1, exports.TextureFormat.R8G8B8A8, false, false);
            Texture2D.whiteTexture.setPixelsData(pixels, false, false);
            Texture2D.whiteTexture.lock = true;
            Texture2D.whiteTexture.name = "Default_White";
            pixels[0] = 0;
            pixels[1] = 0;
            pixels[2] = 0;
            pixels[3] = 255;
            Texture2D.blackTexture = new Texture2D(1, 1, exports.TextureFormat.R8G8B8A8, false, false);
            Texture2D.blackTexture.setPixelsData(pixels, false, false);
            Texture2D.blackTexture.lock = true;
            Texture2D.blackTexture.name = "Default_Black";
            if (LayaGL.renderEngine.getCapable(exports.RenderCapable.TextureFormat_R16G16B16A16)) {
                let floatPixle = new Uint16Array(4);
                floatPixle[0] = 14336;
                floatPixle[1] = 14336;
                floatPixle[2] = 15360;
                floatPixle[3] = 15360;
                Texture2D.normalTexture = new Texture2D(1, 1, exports.TextureFormat.R16G16B16A16, false, false, false);
                Texture2D.normalTexture.setPixelsData(floatPixle, false, false);
            }
            else {
                pixels[0] = 128;
                pixels[1] = 128;
                pixels[2] = 255;
                pixels[3] = 255;
                Texture2D.normalTexture = new Texture2D(1, 1, exports.TextureFormat.R8G8B8A8, false, false, false);
                Texture2D.normalTexture.setPixelsData(pixels, false, false);
            }
            Texture2D.normalTexture.lock = true;
            Texture2D.normalTexture.name = "Default_Normal";
            Texture2D.errorTexture = Texture2D.whiteTexture;
        }
        static _SimpleAnimatorTextureParse(data, propertyParams = null, constructParams = null) {
            var byte = new Byte(data);
            var version = byte.readUTFString();
            var texture;
            var pixelDataArrays;
            var usePixelData;
            switch (version) {
                case "LAYAANIMATORTEXTURE:0000":
                    var textureWidth = byte.readInt32();
                    var pixelDataLength = byte.readInt32();
                    pixelDataArrays = new Float32Array(textureWidth * textureWidth * 4);
                    usePixelData = new Float32Array(byte.readArrayBuffer(pixelDataLength * 4));
                    pixelDataArrays.set(usePixelData, 0);
                    var texture = new Texture2D(textureWidth, textureWidth, exports.TextureFormat.R32G32B32A32, false, false);
                    texture.setPixelsData(pixelDataArrays, false, false);
                    texture.filterMode = exports.FilterMode.Point;
                    break;
                case "LAYACOMPRESSANIMATORTEXTURE:0000":
                    var textureWidth = byte.readInt32();
                    var pixelDataLength = byte.readInt32();
                    pixelDataArrays = new Uint16Array(byte.readArrayBuffer(pixelDataLength * 2));
                    if (!LayaGL.renderEngine.getCapable(exports.RenderCapable.TextureFormat_R16G16B16A16)) {
                        console.log("The platform does not support 16-bit floating-point textures");
                        if (!LayaGL.renderEngine.getCapable(exports.RenderCapable.TextureFormat_R32G32B32A32))
                            console.error("The platform does not support 32-bit floating-point textures");
                        usePixelData = new Float32Array(textureWidth * textureWidth * 4);
                        for (var i = 0, n = pixelDataArrays.length; i < n; i++) {
                            usePixelData[i] = HalfFloatUtils.convertToNumber(pixelDataArrays[i]);
                        }
                        texture = new Texture2D(textureWidth, textureWidth, exports.TextureFormat.R32G32B32A32, false, false);
                        texture.setPixelsData(usePixelData, false, false);
                        texture.filterMode = exports.FilterMode.Point;
                    }
                    else {
                        usePixelData = new Uint16Array(textureWidth * textureWidth * 4);
                        usePixelData.set(pixelDataArrays, 0);
                        texture = new Texture2D(textureWidth, textureWidth, exports.TextureFormat.R16G16B16A16, false, false);
                        texture.setPixelsData(usePixelData, false, false);
                        texture.filterMode = exports.FilterMode.Point;
                    }
                    break;
                default:
                    throw "Laya3D:unknow version.";
            }
            return texture;
        }
        static _parseImage(imageSource, propertyParams = null, constructParams = null) {
            let format = constructParams ? constructParams[2] : exports.TextureFormat.R8G8B8A8;
            let mipmap = constructParams ? constructParams[3] : true;
            let canread = constructParams ? constructParams[4] : false;
            let srgb = constructParams ? constructParams[5] : false;
            let pma = propertyParams ? propertyParams.premultiplyAlpha : false;
            let texture = new Texture2D(imageSource.width, imageSource.height, format, mipmap, canread, srgb, pma);
            if (propertyParams) {
                texture.setImageData(imageSource, pma, false);
                texture.setProperties(propertyParams);
            }
            else
                texture.setImageData(imageSource, false, false);
            if (canread) {
                if (LayaEnv.isConch && imageSource._nativeObj) {
                    texture._pixels = new Uint8Array(imageSource._nativeObj.getImageData(0, 0, imageSource.width, imageSource.height));
                }
                else {
                    Browser.canvas.size(imageSource.width, imageSource.height);
                    Browser.canvas.clear();
                    Browser.context.drawImage(imageSource, 0, 0, imageSource.width, imageSource.height);
                    texture._pixels = new Uint8Array(Browser.context.getImageData(0, 0, imageSource.width, imageSource.height).data.buffer);
                }
            }
            return texture;
        }
        static _parseDDS(data, propertyParams = null, constructParams = null) {
            let ddsInfo = DDSTextureInfo.getDDSTextureInfo(data);
            let sRGB = constructParams ? constructParams[5] : false;
            let texture = new Texture2D(ddsInfo.width, ddsInfo.height, ddsInfo.format, ddsInfo.mipmapCount > 1, false, sRGB);
            texture.setDDSData(ddsInfo);
            if (propertyParams)
                texture.setProperties(propertyParams);
            texture._premultiplyAlpha = propertyParams.premultiplyAlpha;
            return texture;
        }
        static _parseKTX(data, propertyParams = null, constructParams = null) {
            let ktxInfo = KTXTextureInfo.getKTXTextureInfo(data);
            let texture = new Texture2D(ktxInfo.width, ktxInfo.height, ktxInfo.format, ktxInfo.mipmapCount > 1, false, ktxInfo.sRGB);
            texture.setKTXData(ktxInfo);
            if (propertyParams)
                texture.setProperties(propertyParams);
            texture._premultiplyAlpha = propertyParams.premultiplyAlpha;
            return texture;
        }
        static _parsePVR(data, propertyParams = null, constructParams = null) {
            throw new NotImplementedError();
        }
        static load(url, complete) {
            ILaya.loader.load(url, complete, null, ILaya.Loader.TEXTURE2D);
        }
        constructor(width, height, format, mipmap = true, canRead, sRGB = false, premultiplyAlpha = false) {
            super(width, height, format);
            this._canRead = false;
            this._premultiplyAlpha = false;
            this._dimension = exports.TextureDimension.Tex2D;
            this._gammaSpace = sRGB;
            this._canRead = canRead;
            this._premultiplyAlpha = premultiplyAlpha;
            this._texture = LayaGL.textureContext.createTextureInternal(this._dimension, width, height, format, mipmap, sRGB, premultiplyAlpha);
            return;
        }
        setImageData(source, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureImageData(texture, source, premultiplyAlpha, invertY);
        }
        setPixelsData(source, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setTexturePixelsData(texture, source, premultiplyAlpha, invertY);
        }
        setSubPixelsData(xOffset, yOffset, width, height, pixels, mipmapLevel, generateMipmap, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureSubPixelsData(texture, pixels, mipmapLevel, generateMipmap, xOffset, yOffset, width, height, premultiplyAlpha, invertY);
        }
        setDDSData(ddsInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureDDSData(texture, ddsInfo);
        }
        setKTXData(ktxInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureKTXData(texture, ktxInfo);
        }
        setHDRData(hdrInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureHDRData(texture, hdrInfo);
        }
        get defaultTexture() {
            return Texture2D.grayTexture;
        }
        getPixels() {
            if (this._canRead && this._pixels) {
                return this._pixels;
            }
            else {
                throw new Error("Texture2D: must set texture canRead is true.");
            }
        }
        setProperties(propertyParams) {
            if (propertyParams) {
                if (propertyParams.wrapModeU != null)
                    this.wrapModeU = propertyParams.wrapModeU;
                if (propertyParams.wrapModeV != null)
                    this.wrapModeV = propertyParams.wrapModeV;
                if (propertyParams.filterMode != null)
                    this.filterMode = propertyParams.filterMode;
                if (propertyParams.anisoLevel != null)
                    this.anisoLevel = propertyParams.anisoLevel;
            }
        }
    }
    Texture2D.TEXTURE2D = "TEXTURE2D";
    Texture2D.grayTexture = null;
    Texture2D.whiteTexture = null;
    Texture2D.blackTexture = null;
    Texture2D.normalTexture = null;
    Texture2D.errorTexture = null;

    exports.BlendEquationSeparate = void 0;
    (function (BlendEquationSeparate) {
        BlendEquationSeparate[BlendEquationSeparate["ADD"] = 0] = "ADD";
        BlendEquationSeparate[BlendEquationSeparate["SUBTRACT"] = 1] = "SUBTRACT";
        BlendEquationSeparate[BlendEquationSeparate["REVERSE_SUBTRACT"] = 2] = "REVERSE_SUBTRACT";
        BlendEquationSeparate[BlendEquationSeparate["MIN"] = 3] = "MIN";
        BlendEquationSeparate[BlendEquationSeparate["MAX"] = 4] = "MAX";
    })(exports.BlendEquationSeparate || (exports.BlendEquationSeparate = {}));

    exports.BlendFactor = void 0;
    (function (BlendFactor) {
        BlendFactor[BlendFactor["Zero"] = 0] = "Zero";
        BlendFactor[BlendFactor["One"] = 1] = "One";
        BlendFactor[BlendFactor["SourceColor"] = 2] = "SourceColor";
        BlendFactor[BlendFactor["OneMinusSourceColor"] = 3] = "OneMinusSourceColor";
        BlendFactor[BlendFactor["DestinationColor"] = 4] = "DestinationColor";
        BlendFactor[BlendFactor["OneMinusDestinationColor"] = 5] = "OneMinusDestinationColor";
        BlendFactor[BlendFactor["SourceAlpha"] = 6] = "SourceAlpha";
        BlendFactor[BlendFactor["OneMinusSourceAlpha"] = 7] = "OneMinusSourceAlpha";
        BlendFactor[BlendFactor["DestinationAlpha"] = 8] = "DestinationAlpha";
        BlendFactor[BlendFactor["OneMinusDestinationAlpha"] = 9] = "OneMinusDestinationAlpha";
        BlendFactor[BlendFactor["SourceAlphaSaturate"] = 10] = "SourceAlphaSaturate";
        BlendFactor[BlendFactor["BlendColor"] = 11] = "BlendColor";
        BlendFactor[BlendFactor["OneMinusBlendColor"] = 12] = "OneMinusBlendColor";
    })(exports.BlendFactor || (exports.BlendFactor = {}));

    exports.BlendType = void 0;
    (function (BlendType) {
        BlendType[BlendType["BLEND_DISABLE"] = 0] = "BLEND_DISABLE";
        BlendType[BlendType["BLEND_ENABLE_ALL"] = 1] = "BLEND_ENABLE_ALL";
        BlendType[BlendType["BLEND_ENABLE_SEPERATE"] = 2] = "BLEND_ENABLE_SEPERATE";
    })(exports.BlendType || (exports.BlendType = {}));

    exports.CompareFunction = void 0;
    (function (CompareFunction) {
        CompareFunction[CompareFunction["Never"] = 0] = "Never";
        CompareFunction[CompareFunction["Less"] = 1] = "Less";
        CompareFunction[CompareFunction["Equal"] = 2] = "Equal";
        CompareFunction[CompareFunction["LessEqual"] = 3] = "LessEqual";
        CompareFunction[CompareFunction["Greater"] = 4] = "Greater";
        CompareFunction[CompareFunction["NotEqual"] = 5] = "NotEqual";
        CompareFunction[CompareFunction["GreaterEqual"] = 6] = "GreaterEqual";
        CompareFunction[CompareFunction["Always"] = 7] = "Always";
        CompareFunction[CompareFunction["Off"] = 8] = "Off";
    })(exports.CompareFunction || (exports.CompareFunction = {}));

    exports.CullMode = void 0;
    (function (CullMode) {
        CullMode[CullMode["Off"] = 0] = "Off";
        CullMode[CullMode["Front"] = 1] = "Front";
        CullMode[CullMode["Back"] = 2] = "Back";
    })(exports.CullMode || (exports.CullMode = {}));
    exports.FrontFace = void 0;
    (function (FrontFace) {
        FrontFace[FrontFace["CW"] = 0] = "CW";
        FrontFace[FrontFace["CCW"] = 1] = "CCW";
    })(exports.FrontFace || (exports.FrontFace = {}));

    exports.StencilOperation = void 0;
    (function (StencilOperation) {
        StencilOperation[StencilOperation["Keep"] = 0] = "Keep";
        StencilOperation[StencilOperation["Zero"] = 1] = "Zero";
        StencilOperation[StencilOperation["Replace"] = 2] = "Replace";
        StencilOperation[StencilOperation["IncrementSaturate"] = 3] = "IncrementSaturate";
        StencilOperation[StencilOperation["DecrementSaturate"] = 4] = "DecrementSaturate";
        StencilOperation[StencilOperation["Invert"] = 5] = "Invert";
        StencilOperation[StencilOperation["IncrementWrap"] = 6] = "IncrementWrap";
        StencilOperation[StencilOperation["DecrementWrap"] = 7] = "DecrementWrap";
    })(exports.StencilOperation || (exports.StencilOperation = {}));

    class RenderState {
        ;
        get cull() {
            return this._cull;
        }
        set cull(value) {
            this._cull = value;
        }
        get blend() {
            return this._blend;
        }
        set blend(value) {
            this._blend = value;
        }
        get srcBlend() {
            return this._srcBlend;
        }
        set srcBlend(value) {
            this._srcBlend = value;
        }
        get dstBlend() {
            return this._dstBlend;
        }
        set dstBlend(value) {
            this._dstBlend = value;
        }
        get srcBlendRGB() {
            return this._srcBlendRGB;
        }
        set srcBlendRGB(value) {
            this._srcBlendRGB = value;
        }
        get dstBlendRGB() {
            return this._dstBlendRGB;
        }
        set dstBlendRGB(value) {
            this._dstBlendRGB = value;
        }
        get srcBlendAlpha() {
            return this._srcBlendAlpha;
        }
        set srcBlendAlpha(value) {
            this._srcBlendAlpha = value;
        }
        get dstBlendAlpha() {
            return this._dstBlendAlpha;
        }
        set dstBlendAlpha(value) {
            this._dstBlendAlpha = value;
        }
        get blendEquation() {
            return this._blendEquation;
        }
        set blendEquation(value) {
            this._blendEquation = value;
        }
        get blendEquationRGB() {
            return this._blendEquationRGB;
        }
        set blendEquationRGB(value) {
            this._blendEquationRGB = value;
        }
        get blendEquationAlpha() {
            return this._blendEquationAlpha;
        }
        set blendEquationAlpha(value) {
            this._blendEquationAlpha = value;
        }
        get depthTest() {
            return this._depthTest;
        }
        set depthTest(value) {
            this._depthTest = value;
        }
        get depthWrite() {
            return this._depthWrite;
        }
        set depthWrite(value) {
            this._depthWrite = value;
        }
        get stencilWrite() {
            return this._stencilWrite;
        }
        set stencilWrite(value) {
            this._stencilWrite = value;
        }
        get stencilTest() {
            return this._stencilTest;
        }
        set stencilTest(value) {
            this._stencilTest = value;
        }
        get stencilWriteMask() {
            return this._stencilWriteMask;
        }
        set stencilWriteMask(value) {
            this._stencilWriteMask = value;
        }
        get stencilReadMask() {
            return this._stencilReadMask;
        }
        set stencilReadMask(value) {
            this._stencilReadMask = value;
        }
        get stencilRef() {
            return this._stencilRef;
        }
        set stencilRef(value) {
            this._stencilRef = value;
        }
        get stencilOp() {
            return this._stencilOp;
        }
        set stencilOp(value) {
            this._stencilOp = value;
        }
        get depthBias() {
            return this._depthBias;
        }
        set depthBias(value) {
            this._depthBias = value;
        }
        get depthBiasConstant() {
            return this._depthBiasConstant;
        }
        set depthBiasConstant(value) {
            this._depthBiasConstant = value;
        }
        get depthBiasSlopeScale() {
            return this._depthBiasSlopeScale;
        }
        set depthBiasSlopeScale(value) {
            this._depthBiasSlopeScale = value;
        }
        get depthBiasClamp() {
            return this._depthBiasClamp;
        }
        set depthBiasClamp(value) {
            this._depthBiasClamp = value;
        }
        createObj() {
        }
        constructor() {
            this._stencilOp = new Vector3();
            this.createObj();
            this.cull = RenderState.CULL_BACK;
            this.blend = RenderState.BLEND_DISABLE;
            this.srcBlend = RenderState.BLENDPARAM_ONE;
            this.dstBlend = RenderState.BLENDPARAM_ZERO;
            this.srcBlendRGB = RenderState.BLENDPARAM_ONE;
            this.dstBlendRGB = RenderState.BLENDPARAM_ZERO;
            this.srcBlendAlpha = RenderState.BLENDPARAM_ONE;
            this.dstBlendAlpha = RenderState.BLENDPARAM_ZERO;
            this.blendEquation = RenderState.BLENDEQUATION_ADD;
            this.blendEquationRGB = RenderState.BLENDEQUATION_ADD;
            this.blendEquationAlpha = RenderState.BLENDEQUATION_ADD;
            this.depthTest = RenderState.DEPTHTEST_LEQUAL;
            this.depthWrite = true;
            this.stencilWriteMask = 0xFF;
            this.stencilReadMask = 0xFF;
            this.stencilRef = 1;
            this.stencilTest = RenderState.STENCILTEST_OFF;
            this.stencilWrite = false;
            this.stencilOp = new Vector3(RenderState.STENCILOP_KEEP, RenderState.STENCILOP_KEEP, RenderState.STENCILOP_REPLACE);
            this.depthBias = false;
            this.depthBiasConstant = 0;
            this.depthBiasSlopeScale = 0;
            this.depthBiasClamp = 0;
        }
        setNull() {
            this.cull = null;
            this.blend = null;
            this.srcBlend = null;
            this.dstBlend = null;
            this.srcBlendRGB = null;
            this.dstBlendRGB = null;
            this.srcBlendAlpha = null;
            this.dstBlendAlpha = null;
            this.blendEquation = null;
            this.blendEquationRGB = null;
            this.blendEquationAlpha = null;
            this.depthTest = null;
            this.depthWrite = null;
            this.stencilWriteMask = null;
            this.stencilReadMask = null;
            this.stencilRef = null;
            this.stencilTest = null;
            this.stencilWrite = null;
            this.stencilOp.set(null, null, null);
            this.depthBias = null;
            this.depthBiasConstant = null;
            this.depthBiasSlopeScale = null;
            this.depthBiasClamp = null;
        }
        cloneTo(dest) {
            dest.cull = this.cull;
            dest.blend = this.blend;
            dest.srcBlend = this.srcBlend;
            dest.dstBlend = this.dstBlend;
            dest.srcBlendRGB = this.srcBlendRGB;
            dest.dstBlendRGB = this.dstBlendRGB;
            dest.srcBlendAlpha = this.srcBlendAlpha;
            dest.dstBlendAlpha = this.dstBlendAlpha;
            dest.blendEquation = this.blendEquation;
            dest.blendEquationRGB = this.blendEquationRGB;
            dest.blendEquationAlpha = this.blendEquationAlpha;
            dest.depthTest = this.depthTest;
            dest.depthWrite = this.depthWrite;
            dest.stencilWriteMask = this.stencilWriteMask;
            dest.stencilReadMask = this.stencilReadMask;
            dest.stencilRef = this.stencilRef;
            dest.stencilTest = this.stencilTest;
            dest.stencilWrite = this.stencilWrite;
            this.stencilOp.cloneTo(dest.stencilOp);
            dest.depthBias = this.depthBias;
            dest.depthBiasConstant = this.depthBiasConstant;
            dest.depthBiasSlopeScale = this.depthBiasSlopeScale;
            dest.depthBiasClamp = this.depthBiasClamp;
        }
        clone() {
            var dest = new RenderState();
            this.cloneTo(dest);
            return dest;
        }
    }
    RenderState.CULL_NONE = exports.CullMode.Off;
    RenderState.CULL_FRONT = exports.CullMode.Front;
    RenderState.CULL_BACK = exports.CullMode.Back;
    RenderState.BLEND_DISABLE = exports.BlendType.BLEND_DISABLE;
    RenderState.BLEND_ENABLE_ALL = exports.BlendType.BLEND_ENABLE_ALL;
    RenderState.BLEND_ENABLE_SEPERATE = exports.BlendType.BLEND_ENABLE_SEPERATE;
    RenderState.BLENDPARAM_ZERO = exports.BlendFactor.Zero;
    RenderState.BLENDPARAM_ONE = exports.BlendFactor.One;
    RenderState.BLENDPARAM_SRC_COLOR = exports.BlendFactor.SourceColor;
    RenderState.BLENDPARAM_ONE_MINUS_SRC_COLOR = exports.BlendFactor.OneMinusSourceColor;
    RenderState.BLENDPARAM_DST_COLOR = exports.BlendFactor.DestinationColor;
    RenderState.BLENDPARAM_ONE_MINUS_DST_COLOR = exports.BlendFactor.OneMinusDestinationColor;
    RenderState.BLENDPARAM_SRC_ALPHA = exports.BlendFactor.SourceAlpha;
    RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA = exports.BlendFactor.OneMinusSourceAlpha;
    RenderState.BLENDPARAM_DST_ALPHA = exports.BlendFactor.DestinationAlpha;
    RenderState.BLENDPARAM_ONE_MINUS_DST_ALPHA = exports.BlendFactor.OneMinusDestinationAlpha;
    RenderState.BLENDPARAM_SRC_ALPHA_SATURATE = exports.BlendFactor.SourceAlphaSaturate;
    RenderState.BLENDPARAM_BLENDCOLOR = exports.BlendFactor.BlendColor;
    RenderState.BLENDPARAM_BLEND_ONEMINUS_COLOR = exports.BlendFactor.OneMinusBlendColor;
    RenderState.BLENDEQUATION_ADD = exports.BlendEquationSeparate.ADD;
    RenderState.BLENDEQUATION_SUBTRACT = exports.BlendEquationSeparate.SUBTRACT;
    RenderState.BLENDEQUATION_REVERSE_SUBTRACT = exports.BlendEquationSeparate.REVERSE_SUBTRACT;
    RenderState.BLENDEQUATION_MIN = exports.BlendEquationSeparate.MIN;
    RenderState.BLENDEQUATION_MAX = exports.BlendEquationSeparate.MAX;
    RenderState.DEPTHTEST_OFF = exports.CompareFunction.Off;
    RenderState.DEPTHTEST_NEVER = exports.CompareFunction.Never;
    RenderState.DEPTHTEST_LESS = exports.CompareFunction.Less;
    RenderState.DEPTHTEST_EQUAL = exports.CompareFunction.Equal;
    RenderState.DEPTHTEST_LEQUAL = exports.CompareFunction.LessEqual;
    RenderState.DEPTHTEST_GREATER = exports.CompareFunction.Greater;
    RenderState.DEPTHTEST_NOTEQUAL = exports.CompareFunction.NotEqual;
    RenderState.DEPTHTEST_GEQUAL = exports.CompareFunction.GreaterEqual;
    RenderState.DEPTHTEST_ALWAYS = exports.CompareFunction.Always;
    RenderState.STENCILTEST_OFF = exports.CompareFunction.Off;
    RenderState.STENCILTEST_NEVER = exports.CompareFunction.Never;
    RenderState.STENCILTEST_LESS = exports.CompareFunction.Less;
    RenderState.STENCILTEST_EQUAL = exports.CompareFunction.Equal;
    RenderState.STENCILTEST_LEQUAL = exports.CompareFunction.LessEqual;
    RenderState.STENCILTEST_GREATER = exports.CompareFunction.Greater;
    RenderState.STENCILTEST_NOTEQUAL = exports.CompareFunction.NotEqual;
    RenderState.STENCILTEST_GEQUAL = exports.CompareFunction.GreaterEqual;
    RenderState.STENCILTEST_ALWAYS = exports.CompareFunction.Always;
    RenderState.STENCILOP_KEEP = exports.StencilOperation.Keep;
    RenderState.STENCILOP_ZERO = exports.StencilOperation.Zero;
    RenderState.STENCILOP_REPLACE = exports.StencilOperation.Replace;
    RenderState.STENCILOP_INCR = exports.StencilOperation.IncrementSaturate;
    RenderState.STENCILOP_INCR_WRAP = exports.StencilOperation.IncrementWrap;
    RenderState.STENCILOP_DECR = exports.StencilOperation.DecrementSaturate;
    RenderState.STENCILOP_DECR_WRAP = exports.StencilOperation.DecrementWrap;
    RenderState.STENCILOP_INVERT = exports.StencilOperation.Invert;
    RenderState.Default = new RenderState();

    class IncludeFile {
        static splitToWords(str, block) {
            let out = [];
            let c;
            let ofs = -1;
            let word;
            let n = str.length;
            for (let i = 0; i < n; i++) {
                c = str.charAt(i);
                if (" \t=+-*/&%!<>()'\",;".indexOf(c) >= 0) {
                    if (ofs >= 0 && (i - ofs) > 1) {
                        word = str.substring(ofs, i);
                        out.push(word);
                    }
                    if (c == '"' || c == "'") {
                        let ofs2 = str.indexOf(c, i + 1);
                        if (ofs2 < 0) {
                            throw new Error("Sharder err:" + str);
                        }
                        out.push(str.substring(i + 1, ofs2));
                        i = ofs2;
                        ofs = -1;
                        continue;
                    }
                    if (c == '(' && block && out.length > 0) {
                        word = out[out.length - 1] + ";";
                        if ("vec4;main;".indexOf(word) < 0)
                            block.useFuns += word;
                    }
                    ofs = -1;
                    continue;
                }
                if (ofs < 0)
                    ofs = i;
            }
            if (ofs < n && (n - ofs) > 1) {
                word = str.substring(ofs, n);
                out.push(word);
            }
            return out;
        }
        constructor(txt) {
            this.codes = {};
            this.funs = {};
            this.curUseID = -1;
            this.funnames = "";
            this.script = txt;
            let begin = 0, ofs, end;
            while (true) {
                begin = txt.indexOf("#begin", begin);
                if (begin < 0)
                    break;
                end = begin + 5;
                while (true) {
                    end = txt.indexOf("#end", end);
                    if (end < 0)
                        break;
                    if (txt.charAt(end + 4) === 'i')
                        end += 5;
                    else
                        break;
                }
                if (end < 0) {
                    throw new Error("add include err,no #end:" + txt);
                }
                ofs = txt.indexOf('\n', begin);
                let words = IncludeFile.splitToWords(txt.substring(begin, ofs), null);
                if (words[1] == 'code') {
                    this.codes[words[2]] = txt.substring(ofs + 1, end);
                }
                else if (words[1] == 'function') {
                    ofs = txt.indexOf("function", begin);
                    ofs += "function".length;
                    this.funs[words[3]] = txt.substring(ofs + 1, end);
                    this.funnames += words[3] + ";";
                }
                begin = end + 1;
            }
        }
        getWith(name = null) {
            let r = name ? this.codes[name] : this.script;
            if (!r) {
                throw new Error("get with error:" + name);
            }
            return r;
        }
        getFunsScript(funsdef) {
            let r = "";
            for (let i in this.funs) {
                if (funsdef.indexOf(i + ";") >= 0) {
                    r += this.funs[i];
                }
            }
            return r;
        }
    }

    class ShaderNode {
        constructor(includefiles) {
            this.childs = [];
            this.text = "";
            this.useFuns = "";
            this.z = 0;
            this.includefiles = includefiles;
        }
        setParent(parent) {
            parent.childs.push(this);
            this.z = parent.z + 1;
            this.parent = parent;
        }
        setCondition(condition, type) {
            if (condition) {
                this.conditionType = type;
                condition = condition.replace(/(\s*$)/g, "");
                this.condition = function () {
                    return this[condition];
                };
                this.condition.__condition = condition;
            }
        }
        toscript(def, out) {
            return this._toscript(def, out, ++ShaderNode.__id);
        }
        _toscript(def, out, id) {
            if (this.childs.length < 1 && !this.text)
                return out;
            out.length;
            if (this.condition) {
                var ifdef = !!this.condition.call(def);
                this.conditionType === 2 && (ifdef = !ifdef);
                if (!ifdef && ShaderNode.__noCompileEnable)
                    return out;
            }
            if (this.noCompile || !ShaderNode.__noCompileEnable)
                this.text && out.push(this.text);
            this.childs.length > 0 && this.childs.forEach(function (o, index, arr) {
                o._toscript(def, out, id);
            });
            if (this.includefiles.length > 0 && this.useFuns.length > 0) {
                var funsCode;
                for (var i = 0, n = this.includefiles.length; i < n; i++) {
                    if (this.includefiles[i].curUseID == id) {
                        continue;
                    }
                    funsCode = this.includefiles[i].file.getFunsScript(this.useFuns);
                    if (funsCode.length > 0) {
                        this.includefiles[i].curUseID = id;
                        out[0] = funsCode + out[0];
                    }
                }
            }
            return out;
        }
    }
    ShaderNode.__id = 1;
    ShaderNode.__noCompileEnable = true;

    const _clearCR = new RegExp("\r", "g");
    const _splitToWordExps3 = new RegExp("[ \\t=\\+\\-*/&%!<>!%\(\),;\\|]", "g");
    const CullStateMap = {
        "Back": exports.CullMode.Back,
        "Front": exports.CullMode.Front,
        "Off": exports.CullMode.Off
    };
    const BlendStateMap = {
        "Disable": exports.BlendType.BLEND_DISABLE,
        "All": exports.BlendType.BLEND_ENABLE_ALL,
        "Seperate": exports.BlendType.BLEND_ENABLE_SEPERATE
    };
    const BlendFactorMap = {
        "Zero": exports.BlendFactor.Zero,
        "One": exports.BlendFactor.One,
        "SourceColor": exports.BlendFactor.SourceColor,
        "OneMinusSourceColor": exports.BlendFactor.OneMinusSourceColor,
        "DestinationColor": exports.BlendFactor.DestinationColor,
        "OneMinusDestinationColor": exports.BlendFactor.OneMinusDestinationColor,
        "SourceAlpha": exports.BlendFactor.SourceAlpha,
        "OneMinusSourceAlpha": exports.BlendFactor.OneMinusSourceAlpha,
        "DestinationAlpha": exports.BlendFactor.DestinationAlpha,
        "OneMinusDestinationAlpha": exports.BlendFactor.OneMinusDestinationAlpha,
        "SourceAlphaSaturate": exports.BlendFactor.SourceAlphaSaturate,
        "BlendColor": exports.BlendFactor.BlendColor,
        "OneMinusBlendColor": exports.BlendFactor.OneMinusBlendColor,
    };
    const BlendEquationMap = {
        "Add": exports.BlendEquationSeparate.ADD,
        "Subtract": exports.BlendEquationSeparate.SUBTRACT,
        "Reverse_substract": exports.BlendEquationSeparate.REVERSE_SUBTRACT,
        "Min": exports.BlendEquationSeparate.MIN,
        "Max": exports.BlendEquationSeparate.MAX
    };
    const CompareFunctionMap = {
        "Never": exports.CompareFunction.Never,
        "Less": exports.CompareFunction.Less,
        "Equal": exports.CompareFunction.Equal,
        "LessEqual": exports.CompareFunction.LessEqual,
        "Greater": exports.CompareFunction.Greater,
        "NotEqual": exports.CompareFunction.NotEqual,
        "GreaterEqual": exports.CompareFunction.GreaterEqual,
        "Always": exports.CompareFunction.Always,
        "Off": exports.CompareFunction.Off,
    };
    const StencilOperationMap = {
        "Keep": exports.StencilOperation.Keep,
        "Zero": exports.StencilOperation.Zero,
        "Replace": exports.StencilOperation.Replace,
        "IncrementSaturate": exports.StencilOperation.IncrementSaturate,
        "DecrementSaturate": exports.StencilOperation.DecrementSaturate,
        "Invert": exports.StencilOperation.Invert,
        "IncrementWrap": exports.StencilOperation.IncrementWrap,
        "DecrementWrap": exports.StencilOperation.DecrementWrap,
    };
    class ShaderCompile {
        static addInclude(fileName, txt, allowReplace) {
            if (!txt || txt.length === 0) {
                console.error("shader include file err:" + fileName);
                return null;
            }
            if (!allowReplace && ShaderCompile.includes[fileName]) {
                console.warn("shader include file already exists:" + fileName);
                return ShaderCompile.includes[fileName];
            }
            txt = txt.replace(_clearCR, "");
            let file = new IncludeFile(txt);
            ShaderCompile.includes[fileName] = file;
            return file;
        }
        static compile(vs, ps, basePath) {
            let result = {
                vsNode: new ShaderNode([]),
                psNode: new ShaderNode([]),
                includeNames: new Set(),
                defs: new Set()
            };
            let includes = [];
            vs = vs.replace(_clearCR, "");
            ps = ps.replace(_clearCR, "");
            ShaderCompile._compileToTree(result.vsNode, vs, result.defs, includes, basePath);
            ShaderCompile._compileToTree(result.psNode, ps, result.defs, includes, basePath);
            for (let inc of includes) {
                if (inc.file)
                    result.includeNames.add(inc.name);
                else
                    console.warn(`ShaderCompile missing file ${inc.name}`);
            }
            return result;
        }
        static compileAsync(vs, ps, basePath) {
            let result = {
                vsNode: new ShaderNode([]),
                psNode: new ShaderNode([]),
                includeNames: new Set(),
                defs: new Set()
            };
            let includes = [];
            vs = vs.replace(_clearCR, "");
            ps = ps.replace(_clearCR, "");
            ShaderCompile._compileToTree(result.vsNode, vs, result.defs, includes, basePath);
            ShaderCompile._compileToTree(result.psNode, ps, result.defs, includes, basePath);
            return this._loadIncludesDeep(result, includes, 0);
        }
        static _loadIncludesDeep(result, includes, index) {
            let toLoad;
            let includesCnt = includes.length;
            for (let i = index; i < includesCnt; i++) {
                let inc = includes[i];
                if (inc.file)
                    result.includeNames.add(inc.name);
                else {
                    if (!toLoad)
                        toLoad = [];
                    toLoad.push(inc);
                }
            }
            if (!toLoad)
                return Promise.resolve(result);
            return ILaya.loader.load(toLoad.map(tc => tc.name)).then(files => {
                let cnt = toLoad.length;
                for (let i = 0; i < cnt; i++) {
                    let inc = toLoad[i];
                    let file = files[i];
                    if (!file) {
                        let childs = inc.node.parent.childs;
                        childs.splice(childs.indexOf(inc.node), 1);
                    }
                    else {
                        result.includeNames.add(inc.name);
                        let text = file.getWith(inc.codeName);
                        if (inc.node.condition)
                            inc.node.text = text;
                        else {
                            ShaderCompile._compileToTree(inc.node, text, result.defs, includes, URL.getPath(inc.name));
                            inc.node.text = "";
                        }
                    }
                }
                if (includes.length > includesCnt)
                    return ShaderCompile._loadIncludesDeep(result, includes, includesCnt);
                else
                    return result;
            });
        }
        static _compileToTree(parent, script, defs, includes, basePath) {
            let node, preNode;
            let text, name, fname;
            let ofs, words;
            let i, n, j;
            let lines = script.split("\n");
            for (i = 0; i < lines.length; i++) {
                text = lines[i];
                if (text.length < 1)
                    continue;
                ofs = text.indexOf("//");
                if (ofs === 0)
                    continue;
                if (ofs >= 0)
                    text = text.substr(0, ofs);
                if ((ofs = text.indexOf("#")) < 0) {
                    preNode = parent.childs[parent.childs.length - 1];
                    let includefiles = parent.includefiles;
                    if (preNode && !preNode.name) {
                        includefiles.length > 0 && IncludeFile.splitToWords(text, preNode);
                        preNode.text += "\n" + text;
                        continue;
                    }
                    node = new ShaderNode(includefiles);
                    node.text = text;
                    node.noCompile = true;
                    includefiles.length > 0 && IncludeFile.splitToWords(text, node);
                    node.setParent(parent);
                    continue;
                }
                node = new ShaderNode(parent.includefiles);
                node.text = text;
                node.noCompile = true;
                name = "#";
                for (j = ofs + 1, n = text.length; j < n; j++) {
                    let c = text.charAt(j);
                    if (c === ' ' || c === '\t' || c === '?')
                        break;
                    name += c;
                }
                node.name = name;
                switch (name) {
                    case "#ifdef":
                    case "#ifndef":
                        node.src = text;
                        node.noCompile = text.match(/[!&|()=<>]/) != null;
                        if (!node.noCompile) {
                            words = text.replace(/^\s*/, '').split(/\s+/);
                            node.setCondition(words[1], name === "#ifdef" ? ShaderCompile.IFDEF_YES : ShaderCompile.IFDEF_ELSE);
                            node.text = node.text;
                        }
                        else {
                            console.log("function():Boolean{return " + text.substr(ofs + node.name.length) + "}");
                        }
                        node.setParent(parent);
                        parent = node;
                        words = text.substr(j).split(_splitToWordExps3);
                        for (j = 0; j < words.length; j++) {
                            text = words[j];
                            text.length && defs.add(text);
                        }
                        break;
                    case "#if":
                    case "#elif":
                        node.src = text;
                        node.noCompile = true;
                        if (name == "#elif") {
                            parent = parent.parent;
                            preNode = parent.childs[parent.childs.length - 1];
                            preNode.text = preNode.src;
                            preNode.noCompile = true;
                            preNode.condition = null;
                        }
                        node.setParent(parent);
                        parent = node;
                        words = text.substr(j).split(_splitToWordExps3);
                        for (j = 0; j < words.length; j++) {
                            text = words[j];
                            text.length && text != "defined" && defs.add(text);
                        }
                        break;
                    case "#else":
                        node.src = text;
                        parent = parent.parent;
                        preNode = parent.childs[parent.childs.length - 1];
                        node.noCompile = preNode.noCompile;
                        if (!node.noCompile) {
                            node.condition = preNode.condition;
                            node.conditionType = preNode.conditionType == ShaderCompile.IFDEF_YES ? ShaderCompile.IFDEF_ELSE : ShaderCompile.IFDEF_YES;
                        }
                        node.setParent(parent);
                        parent = node;
                        break;
                    case "#endif":
                        parent = parent.parent;
                        preNode = parent.childs[parent.childs.length - 1];
                        node.noCompile = preNode.noCompile;
                        if (!node.noCompile) {
                            node.text = node.text;
                        }
                        node.setParent(parent);
                        break;
                    case "#include":
                        words = IncludeFile.splitToWords(text, null);
                        let includeName = words[1];
                        let includeFile;
                        if (includeName.startsWith("."))
                            includeName = URL.join(basePath, includeName);
                        else if (includeName.startsWith("/"))
                            includeName = URL.formatURL(includeName.substring(1));
                        else {
                            includeFile = ShaderCompile.includes[includeName];
                            if (!includeFile)
                                includeName = "internal/" + includeName;
                        }
                        includeFile = ShaderCompile.includes[includeName];
                        if (!includeFile && ShaderCompile.loadIncludeFileSync) {
                            ShaderCompile.loadIncludeFileSync(includeName);
                            includeFile = ShaderCompile.includes[includeName];
                        }
                        let codeName = words[2] == 'with' ? words[3] : null;
                        includes.push({ name: includeName, codeName: codeName, node: node, file: includeFile });
                        node.setParent(parent);
                        if ((ofs = words[0].indexOf("?")) < 0) {
                            if (includeFile) {
                                text = includeFile.getWith(codeName);
                                this._compileToTree(node, text, defs, includes, URL.getPath(includeName));
                            }
                            node.text = "";
                        }
                        else {
                            node.setCondition(words[0].substr(ofs + 1), ShaderCompile.IFDEF_YES);
                            if (includeFile)
                                node.text = includeFile.getWith(codeName);
                        }
                        break;
                    case "#import":
                        words = IncludeFile.splitToWords(text, null);
                        fname = words[1];
                        node.includefiles.push({ node: node, file: ShaderCompile.includes[fname], ofs: node.text.length });
                        break;
                    default:
                        node.setParent(parent);
                        break;
                }
            }
        }
        static getRenderState(obj, renderState) {
            if (!obj) {
                return;
            }
            renderState.cull = CullStateMap[obj.cull];
            renderState.blend = BlendStateMap[obj.blend];
            renderState.srcBlend = BlendFactorMap[obj.srcBlend];
            renderState.dstBlend = BlendFactorMap[obj.dstBlend];
            renderState.srcBlendRGB = BlendFactorMap[obj.srcBlendRGB];
            renderState.dstBlendRGB = BlendFactorMap[obj.dstBlendRGB];
            renderState.srcBlendAlpha = BlendFactorMap[obj.srcBlendAlpha];
            renderState.dstBlendAlpha = BlendFactorMap[obj.dstBlendAlpha];
            renderState.blendEquation = BlendEquationMap[obj.blendEquation];
            renderState.blendEquationRGB = BlendEquationMap[obj.blendEquationRGB];
            renderState.blendEquationAlpha = BlendEquationMap[obj.blendEquationAlpha];
            renderState.depthTest = CompareFunctionMap[obj.depthTest];
            renderState.depthWrite = obj.depthWrite;
            renderState.stencilRef = obj.stencilRef;
            renderState.stencilTest = CompareFunctionMap[obj.stencilTest];
            renderState.stencilWrite = obj.stencilWrite;
            renderState.stencilWriteMask = obj.stencilWriteMask;
            renderState.stencilReadMask = obj.stencilReadMask;
            let stencilOp = obj.stencilOp;
            let stencilFail = stencilOp ? stencilOp[0] : null;
            let stencilZFail = stencilOp ? stencilOp[1] : null;
            let stencilZPass = stencilOp ? stencilOp[2] : null;
            renderState.stencilOp.x = StencilOperationMap[stencilFail];
            renderState.stencilOp.y = StencilOperationMap[stencilZFail];
            renderState.stencilOp.z = StencilOperationMap[stencilZPass];
            renderState.depthBias = obj.depthBias;
            renderState.depthBiasConstant = obj.depthBiasConstant;
            renderState.depthBiasSlopeScale = obj.depthBiasSlopeScale;
            renderState.depthBiasClamp = obj.depthBiasClamp;
        }
    }
    ShaderCompile.IFDEF_NO = 0;
    ShaderCompile.IFDEF_YES = 1;
    ShaderCompile.IFDEF_ELSE = 2;
    ShaderCompile.IFDEF_PARENT = 3;
    ShaderCompile.includes = {};

    const _DEFAULTELEMENTS = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    class Matrix3x3 {
        static createRotationQuaternion(rotation, out) {
            var rotX = rotation.x;
            var rotY = rotation.y;
            var rotZ = rotation.z;
            var rotW = rotation.w;
            var xx = rotX * rotX;
            var yy = rotY * rotY;
            var zz = rotZ * rotZ;
            var xy = rotX * rotY;
            var zw = rotZ * rotW;
            var zx = rotZ * rotX;
            var yw = rotY * rotW;
            var yz = rotY * rotZ;
            var xw = rotX * rotW;
            var resultE = out.elements;
            resultE[0] = 1.0 - (2.0 * (yy + zz));
            resultE[1] = 2.0 * (xy + zw);
            resultE[2] = 2.0 * (zx - yw);
            resultE[3] = 2.0 * (xy - zw);
            resultE[4] = 1.0 - (2.0 * (zz + xx));
            resultE[5] = 2.0 * (yz + xw);
            resultE[6] = 2.0 * (zx + yw);
            resultE[7] = 2.0 * (yz - xw);
            resultE[8] = 1.0 - (2.0 * (yy + xx));
        }
        static createFromTranslation(trans, out) {
            var e = out.elements;
            e[0] = 1;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = 1;
            e[5] = 0;
            e[6] = trans.x;
            e[7] = trans.y;
            e[8] = 1;
        }
        static createMatrixFromValue(pos, rotate, scale = Vector2.ONE, out) {
            var e = out.elements;
            var s = Math.sin(rotate), c = Math.cos(rotate);
            e[0] = c * scale.x;
            e[1] = s * scale.x;
            e[2] = 0;
            e[3] = -s * scale.y;
            e[4] = c * scale.y;
            e[5] = 0;
            e[6] = pos.x;
            e[7] = pos.y;
            e[8] = 1;
        }
        static createFromRotation(rad, out) {
            var e = out.elements;
            var s = Math.sin(rad), c = Math.cos(rad);
            e[0] = c;
            e[1] = s;
            e[2] = 0;
            e[3] = -s;
            e[4] = c;
            e[5] = 0;
            e[6] = 0;
            e[7] = 0;
            e[8] = 1;
        }
        static createFromScaling(scale, out) {
            var e = out.elements;
            e[0] = scale.x;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = scale.y;
            e[5] = 0;
            e[6] = 0;
            e[7] = 0;
            e[8] = scale.z;
        }
        static createFromMatrix4x4(sou, out) {
            var souE = sou.elements;
            var outE = out.elements;
            outE[0] = souE[0];
            outE[1] = souE[1];
            outE[2] = souE[2];
            outE[3] = souE[4];
            outE[4] = souE[5];
            outE[5] = souE[6];
            outE[6] = souE[8];
            outE[7] = souE[9];
            outE[8] = souE[10];
        }
        static multiply(left, right, out) {
            var l = left.elements;
            var r = right.elements;
            var e = out.elements;
            var l11 = l[0], l12 = l[1], l13 = l[2];
            var l21 = l[3], l22 = l[4], l23 = l[5];
            var l31 = l[6], l32 = l[7], l33 = l[8];
            var r11 = r[0], r12 = r[1], r13 = r[2];
            var r21 = r[3], r22 = r[4], r23 = r[5];
            var r31 = r[6], r32 = r[7], r33 = r[8];
            e[0] = r11 * l11 + r12 * l21 + r13 * l31;
            e[1] = r11 * l12 + r12 * l22 + r13 * r32;
            e[2] = r11 * l13 + r12 * l23 + r13 * l33;
            e[3] = r21 * l11 + r22 * l21 + r23 * l31;
            e[4] = r21 * l12 + r22 * l22 + r23 * l32;
            e[5] = r21 * l13 + r22 * l23 + r23 * l33;
            e[6] = r31 * l11 + r32 * l21 + r33 * l31;
            e[7] = r31 * l12 + r32 * l22 + r33 * l32;
            e[8] = r31 * l13 + r32 * l23 + r33 * l33;
        }
        constructor(createElement = true) {
            createElement && (this.elements = _DEFAULTELEMENTS.slice());
        }
        cloneByArray(destObject) {
            this.elements.set(destObject);
        }
        determinant() {
            var f = this.elements;
            var a00 = f[0], a01 = f[1], a02 = f[2];
            var a10 = f[3], a11 = f[4], a12 = f[5];
            var a20 = f[6], a21 = f[7], a22 = f[8];
            return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        }
        translate(trans, out) {
            var e = out.elements;
            var f = this.elements;
            var a00 = f[0], a01 = f[1], a02 = f[2];
            var a10 = f[3], a11 = f[4], a12 = f[5];
            var a20 = f[6], a21 = f[7], a22 = f[8];
            var x = trans.x, y = trans.y;
            e[0] = a00;
            e[1] = a01;
            e[2] = a02;
            e[3] = a10;
            e[4] = a11;
            e[5] = a12;
            e[6] = x * a00 + y * a10 + a20;
            e[7] = x * a01 + y * a11 + a21;
            e[8] = x * a02 + y * a12 + a22;
        }
        rotate(rad, out) {
            var e = out.elements;
            var f = this.elements;
            var a00 = f[0], a01 = f[1], a02 = f[2];
            var a10 = f[3], a11 = f[4], a12 = f[5];
            var a20 = f[6], a21 = f[7], a22 = f[8];
            var s = Math.sin(rad);
            var c = Math.cos(rad);
            e[0] = c * a00 + s * a10;
            e[1] = c * a01 + s * a11;
            e[2] = c * a02 + s * a12;
            e[3] = c * a10 - s * a00;
            e[4] = c * a11 - s * a01;
            e[5] = c * a12 - s * a02;
            e[6] = a20;
            e[7] = a21;
            e[8] = a22;
        }
        scale(scale, out) {
            var e = out.elements;
            var f = this.elements;
            var x = scale.x, y = scale.y;
            e[0] = x * f[0];
            e[1] = x * f[1];
            e[2] = x * f[2];
            e[3] = y * f[3];
            e[4] = y * f[4];
            e[5] = y * f[5];
            e[6] = f[6];
            e[7] = f[7];
            e[8] = f[8];
        }
        invert(out) {
            var e = out.elements;
            var f = this.elements;
            var a00 = f[0], a01 = f[1], a02 = f[2];
            var a10 = f[3], a11 = f[4], a12 = f[5];
            var a20 = f[6], a21 = f[7], a22 = f[8];
            var b01 = a22 * a11 - a12 * a21;
            var b11 = -a22 * a10 + a12 * a20;
            var b21 = a21 * a10 - a11 * a20;
            var det = a00 * b01 + a01 * b11 + a02 * b21;
            if (!det) {
                return;
            }
            det = 1.0 / det;
            e[0] = b01 * det;
            e[1] = (-a22 * a01 + a02 * a21) * det;
            e[2] = (a12 * a01 - a02 * a11) * det;
            e[3] = b11 * det;
            e[4] = (a22 * a00 - a02 * a20) * det;
            e[5] = (-a12 * a00 + a02 * a10) * det;
            e[6] = b21 * det;
            e[7] = (-a21 * a00 + a01 * a20) * det;
            e[8] = (a11 * a00 - a01 * a10) * det;
        }
        transpose(out) {
            var e = out.elements;
            var f = this.elements;
            if (out === this) {
                var a01 = f[1], a02 = f[2], a12 = f[5];
                e[1] = f[3];
                e[2] = f[6];
                e[3] = a01;
                e[5] = f[7];
                e[6] = a02;
                e[7] = a12;
            }
            else {
                e[0] = f[0];
                e[1] = f[3];
                e[2] = f[6];
                e[3] = f[1];
                e[4] = f[4];
                e[5] = f[7];
                e[6] = f[2];
                e[7] = f[5];
                e[8] = f[8];
            }
        }
        identity() {
            this.elements.set(_DEFAULTELEMENTS);
        }
        cloneTo(destObject) {
            var s, d;
            s = this.elements;
            d = destObject.elements;
            if (s === d) {
                return;
            }
            d.set(s);
        }
        clone() {
            var dest = new Matrix3x3(false);
            dest.elements = this.elements.slice();
            return dest;
        }
        static lookAt(eye, target, up, out) {
            Vector3.subtract(eye, target, _tempV30);
            Vector3.normalize(_tempV30, _tempV30);
            Vector3.cross(up, _tempV30, _tempV31);
            Vector3.normalize(_tempV31, _tempV31);
            Vector3.cross(_tempV30, _tempV31, _tempV32);
            var v0 = _tempV30;
            var v1 = _tempV31;
            var v2 = _tempV32;
            var me = out.elements;
            me[0] = v1.x;
            me[3] = v1.y;
            me[6] = v1.z;
            me[1] = v2.x;
            me[4] = v2.y;
            me[7] = v2.z;
            me[2] = v0.x;
            me[5] = v0.y;
            me[8] = v0.z;
        }
        static forwardLookAt(eye, target, up, out) {
            var vx = _tempV31;
            var vy = _tempV32;
            var vz = _tempV30;
            target.vsub(eye, vz).normalize();
            up.cross(vz, vx).normalize();
            vz.cross(vx, vy);
            var m = out.elements;
            m[0] = vx.x;
            m[1] = vx.y;
            m[2] = vx.z;
            m[3] = vy.x;
            m[4] = vy.y;
            m[5] = vy.z;
            m[6] = vz.x;
            m[7] = vz.y;
            m[8] = vz.z;
        }
    }
    Matrix3x3.DEFAULT = new Matrix3x3();
    Matrix3x3.TEMP = new Matrix3x3();
    const _tempV30 = new Vector3();
    const _tempV31 = new Vector3();
    const _tempV32 = new Vector3();

    class Quaternion {
        static createFromYawPitchRoll(yaw, pitch, roll, out) {
            var halfRoll = roll * 0.5;
            var halfPitch = pitch * 0.5;
            var halfYaw = yaw * 0.5;
            var sinRoll = Math.sin(halfRoll);
            var cosRoll = Math.cos(halfRoll);
            var sinPitch = Math.sin(halfPitch);
            var cosPitch = Math.cos(halfPitch);
            var sinYaw = Math.sin(halfYaw);
            var cosYaw = Math.cos(halfYaw);
            out.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);
            out.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);
            out.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);
            out.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);
        }
        static multiply(left, right, out) {
            var lx = left.x;
            var ly = left.y;
            var lz = left.z;
            var lw = left.w;
            var rx = right.x;
            var ry = right.y;
            var rz = right.z;
            var rw = right.w;
            var a = (ly * rz - lz * ry);
            var b = (lz * rx - lx * rz);
            var c = (lx * ry - ly * rx);
            var d = (lx * rx + ly * ry + lz * rz);
            out.x = (lx * rw + rx * lw) + a;
            out.y = (ly * rw + ry * lw) + b;
            out.z = (lz * rw + rz * lw) + c;
            out.w = lw * rw - d;
        }
        static rotationAxisAngle(axis, rad, out) {
            const normalAxis = Vector3.TEMP;
            Vector3.normalize(axis, normalAxis);
            rad *= 0.5;
            const s = Math.sin(rad);
            out.x = normalAxis.x * s;
            out.y = normalAxis.y * s;
            out.z = normalAxis.z * s;
            out.w = Math.cos(rad);
        }
        static arcTanAngle(x, y) {
            if (x == 0) {
                if (y == 1)
                    return Math.PI / 2;
                return -Math.PI / 2;
            }
            if (x > 0)
                return Math.atan(y / x);
            if (x < 0) {
                if (y > 0)
                    return Math.atan(y / x) + Math.PI;
                return Math.atan(y / x) - Math.PI;
            }
            return 0;
        }
        static angleTo(from, location, angle) {
            Vector3.subtract(location, from, TEMPVector30);
            Vector3.normalize(TEMPVector30, TEMPVector30);
            angle.x = Math.asin(TEMPVector30.y);
            angle.y = Quaternion.arcTanAngle(-TEMPVector30.z, -TEMPVector30.x);
        }
        static createFromAxisAngle(axis, rad, out) {
            rad = rad * 0.5;
            var s = Math.sin(rad);
            out.x = s * axis.x;
            out.y = s * axis.y;
            out.z = s * axis.z;
            out.w = Math.cos(rad);
        }
        static createFromMatrix4x4(mat, out) {
            var me = mat.elements;
            var sqrt;
            var half;
            var scale = me[0] + me[5] + me[10];
            if (scale > 0.0) {
                sqrt = Math.sqrt(scale + 1.0);
                out.w = sqrt * 0.5;
                sqrt = 0.5 / sqrt;
                out.x = (me[6] - me[9]) * sqrt;
                out.y = (me[8] - me[2]) * sqrt;
                out.z = (me[1] - me[4]) * sqrt;
            }
            else if ((me[0] >= me[5]) && (me[0] >= me[10])) {
                sqrt = Math.sqrt(1.0 + me[0] - me[5] - me[10]);
                half = 0.5 / sqrt;
                out.x = 0.5 * sqrt;
                out.y = (me[1] + me[4]) * half;
                out.z = (me[2] + me[8]) * half;
                out.w = (me[6] - me[9]) * half;
            }
            else if (me[5] > me[10]) {
                sqrt = Math.sqrt(1.0 + me[5] - me[0] - me[10]);
                half = 0.5 / sqrt;
                out.x = (me[4] + me[1]) * half;
                out.y = 0.5 * sqrt;
                out.z = (me[9] + me[6]) * half;
                out.w = (me[8] - me[2]) * half;
            }
            else {
                sqrt = Math.sqrt(1.0 + me[10] - me[0] - me[5]);
                half = 0.5 / sqrt;
                out.x = (me[8] + me[2]) * half;
                out.y = (me[9] + me[6]) * half;
                out.z = 0.5 * sqrt;
                out.w = (me[1] - me[4]) * half;
            }
        }
        static slerp(left, right, t, out) {
            var ax = left.x, ay = left.y, az = left.z, aw = left.w, bx = right.x, by = right.y, bz = right.z, bw = right.w;
            var omega, cosom, sinom, scale0, scale1;
            cosom = ax * bx + ay * by + az * bz + aw * bw;
            if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
            }
            if ((1.0 - cosom) > 0.000001) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            }
            else {
                scale0 = 1.0 - t;
                scale1 = t;
            }
            out.x = scale0 * ax + scale1 * bx;
            out.y = scale0 * ay + scale1 * by;
            out.z = scale0 * az + scale1 * bz;
            out.w = scale0 * aw + scale1 * bw;
            return out;
        }
        static lerp(left, right, amount, out) {
            var inverse = 1.0 - amount;
            if (Quaternion.dot(left, right) >= 0) {
                out.x = (inverse * left.x) + (amount * right.x);
                out.y = (inverse * left.y) + (amount * right.y);
                out.z = (inverse * left.z) + (amount * right.z);
                out.w = (inverse * left.w) + (amount * right.w);
            }
            else {
                out.x = (inverse * left.x) - (amount * right.x);
                out.y = (inverse * left.y) - (amount * right.y);
                out.z = (inverse * left.z) - (amount * right.z);
                out.w = (inverse * left.w) - (amount * right.w);
            }
            out.normalize(out);
        }
        static add(left, right, out) {
            out.x = left.x + right.x;
            out.y = left.y + right.y;
            out.z = left.z + right.z;
            out.w = left.w + right.w;
        }
        static dot(left, right) {
            return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
        }
        constructor(x = 0, y = 0, z = 0, w = 1) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        setValue(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        set(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        }
        scaling(scaling, out) {
            out.x = this.x * scaling;
            out.y = this.y * scaling;
            out.z = this.z * scaling;
            out.w = this.w * scaling;
        }
        normalize(out) {
            var len = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out.x = this.x * len;
                out.y = this.y * len;
                out.z = this.z * len;
                out.w = this.w * len;
            }
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        rotateX(rad, out) {
            rad *= 0.5;
            var bx = Math.sin(rad), bw = Math.cos(rad);
            out.x = this.x * bw + this.w * bx;
            out.y = this.y * bw + this.z * bx;
            out.z = this.z * bw - this.y * bx;
            out.w = this.w * bw - this.x * bx;
        }
        rotateY(rad, out) {
            rad *= 0.5;
            var by = Math.sin(rad), bw = Math.cos(rad);
            out.x = this.x * bw - this.z * by;
            out.y = this.y * bw + this.w * by;
            out.z = this.z * bw + this.x * by;
            out.w = this.w * bw - this.y * by;
        }
        rotateZ(rad, out) {
            rad *= 0.5;
            var bz = Math.sin(rad), bw = Math.cos(rad);
            out.x = this.x * bw + this.y * bz;
            out.y = this.y * bw - this.x * bz;
            out.z = this.z * bw + this.w * bz;
            out.w = this.w * bw - this.z * bz;
        }
        getYawPitchRoll(out) {
            Vector3.transformQuat(Vector3.ForwardRH, this, TEMPVector31);
            let upe = TEMPVector32;
            let angle = TEMPVector33;
            Vector3.transformQuat(Vector3.Up, this, upe);
            Quaternion.angleTo(Vector3.ZERO, TEMPVector31, angle);
            if (angle.x == Math.PI / 2) {
                angle.y = Quaternion.arcTanAngle(upe.z, upe.x);
                angle.z = 0;
            }
            else if (angle.x == -Math.PI / 2) {
                angle.y = Quaternion.arcTanAngle(-upe.z, -upe.x);
                angle.z = 0;
            }
            else {
                Matrix4x4.createRotationY(-angle.y, Matrix4x4.TEMP);
                Vector3.transformCoordinate(upe, Matrix4x4.TEMP, upe);
                Matrix4x4.createRotationX(-angle.x, Matrix4x4.TEMP);
                Vector3.transformCoordinate(upe, Matrix4x4.TEMP, upe);
                angle.z = Quaternion.arcTanAngle(upe.y, -upe.x);
            }
            if (angle.y <= -Math.PI)
                angle.y = Math.PI;
            if (angle.z <= -Math.PI)
                angle.z = Math.PI;
            if (angle.y >= Math.PI && angle.z >= Math.PI) {
                angle.y = 0;
                angle.z = 0;
                angle.x = Math.PI - angle.x;
            }
            var oe = out;
            oe.x = angle.y;
            oe.y = angle.x;
            oe.z = angle.z;
        }
        invert(out) {
            var a0 = this.x, a1 = this.y, a2 = this.z, a3 = this.w;
            var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
            var invDot = dot ? 1.0 / dot : 0;
            out.x = -a0 * invDot;
            out.y = -a1 * invDot;
            out.z = -a2 * invDot;
            out.w = a3 * invDot;
        }
        identity() {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1;
        }
        fromArray(array, offset = 0) {
            this.x = array[offset + 0];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            this.w = array[offset + 3];
        }
        cloneTo(destObject) {
            if (this === destObject) {
                return;
            }
            destObject.x = this.x;
            destObject.y = this.y;
            destObject.z = this.z;
            destObject.w = this.w;
        }
        clone() {
            var dest = new Quaternion();
            this.cloneTo(dest);
            return dest;
        }
        equals(b) {
            return MathUtils3D.nearEqual(this.x, b.x) && MathUtils3D.nearEqual(this.y, b.y) && MathUtils3D.nearEqual(this.z, b.z) && MathUtils3D.nearEqual(this.w, b.w);
        }
        static rotationLookAt(forward, up, out) {
            Quaternion.lookAt(Vector3.ZERO, forward, up, out);
        }
        static lookAt(eye, target, up, out) {
            Matrix3x3.lookAt(eye, target, up, Matrix3x3.TEMP);
            Quaternion.rotationMatrix(Matrix3x3.TEMP, out);
        }
        static forwardLookAt(eye, target, up, out) {
            Matrix3x3.forwardLookAt(eye, target, up, Matrix3x3.TEMP);
            Quaternion.rotationMatrix(Matrix3x3.TEMP, out);
        }
        lengthSquared() {
            return (this.x * this.x) + (this.y * this.y) + (this.z * this.z) + (this.w * this.w);
        }
        static invert(value, out) {
            var lengthSq = value.lengthSquared();
            if (!MathUtils3D.isZero(lengthSq)) {
                lengthSq = 1.0 / lengthSq;
                out.x = -value.x * lengthSq;
                out.y = -value.y * lengthSq;
                out.z = -value.z * lengthSq;
                out.w = value.w * lengthSq;
            }
        }
        static rotationMatrix(matrix3x3, out) {
            var me = matrix3x3.elements;
            var m11 = me[0];
            var m12 = me[1];
            var m13 = me[2];
            var m21 = me[3];
            var m22 = me[4];
            var m23 = me[5];
            var m31 = me[6];
            var m32 = me[7];
            var m33 = me[8];
            var sqrt, half;
            var scale = m11 + m22 + m33;
            if (scale > 0) {
                sqrt = Math.sqrt(scale + 1);
                out.w = sqrt * 0.5;
                sqrt = 0.5 / sqrt;
                out.x = (m23 - m32) * sqrt;
                out.y = (m31 - m13) * sqrt;
                out.z = (m12 - m21) * sqrt;
            }
            else if ((m11 >= m22) && (m11 >= m33)) {
                sqrt = Math.sqrt(1 + m11 - m22 - m33);
                half = 0.5 / sqrt;
                out.x = 0.5 * sqrt;
                out.y = (m12 + m21) * half;
                out.z = (m13 + m31) * half;
                out.w = (m23 - m32) * half;
            }
            else if (m22 > m33) {
                sqrt = Math.sqrt(1 + m22 - m11 - m33);
                half = 0.5 / sqrt;
                out.x = (m21 + m12) * half;
                out.y = 0.5 * sqrt;
                out.z = (m32 + m23) * half;
                out.w = (m31 - m13) * half;
            }
            else {
                sqrt = Math.sqrt(1 + m33 - m11 - m22);
                half = 0.5 / sqrt;
                out.x = (m31 + m13) * half;
                out.y = (m32 + m23) * half;
                out.z = 0.5 * sqrt;
                out.w = (m12 - m21) * half;
            }
        }
    }
    Quaternion.TEMP = new Quaternion();
    Quaternion.DEFAULT = new Quaternion();
    Quaternion.NAN = new Quaternion(NaN, NaN, NaN, NaN);
    const TEMPVector30 = new Vector3();
    const TEMPVector31 = new Vector3();
    const TEMPVector32 = new Vector3();
    const TEMPVector33 = new Vector3();

    const DEFAULTARRAY = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    class Matrix4x4 {
        static createRotationX(rad, out) {
            var oe = out.elements;
            var s = Math.sin(rad), c = Math.cos(rad);
            oe[1] = oe[2] = oe[3] = oe[4] = oe[7] = oe[8] = oe[11] = oe[12] = oe[13] = oe[14] = 0;
            oe[0] = oe[15] = 1;
            oe[5] = oe[10] = c;
            oe[6] = s;
            oe[9] = -s;
        }
        static createRotationY(rad, out) {
            var oe = out.elements;
            var s = Math.sin(rad), c = Math.cos(rad);
            oe[1] = oe[3] = oe[4] = oe[6] = oe[7] = oe[9] = oe[11] = oe[12] = oe[13] = oe[14] = 0;
            oe[5] = oe[15] = 1;
            oe[0] = oe[10] = c;
            oe[2] = -s;
            oe[8] = s;
        }
        static createRotationZ(rad, out) {
            var oe = out.elements;
            var s = Math.sin(rad), c = Math.cos(rad);
            oe[2] = oe[3] = oe[6] = oe[7] = oe[8] = oe[9] = oe[11] = oe[12] = oe[13] = oe[14] = 0;
            oe[10] = oe[15] = 1;
            oe[0] = oe[5] = c;
            oe[1] = s;
            oe[4] = -s;
        }
        static createRotationYawPitchRoll(yaw, pitch, roll, result) {
            Quaternion.createFromYawPitchRoll(yaw, pitch, roll, Quaternion.TEMP);
            Matrix4x4.createRotationQuaternion(Quaternion.TEMP, result);
        }
        static createRotationAxis(axis, angle, result) {
            var x = axis.x;
            var y = axis.y;
            var z = axis.z;
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var xx = x * x;
            var yy = y * y;
            var zz = z * z;
            var xy = x * y;
            var xz = x * z;
            var yz = y * z;
            var resultE = result.elements;
            resultE[3] = resultE[7] = resultE[11] = resultE[12] = resultE[13] = resultE[14] = 0;
            resultE[15] = 1.0;
            resultE[0] = xx + (cos * (1.0 - xx));
            resultE[1] = (xy - (cos * xy)) + (sin * z);
            resultE[2] = (xz - (cos * xz)) - (sin * y);
            resultE[4] = (xy - (cos * xy)) - (sin * z);
            resultE[5] = yy + (cos * (1.0 - yy));
            resultE[6] = (yz - (cos * yz)) + (sin * x);
            resultE[8] = (xz - (cos * xz)) + (sin * y);
            resultE[9] = (yz - (cos * yz)) - (sin * x);
            resultE[10] = zz + (cos * (1.0 - zz));
        }
        static createRotationQuaternion(rotation, result) {
            var resultE = result.elements;
            var rotationX = rotation.x;
            var rotationY = rotation.y;
            var rotationZ = rotation.z;
            var rotationW = rotation.w;
            var xx = rotationX * rotationX;
            var yy = rotationY * rotationY;
            var zz = rotationZ * rotationZ;
            var xy = rotationX * rotationY;
            var zw = rotationZ * rotationW;
            var zx = rotationZ * rotationX;
            var yw = rotationY * rotationW;
            var yz = rotationY * rotationZ;
            var xw = rotationX * rotationW;
            resultE[3] = resultE[7] = resultE[11] = resultE[12] = resultE[13] = resultE[14] = 0;
            resultE[15] = 1.0;
            resultE[0] = 1.0 - (2.0 * (yy + zz));
            resultE[1] = 2.0 * (xy + zw);
            resultE[2] = 2.0 * (zx - yw);
            resultE[4] = 2.0 * (xy - zw);
            resultE[5] = 1.0 - (2.0 * (zz + xx));
            resultE[6] = 2.0 * (yz + xw);
            resultE[8] = 2.0 * (zx + yw);
            resultE[9] = 2.0 * (yz - xw);
            resultE[10] = 1.0 - (2.0 * (yy + xx));
        }
        static createTranslate(trans, out) {
            var oe = out.elements;
            oe[4] = oe[8] = oe[1] = oe[9] = oe[2] = oe[6] = oe[3] = oe[7] = oe[11] = 0;
            oe[0] = oe[5] = oe[10] = oe[15] = 1;
            oe[12] = trans.x;
            oe[13] = trans.y;
            oe[14] = trans.z;
        }
        static createScaling(scale, out) {
            var oe = out.elements;
            oe[0] = scale.x;
            oe[5] = scale.y;
            oe[10] = scale.z;
            oe[1] = oe[4] = oe[8] = oe[12] = oe[9] = oe[13] = oe[2] = oe[6] = oe[14] = oe[3] = oe[7] = oe[11] = 0;
            oe[15] = 1;
        }
        static multiply(left, right, out) {
            var l = right.elements;
            var r = left.elements;
            var e = out.elements;
            var l11 = l[0], l12 = l[1], l13 = l[2], l14 = l[3];
            var l21 = l[4], l22 = l[5], l23 = l[6], l24 = l[7];
            var l31 = l[8], l32 = l[9], l33 = l[10], l34 = l[11];
            var l41 = l[12], l42 = l[13], l43 = l[14], l44 = l[15];
            var r11 = r[0], r12 = r[1], r13 = r[2], r14 = r[3];
            var r21 = r[4], r22 = r[5], r23 = r[6], r24 = r[7];
            var r31 = r[8], r32 = r[9], r33 = r[10], r34 = r[11];
            var r41 = r[12], r42 = r[13], r43 = r[14], r44 = r[15];
            e[0] = (l11 * r11) + (l12 * r21) + (l13 * r31) + (l14 * r41);
            e[1] = (l11 * r12) + (l12 * r22) + (l13 * r32) + (l14 * r42);
            e[2] = (l11 * r13) + (l12 * r23) + (l13 * r33) + (l14 * r43);
            e[3] = (l11 * r14) + (l12 * r24) + (l13 * r34) + (l14 * r44);
            e[4] = (l21 * r11) + (l22 * r21) + (l23 * r31) + (l24 * r41);
            e[5] = (l21 * r12) + (l22 * r22) + (l23 * r32) + (l24 * r42);
            e[6] = (l21 * r13) + (l22 * r23) + (l23 * r33) + (l24 * r43);
            e[7] = (l21 * r14) + (l22 * r24) + (l23 * r34) + (l24 * r44);
            e[8] = (l31 * r11) + (l32 * r21) + (l33 * r31) + (l34 * r41);
            e[9] = (l31 * r12) + (l32 * r22) + (l33 * r32) + (l34 * r42);
            e[10] = (l31 * r13) + (l32 * r23) + (l33 * r33) + (l34 * r43);
            e[11] = (l31 * r14) + (l32 * r24) + (l33 * r34) + (l34 * r44);
            e[12] = (l41 * r11) + (l42 * r21) + (l43 * r31) + (l44 * r41);
            e[13] = (l41 * r12) + (l42 * r22) + (l43 * r32) + (l44 * r42);
            e[14] = (l41 * r13) + (l42 * r23) + (l43 * r33) + (l44 * r43);
            e[15] = (l41 * r14) + (l42 * r24) + (l43 * r34) + (l44 * r44);
        }
        static createFromQuaternion(rotation, out) {
            var e = out.elements;
            var x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w;
            var x2 = x + x;
            var y2 = y + y;
            var z2 = z + z;
            var xx = x * x2;
            var yx = y * x2;
            var yy = y * y2;
            var zx = z * x2;
            var zy = z * y2;
            var zz = z * z2;
            var wx = w * x2;
            var wy = w * y2;
            var wz = w * z2;
            e[0] = 1 - yy - zz;
            e[1] = yx + wz;
            e[2] = zx - wy;
            e[3] = 0;
            e[4] = yx - wz;
            e[5] = 1 - xx - zz;
            e[6] = zy + wx;
            e[7] = 0;
            e[8] = zx + wy;
            e[9] = zy - wx;
            e[10] = 1 - xx - yy;
            e[11] = 0;
            e[12] = 0;
            e[13] = 0;
            e[14] = 0;
            e[15] = 1;
        }
        static createAffineTransformation(trans, rot, scale, out) {
            var oe = out.elements;
            var x = rot.x, y = rot.y, z = rot.z, w = rot.w, x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2, sx = scale.x, sy = scale.y, sz = scale.z;
            oe[0] = (1 - (yy + zz)) * sx;
            oe[1] = (xy + wz) * sx;
            oe[2] = (xz - wy) * sx;
            oe[3] = 0;
            oe[4] = (xy - wz) * sy;
            oe[5] = (1 - (xx + zz)) * sy;
            oe[6] = (yz + wx) * sy;
            oe[7] = 0;
            oe[8] = (xz + wy) * sz;
            oe[9] = (yz - wx) * sz;
            oe[10] = (1 - (xx + yy)) * sz;
            oe[11] = 0;
            oe[12] = trans.x;
            oe[13] = trans.y;
            oe[14] = trans.z;
            oe[15] = 1;
        }
        static createLookAt(eye, target, up, out) {
            var oE = out.elements;
            var xaxis = _tempVector0;
            var yaxis = _tempVector1;
            var zaxis = _tempVector2;
            Vector3.subtract(eye, target, zaxis);
            Vector3.normalize(zaxis, zaxis);
            Vector3.cross(up, zaxis, xaxis);
            Vector3.normalize(xaxis, xaxis);
            Vector3.cross(zaxis, xaxis, yaxis);
            oE[3] = oE[7] = oE[11] = 0;
            oE[15] = 1;
            oE[0] = xaxis.x;
            oE[4] = xaxis.y;
            oE[8] = xaxis.z;
            oE[1] = yaxis.x;
            oE[5] = yaxis.y;
            oE[9] = yaxis.z;
            oE[2] = zaxis.x;
            oE[6] = zaxis.y;
            oE[10] = zaxis.z;
            oE[12] = -Vector3.dot(xaxis, eye);
            oE[13] = -Vector3.dot(yaxis, eye);
            oE[14] = -Vector3.dot(zaxis, eye);
        }
        static createPerspective(fov, aspect, znear, zfar, out) {
            var yScale = 1.0 / Math.tan(fov * 0.5);
            var xScale = yScale / aspect;
            var halfWidth = znear / xScale;
            var halfHeight = znear / yScale;
            Matrix4x4.createPerspectiveOffCenter(-halfWidth, halfWidth, -halfHeight, halfHeight, znear, zfar, out);
        }
        static createPerspectiveOffCenter(left, right, bottom, top, znear, zfar, out) {
            var oe = out.elements;
            var zRange = zfar / (zfar - znear);
            oe[1] = oe[2] = oe[3] = oe[4] = oe[6] = oe[7] = oe[12] = oe[13] = oe[15] = 0;
            oe[0] = 2.0 * znear / (right - left);
            oe[5] = 2.0 * znear / (top - bottom);
            oe[8] = (left + right) / (right - left);
            oe[9] = (top + bottom) / (top - bottom);
            oe[10] = -zRange;
            oe[11] = -1.0;
            oe[14] = -znear * zRange;
        }
        static createOrthoOffCenter(left, right, bottom, top, znear, zfar, out) {
            var oe = out.elements;
            var zRange = 1.0 / (zfar - znear);
            oe[1] = oe[2] = oe[3] = oe[4] = oe[6] = oe[8] = oe[7] = oe[9] = oe[11] = 0;
            oe[15] = 1;
            oe[0] = 2.0 / (right - left);
            oe[5] = 2.0 / (top - bottom);
            oe[10] = -zRange;
            oe[12] = (left + right) / (left - right);
            oe[13] = (top + bottom) / (bottom - top);
            oe[14] = -znear * zRange;
        }
        constructor(m11 = 1, m12 = 0, m13 = 0, m14 = 0, m21 = 0, m22 = 1, m23 = 0, m24 = 0, m31 = 0, m32 = 0, m33 = 1, m34 = 0, m41 = 0, m42 = 0, m43 = 0, m44 = 1, elements = null) {
            if (arguments.length == 0) {
                this.elements = DEFAULTARRAY.slice();
                return;
            }
            if (arguments.length === 1 && arguments[0] === null)
                return;
            var e = elements ? this.elements = elements : this.elements = new Float32Array(16);
            e[0] = m11;
            e[1] = m12;
            e[2] = m13;
            e[3] = m14;
            e[4] = m21;
            e[5] = m22;
            e[6] = m23;
            e[7] = m24;
            e[8] = m31;
            e[9] = m32;
            e[10] = m33;
            e[11] = m34;
            e[12] = m41;
            e[13] = m42;
            e[14] = m43;
            e[15] = m44;
        }
        getElementByRowColumn(row, column) {
            if (row < 0 || row > 3)
                throw new Error("row for matrices run from 0 to 3, inclusive.");
            if (column < 0 || column > 3)
                throw new Error("column for matrices run from 0 to 3, inclusive.");
            return this.elements[(row * 4) + column];
        }
        setElementByRowColumn(row, column, value) {
            if (row < 0 || row > 3)
                throw new Error("row for matrices run from 0 to 3, inclusive.");
            if (column < 0 || column > 3)
                throw new Error("column for matrices run from 0 to 3, inclusive.");
            this.elements[(row * 4) + column] = value;
        }
        setRotation(rotation) {
            var rotationX = rotation.x;
            var rotationY = rotation.y;
            var rotationZ = rotation.z;
            var rotationW = rotation.w;
            var xx = rotationX * rotationX;
            var yy = rotationY * rotationY;
            var zz = rotationZ * rotationZ;
            var xy = rotationX * rotationY;
            var zw = rotationZ * rotationW;
            var zx = rotationZ * rotationX;
            var yw = rotationY * rotationW;
            var yz = rotationY * rotationZ;
            var xw = rotationX * rotationW;
            var e = this.elements;
            e[0] = 1.0 - (2.0 * (yy + zz));
            e[1] = 2.0 * (xy + zw);
            e[2] = 2.0 * (zx - yw);
            e[4] = 2.0 * (xy - zw);
            e[5] = 1.0 - (2.0 * (zz + xx));
            e[6] = 2.0 * (yz + xw);
            e[8] = 2.0 * (zx + yw);
            e[9] = 2.0 * (yz - xw);
            e[10] = 1.0 - (2.0 * (yy + xx));
        }
        setPosition(position) {
            var e = this.elements;
            e[12] = position.x;
            e[13] = position.y;
            e[14] = position.z;
        }
        equalsOtherMatrix(other) {
            var e = this.elements;
            var oe = other.elements;
            return (MathUtils3D.nearEqual(e[0], oe[0]) && MathUtils3D.nearEqual(e[1], oe[1]) && MathUtils3D.nearEqual(e[2], oe[2]) && MathUtils3D.nearEqual(e[3], oe[3]) && MathUtils3D.nearEqual(e[4], oe[4]) && MathUtils3D.nearEqual(e[5], oe[5]) && MathUtils3D.nearEqual(e[6], oe[6]) && MathUtils3D.nearEqual(e[7], oe[7]) && MathUtils3D.nearEqual(e[8], oe[8]) && MathUtils3D.nearEqual(e[9], oe[9]) && MathUtils3D.nearEqual(e[10], oe[10]) && MathUtils3D.nearEqual(e[11], oe[11]) && MathUtils3D.nearEqual(e[12], oe[12]) && MathUtils3D.nearEqual(e[13], oe[13]) && MathUtils3D.nearEqual(e[14], oe[14]) && MathUtils3D.nearEqual(e[15], oe[15]));
        }
        decomposeTransRotScale(translation, rotation, scale) {
            var rotationMatrix = _tempMatrix;
            if (this.decomposeTransRotMatScale(translation, rotationMatrix, scale)) {
                Quaternion.createFromMatrix4x4(rotationMatrix, rotation);
                return true;
            }
            else {
                rotation.identity();
                return false;
            }
        }
        decomposeTransRotMatScale(translation, rotationMatrix, scale) {
            var e = this.elements;
            var te = translation;
            var re = rotationMatrix.elements;
            var se = scale;
            te.x = e[12];
            te.y = e[13];
            te.z = e[14];
            var m11 = e[0], m12 = e[1], m13 = e[2];
            var m21 = e[4], m22 = e[5], m23 = e[6];
            var m31 = e[8], m32 = e[9], m33 = e[10];
            var sX = se.x = Math.sqrt((m11 * m11) + (m12 * m12) + (m13 * m13));
            var sY = se.y = Math.sqrt((m21 * m21) + (m22 * m22) + (m23 * m23));
            var sZ = se.z = Math.sqrt((m31 * m31) + (m32 * m32) + (m33 * m33));
            if (MathUtils3D.isZero(sX) || MathUtils3D.isZero(sY) || MathUtils3D.isZero(sZ)) {
                re[1] = re[2] = re[3] = re[4] = re[6] = re[7] = re[8] = re[9] = re[11] = re[12] = re[13] = re[14] = 0;
                re[0] = re[5] = re[10] = re[15] = 1;
                return false;
            }
            var at = _tempVector0;
            at.x = m31 / sZ;
            at.y = m32 / sZ;
            at.z = m33 / sZ;
            var tempRight = _tempVector1;
            tempRight.x = m11 / sX;
            tempRight.y = m12 / sX;
            tempRight.z = m13 / sX;
            var up = _tempVector2;
            Vector3.cross(at, tempRight, up);
            var right = _tempVector1;
            Vector3.cross(up, at, right);
            re[3] = re[7] = re[11] = re[12] = re[13] = re[14] = 0;
            re[15] = 1;
            re[0] = right.x;
            re[1] = right.y;
            re[2] = right.z;
            re[4] = up.x;
            re[5] = up.y;
            re[6] = up.z;
            re[8] = at.x;
            re[9] = at.y;
            re[10] = at.z;
            ((re[0] * m11 + re[1] * m12 + re[2] * m13) < 0.0) && (se.x = -sX);
            ((re[4] * m21 + re[5] * m22 + re[6] * m23) < 0.0) && (se.y = -sY);
            ((re[8] * m31 + re[9] * m32 + re[10] * m33) < 0.0) && (se.z = -sZ);
            return true;
        }
        decomposeYawPitchRoll(yawPitchRoll) {
            var pitch = Math.asin(-this.elements[9]);
            yawPitchRoll.y = pitch;
            var test = Math.cos(pitch);
            if (test > MathUtils3D.zeroTolerance) {
                yawPitchRoll.z = Math.atan2(this.elements[1], this.elements[5]);
                yawPitchRoll.x = Math.atan2(this.elements[8], this.elements[10]);
            }
            else {
                yawPitchRoll.z = Math.atan2(-this.elements[4], this.elements[0]);
                yawPitchRoll.x = 0.0;
            }
        }
        normalize() {
            var v = this.elements;
            var c = v[0], d = v[1], e = v[2], g = Math.sqrt(c * c + d * d + e * e);
            if (g) {
                if (g == 1)
                    return;
            }
            else {
                v[0] = 0;
                v[1] = 0;
                v[2] = 0;
                return;
            }
            g = 1 / g;
            v[0] = c * g;
            v[1] = d * g;
            v[2] = e * g;
        }
        transpose() {
            var e, t;
            e = this.elements;
            t = e[1];
            e[1] = e[4];
            e[4] = t;
            t = e[2];
            e[2] = e[8];
            e[8] = t;
            t = e[3];
            e[3] = e[12];
            e[12] = t;
            t = e[6];
            e[6] = e[9];
            e[9] = t;
            t = e[7];
            e[7] = e[13];
            e[13] = t;
            t = e[11];
            e[11] = e[14];
            e[14] = t;
            return this;
        }
        invert(out) {
            var ae = this.elements;
            var oe = out.elements;
            var a00 = ae[0], a01 = ae[1], a02 = ae[2], a03 = ae[3], a10 = ae[4], a11 = ae[5], a12 = ae[6], a13 = ae[7], a20 = ae[8], a21 = ae[9], a22 = ae[10], a23 = ae[11], a30 = ae[12], a31 = ae[13], a32 = ae[14], a33 = ae[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            if (Math.abs(det) === 0.0) {
                return;
            }
            det = 1.0 / det;
            oe[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
            oe[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
            oe[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
            oe[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
            oe[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
            oe[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
            oe[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
            oe[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
            oe[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
            oe[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
            oe[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
            oe[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
            oe[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
            oe[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
            oe[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
            oe[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
        }
        static billboard(objectPosition, cameraPosition, cameraUp, cameraForward, mat) {
            Vector3.subtract(objectPosition, cameraPosition, _tempVector0);
            var lengthSq = Vector3.scalarLengthSquared(_tempVector0);
            if (MathUtils3D.isZero(lengthSq)) {
                Vector3.scale(cameraForward, -1, _tempVector1);
                _tempVector1.cloneTo(_tempVector0);
            }
            else {
                Vector3.scale(_tempVector0, 1 / Math.sqrt(lengthSq), _tempVector0);
            }
            Vector3.cross(cameraUp, _tempVector0, _tempVector2);
            Vector3.normalize(_tempVector2, _tempVector2);
            Vector3.cross(_tempVector0, _tempVector2, _tempVector3);
            var crosse = _tempVector2;
            var finale = _tempVector3;
            var diffee = _tempVector0;
            var obpose = objectPosition;
            var mate = mat.elements;
            mate[0] = crosse.x;
            mate[1] = crosse.y;
            mate[2] = crosse.z;
            mate[3] = 0.0;
            mate[4] = finale.x;
            mate[5] = finale.y;
            mate[6] = finale.z;
            mate[7] = 0.0;
            mate[8] = diffee.x;
            mate[9] = diffee.y;
            mate[10] = diffee.z;
            mate[11] = 0.0;
            mate[12] = obpose.x;
            mate[13] = obpose.y;
            mate[14] = obpose.z;
            mate[15] = 1.0;
        }
        identity() {
            this.elements.set(DEFAULTARRAY);
        }
        isIdentity() {
            let delty = function (num0, num1) {
                return Math.abs(num0 - num1) < 1e-7;
            };
            let e = this.elements;
            let defined = Matrix4x4.DEFAULT.elements;
            for (let i = 0, n = e.length; i < n; i++) {
                if (!delty(e[i], defined[i]))
                    return false;
            }
            return true;
        }
        cloneTo(destObject) {
            var s, d;
            s = this.elements;
            d = destObject.elements;
            if (s === d) {
                return;
            }
            destObject.elements.set(this.elements);
        }
        cloneByArray(destObject) {
            this.elements.set(destObject);
        }
        clone() {
            var dest = new Matrix4x4(null);
            dest.elements = this.elements.slice();
            return dest;
        }
        static translation(v3, out) {
            var oe = out.elements;
            oe[0] = oe[5] = oe[10] = oe[15] = 1;
            oe[12] = v3.x;
            oe[13] = v3.y;
            oe[14] = v3.z;
        }
        getTranslationVector(out) {
            var me = this.elements;
            out.x = me[12];
            out.y = me[13];
            out.z = me[14];
        }
        setTranslationVector(translate) {
            var me = this.elements;
            var ve = translate;
            me[12] = ve.x;
            me[13] = ve.y;
            me[14] = ve.z;
        }
        getForward(out) {
            var me = this.elements;
            out.x = -me[8];
            out.y = -me[9];
            out.z = -me[10];
        }
        setForward(forward) {
            var me = this.elements;
            me[8] = -forward.x;
            me[9] = -forward.y;
            me[10] = -forward.z;
        }
        getInvertFront() {
            this.decomposeTransRotScale(_tempVector0, Quaternion.TEMP, _tempVector1);
            var scale = _tempVector1;
            var isInvert = scale.x < 0;
            (scale.y < 0) && (isInvert = !isInvert);
            (scale.z < 0) && (isInvert = !isInvert);
            return isInvert;
        }
    }
    Matrix4x4.TEMP = new Matrix4x4();
    Matrix4x4.DEFAULT = new Matrix4x4();
    Matrix4x4.DEFAULTINVERT = new Matrix4x4(-1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    Matrix4x4.ZERO = new Matrix4x4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _tempVector0 = new Vector3();
    const _tempVector1 = new Vector3();
    const _tempVector2 = new Vector3();
    const _tempVector3 = new Vector3();
    const _tempMatrix = new Matrix4x4();

    exports.ShaderDataType = void 0;
    (function (ShaderDataType) {
        ShaderDataType[ShaderDataType["None"] = 0] = "None";
        ShaderDataType[ShaderDataType["Int"] = 1] = "Int";
        ShaderDataType[ShaderDataType["Bool"] = 2] = "Bool";
        ShaderDataType[ShaderDataType["Float"] = 3] = "Float";
        ShaderDataType[ShaderDataType["Vector2"] = 4] = "Vector2";
        ShaderDataType[ShaderDataType["Vector3"] = 5] = "Vector3";
        ShaderDataType[ShaderDataType["Vector4"] = 6] = "Vector4";
        ShaderDataType[ShaderDataType["Color"] = 7] = "Color";
        ShaderDataType[ShaderDataType["Matrix4x4"] = 8] = "Matrix4x4";
        ShaderDataType[ShaderDataType["Buffer"] = 9] = "Buffer";
        ShaderDataType[ShaderDataType["Matrix3x3"] = 10] = "Matrix3x3";
        ShaderDataType[ShaderDataType["ReadOnlyDeviceBuffer"] = 11] = "ReadOnlyDeviceBuffer";
        ShaderDataType[ShaderDataType["DeviceBuffer"] = 12] = "DeviceBuffer";
        ShaderDataType[ShaderDataType["StorageTexture2D"] = 13] = "StorageTexture2D";
        ShaderDataType[ShaderDataType["Texture2D"] = 14] = "Texture2D";
        ShaderDataType[ShaderDataType["Texture3D"] = 15] = "Texture3D";
        ShaderDataType[ShaderDataType["TextureCube"] = 16] = "TextureCube";
        ShaderDataType[ShaderDataType["Texture2DArray"] = 17] = "Texture2DArray";
    })(exports.ShaderDataType || (exports.ShaderDataType = {}));
    function isUboBufferShaderType(type) {
        return !(type === exports.ShaderDataType.ReadOnlyDeviceBuffer ||
            type === exports.ShaderDataType.DeviceBuffer ||
            type === exports.ShaderDataType.StorageTexture2D ||
            type === exports.ShaderDataType.Texture2D ||
            type === exports.ShaderDataType.Texture3D ||
            type === exports.ShaderDataType.TextureCube ||
            type === exports.ShaderDataType.Texture2DArray);
    }
    function checkShaderDataValueLegal(value, shaderType) {
        let legal = false;
        switch (shaderType) {
            case exports.ShaderDataType.Int:
            case exports.ShaderDataType.Float:
                legal = typeof value == "number";
                break;
            case exports.ShaderDataType.Bool:
                legal = typeof value == "boolean";
                break;
            case exports.ShaderDataType.Vector2:
                legal = value instanceof Vector2;
                break;
            case exports.ShaderDataType.Vector3:
                legal = value instanceof Vector3;
                break;
            case exports.ShaderDataType.Vector4:
                legal = value instanceof Vector4;
                break;
            case exports.ShaderDataType.Color:
                legal = value instanceof Color;
                break;
            case exports.ShaderDataType.Matrix4x4:
                legal = value instanceof Matrix4x4;
                break;
            case exports.ShaderDataType.Texture2D:
                legal = value instanceof BaseTexture;
                break;
            case exports.ShaderDataType.TextureCube:
                legal = value instanceof BaseTexture;
                break;
            case exports.ShaderDataType.Buffer:
                legal = value instanceof ArrayBuffer;
                break;
            case exports.ShaderDataType.Matrix3x3:
                legal = value instanceof Matrix3x3;
                break;
            default:
                legal = false;
                break;
        }
        if (!legal)
            console.warn("The setting value and Shader type do not match");
        return legal;
    }
    function ShaderDataDefaultValue(type) {
        switch (type) {
            case exports.ShaderDataType.Int:
                return 0;
            case exports.ShaderDataType.Bool:
                return false;
            case exports.ShaderDataType.Float:
                return 0;
            case exports.ShaderDataType.Vector2:
                return Vector2.ZERO;
            case exports.ShaderDataType.Vector3:
                return Vector3.ZERO;
            case exports.ShaderDataType.Vector4:
                return Vector4.ZERO;
            case exports.ShaderDataType.Color:
                return Color.BLACK;
            case exports.ShaderDataType.Matrix4x4:
                return Matrix4x4.DEFAULT;
            case exports.ShaderDataType.Matrix3x3:
                return Matrix3x3.DEFAULT;
        }
        return null;
    }
    class ShaderData {
        constructor(ownerResource = null) {
            this._ownerResource = ownerResource;
        }
        getDefineData() {
            throw new NotImplementedError();
        }
        getData() {
            throw new NotImplementedError();
        }
        addDefine(define) {
            throw new NotImplementedError();
        }
        addDefines(define) {
            throw new NotImplementedError();
        }
        removeDefine(define) {
            throw new NotImplementedError();
        }
        hasDefine(define) {
            throw new NotImplementedError();
        }
        clearDefine() {
            throw new NotImplementedError();
        }
        clearData() {
            throw new NotImplementedError();
        }
        getBool(index) {
            throw new NotImplementedError();
        }
        setBool(index, value) {
            throw new NotImplementedError();
        }
        getInt(index) {
            throw new NotImplementedError();
        }
        setInt(index, value) {
            throw new NotImplementedError();
        }
        getNumber(index) {
            throw new NotImplementedError();
        }
        setNumber(index, value) {
            throw new NotImplementedError();
        }
        getVector2(index) {
            throw new NotImplementedError();
        }
        setVector2(index, value) {
            throw new NotImplementedError();
        }
        getVector3(index) {
            throw new NotImplementedError();
        }
        setVector3(index, value) {
            throw new NotImplementedError();
        }
        getVector(index) {
            throw new NotImplementedError();
        }
        setVector(index, value) {
            throw new NotImplementedError();
        }
        getColor(index) {
            throw new NotImplementedError();
        }
        setColor(index, value) {
            throw new NotImplementedError();
        }
        getMatrix4x4(index) {
            throw new NotImplementedError();
        }
        setMatrix4x4(index, value) {
            throw new NotImplementedError();
        }
        getMatrix3x3(index) {
            throw new NotImplementedError();
        }
        setMatrix3x3(index, value) {
            throw new NotImplementedError();
        }
        getBuffer(index) {
            throw new NotImplementedError();
        }
        setBuffer(index, value) {
            throw new NotImplementedError();
        }
        setDeviceBuffer(index, value) {
            throw new NotImplementedError();
        }
        getStorageBuffer(index) {
            throw new NotImplementedError();
        }
        setTexture(index, value) {
            throw new NotImplementedError();
        }
        getTexture(index) {
            throw new NotImplementedError();
        }
        setShaderData(uniformIndex, type, value) {
            switch (type) {
                case exports.ShaderDataType.Int:
                    this.setInt(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Bool:
                    this.setBool(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Float:
                    this.setNumber(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Vector2:
                    this.setVector2(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Vector3:
                    this.setVector3(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Vector4:
                    this.setVector(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Color:
                    this.setColor(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Matrix4x4:
                    this.setMatrix4x4(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Matrix3x3:
                    this.setMatrix3x3(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Texture2D:
                case exports.ShaderDataType.TextureCube:
                    this.setTexture(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Buffer:
                    this.setBuffer(uniformIndex, value);
                    break;
                default:
                    throw new Error(`unknown shader data type: ${type}`);
            }
        }
        getShaderData(uniformIndex, type) {
            switch (type) {
                case exports.ShaderDataType.Int:
                    return this.getInt(uniformIndex);
                case exports.ShaderDataType.Bool:
                    return this.getBool(uniformIndex);
                case exports.ShaderDataType.Float:
                    return this.getNumber(uniformIndex);
                case exports.ShaderDataType.Vector2:
                    return this.getVector2(uniformIndex);
                case exports.ShaderDataType.Vector3:
                    return this.getVector3(uniformIndex);
                case exports.ShaderDataType.Vector4:
                    return this.getVector(uniformIndex);
                case exports.ShaderDataType.Color:
                    return this.getColor(uniformIndex);
                case exports.ShaderDataType.Texture2D:
                case exports.ShaderDataType.TextureCube:
                    return this.getTexture(uniformIndex);
                case exports.ShaderDataType.Buffer:
                    return this.getBuffer(uniformIndex);
                case exports.ShaderDataType.Matrix3x3:
                    return this.getMatrix3x3(uniformIndex);
                case exports.ShaderDataType.Matrix4x4:
                    return this.getMatrix4x4(uniformIndex);
                default:
                    throw "unknown shader data type.";
            }
        }
        _setInternalTexture(index, value) {
            throw new NotImplementedError();
        }
        cloneTo(destObject) {
            throw new NotImplementedError();
        }
        clone() {
            throw new NotImplementedError();
        }
        destroy() {
            throw new NotImplementedError();
        }
    }

    class ShaderCompileDefineBase {
        constructor(owner, name, compiledObj) {
            this._owner = owner;
            this.name = name;
            this._VS = compiledObj.vsNode;
            this._PS = compiledObj.psNode;
            this._defs = compiledObj.defs;
            this._validDefine = LayaGL.unitRenderModuleDataFactory.createDefineDatas();
            for (let k of compiledObj.defs)
                this._validDefine.add(Shader3D.getDefineByName(k));
            this._validDefine.add(Shader3D.getDefineByName("VBONEW"));
            this._validDefine.add(Shader3D.getDefineByName("VBONEI"));
        }
        withCompile(compileDefine) {
            return null;
        }
    }

    class ShaderPass extends ShaderCompileDefineBase {
        get pipelineMode() {
            return this._pipelineMode;
        }
        set pipelineMode(value) {
            this._pipelineMode = value;
            this.moduleData.pipelineMode = value;
        }
        set nodeCommonMap(value) {
            this.moduleData.nodeCommonMap = value;
        }
        get nodeCommonMap() {
            return this.moduleData.nodeCommonMap;
        }
        set additionShaderData(value) {
            this.moduleData.additionShaderData = value;
        }
        get additionShaderData() {
            return this.moduleData.additionShaderData;
        }
        get statefirst() {
            return this._statefirst;
        }
        set statefirst(value) {
            this._statefirst = value;
            this.moduleData.statefirst = value;
        }
        get attributeLocations() {
            return this.moduleData.attributeLocations;
        }
        set attributeLocations(value) {
            this.moduleData.attributeLocations = value;
        }
        get renderState() {
            return this.moduleData.renderState;
        }
        constructor(owner, compiledObj) {
            super(owner, owner._owner.name, compiledObj);
            this._statefirst = false;
            this.moduleData = LayaGL.unitRenderModuleDataFactory.createShaderPass(this);
            this.moduleData.validDefine = this._validDefine;
            this.moduleData.name = this.name;
        }
        static createShaderInstance(shaderpass, is2D, compileDefine) {
            _defineStrings.length = 0;
            Shader3D._getNamesByDefineData(compileDefine, _defineStrings);
            let shaderProcessInfo = {
                is2D,
                vs: shaderpass._VS,
                ps: shaderpass._PS,
                attributeMap: shaderpass._owner._attributeMap,
                uniformMap: shaderpass._owner._uniformMap,
                defineString: _defineStrings,
            };
            let shader = LayaGL.renderDeviceFactory.createShaderInstance(shaderProcessInfo, shaderpass);
            return shader;
        }
        withCompile(compileDefine, is2D = false) {
            var shader = this.moduleData.getCacheShader(compileDefine);
            if (shader)
                return shader;
            shader = ShaderPass.createShaderInstance(this, is2D, compileDefine);
            this.moduleData.setCacheShader(compileDefine, shader);
            return shader;
        }
        withComplieByBin(compileDefine, is2D = false, buffer) {
            var shader = this.moduleData.getCacheShader(compileDefine);
            if (shader)
                return shader;
            this.moduleData.setCacheShader(compileDefine, shader);
            return null;
        }
    }
    const _defineStrings = [];

    class VertexElement {
        get offset() {
            return this._offset;
        }
        get elementFormat() {
            return this._elementFormat;
        }
        get elementUsage() {
            return this._elementUsage;
        }
        constructor(offset, elementFormat, elementUsage) {
            this._offset = offset;
            this._elementFormat = elementFormat;
            this._elementUsage = elementUsage;
        }
    }

    exports.RenderParams = void 0;
    (function (RenderParams) {
        RenderParams[RenderParams["Max_Active_Texture_Count"] = 0] = "Max_Active_Texture_Count";
        RenderParams[RenderParams["Max_Uniform_Count"] = 1] = "Max_Uniform_Count";
        RenderParams[RenderParams["Max_AnisoLevel_Count"] = 2] = "Max_AnisoLevel_Count";
        RenderParams[RenderParams["MAX_Texture_Size"] = 3] = "MAX_Texture_Size";
        RenderParams[RenderParams["MAX_Texture_Image_Uint"] = 4] = "MAX_Texture_Image_Uint";
        RenderParams[RenderParams["SHADER_CAPAILITY_LEVEL"] = 5] = "SHADER_CAPAILITY_LEVEL";
        RenderParams[RenderParams["FLOAT"] = 6] = "FLOAT";
        RenderParams[RenderParams["UNSIGNED_BYTE"] = 7] = "UNSIGNED_BYTE";
        RenderParams[RenderParams["BYTE"] = 8] = "BYTE";
        RenderParams[RenderParams["UNSIGNED_SHORT"] = 9] = "UNSIGNED_SHORT";
    })(exports.RenderParams || (exports.RenderParams = {}));

    class VertexElementFormat {
        static __init__() {
            VertexElementFormat._elementInfos = {
                "single": [1, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "vector2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "vector3": [3, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "vector4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "color": [4, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "byte4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 0],
                "byte3": [3, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 0],
                "byte2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 0],
                "byte": [1, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 0],
                "short2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_SHORT), 0],
                "short4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_SHORT), 0],
                "normalizedshort2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_SHORT), 1],
                "normalizedshort4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_SHORT), 1],
                "halfvector2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "halfvector4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "nbyte4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.BYTE), 1],
                "ubyte4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 1],
            };
        }
        static getElementInfos(element) {
            var info = VertexElementFormat._elementInfos[element];
            if (info)
                return info;
            else
                throw new NotImplementedError();
        }
    }
    VertexElementFormat.Single = "single";
    VertexElementFormat.Vector2 = "vector2";
    VertexElementFormat.Vector3 = "vector3";
    VertexElementFormat.Vector4 = "vector4";
    VertexElementFormat.Color = "color";
    VertexElementFormat.Byte4 = "byte4";
    VertexElementFormat.Byte3 = "byte3";
    VertexElementFormat.Byte2 = "byte2";
    VertexElementFormat.ByteOne = "byte";
    VertexElementFormat.Short2 = "short2";
    VertexElementFormat.Short4 = "short4";
    VertexElementFormat.NormalizedShort2 = "normalizedshort2";
    VertexElementFormat.NormalizedShort4 = "normalizedshort4";
    VertexElementFormat.HalfVector2 = "halfvector2";
    VertexElementFormat.HalfVector4 = "halfvector4";
    VertexElementFormat.NorByte4 = "nbyte4";
    VertexElementFormat.NorUByte4 = "ubyte4";

    class VertexStateContext {
    }
    class VertexDeclaration {
        get id() {
            return this._id;
        }
        get vertexStride() {
            return this._vertexStride;
        }
        get vertexElementCount() {
            return this._vertexElements.length;
        }
        constructor(vertexStride, vertexElements) {
            this._id = ++VertexDeclaration._uniqueIDCounter;
            this._vertexElementsDic = {};
            this._vertexStride = vertexStride;
            this._vertexElements = vertexElements;
            this._VAElements = [];
            var count = vertexElements.length;
            this._shaderValues = {};
            for (var j = 0; j < count; j++) {
                var vertexElement = vertexElements[j];
                var name = vertexElement._elementUsage;
                this._vertexElementsDic[name] = vertexElement;
                var value = new VertexStateContext();
                var elmentInfo = VertexElementFormat.getElementInfos(vertexElement._elementFormat);
                value.elementString = vertexElement._elementFormat;
                value.elementCount = elmentInfo[0];
                value.elementType = elmentInfo[1];
                value.normalized = elmentInfo[2];
                value.vertexStride = this._vertexStride;
                value.elementOffset = vertexElement._offset;
                this._shaderValues[name] = value;
                this._VAElements.push({ format: vertexElement._elementFormat, stride: vertexElement._offset, shaderLocation: name });
            }
        }
        getVertexElementByIndex(index) {
            return this._vertexElements[index];
        }
        getVertexElementByUsage(usage) {
            return this._vertexElementsDic[usage];
        }
    }
    VertexDeclaration._uniqueIDCounter = 1;

    class VertexMesh {
        static __init__() {
            VertexMesh.instanceWorldMatrixDeclaration = new VertexDeclaration(80, [new VertexElement(0, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW0),
                new VertexElement(16, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW1),
                new VertexElement(32, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW2),
                new VertexElement(48, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW3),
                new VertexElement(64, VertexElementFormat.Vector4, VertexMesh.MESH_CUSTOME2),
            ]);
            VertexMesh.instanceSimpleAnimatorDeclaration = new VertexDeclaration(16, [new VertexElement(0, VertexElementFormat.Vector4, VertexMesh.MESH_SIMPLEANIMATOR)]);
            VertexMesh.instanceLightMapScaleOffsetDeclaration = new VertexDeclaration(16, [new VertexElement(0, VertexElementFormat.Vector4, VertexMesh.MESH_LIGHTMAPSCALEOFFSET)]);
        }
        static getVertexDeclaration(vertexFlag, compatible = true) {
            var verDec = VertexMesh._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")];
            if (!verDec) {
                var subFlags = vertexFlag.split(",");
                var offset = 0;
                var elements = [];
                for (var i = 0, n = subFlags.length; i < n; i++) {
                    var element;
                    switch (subFlags[i]) {
                        case "POSITION":
                            element = new VertexElement(offset, VertexElementFormat.Vector3, VertexMesh.MESH_POSITION0);
                            offset += 12;
                            break;
                        case "NORMAL":
                            element = new VertexElement(offset, VertexElementFormat.Vector3, VertexMesh.MESH_NORMAL0);
                            offset += 12;
                            break;
                        case "COLOR":
                            element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_COLOR0);
                            offset += 16;
                            break;
                        case "UV":
                            element = new VertexElement(offset, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE0);
                            offset += 8;
                            break;
                        case "UV1":
                            element = new VertexElement(offset, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE1);
                            offset += 8;
                            break;
                        case "BLENDWEIGHT":
                            element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDWEIGHT0);
                            offset += 16;
                            break;
                        case "BLENDINDICES":
                            if (compatible) {
                                element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDINDICES0);
                                offset += 16;
                            }
                            else {
                                element = new VertexElement(offset, VertexElementFormat.Byte4, VertexMesh.MESH_BLENDINDICES0);
                                offset += 4;
                            }
                            break;
                        case "TANGENT":
                            element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_TANGENT0);
                            offset += 16;
                            break;
                        case "NORMAL_BYTE":
                            element = new VertexElement(offset, VertexElementFormat.NorByte4, VertexMesh.MESH_NORMAL0);
                            offset += 4;
                            break;
                        default:
                            throw "VertexMesh: unknown vertex flag.";
                    }
                    elements.push(element);
                }
                verDec = new VertexDeclaration(offset, elements);
                VertexMesh._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")] = verDec;
            }
            return verDec;
        }
    }
    VertexMesh.MESH_POSITION0 = 0;
    VertexMesh.MESH_COLOR0 = 1;
    VertexMesh.MESH_TEXTURECOORDINATE0 = 2;
    VertexMesh.MESH_NORMAL0 = 3;
    VertexMesh.MESH_TANGENT0 = 4;
    VertexMesh.MESH_BLENDINDICES0 = 5;
    VertexMesh.MESH_BLENDWEIGHT0 = 6;
    VertexMesh.MESH_TEXTURECOORDINATE1 = 7;
    VertexMesh.MESH_WORLDMATRIX_ROW0 = 8;
    VertexMesh.MESH_WORLDMATRIX_ROW1 = 9;
    VertexMesh.MESH_WORLDMATRIX_ROW2 = 10;
    VertexMesh.MESH_WORLDMATRIX_ROW3 = 11;
    VertexMesh.MESH_SIMPLEANIMATOR = 12;
    VertexMesh.MESH_LIGHTMAPSCALEOFFSET = 13;
    VertexMesh.MESH_CUSTOME0 = 12;
    VertexMesh.MESH_CUSTOME1 = 13;
    VertexMesh.MESH_CUSTOME2 = 14;
    VertexMesh.MESH_CUSTOME3 = 15;
    VertexMesh._vertexDeclarationMap = {};

    class SubShader {
        static regIncludeBindUnifrom(includeName, uniformMap, defaultValue) {
            let obj = {};
            let data = obj[includeName] = {};
            data["uniformMap"] = uniformMap;
            data["defaultValue"] = defaultValue;
            Object.assign(SubShader.IncludeUniformMap, obj);
        }
        constructor(attributeMap = SubShader.DefaultAttributeMap, uniformMap = {}, uniformDefaultValue = null) {
            this._flags = {};
            this._passes = [];
            this.moduleData = LayaGL.unitRenderModuleDataFactory.createSubShader();
            this._attributeMap = attributeMap;
            this._uniformDefaultValue = uniformDefaultValue;
            this._uniformMap = new Map();
            for (const key in uniformMap) {
                if (typeof uniformMap[key] == "object") {
                    let block = (uniformMap[key]);
                    for (const uniformName in block) {
                        let uniformType = block[uniformName];
                        this.addUniform(uniformName, uniformType);
                    }
                }
                else {
                    let unifromType = uniformMap[key];
                    this.addUniform(key, unifromType);
                    if (unifromType == exports.ShaderDataType.Texture2D || unifromType == exports.ShaderDataType.TextureCube || unifromType == exports.ShaderDataType.Texture3D || unifromType == exports.ShaderDataType.Texture2DArray) {
                        let textureGammaDefine = Shader3D.getDefineByName(`Gamma_${key}`);
                        let uniformIndex = Shader3D.propertyNameToID(key);
                        LayaGL.renderEngine.addTexGammaDefine(uniformIndex, textureGammaDefine);
                    }
                }
            }
            this.moduleData.setUniformMap(this._uniformMap);
        }
        addUniform(name, type) {
            let uniformName = name;
            let arrayLength = getArrayLength(name);
            if (arrayLength > 0) {
                uniformName = name.substring(0, name.lastIndexOf('['));
            }
            let uniform = {
                id: Shader3D.propertyNameToID(uniformName),
                propertyName: uniformName,
                uniformtype: type,
                arrayLength: arrayLength
            };
            this._uniformMap.set(uniform.id, uniform);
            if (type == exports.ShaderDataType.Texture2D || type == exports.ShaderDataType.TextureCube || type == exports.ShaderDataType.Texture3D || type == exports.ShaderDataType.Texture2DArray) {
                let textureGammaDefine = Shader3D.getDefineByName(`Gamma_${name}`);
                LayaGL.renderEngine.addTexGammaDefine(uniform.id, textureGammaDefine);
            }
        }
        addShaderPass(vs, ps, pipelineMode = "Forward") {
            return this._addShaderPass(ShaderCompile.compile(vs, ps), pipelineMode);
        }
        _addShaderPass(compiledObj, pipelineMode = "Forward") {
            var shaderPass = new ShaderPass(this, compiledObj);
            shaderPass.pipelineMode = pipelineMode;
            this._passes.push(shaderPass);
            this.moduleData.addShaderPass(shaderPass.moduleData);
            this._addIncludeUniform(compiledObj.includeNames);
            return shaderPass;
        }
        _addIncludeUniform(includemap) {
            for (let ele of includemap) {
                if (SubShader.IncludeUniformMap[ele]) {
                    let includeBindInfo = SubShader.IncludeUniformMap[ele];
                    let bindtypeMap = includeBindInfo["uniformMap"];
                    let bindDefaultValue = includeBindInfo["defaultValue"];
                    for (var i in bindtypeMap) {
                        if (!this._uniformMap.has(Shader3D.propertyNameToID(i))) {
                            this.addUniform(i, bindtypeMap[i]);
                        }
                    }
                    for (var i in bindDefaultValue) {
                        if (!this._uniformDefaultValue[i]) {
                            this._uniformDefaultValue[i] = bindDefaultValue[i];
                        }
                    }
                }
            }
        }
    }
    SubShader.IncludeUniformMap = {};
    SubShader.DefaultAttributeMap = {
        'a_Position': [VertexMesh.MESH_POSITION0, exports.ShaderDataType.Vector4],
        'a_Normal': [VertexMesh.MESH_NORMAL0, exports.ShaderDataType.Vector3],
        'a_Tangent0': [VertexMesh.MESH_TANGENT0, exports.ShaderDataType.Vector4],
        'a_Texcoord0': [VertexMesh.MESH_TEXTURECOORDINATE0, exports.ShaderDataType.Vector2],
        'a_Texcoord1': [VertexMesh.MESH_TEXTURECOORDINATE1, exports.ShaderDataType.Vector2],
        'a_Color': [VertexMesh.MESH_COLOR0, exports.ShaderDataType.Vector4],
        'a_BoneWeights': [VertexMesh.MESH_BLENDWEIGHT0, exports.ShaderDataType.Vector4],
        'a_BoneIndices': [VertexMesh.MESH_BLENDINDICES0, exports.ShaderDataType.Vector4],
        'a_WorldMat': [VertexMesh.MESH_WORLDMATRIX_ROW0, exports.ShaderDataType.Matrix4x4],
        'a_SimpleTextureParams': [VertexMesh.MESH_SIMPLEANIMATOR, exports.ShaderDataType.Vector4],
        'a_LightmapScaleOffset': [VertexMesh.MESH_LIGHTMAPSCALEOFFSET, exports.ShaderDataType.Vector4],
        "a_WorldInvertFront": [VertexMesh.MESH_CUSTOME2, exports.ShaderDataType.Vector4],
    };
    function getArrayLength(name) {
        let endPos = name.lastIndexOf(']');
        let startPos = name.lastIndexOf('[');
        if (startPos != -1 && endPos == name.length - 1) {
            let arrayLengthStr = name.slice(startPos + 1, endPos);
            let arrayLength = parseInt(arrayLengthStr);
            if (!isNaN(arrayLength) && arrayLength > 0) {
                return arrayLength;
            }
        }
        return 0;
    }

    exports.ShaderFeatureType = void 0;
    (function (ShaderFeatureType) {
        ShaderFeatureType[ShaderFeatureType["None"] = -1] = "None";
        ShaderFeatureType[ShaderFeatureType["Default"] = 0] = "Default";
        ShaderFeatureType[ShaderFeatureType["D3"] = 1] = "D3";
        ShaderFeatureType[ShaderFeatureType["D2_primitive"] = 2] = "D2_primitive";
        ShaderFeatureType[ShaderFeatureType["D2_TextureSV"] = 3] = "D2_TextureSV";
        ShaderFeatureType[ShaderFeatureType["D2_BaseRenderNode2D"] = 4] = "D2_BaseRenderNode2D";
        ShaderFeatureType[ShaderFeatureType["PostProcess"] = 5] = "PostProcess";
        ShaderFeatureType[ShaderFeatureType["Sky"] = 6] = "Sky";
        ShaderFeatureType[ShaderFeatureType["Effect"] = 7] = "Effect";
    })(exports.ShaderFeatureType || (exports.ShaderFeatureType = {}));
    class Shader3D {
        static init() {
            Shader3D._configDefineValues = LayaGL.unitRenderModuleDataFactory.createDefineDatas();
            Shader3D.SHADERDEFINE_REMAP_POSITIONZ = Shader3D.getDefineByName("REMAP_Z");
            Shader3D.SHADERDEFINE_LOD_TEXTURE_SAMPLE = Shader3D.getDefineByName("LOD_TEXTURE_SAMPLE");
            Shader3D.SHADERDEFINE_BREAK_TEXTURE_SAMPLE = Shader3D.getDefineByName("BREAK_TEXTURE_SAMPLE");
            if (LayaGL.renderEngine._remapZ)
                Shader3D._configDefineValues.add(Shader3D.SHADERDEFINE_REMAP_POSITIONZ);
            if (LayaGL.renderEngine._lodTextureSample)
                Shader3D._configDefineValues.add(Shader3D.SHADERDEFINE_LOD_TEXTURE_SAMPLE);
            if (LayaGL.renderEngine._breakTextureSample)
                Shader3D._configDefineValues.add(Shader3D.SHADERDEFINE_BREAK_TEXTURE_SAMPLE);
            Shader3D._compileDefineDatas = LayaGL.unitRenderModuleDataFactory.createDefineDatas();
        }
        static _getNamesByDefineData(defineData, out) {
            LayaGL.renderEngine.getNamesByDefineData(defineData, out);
            return out;
        }
        static getDefineByName(name) {
            return LayaGL.renderEngine.getDefineByName(name);
        }
        static propertyNameToID(name) {
            return LayaGL.renderEngine.propertyNameToID(name);
        }
        static propertyIDToName(id) {
            return LayaGL.renderEngine.propertyIDToName(id);
        }
        static addInclude(fileName, txt) {
            ShaderCompile.addInclude(fileName, txt);
        }
        static compileShaderByDefineNames(shaderName, subShaderIndex, passIndex, defineNames, nodeCommonMap, additionMap, is2D, attributeLocations) {
            var shader = Shader3D.find(shaderName);
            if (shader) {
                var subShader = shader.getSubShaderAt(subShaderIndex);
                if (subShader) {
                    var pass = subShader._passes[passIndex];
                    if (pass) {
                        pass.nodeCommonMap = nodeCommonMap;
                        pass.additionShaderData = additionMap;
                        pass.attributeLocations = new Set(attributeLocations);
                        var compileDefineDatas = Shader3D._compileDefineDatas;
                        Shader3D._configDefineValues.cloneTo(compileDefineDatas);
                        for (let n of defineNames)
                            compileDefineDatas.add(Shader3D.getDefineByName(n));
                        pass.withCompile(compileDefineDatas, is2D);
                        return true;
                    }
                }
            }
            return false;
        }
        static compileShaderByBin(shaderName, subShaderIndex, passIndex, defineNames, nodeCommonMap, cacheBuffer) {
            var shader = Shader3D.find(shaderName);
            if (shader) {
                var subShader = shader.getSubShaderAt(subShaderIndex);
                if (subShader) {
                    var pass = subShader._passes[passIndex];
                    pass.nodeCommonMap = nodeCommonMap;
                    if (pass) {
                        var compileDefineDatas = Shader3D._compileDefineDatas;
                        compileDefineDatas.clear();
                        for (let n of defineNames)
                            compileDefineDatas.add(Shader3D.getDefineByName(n));
                        pass.withComplieByBin(compileDefineDatas, false, cacheBuffer);
                    }
                }
            }
        }
        static add(name, enableInstancing = false, supportReflectionProbe = false) {
            return Shader3D._preCompileShader[name] = new Shader3D(name, enableInstancing, supportReflectionProbe);
        }
        static find(name) {
            return Shader3D._preCompileShader[name];
        }
        static parse(data, basePath) {
            var _a;
            if (!data.name)
                console.warn("shader name is empty", data);
            if (!data.uniformMap)
                console.warn(`${data.name}: uniformMap is empty`);
            let shader = Shader3D.add(data.name, data.enableInstancing, data.supportReflectionProbe);
            shader._supportVolumetricGI = data.supportVolumetricGI;
            shader.shaderType = data.shaderType;
            let subshader = new SubShader(data.attributeMap ? data.attributeMap : SubShader.DefaultAttributeMap, data.uniformMap, data.defaultValue);
            shader.addSubShader(subshader);
            let passDataArray = data.shaderPass;
            for (var i in passDataArray) {
                let passData = passDataArray[i];
                if (!passData.VS) {
                    console.warn(`${data.name}: VS of pass ${i} is empty`);
                    continue;
                }
                if (!passData.FS) {
                    console.warn(`${data.name}: FS of pass ${i} is empty`);
                    continue;
                }
                let shaderPass = subshader._addShaderPass(ShaderCompile.compile(passData.VS, passData.FS, basePath), passData.pipeline);
                shaderPass.statefirst = (_a = passData.statefirst) !== null && _a !== void 0 ? _a : false;
                ShaderCompile.getRenderState(passData.renderState, shaderPass.renderState);
            }
            return shader;
        }
        get name() {
            return this._name;
        }
        constructor(name, enableInstancing, supportReflectionProbe) {
            this._enableInstancing = false;
            this._supportReflectionProbe = false;
            this._supportVolumetricGI = false;
            this._subShaders = [];
            this.shaderType = exports.ShaderFeatureType.None;
            this._name = name;
            this._enableInstancing = enableInstancing;
            this._supportReflectionProbe = supportReflectionProbe;
        }
        addSubShader(subShader) {
            this._subShaders.push(subShader);
            subShader._owner = this;
            subShader.moduleData.enableInstance = this._enableInstancing;
            subShader.moduleData.shaderName = this._name;
        }
        getSubShaderAt(index) {
            return this._subShaders[index];
        }
    }
    Shader3D.PERIOD_CUSTOM = 0;
    Shader3D.PERIOD_MATERIAL = 1;
    Shader3D.PERIOD_SPRITE = 2;
    Shader3D.PERIOD_CAMERA = 3;
    Shader3D.PERIOD_SCENE = 4;
    Shader3D._propertyNameMap = {};
    Shader3D._preCompileShader = {};
    Shader3D.debugMode = false;

    class ShaderDefines2D {
        static __init__() {
            ShaderDefines2D.VERTEX_SIZE = Shader3D.getDefineByName("VERTEX_SIZE");
            ShaderDefines2D.FILLTEXTURE = Shader3D.getDefineByName("FILLTEXTURE");
            ShaderDefines2D.RENDERTEXTURE = Shader3D.getDefineByName('RENDERTEXTURE');
            ShaderDefines2D.MATERIALCLIP = Shader3D.getDefineByName('MATERIALCLIP');
            ShaderDefines2D.GAMMASPACE = Shader3D.getDefineByName('GAMMASPACE');
            ShaderDefines2D.INVERTY = Shader3D.getDefineByName('INVERTY');
            ShaderDefines2D.GAMMATEXTURE = Shader3D.getDefineByName('GAMMATEXTURE');
            ShaderDefines2D.TEXTURESHADER = Shader3D.getDefineByName("TEXTUREVS");
            ShaderDefines2D.PRIMITIVESHADER = Shader3D.getDefineByName("PRIMITIVEMESH");
            ShaderDefines2D.initSprite2DCommandEncoder();
        }
        static initSprite2DCommandEncoder() {
            ShaderDefines2D.UNIFORM_NMATRIX_0 = Shader3D.propertyNameToID("u_NMatrix_0");
            ShaderDefines2D.UNIFORM_NMATRIX_1 = Shader3D.propertyNameToID("u_NMatrix_1");
            ShaderDefines2D.UNIFORM_INVERTMAT_0 = Shader3D.propertyNameToID("u_InvertMat_0");
            ShaderDefines2D.UNIFORM_INVERTMAT_1 = Shader3D.propertyNameToID("u_InvertMat_1");
            ShaderDefines2D.UNIFORM_CLIPMATDIR = Shader3D.propertyNameToID("u_clipMatDir");
            ShaderDefines2D.UNIFORM_CLIPMATPOS = Shader3D.propertyNameToID("u_clipMatPos");
            ShaderDefines2D.UNIFORM_SIZE = Shader3D.propertyNameToID("u_size");
            ShaderDefines2D.UNIFORM_VERTALPHA = Shader3D.propertyNameToID("u_VertAlpha");
            const commandUniform = LayaGL.renderDeviceFactory.createGlobalUniformMap("Sprite2D");
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_NMATRIX_0, "u_NMatrix_0", exports.ShaderDataType.Vector3);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_NMATRIX_1, "u_NMatrix_1", exports.ShaderDataType.Vector3);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_VERTALPHA, "u_VertAlpha", exports.ShaderDataType.Float);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_CLIPMATDIR, "u_clipMatDir", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_CLIPMATPOS, "u_clipMatPos", exports.ShaderDataType.Vector4);
            let passUniformMap = LayaGL.renderDeviceFactory.createGlobalUniformMap("Sprite2DPass");
            passUniformMap.addShaderUniform(ShaderDefines2D.UNIFORM_SIZE, "u_size", exports.ShaderDataType.Vector2);
            passUniformMap.addShaderUniform(ShaderDefines2D.UNIFORM_INVERTMAT_0, "u_InvertMat_0", exports.ShaderDataType.Vector3);
            passUniformMap.addShaderUniform(ShaderDefines2D.UNIFORM_INVERTMAT_1, "u_InvertMat_1", exports.ShaderDataType.Vector3);
            ShaderDefines2D.UNIFORM_MATERIAL_CLIPMATDIR = Shader3D.propertyNameToID("u_mClipMatDir");
            ShaderDefines2D.UNIFORM_MATERIAL_CLIPMATPOS = Shader3D.propertyNameToID("u_mClipMatPos");
            ShaderDefines2D.UNIFORM_VERTEX_SIZE = Shader3D.propertyNameToID("u_vertexSize");
            ShaderDefines2D.UNIFORM_TEXRANGE = Shader3D.propertyNameToID("u_TexRange");
            ShaderDefines2D.UNIFORM_SPRITETEXTURE = Shader3D.propertyNameToID("u_spriteTexture");
            const graphicsUniformMap = LayaGL.renderDeviceFactory.createGlobalUniformMap("Sprite2DGraphics");
            graphicsUniformMap.addShaderUniform(ShaderDefines2D.UNIFORM_MATERIAL_CLIPMATDIR, "u_mClipMatDir", exports.ShaderDataType.Vector4);
            graphicsUniformMap.addShaderUniform(ShaderDefines2D.UNIFORM_MATERIAL_CLIPMATPOS, "u_mClipMatPos", exports.ShaderDataType.Vector4);
            graphicsUniformMap.addShaderUniform(ShaderDefines2D.UNIFORM_VERTEX_SIZE, "u_vertexSize", exports.ShaderDataType.Vector4);
            graphicsUniformMap.addShaderUniform(ShaderDefines2D.UNIFORM_TEXRANGE, "u_TexRange", exports.ShaderDataType.Vector4);
            graphicsUniformMap.addShaderUniform(ShaderDefines2D.UNIFORM_SPRITETEXTURE, "u_spriteTexture", exports.ShaderDataType.Texture2D);
        }
    }

    exports.BlendMode = void 0;
    (function (BlendMode) {
        BlendMode[BlendMode["invalid"] = 0] = "invalid";
        BlendMode[BlendMode["normal"] = 1] = "normal";
        BlendMode[BlendMode["add"] = 2] = "add";
        BlendMode[BlendMode["multiply"] = 3] = "multiply";
        BlendMode[BlendMode["screen"] = 4] = "screen";
        BlendMode[BlendMode["overlay"] = 5] = "overlay";
        BlendMode[BlendMode["light"] = 6] = "light";
        BlendMode[BlendMode["lighter"] = 7] = "lighter";
        BlendMode[BlendMode["mask"] = 8] = "mask";
        BlendMode[BlendMode["destinationOut"] = 9] = "destinationOut";
        BlendMode[BlendMode["addOld"] = 10] = "addOld";
        BlendMode[BlendMode["lighterOld"] = 11] = "lighterOld";
        BlendMode[BlendMode["sourceAlpha"] = 12] = "sourceAlpha";
    })(exports.BlendMode || (exports.BlendMode = {}));
    const TOINT = {
        [exports.BlendMode.normal]: 0,
        [exports.BlendMode.add]: 1,
        [exports.BlendMode.multiply]: 2,
        [exports.BlendMode.screen]: 3,
        [exports.BlendMode.overlay]: 4,
        [exports.BlendMode.light]: 5,
        [exports.BlendMode.mask]: 6,
        [exports.BlendMode.destinationOut]: 7,
        [exports.BlendMode.lighter]: 1,
        [exports.BlendMode.lighterOld]: 8,
        [exports.BlendMode.addOld]: 8,
        [exports.BlendMode.sourceAlpha]: 9
    };
    class BlendModeHandler {
        static _init_() {
        }
        static setShaderData(blendType, shaderData, premultipliedAlpha = true) {
            let type = TOINT[blendType];
            switch (type) {
                case 1:
                case 3:
                case 5:
                    shaderData.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
                    shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE);
                    break;
                case 2:
                    shaderData.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_DST_COLOR);
                    shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
                    break;
                case 6:
                    shaderData.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ZERO);
                    shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_SRC_ALPHA);
                    break;
                case 7:
                    shaderData.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ZERO);
                    shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ZERO);
                    break;
                case 9:
                    shaderData.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_SRC_ALPHA);
                    shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
                    break;
                default:
                    shaderData.setInt(Shader3D.BLEND_SRC, premultipliedAlpha ? RenderState.BLENDPARAM_ONE : RenderState.BLENDPARAM_SRC_ALPHA);
                    shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
            }
        }
        static initBlendMode(shaderData) {
            shaderData.setBool(Shader3D.DEPTH_WRITE, false);
            shaderData.setInt(Shader3D.DEPTH_TEST, RenderState.DEPTHTEST_OFF);
            shaderData.setInt(Shader3D.BLEND, RenderState.BLEND_ENABLE_ALL);
            shaderData.setInt(Shader3D.BLEND_EQUATION, RenderState.BLENDEQUATION_ADD);
            shaderData.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
            shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
            shaderData.setNumber(ShaderDefines2D.UNIFORM_VERTALPHA, 1.0);
            shaderData.setInt(Shader3D.CULL, RenderState.CULL_NONE);
        }
    }

    class DrawStyle {
        static create(value) {
            if (value != null) {
                let color = (value instanceof ColorUtils) ? value : ColorUtils.create(value);
                return color._drawStyle || (color._drawStyle = new DrawStyle(value));
            }
            else
                return DrawStyle.DEFAULT;
        }
        constructor(value) {
            if (value != null)
                this._color = (value instanceof ColorUtils) ? value : ColorUtils.create(value);
            else
                this._color = ColorUtils.create(0);
        }
        equal(value) {
            if (typeof (value) == 'string')
                return this._color.strColor === value;
            if (value instanceof ColorUtils)
                return this._color.numColor === value.numColor;
            return false;
        }
    }
    DrawStyle.DEFAULT = DrawStyle.create(0);

    class Path {
        constructor() {
            this._lastOriX = 0;
            this._lastOriY = 0;
            this.paths = [];
            this._curPath = null;
        }
        beginPath(convex) {
            this.paths.length = 1;
            this._curPath = this.paths[0] = new RenderPath();
            this._curPath.convex = convex;
        }
        closePath() {
            this._curPath.loop = true;
        }
        newPath() {
            this._curPath = new RenderPath();
            this.paths.push(this._curPath);
        }
        addPoint(pointX, pointY) {
            this._curPath.path.push(pointX, pointY);
        }
        push(points, convex) {
            if (!this._curPath) {
                this._curPath = new RenderPath();
                this.paths.push(this._curPath);
            }
            else if (this._curPath.path.length > 0) {
                this._curPath = new RenderPath();
                this.paths.push(this._curPath);
            }
            var rp = this._curPath;
            rp.path = points.slice();
            rp.convex = convex;
        }
        reset() {
            this.paths.length = 0;
        }
    }
    class RenderPath {
        constructor() {
            this.path = [];
            this.loop = false;
            this.convex = false;
        }
    }

    class SaveBase {
        constructor() {
        }
        static _createArray() {
            var value = [];
            value._length = 0;
            return value;
        }
        static _init() {
            var namemap = SaveBase._namemap = {};
            namemap[SaveBase.TYPE_ALPHA] = "_alpha";
            namemap[SaveBase.TYPE_FONT] = "font";
            namemap[SaveBase.TYPE_LINEWIDTH] = "lineWidth";
            namemap[SaveBase.TYPE_ENABLEMERGE] = "_mergeID";
            namemap[SaveBase.TYPE_MARK] = namemap[SaveBase.TYPE_TRANSFORM] = namemap[SaveBase.TYPE_TRANSLATE] = [];
            namemap[SaveBase.TYPE_TEXTBASELINE] = "textBaseline";
            namemap[SaveBase.TYPE_TEXTALIGN] = "textAlign";
            namemap[SaveBase.TYPE_GLOBALCOMPOSITEOPERATION] = "_nBlendType";
            namemap[SaveBase.TYPE_SHADER] = "shader";
            namemap[SaveBase.TYPE_FILTERS] = "filters";
            return namemap;
        }
        isSaveMark() { return false; }
        restore(runner) {
            this._dataObj[this._valueName] = this._value;
            SaveBase.POOL[SaveBase.POOL._length++] = this;
            this._newSubmit && runner.breakNextMerge();
        }
        static save(runner, type, dataObj, newSubmit) {
            if ((runner._saveMark._saveuse & type) !== type) {
                runner._saveMark._saveuse |= type;
                var cache = SaveBase.POOL;
                var o = cache._length > 0 ? cache[--cache._length] : (new SaveBase());
                o._value = dataObj[o._valueName = SaveBase._namemap[type]];
                o._dataObj = dataObj;
                o._newSubmit = newSubmit;
                var _save = runner._save;
                _save[_save._length++] = o;
            }
        }
    }
    SaveBase.TYPE_ALPHA = 0x1;
    SaveBase.TYPE_STYLE = 0x2;
    SaveBase.TYPE_FONT = 0x8;
    SaveBase.TYPE_LINEWIDTH = 0x100;
    SaveBase.TYPE_MARK = 0x400;
    SaveBase.TYPE_TRANSFORM = 0x800;
    SaveBase.TYPE_TRANSLATE = 0x1000;
    SaveBase.TYPE_ENABLEMERGE = 0x2000;
    SaveBase.TYPE_TEXTBASELINE = 0x4000;
    SaveBase.TYPE_TEXTALIGN = 0x8000;
    SaveBase.TYPE_GLOBALCOMPOSITEOPERATION = 0x10000;
    SaveBase.TYPE_CLIPRECT = 0x20000;
    SaveBase.TYPE_CLIPRECT_STENCIL = 0x40000;
    SaveBase.TYPE_IBVB = 0x80000;
    SaveBase.TYPE_SHADER = 0x100000;
    SaveBase.TYPE_FILTERS = 0x200000;
    SaveBase.TYPE_FILTERS_TYPE = 0x400000;
    SaveBase.POOL = SaveBase._createArray();
    SaveBase._namemap = SaveBase._init();

    class SaveClipRect {
        constructor() {
            this._globalClipMatrix = new Matrix();
            this._clipInfoID = -1;
            this._clipRect = new Rectangle();
            this._clip_x = 0;
            this._clip_y = 0;
        }
        isSaveMark() { return false; }
        restore(runner) {
            if (this._clipRect.width == SaveClipRect.MAX.width
                && this._clipRect.height == SaveClipRect.MAX.height
                && this._clip_x == SaveClipRect.MAX.x
                && this._clip_y == SaveClipRect.MAX.y) {
                runner._clipRect = SaveClipRect.MAX;
            }
            else {
                this._clipRect.clone(runner._clipRect);
            }
            runner._clip_x = this._clip_x;
            runner._clip_y = this._clip_y;
            this._globalClipMatrix.copyTo(runner._globalClipMatrix);
            runner._clipInfoID = this._clipInfoID;
            SaveClipRect.POOL[SaveClipRect.POOL._length++] = this;
        }
        static save(runner) {
            if ((runner._saveMark._saveuse & SaveBase.TYPE_CLIPRECT) == SaveBase.TYPE_CLIPRECT)
                return;
            runner._saveMark._saveuse |= SaveBase.TYPE_CLIPRECT;
            var cache = SaveClipRect.POOL;
            var o = cache._length > 0 ? cache[--cache._length] : (new SaveClipRect());
            runner._globalClipMatrix.copyTo(o._globalClipMatrix);
            runner._clipRect.clone(o._clipRect);
            o._clipInfoID = runner._clipInfoID;
            o._clip_x = runner._clip_x;
            o._clip_y = runner._clip_y;
            var _save = runner._save;
            _save[_save._length++] = o;
        }
    }
    SaveClipRect.MAX = new Rectangle(0, 0, Const.MAX_CLIP_SIZE, Const.MAX_CLIP_SIZE);
    SaveClipRect.POOL = SaveBase._createArray();

    class SaveStyle {
        constructor() {
        }
        isSaveMark() {
            return false;
        }
        restore(runner) {
            runner["_" + this._key] = this._fillStyle;
            runner._submitKey.other = this._other;
            SaveStyle.POOL[SaveStyle.POOL._length++] = this;
        }
        static save(runner, key) {
            let _saveMark = runner._saveMark;
            if ((_saveMark._saveuse & SaveBase.TYPE_STYLE) === SaveBase.TYPE_STYLE)
                return;
            _saveMark._saveuse |= SaveBase.TYPE_STYLE;
            let no = SaveStyle.POOL;
            let o = no._length > 0 ? no[--no._length] : (new SaveStyle());
            o._fillStyle = runner[key];
            o._other = runner._submitKey.other;
            o._key = key;
        }
    }
    SaveStyle.POOL = SaveBase._createArray();

    class SaveMark {
        constructor() {
            this._saveuse = 0;
        }
        isSaveMark() {
            return true;
        }
        restore(runner) {
            runner._saveMark = this._preSaveMark;
            SaveMark.POOL[SaveMark.POOL._length++] = this;
        }
        static Create(runner) {
            var no = SaveMark.POOL;
            var o = no._length > 0 ? no[--no._length] : (new SaveMark());
            o._saveuse = 0;
            o._preSaveMark = runner._saveMark;
            runner._saveMark = o;
            return o;
        }
    }
    SaveMark.POOL = SaveBase._createArray();

    class SaveTransform {
        constructor() {
            this._matrix = new Matrix();
        }
        isSaveMark() { return false; }
        restore(runner) {
            runner._curMat = this._savematrix;
            runner._matrixChanged = false;
            SaveTransform.POOL[SaveTransform.POOL._length++] = this;
        }
        static save(runner) {
            var _saveMark = runner._saveMark;
            if ((_saveMark._saveuse & SaveBase.TYPE_TRANSFORM) === SaveBase.TYPE_TRANSFORM)
                return;
            _saveMark._saveuse |= SaveBase.TYPE_TRANSFORM;
            var no = SaveTransform.POOL;
            var o = no._length > 0 ? no[--no._length] : (new SaveTransform());
            o._savematrix = runner._curMat;
            runner._curMat = runner._curMat.copyTo(o._matrix);
            var _save = runner._save;
            _save[_save._length++] = o;
        }
    }
    SaveTransform.POOL = SaveBase._createArray();

    class SaveTranslate {
        constructor() {
            this._mat = new Matrix();
        }
        isSaveMark() { return false; }
        restore(runner) {
            this._mat.copyTo(runner._curMat);
            SaveTranslate.POOL[SaveTranslate.POOL._length++] = this;
        }
        static save(runner) {
            var no = SaveTranslate.POOL;
            var o = no._length > 0 ? no[--no._length] : (new SaveTranslate());
            runner._curMat.copyTo(o._mat);
            var _save = runner._save;
            _save[_save._length++] = o;
        }
    }
    SaveTranslate.POOL = SaveBase._createArray();

    const precision = 1e-13;
    const tempData = new Array(256);
    const vec2$1 = new Vector2();
    class BasePoly {
        static createLine2(p, indices, lineWidth, indexBase, outVertex, loop) {
            if (p.length < 4)
                return null;
            let offset = indexBase;
            var points = tempData.length > (p.length + 2) ? tempData : new Array(p.length + 2);
            points[0] = p[0];
            points[1] = p[1];
            var newlen = 2;
            var i = 0;
            var length = p.length;
            for (i = 2; i < length; i += 2) {
                if (Math.abs(p[i] - p[i - 2]) + Math.abs(p[i + 1] - p[i - 1]) > 0.01) {
                    points[newlen++] = p[i];
                    points[newlen++] = p[i + 1];
                }
            }
            let delta = Math.abs(p[0] - points[newlen - 2]) + Math.abs(p[1] - points[newlen - 1]);
            if (loop && delta > 0) {
                if (delta > precision) {
                    points[newlen++] = p[0];
                    points[newlen++] = p[1];
                }
                else {
                    points[newlen - 2] = p[0];
                    points[newlen - 1] = p[1];
                }
            }
            var result = outVertex;
            let startIndex = result.length;
            length = newlen / 2;
            var w = lineWidth / 2;
            let x1 = points[0];
            let y1 = points[1];
            let x2 = points[2];
            let y2 = points[3];
            let x3, y3;
            this.getNormal(x1, y1, x2, y2, w, vec2$1);
            result.push(x1 - vec2$1.x, y1 - vec2$1.y, x1 + vec2$1.x, y1 + vec2$1.y);
            let verIndex = [];
            let cVerIndex = 0;
            for (i = 1; i < length - 1; i++) {
                x1 = points[(i - 1) * 2];
                y1 = points[(i - 1) * 2 + 1];
                x2 = points[(i) * 2];
                y2 = points[(i) * 2 + 1];
                x3 = points[(i + 1) * 2];
                y3 = points[(i + 1) * 2 + 1];
                cVerIndex = this._setMiddleVertexs(x1, y1, x2, y2, x3, y3, w, result, vec2$1, verIndex, cVerIndex);
            }
            x1 = points[newlen - 4];
            y1 = points[newlen - 3];
            x2 = points[newlen - 2];
            y2 = points[newlen - 1];
            if (x2 == points[0] && y2 == points[1]) {
                x3 = points[2];
                y3 = points[3];
                cVerIndex = this._setMiddleVertexs(x1, y1, x2, y2, x3, y3, w, result, vec2$1, verIndex, cVerIndex);
                let len = result.length;
                result[startIndex] = result[len - 4];
                result[startIndex + 1] = result[len - 3];
                result[startIndex + 2] = result[len - 2];
                result[startIndex + 3] = result[len - 1];
                verIndex.push(cVerIndex, cVerIndex + 1, 1, cVerIndex + 1, 1, 0);
            }
            else {
                this.getNormal(x1, y1, x2, y2, w, vec2$1);
                result.push(x2 - vec2$1.x, y2 - vec2$1.y, x2 + vec2$1.x, y2 + vec2$1.y);
                verIndex.push(cVerIndex, cVerIndex + 1, cVerIndex + 2, cVerIndex + 1, cVerIndex + 2, cVerIndex + 3);
            }
            for (let i = 0, len = verIndex.length; i < len; i++) {
                const pIndex = verIndex[i] + offset;
                indices.push(pIndex);
            }
            return result;
        }
        static _setMiddleVertexs(x1, y1, x2, y2, x3, y3, w, vertexs, out, verIndex, cVerIndex) {
            this.getNormal(x1, y1, x2, y2, w, out);
            let pl1x = x1 - out.x;
            let pl1y = y1 - out.y;
            let pl2x = x2 - out.x;
            let pl2y = y2 - out.y;
            let pr1x = x1 + out.x;
            let pr1y = y1 + out.y;
            let pr2x = x2 + out.x;
            let pr2y = y2 + out.y;
            this.getNormal(x2, y2, x3, y3, w, out);
            let pl3x = x2 - out.x;
            let pl3y = y2 - out.y;
            let pl4x = x3 - out.x;
            let pl4y = y3 - out.y;
            let pr3x = x2 + out.x;
            let pr3y = y2 + out.y;
            let pr4x = x3 + out.x;
            let pr4y = y3 + out.y;
            let addCount = 1;
            let count = BasePoly.checkCrossPoint(pl1x, pl1y, pl2x, pl2y, pl3x, pl3y, pl4x, pl4y, vertexs, pr1x, pr1y, pr4x, pr4y, x2, y2, w);
            if (false === count) {
                return this._createSimpleLineVertices(x1, y1, x2, y2, x3, y3, vertexs, verIndex, cVerIndex, pr2x, pr2y, pl2x, pl2y);
            }
            else {
                addCount = BasePoly.checkCrossPoint(pr1x, pr1y, pr2x, pr2y, pr3x, pr3y, pr4x, pr4y, vertexs, pl1x, pl1y, pl4x, pl4y, x2, y2, w);
                if (false === addCount) {
                    vertexs.splice(vertexs.length - count * 2, count * 2);
                    return this._createSimpleLineVertices(x1, y1, x2, y2, x3, y3, vertexs, verIndex, cVerIndex, pr2x, pr2y, pl2x, pl2y);
                }
            }
            if (2 === addCount) {
                this._setTurnPoint(vertexs, 2);
                verIndex.push(cVerIndex, cVerIndex + 1, cVerIndex + 3, cVerIndex + 1, cVerIndex + 3, cVerIndex + 2);
                cVerIndex += 2;
                verIndex.push(cVerIndex, cVerIndex + 1, cVerIndex + 2);
                cVerIndex += 1;
            }
            else {
                if (2 === count) {
                    verIndex.push(cVerIndex, cVerIndex + 1, cVerIndex + 2, cVerIndex + 1, cVerIndex + 2, cVerIndex + 4);
                    cVerIndex += 2;
                    verIndex.push(cVerIndex, cVerIndex + 1, cVerIndex + 2);
                    cVerIndex += 1;
                }
                else {
                    verIndex.push(cVerIndex, cVerIndex + 1, cVerIndex + 2, cVerIndex + 1, cVerIndex + 2, cVerIndex + 3);
                    cVerIndex += 2;
                }
            }
            return cVerIndex;
        }
        static angleBetweenPoints(x1, y1, x2, y2, x3, y3) {
            const v1x = x1 - x2;
            const v1y = y1 - y2;
            const v2x = x3 - x2;
            const v2y = y3 - y2;
            const dot = v1x * v2x + v1y * v2y;
            const len1 = Math.hypot(v1x, v1y);
            const len2 = Math.hypot(v2x, v2y);
            if (len1 === 0 || len2 === 0)
                return 0;
            let cosTheta = dot / (len1 * len2);
            cosTheta = Math.min(1, Math.max(-1, cosTheta));
            return Math.acos(cosTheta);
        }
        static _createSimpleLineVertices(x1, y1, x2, y2, x3, y3, vertexs, verIndex, cVerIndex, pr2x, pr2y, pl2x, pl2y) {
            let angle = this.angleBetweenPoints(x1, y1, x2, y2, x3, y3);
            if (angle > Math.PI / 2) {
                vertexs.push(pl2x, pl2y, pr2x, pr2y);
                verIndex.push(cVerIndex, cVerIndex + 1, cVerIndex + 2, cVerIndex + 1, cVerIndex + 2, cVerIndex + 3);
                cVerIndex += 2;
                return cVerIndex;
            }
            vertexs.push(pr2x, pr2y, pl2x, pl2y);
            verIndex.push(cVerIndex, cVerIndex + 1, cVerIndex + 3, cVerIndex + 1, cVerIndex + 3, cVerIndex + 2);
            cVerIndex += 2;
            return cVerIndex;
        }
        static _setTurnPoint(vertexs, position = 0) {
            let p3x = vertexs[vertexs.length - 2 - position];
            let p3y = vertexs[vertexs.length - 1 - position];
            let p4x = vertexs[vertexs.length - 4 - position];
            let p4y = vertexs[vertexs.length - 3 - position];
            vertexs[vertexs.length - 2 - position] = p4x;
            vertexs[vertexs.length - 1 - position] = p4y;
            vertexs[vertexs.length - 4 - position] = p3x;
            vertexs[vertexs.length - 3 - position] = p3y;
        }
        static checkCrossPoint(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y, vertexs, pp1x, pp1y, pp4x, pp4y, cpx, cpy, wnum) {
            const crossPoint = this.getCrossPoint(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y, true);
            if (crossPoint) {
                vertexs.push(crossPoint.x, crossPoint.y);
                return 1;
            }
            else if (false === crossPoint) {
                return false;
            }
            const crossPoint1 = this.getCrossPoint(pp1x, pp1y, p1x, p1y, p3x, p3y, p4x, p4y, true);
            if (crossPoint1) {
                return false;
            }
            else {
                const crossPoint2 = this.getCrossPoint(p1x, p1y, p2x, p2y, p4x, p4y, pp4x, pp4y, true);
                if (crossPoint2) {
                    return false;
                }
            }
            const crossPoint3 = this.getCrossPoint(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y);
            if (crossPoint3) {
                const d = Math.abs(this.getDistance(cpx, cpy, crossPoint3.x, crossPoint3.y));
                const maxNum = wnum * 1.5;
                if (d > maxNum) {
                    vertexs.push(p2x, p2y);
                    vertexs.push(p3x, p3y);
                    return 2;
                }
                vertexs.push(crossPoint3.x, crossPoint3.y);
                return 1;
            }
            return false;
        }
        static getCrossPoint(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y, isLineSegment = false) {
            const dx1 = p2x - p1x;
            const dy1 = p2y - p1y;
            const dx2 = p4x - p3x;
            const dy2 = p4y - p3y;
            const denominator = dx1 * dy2 - dx2 * dy1;
            if (Math.abs(denominator) < 1e-10) {
                return false;
            }
            const t1 = ((p3x - p1x) * dy2 - (p3y - p1y) * dx2) / denominator;
            const t2 = ((p3x - p1x) * dy1 - (p3y - p1y) * dx1) / denominator;
            if (isLineSegment) {
                if (t1 < 0 || t1 > 1) {
                    return null;
                }
                if (t2 < 0 || t2 > 1) {
                    return null;
                }
            }
            const x = p1x + t1 * dx1;
            const y = p1y + t1 * dy1;
            return { x, y };
        }
        static getDistance(x1, y1, x2, y2) {
            return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
        }
        static getNormal(x1, y1, x2, y2, w, out) {
            if (!out) {
                out = new Vector2();
            }
            let perpx = y2 - y1;
            let perpy = x1 - x2;
            let dist = Math.sqrt(perpx * perpx + perpy * perpy);
            out.x = perpx / dist * w;
            out.y = perpy / dist * w;
            return out;
        }
        static createLineTriangle(path, color, width, loop, outvb, vbstride, outib) {
            var points = path.slice();
            var ptlen = points.length;
            var p1x = points[0], p1y = points[1];
            var p2x = points[2], p2y = points[2];
            var len = 0;
            var rp = 0;
            var dx = 0, dy = 0;
            var pointnum = ptlen / 2;
            if (pointnum <= 1)
                return;
            if (pointnum == 2) {
                return;
            }
            var tmpData = new Array(pointnum * 4);
            var realPtNum = 0;
            var ci = 0;
            for (var i = 0; i < pointnum - 1; i++) {
                p1x = points[ci++], p1y = points[ci++];
                p2x = points[ci++], p2y = points[ci++];
                dx = p2x - p1x, dy = p2y - p1y;
                if (dx != 0 && dy != 0) {
                    len = Math.sqrt(dx * dx + dy * dy);
                    if (len > 1e-3) {
                        rp = realPtNum * 4;
                        tmpData[rp] = p1x;
                        tmpData[rp + 1] = p1y;
                        tmpData[rp + 2] = dx / len;
                        tmpData[rp + 3] = dy / len;
                        realPtNum++;
                    }
                }
            }
            if (loop) {
                p1x = points[ptlen - 2], p1y = points[ptlen - 1];
                p2x = points[0], p2y = points[1];
                dx = p2x - p1x, dy = p2y - p1y;
                if (dx != 0 && dy != 0) {
                    len = Math.sqrt(dx * dx + dy * dy);
                    if (len > 1e-3) {
                        rp = realPtNum * 4;
                        tmpData[rp] = p1x;
                        tmpData[rp + 1] = p1y;
                        tmpData[rp + 2] = dx / len;
                        tmpData[rp + 3] = dy / len;
                        realPtNum++;
                    }
                }
            }
            else {
                rp = realPtNum * 4;
                tmpData[rp] = p1x;
                tmpData[rp + 1] = p1y;
                tmpData[rp + 2] = dx / len;
                tmpData[rp + 3] = dy / len;
                realPtNum++;
            }
            ci = 0;
            for (i = 0; i < pointnum; i++) {
                p1x = points[ci], p1y = points[ci + 1];
                p2x = points[ci + 2], p2y = points[ci + 3];
            }
        }
    }

    class EarcutNode {
        constructor(i, x, y) {
            this.i = i;
            this.x = x;
            this.y = y;
            this.prev = null;
            this.next = null;
            this.z = null;
            this.prevZ = null;
            this.nextZ = null;
            this.steiner = false;
        }
    }

    class Earcut {
        static earcut(data, holeIndices, dim) {
            dim = dim || 2;
            var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = Earcut.linkedList(data, 0, outerLen, dim, true), triangles = [];
            if (!outerNode)
                return triangles;
            var minX, minY, maxX, maxY, x, y, invSize;
            if (hasHoles)
                outerNode = Earcut.eliminateHoles(data, holeIndices, outerNode, dim);
            if (data.length > 80 * dim) {
                minX = maxX = data[0];
                minY = maxY = data[1];
                for (var i = dim; i < outerLen; i += dim) {
                    x = data[i];
                    y = data[i + 1];
                    if (x < minX)
                        minX = x;
                    if (y < minY)
                        minY = y;
                    if (x > maxX)
                        maxX = x;
                    if (y > maxY)
                        maxY = y;
                }
                invSize = Math.max(maxX - minX, maxY - minY);
                invSize = invSize !== 0 ? 1 / invSize : 0;
            }
            Earcut.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
            return triangles;
        }
        static linkedList(data, start, end, dim, clockwise) {
            var i, last;
            if (clockwise === (Earcut.signedArea(data, start, end, dim) > 0)) {
                for (i = start; i < end; i += dim)
                    last = Earcut.insertNode(i, data[i], data[i + 1], last);
            }
            else {
                for (i = end - dim; i >= start; i -= dim)
                    last = Earcut.insertNode(i, data[i], data[i + 1], last);
            }
            if (last && Earcut.equals(last, last.next)) {
                Earcut.removeNode(last);
                last = last.next;
            }
            return last;
        }
        static filterPoints(start, end) {
            if (!start)
                return start;
            if (!end)
                end = start;
            var p = start, again;
            do {
                again = false;
                if (!p.steiner && (Earcut.equals(p, p.next) || Earcut.area(p.prev, p, p.next) === 0)) {
                    Earcut.removeNode(p);
                    p = end = p.prev;
                    if (p === p.next)
                        break;
                    again = true;
                }
                else {
                    p = p.next;
                }
            } while (again || p !== end);
            return end;
        }
        static earcutLinked(ear, triangles, dim, minX, minY, invSize, pass = null) {
            if (!ear)
                return;
            if (!pass && invSize)
                Earcut.indexCurve(ear, minX, minY, invSize);
            var stop = ear, prev, next;
            while (ear.prev !== ear.next) {
                prev = ear.prev;
                next = ear.next;
                if (invSize ? Earcut.isEarHashed(ear, minX, minY, invSize) : Earcut.isEar(ear)) {
                    triangles.push(prev.i / dim);
                    triangles.push(ear.i / dim);
                    triangles.push(next.i / dim);
                    Earcut.removeNode(ear);
                    ear = next.next;
                    stop = next.next;
                    continue;
                }
                ear = next;
                if (ear === stop) {
                    if (!pass) {
                        Earcut.earcutLinked(Earcut.filterPoints(ear, null), triangles, dim, minX, minY, invSize, 1);
                    }
                    else if (pass === 1) {
                        ear = Earcut.cureLocalIntersections(ear, triangles, dim);
                        Earcut.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                    }
                    else if (pass === 2) {
                        Earcut.splitEarcut(ear, triangles, dim, minX, minY, invSize);
                    }
                    break;
                }
            }
        }
        static isEar(ear) {
            var a = ear.prev, b = ear, c = ear.next;
            if (Earcut.area(a, b, c) >= 0)
                return false;
            var p = ear.next.next;
            while (p !== ear.prev) {
                if (Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.next;
            }
            return true;
        }
        static isEarHashed(ear, minX, minY, invSize) {
            var a = ear.prev, b = ear, c = ear.next;
            if (Earcut.area(a, b, c) >= 0)
                return false;
            var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
            var minZ = Earcut.zOrder(minTX, minTY, minX, minY, invSize), maxZ = Earcut.zOrder(maxTX, maxTY, minX, minY, invSize);
            var p = ear.nextZ;
            while (p && p.z <= maxZ) {
                if (p !== ear.prev && p !== ear.next &&
                    Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.nextZ;
            }
            p = ear.prevZ;
            while (p && p.z >= minZ) {
                if (p !== ear.prev && p !== ear.next &&
                    Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.prevZ;
            }
            return true;
        }
        static cureLocalIntersections(start, triangles, dim) {
            var p = start;
            do {
                var a = p.prev, b = p.next.next;
                if (!Earcut.equals(a, b) && Earcut.intersects(a, p, p.next, b) && Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a)) {
                    triangles.push(a.i / dim);
                    triangles.push(p.i / dim);
                    triangles.push(b.i / dim);
                    Earcut.removeNode(p);
                    Earcut.removeNode(p.next);
                    p = start = b;
                }
                p = p.next;
            } while (p !== start);
            return p;
        }
        static splitEarcut(start, triangles, dim, minX, minY, invSize) {
            var a = start;
            do {
                var b = a.next.next;
                while (b !== a.prev) {
                    if (a.i !== b.i && Earcut.isValidDiagonal(a, b)) {
                        var c = Earcut.splitPolygon(a, b);
                        a = Earcut.filterPoints(a, a.next);
                        c = Earcut.filterPoints(c, c.next);
                        Earcut.earcutLinked(a, triangles, dim, minX, minY, invSize);
                        Earcut.earcutLinked(c, triangles, dim, minX, minY, invSize);
                        return;
                    }
                    b = b.next;
                }
                a = a.next;
            } while (a !== start);
        }
        static eliminateHoles(data, holeIndices, outerNode, dim) {
            var queue = [], i, len, start, end, list;
            for (i = 0, len = holeIndices.length; i < len; i++) {
                start = holeIndices[i] * dim;
                end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                list = Earcut.linkedList(data, start, end, dim, false);
                if (list === list.next)
                    list.steiner = true;
                queue.push(Earcut.getLeftmost(list));
            }
            queue.sort(Earcut.compareX);
            for (i = 0; i < queue.length; i++) {
                Earcut.eliminateHole(queue[i], outerNode);
                outerNode = Earcut.filterPoints(outerNode, outerNode.next);
            }
            return outerNode;
        }
        static compareX(a, b) {
            return a.x - b.x;
        }
        static eliminateHole(hole, outerNode) {
            outerNode = Earcut.findHoleBridge(hole, outerNode);
            if (outerNode) {
                var b = Earcut.splitPolygon(outerNode, hole);
                Earcut.filterPoints(b, b.next);
            }
        }
        static findHoleBridge(hole, outerNode) {
            var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
            do {
                if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                    var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                    if (x <= hx && x > qx) {
                        qx = x;
                        if (x === hx) {
                            if (hy === p.y)
                                return p;
                            if (hy === p.next.y)
                                return p.next;
                        }
                        m = p.x < p.next.x ? p : p.next;
                    }
                }
                p = p.next;
            } while (p !== outerNode);
            if (!m)
                return null;
            if (hx === qx)
                return m.prev;
            var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
            p = m.next;
            while (p !== stop) {
                if (hx >= p.x && p.x >= mx && hx !== p.x &&
                    Earcut.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                    tan = Math.abs(hy - p.y) / (hx - p.x);
                    if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && Earcut.locallyInside(p, hole)) {
                        m = p;
                        tanMin = tan;
                    }
                }
                p = p.next;
            }
            return m;
        }
        static indexCurve(start, minX, minY, invSize) {
            var p = start;
            do {
                if (p.z === null)
                    p.z = Earcut.zOrder(p.x, p.y, minX, minY, invSize);
                p.prevZ = p.prev;
                p.nextZ = p.next;
                p = p.next;
            } while (p !== start);
            p.prevZ.nextZ = null;
            p.prevZ = null;
            Earcut.sortLinked(p);
        }
        static sortLinked(list) {
            var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
            do {
                p = list;
                list = null;
                tail = null;
                numMerges = 0;
                while (p) {
                    numMerges++;
                    q = p;
                    pSize = 0;
                    for (i = 0; i < inSize; i++) {
                        pSize++;
                        q = q.nextZ;
                        if (!q)
                            break;
                    }
                    qSize = inSize;
                    while (pSize > 0 || (qSize > 0 && q)) {
                        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                            e = p;
                            p = p.nextZ;
                            pSize--;
                        }
                        else {
                            e = q;
                            q = q.nextZ;
                            qSize--;
                        }
                        if (tail)
                            tail.nextZ = e;
                        else
                            list = e;
                        e.prevZ = tail;
                        tail = e;
                    }
                    p = q;
                }
                tail.nextZ = null;
                inSize *= 2;
            } while (numMerges > 1);
            return list;
        }
        static zOrder(x, y, minX, minY, invSize) {
            x = 32767 * (x - minX) * invSize;
            y = 32767 * (y - minY) * invSize;
            x = (x | (x << 8)) & 0x00FF00FF;
            x = (x | (x << 4)) & 0x0F0F0F0F;
            x = (x | (x << 2)) & 0x33333333;
            x = (x | (x << 1)) & 0x55555555;
            y = (y | (y << 8)) & 0x00FF00FF;
            y = (y | (y << 4)) & 0x0F0F0F0F;
            y = (y | (y << 2)) & 0x33333333;
            y = (y | (y << 1)) & 0x55555555;
            return x | (y << 1);
        }
        static getLeftmost(start) {
            var p = start, leftmost = start;
            do {
                if (p.x < leftmost.x)
                    leftmost = p;
                p = p.next;
            } while (p !== start);
            return leftmost;
        }
        static pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
            return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
                (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
                (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
        }
        static isValidDiagonal(a, b) {
            return a.next.i !== b.i && a.prev.i !== b.i && !Earcut.intersectsPolygon(a, b) &&
                Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a) && Earcut.middleInside(a, b);
        }
        static area(p, q, r) {
            return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        }
        static equals(p1, p2) {
            return p1.x === p2.x && p1.y === p2.y;
        }
        static intersects(p1, q1, p2, q2) {
            if ((Earcut.equals(p1, q1) && Earcut.equals(p2, q2)) ||
                (Earcut.equals(p1, q2) && Earcut.equals(p2, q1)))
                return true;
            return Earcut.area(p1, q1, p2) > 0 !== Earcut.area(p1, q1, q2) > 0 &&
                Earcut.area(p2, q2, p1) > 0 !== Earcut.area(p2, q2, q1) > 0;
        }
        static intersectsPolygon(a, b) {
            var p = a;
            do {
                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                    Earcut.intersects(p, p.next, a, b))
                    return true;
                p = p.next;
            } while (p !== a);
            return false;
        }
        static locallyInside(a, b) {
            return Earcut.area(a.prev, a, a.next) < 0 ?
                Earcut.area(a, b, a.next) >= 0 && Earcut.area(a, a.prev, b) >= 0 :
                Earcut.area(a, b, a.prev) < 0 || Earcut.area(a, a.next, b) < 0;
        }
        static middleInside(a, b) {
            var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
            do {
                if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                    (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                    inside = !inside;
                p = p.next;
            } while (p !== a);
            return inside;
        }
        static splitPolygon(a, b) {
            var a2 = new EarcutNode(a.i, a.x, a.y), b2 = new EarcutNode(b.i, b.x, b.y), an = a.next, bp = b.prev;
            a.next = b;
            b.prev = a;
            a2.next = an;
            an.prev = a2;
            b2.next = a2;
            a2.prev = b2;
            bp.next = b2;
            b2.prev = bp;
            return b2;
        }
        static insertNode(i, x, y, last) {
            var p = new EarcutNode(i, x, y);
            if (!last) {
                p.prev = p;
                p.next = p;
            }
            else {
                p.next = last.next;
                p.prev = last;
                last.next.prev = p;
                last.next = p;
            }
            return p;
        }
        static removeNode(p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            if (p.prevZ)
                p.prevZ.nextZ = p.nextZ;
            if (p.nextZ)
                p.nextZ.prevZ = p.prevZ;
        }
        static signedArea(data, start, end, dim) {
            var sum = 0;
            for (var i = start, j = end - dim; i < end; i += dim) {
                sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
                j = i;
            }
            return sum;
        }
    }

    const _TEMP_CLIPDIR = new Vector4(Const.MAX_CLIP_SIZE, 0, 0, Const.MAX_CLIP_SIZE);
    class GraphicsShaderInfo {
        constructor() {
            this.shaderData = LayaGL.renderDeviceFactory.createShaderData();
            this.toDefault();
        }
        toDefault() {
            this.clipMatDir = _TEMP_CLIPDIR;
            this.clipMatPos = Vector4.ZERO;
            this.vertexSize = Vector4.ZERO;
            BlendModeHandler.initBlendMode(this.shaderData);
            this.shaderData.addDefine(ShaderDefines2D.TEXTURESHADER);
            this.textureHost = null;
            this.enableVertexSize = false;
            this.materialClip = false;
            this.fillTexture = false;
        }
        get textureHost() {
            return this._textureHost;
        }
        set textureHost(value) {
            this._textureHost = value;
            let textrueReadGamma = false;
            if (this.textureHost) {
                if (this.textureHost instanceof BaseTexture) {
                    textrueReadGamma = this.textureHost.gammaCorrection != 1;
                }
                else if (this.textureHost instanceof Texture && this.textureHost.bitmap) {
                    textrueReadGamma = this.textureHost.bitmap.gammaCorrection != 1;
                }
            }
            if (textrueReadGamma) {
                this.shaderData.addDefine(ShaderDefines2D.GAMMATEXTURE);
            }
            else {
                this.shaderData.removeDefine(ShaderDefines2D.GAMMATEXTURE);
            }
            let tex;
            if (value instanceof Texture) {
                tex = value.bitmap;
            }
            else {
                tex = value;
            }
            if (!tex) {
                tex = Texture2D.whiteTexture;
            }
            this.shaderData.setTexture(ShaderDefines2D.UNIFORM_SPRITETEXTURE, tex);
        }
        set enableVertexSize(value) {
            if (value) {
                this.shaderData.addDefine(ShaderDefines2D.VERTEX_SIZE);
            }
            else {
                this.shaderData.removeDefine(ShaderDefines2D.VERTEX_SIZE);
            }
        }
        get enableVertexSize() {
            return this.shaderData.hasDefine(ShaderDefines2D.VERTEX_SIZE);
        }
        set vertexSize(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_VERTEX_SIZE, value);
        }
        get vertexSize() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_VERTEX_SIZE);
        }
        set materialClip(value) {
            if (value) {
                this.shaderData.addDefine(ShaderDefines2D.MATERIALCLIP);
            }
            else {
                this.shaderData.removeDefine(ShaderDefines2D.MATERIALCLIP);
            }
        }
        get materialClip() {
            return this.shaderData.hasDefine(ShaderDefines2D.MATERIALCLIP);
        }
        set clipMatDir(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_MATERIAL_CLIPMATDIR, value);
        }
        get clipMatDir() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_MATERIAL_CLIPMATDIR);
        }
        set clipMatPos(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_MATERIAL_CLIPMATPOS, value);
        }
        get clipMatPos() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_MATERIAL_CLIPMATPOS);
        }
        get u_TexRange() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_TEXRANGE);
        }
        set u_TexRange(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_TEXRANGE, value);
        }
        set fillTexture(value) {
            if (value) {
                this.shaderData.addDefine(ShaderDefines2D.FILLTEXTURE);
            }
            else {
                this.shaderData.removeDefine(ShaderDefines2D.FILLTEXTURE);
            }
        }
        get fillTexture() {
            return this.shaderData.hasDefine(ShaderDefines2D.FILLTEXTURE);
        }
        cloneTo(shaderData) {
            if (this.enableVertexSize) {
                shaderData.addDefine(ShaderDefines2D.VERTEX_SIZE);
                shaderData.setVector(ShaderDefines2D.UNIFORM_VERTEX_SIZE, this.vertexSize);
            }
            if (this.materialClip) {
                shaderData.addDefine(ShaderDefines2D.MATERIALCLIP);
                shaderData.setVector(ShaderDefines2D.UNIFORM_MATERIAL_CLIPMATDIR, this.clipMatDir);
                shaderData.setVector(ShaderDefines2D.UNIFORM_MATERIAL_CLIPMATPOS, this.clipMatPos);
            }
            let textrueReadGamma = this.shaderData.hasDefine(ShaderDefines2D.GAMMATEXTURE);
            if (textrueReadGamma) {
                shaderData.addDefine(ShaderDefines2D.GAMMATEXTURE);
            }
            else {
                shaderData.removeDefine(ShaderDefines2D.GAMMATEXTURE);
            }
            let tex = this._textureHost.bitmap;
            if (!tex) {
                tex = this._textureHost;
            }
            let fill = this.shaderData.hasDefine(ShaderDefines2D.FILLTEXTURE);
            if (fill) {
                shaderData.addDefine(ShaderDefines2D.FILLTEXTURE);
                shaderData.setVector(ShaderDefines2D.UNIFORM_TEXRANGE, this.u_TexRange);
            }
            else {
                shaderData.removeDefine(ShaderDefines2D.FILLTEXTURE);
            }
            shaderData.setTexture(ShaderDefines2D.UNIFORM_SPRITETEXTURE, tex);
        }
        clear() {
            this.toDefault();
        }
        destroy() {
            this.shaderData.destroy();
            this._textureHost = null;
        }
    }

    class SubmitKey {
        constructor() {
            this.clear();
        }
        clear() {
            this.blendShader = this.other = 0;
        }
    }

    class SubmitBase {
        constructor() {
            this.clipInfoID = -1;
            this._id = 0;
            this._renderType = 0;
            this._key = new SubmitKey();
            this.vertexs = [];
            this.blockIndexs = [];
            this.indexCount = 0;
            this.indices = [];
            this._internalInfo = null;
            this.renderStateIsBySprite = true;
            this._id = ++SubmitBase.ID;
        }
        clear() {
            this._key.clear();
            this._internalInfo.clear();
            this.material = null;
            if (this.mesh) {
                this.mesh.clearBlocks(this.blockIndexs);
                this.mesh.clearIndexView(this.indexView);
                this.vertexs.length = 0;
                this.blockIndexs.length = 0;
                this.mesh = null;
            }
        }
        destroy() {
            this.clear();
            if (this.indexView) {
                this.indexView.destroy();
                this.indexView = null;
            }
            this._internalInfo.destroy();
            this._internalInfo = null;
        }
        appendData(info) {
            this.blockIndexs.push(...info.vertexBlocks);
            let vertexBlock = LayaGL.render2DRenderPassFactory.createGraphic2DVertexBlock();
            vertexBlock.positions = info.positions;
            vertexBlock.vertexViews = info.vertexViews;
            this.vertexs.push(vertexBlock);
        }
        update(runner, mesh, material) {
            var blendType = runner._nBlendType;
            let struct = runner.sprite._struct;
            let sBlendMode = struct.blendMode;
            this._key.blendShader = blendType;
            if (runner.globalCompositeOperation != sBlendMode) {
                BlendModeHandler.setShaderData(blendType, this._internalInfo.shaderData);
                this.renderStateIsBySprite = false;
            }
            this.mesh = mesh;
            this.material = material;
        }
        static create(runner, mesh, material) {
            var o = new SubmitBase();
            o._internalInfo = new GraphicsShaderInfo();
            o.update(runner, mesh, material);
            return o;
        }
    }
    SubmitBase.ID = 1;
    SubmitBase.RENDERBASE = new SubmitBase();

    class TextRenderConfig {
    }
    TextRenderConfig.maxCanvasWidth = 4096;
    TextRenderConfig.atlasWidth = 1024;
    TextRenderConfig.atlasGridW = 16;
    TextRenderConfig.standardFontSize = 32;
    TextRenderConfig.noAtlas = false;
    TextRenderConfig.forceSplitRender = false;
    TextRenderConfig.forceWholeRender = false;
    TextRenderConfig.scaleFontWithCtx = true;
    TextRenderConfig.maxFontScale = 3;
    TextRenderConfig.fontScale = 1;
    TextRenderConfig.destroyAtlasDt = 10;
    TextRenderConfig.checkCleanTextureDt = 2000;
    TextRenderConfig.destroyUnusedTextureDt = 10;
    TextRenderConfig.cleanMem = 100 * 1024 * 1024;
    TextRenderConfig.showLog = false;

    function measureFont(ctx, font, bold) {
        let size = TextRenderConfig.standardFontSize;
        ctx.font = (bold ? 'bold ' : '') + size + 'px ' + font;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.textBaseline = "middle";
        ctx.lineWidth = 0;
        ctx.fillStyle = "red";
        let margin = 16;
        const pixelBBX = [0, 0, 0, 0];
        pixelBBX[0] = size / 2;
        pixelBBX[1] = size / 2;
        pixelBBX[2] = size;
        pixelBBX[3] = size;
        drawTestChar(ctx, 'g', size, margin, pixelBBX);
        drawTestChar(ctx, '有', size, margin, pixelBBX);
        drawTestChar(ctx, '🤡', size, margin, pixelBBX, true);
        let xoff = Math.max(margin - pixelBBX[0], 0);
        let yoff = Math.max(margin - pixelBBX[1], 0);
        let bbxw = pixelBBX[2] - pixelBBX[0];
        let bbxh = pixelBBX[3] - pixelBBX[1];
        return { xoff, yoff, bbxw, bbxh };
    }
    function drawTestChar(ctx, char, fontSize, margin, pixelBBX, onlyH) {
        let charWidth = ctx.measureText(char).width;
        let width = charWidth + margin * 2;
        let height = fontSize + margin * 2;
        ctx.clearRect(0, 0, width, height);
        ctx.fillText(char, margin, margin + fontSize / 2);
        let bmp = ctx.getImageData(0, 0, width, height);
        updateBbx(bmp, pixelBBX, onlyH);
    }
    function updateBbx(data, curbbx, onlyH) {
        let bmpData32 = new Uint32Array(data.data.buffer);
        function checkBmpLine(data, l, sx, ex) {
            let stpos = data.width * l + sx;
            for (let x = sx; x < ex; x++) {
                if (bmpData32[stpos++] !== 0)
                    return true;
            }
            return false;
        }
        let w = data.width;
        let h = data.height;
        let x = 0;
        let sy = curbbx[1];
        let ey = 0;
        let y = sy;
        if (checkBmpLine(data, sy, 0, w)) {
            while (true) {
                y = (sy + ey) / 2 | 0;
                if (y + 1 >= sy) {
                    curbbx[1] = y;
                    break;
                }
                if (checkBmpLine(data, y, 0, w)) {
                    sy = y;
                }
                else {
                    ey = y;
                }
            }
        }
        if (curbbx[3] > h)
            curbbx[3] = h;
        else {
            y = sy = curbbx[3];
            ey = h;
            if (checkBmpLine(data, sy, 0, w)) {
                while (true) {
                    y = (sy + ey) / 2 | 0;
                    if (y - 1 <= sy) {
                        curbbx[3] = y;
                        break;
                    }
                    if (checkBmpLine(data, y, 0, w)) {
                        sy = y;
                    }
                    else {
                        ey = y;
                    }
                }
            }
        }
        if (onlyH)
            return;
        let minx = curbbx[0];
        let stpos = w * curbbx[1];
        for (y = curbbx[1]; y < curbbx[3]; y++) {
            for (x = 0; x < minx; x++) {
                if (bmpData32[stpos + x] !== 0) {
                    minx = x;
                    break;
                }
            }
            stpos += w;
        }
        curbbx[0] = minx;
        let maxx = curbbx[2];
        stpos = w * curbbx[1];
        for (y = curbbx[1]; y < curbbx[3]; y++) {
            for (x = maxx; x < w; x++) {
                if (bmpData32[stpos + x] !== 0) {
                    maxx = x;
                    break;
                }
            }
            stpos += w;
        }
        curbbx[2] = maxx;
    }

    exports.WrapMode = void 0;
    (function (WrapMode) {
        WrapMode[WrapMode["Repeat"] = 0] = "Repeat";
        WrapMode[WrapMode["Clamp"] = 1] = "Clamp";
        WrapMode[WrapMode["Mirrored"] = 2] = "Mirrored";
    })(exports.WrapMode || (exports.WrapMode = {}));

    class AtlasGrid {
        constructor(atlasWidth, atlasHeight, cellSize) {
            this.atlasWidth = atlasWidth;
            this.atlasHeight = atlasHeight;
            this.cellSize = cellSize;
            this.cols = Math.floor(this.atlasWidth / this.cellSize);
            this.rows = Math.floor(this.atlasHeight / this.cellSize);
            this.freeCells = this.totalCells = this.cols * this.rows;
            this.columnHeights = new Uint8Array(this.cols);
        }
        allocate(widthPx, heightPx) {
            if (widthPx <= 0 || heightPx <= 0)
                return null;
            const cs = this.cellSize;
            const cw = Math.ceil(widthPx / cs);
            const ch = Math.ceil(heightPx / cs);
            if (cw <= 0 || ch <= 0)
                return null;
            if (cw > this.cols || ch > this.rows)
                return null;
            const cols = this.cols;
            const rows = this.rows;
            const heights = this.columnHeights;
            let bestCol = -1;
            let bestHeight = Number.MAX_SAFE_INTEGER;
            outer: for (let c = 0; c <= cols - cw; c++) {
                let maxH = 0;
                for (let cc = c; cc < c + cw; cc++) {
                    const hCol = heights[cc];
                    if (hCol > maxH)
                        maxH = hCol;
                    if (maxH + ch > rows) {
                        continue outer;
                    }
                }
                if (maxH < bestHeight) {
                    bestHeight = maxH;
                    bestCol = c;
                    if (bestHeight === 0)
                        break;
                }
            }
            if (bestCol < 0)
                return null;
            const x = bestCol * cs;
            const y = bestHeight * cs;
            const newH = bestHeight + ch;
            for (let cc = bestCol; cc < bestCol + cw; cc++) {
                const oldH = heights[cc];
                heights[cc] = newH;
                this.freeCells -= (newH - oldH);
            }
            const region = {
                x,
                y,
                w: cw * cs,
                h: ch * cs,
                _cx: cw,
                _cy: ch
            };
            return region;
        }
        reset() {
            if (this.freeCells === this.totalCells)
                return;
            this.columnHeights.fill(0);
            this.freeCells = this.totalCells;
        }
    }

    class TextRender {
        constructor(owner) {
            this.fontMap = new Map();
            this.textAtlases = [];
            this.charMap = new Map();
            this.textMap = new Map();
            this.freeRegions = [];
            this.freeIsoTextures = [];
            this.owner = owner;
            let canvas = Browser.createElement("canvas");
            this.canvas = canvas;
            canvas.width = 1024;
            canvas.height = 512;
            if (Browser.isDomSupported) {
                canvas.style.left = "-10000px";
                canvas.style.position = "absolute";
                Browser.document.body.appendChild(canvas);
            }
            this.ctx = canvas.getContext('2d', { willReadFrequently: true });
            ILaya.systemTimer.loop(5000, this, this.GC);
        }
        draw(text, x, y, font, fontSize, bold, italic, color, stroke, strokeColor, charMode, preMeasuredWidth, renderInfo) {
            let curFont = this.getFont(font);
            let info = bold ? curFont.bold : curFont.normal;
            let k = fontSize / TextRenderConfig.standardFontSize;
            fontSizeOffX = Math.ceil(info.xoff * k);
            fontSizeOffY = Math.ceil(info.yoff * k);
            fontSizeH = Math.ceil(info.bbxh * k);
            fontScale = TextRenderConfig.fontScale;
            italicDeg = italic ? 13 : 0;
            let cacheKey = (curFont.id * 10000) + fontSize + (bold ? "b_" : "_");
            let colorNum = ColorUtils.create(color).numColor;
            let tint = stroke > 0 || !charMode && emojiTest$1.test(text);
            if (tint)
                cacheKey += colorNum + "_";
            if (stroke > 0)
                cacheKey += ColorUtils.create(strokeColor).numColor + "_" + stroke + "_";
            let ctx = this.ctx;
            ctx.font = (bold ? "bold " : "") + fontSize + "px " + font;
            ctx.setTransform(fontScale, 0, 0, fontScale, 0, 0);
            ctx.textBaseline = "middle";
            ctx.fillStyle = tint ? color : 'white';
            if (stroke > 0) {
                ctx.lineJoin = "round";
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = stroke;
            }
            else {
                ctx.lineWidth = 0;
            }
            if (!renderInfo)
                renderInfo = [];
            let drawColor = tint ? 0xffffffff : colorNum;
            if ((charMode || TextRenderConfig.forceSplitRender) && !TextRenderConfig.forceWholeRender) {
                let mat = this.owner._curMat;
                renderInfo.length > 0 && this.freeRenderInfo(renderInfo);
                for (let i = 0, len = text.length; i < len; i++) {
                    let cc = text.charAt(i);
                    let ccode = cc.charCodeAt(0);
                    if (ccode >= 0xD800 && ccode <= 0xDBFF && i + 1 < len)
                        cc += text.charAt(++i);
                    let key = cacheKey + cc;
                    let ri = this.charMap.get(key);
                    if (!ri) {
                        let width = ctx.measureText(cc).width;
                        ri = this.drawOffscreen(ctx, cc, width, fontSize, stroke, true);
                        ri.key = key;
                        ri.isChar = true;
                        this.charMap.set(key, ri);
                    }
                    ri.ref++;
                    renderInfo.push(ri);
                    this.owner._inner_drawTexture(ri.tex, ri.tex.id, x + ri.x, y + ri.y, ri.w, ri.h, mat, ri.uv, 1.0, cc.length > 1 ? 0xffffffff : drawColor, italicDeg, true);
                    x += ri.advance;
                }
            }
            else {
                let key = cacheKey + text;
                let ri = this.textMap.get(key);
                ri && ri.ref++;
                renderInfo[0] && this.free(renderInfo[0]);
                if (!ri) {
                    if (preMeasuredWidth == null)
                        preMeasuredWidth = ctx.measureText(text).width;
                    ri = this.drawOffscreen(ctx, text, preMeasuredWidth, fontSize, stroke, false);
                    ri.key = key;
                    ri.ref = 1;
                    this.textMap.set(key, ri);
                }
                renderInfo[0] = ri;
                this.owner._inner_drawTexture(ri.tex, ri.tex.id, x + ri.x, y + ri.y, ri.w, ri.h, this.owner._curMat, ri.uv, 1.0, drawColor, italicDeg, true);
                for (let i = 1, n = renderInfo.length; i < n; i++)
                    this.free(renderInfo[i]);
                renderInfo.length = 1;
            }
            return renderInfo;
        }
        drawOffscreen(ctx, text, width, height, lineWidth, charMode) {
            let margin = height / 3 | 0 + lineWidth;
            let rectX = ((margin - fontSizeOffX - lineWidth) * fontScale | 0) - blockGap;
            let rectY = ((margin - fontSizeOffY - lineWidth) * fontScale | 0) - blockGap;
            let rectW = Math.ceil((width + lineWidth * 2) * fontScale) + blockGap * 2;
            let rectH = Math.ceil((fontSizeH + lineWidth * 2) * fontScale) + blockGap * 2;
            let needCanvW = Math.min(rectW + Math.ceil(margin * 2 * fontScale), TextRenderConfig.maxCanvasWidth);
            let needCanvH = Math.min(rectH + Math.ceil(margin * 2 * fontScale), TextRenderConfig.maxCanvasWidth);
            if (needCanvW > this.canvas.width || needCanvH > this.canvas.height)
                this.resizeCanvas(ctx, needCanvW, needCanvH);
            ctx.clearRect(0, 0, Math.ceil(needCanvW / fontScale), Math.ceil(needCanvH / fontScale));
            lineWidth > 0 && ctx.strokeText(text, margin, margin + height / 2);
            ctx.fillText(text, margin, margin + height / 2);
            let imgdt = ctx.getImageData(rectX, rectY, rectW, rectH);
            let ri = {
                x: -(fontSizeOffX + lineWidth),
                y: -lineWidth,
                w: (imgdt.width - blockGap * 2) / fontScale,
                h: (imgdt.height - blockGap * 2) / fontScale,
                advance: width,
                uv: new Array(8),
                tex: null,
                region: null,
                ref: 0
            };
            if (imgdt.width > TextRenderConfig.atlasWidth || imgdt.height > TextRenderConfig.atlasWidth
                || !charMode && TextRenderConfig.noAtlas) {
                ri.tex = this.createIsoTexture(imgdt.width, imgdt.height);
                this.setPixelsToTexture(imgdt, ri.tex, 0, 0, ri.uv);
            }
            else {
                ri.region = this.addToAtlas(imgdt.width, imgdt.height);
                ri.tex = ri.region.owner.tex;
                this.setPixelsToTexture(imgdt, ri.tex, ri.region.x, ri.region.y, ri.uv);
            }
            return ri;
        }
        resizeCanvas(ctx, newWidth, newHeight) {
            newWidth = 512 * Math.ceil(newWidth / 512);
            newHeight = 512 * Math.ceil(newHeight / 512);
            let fontStr = ctx.font;
            let fillStyle = ctx.fillStyle;
            let strokeStyle = ctx.strokeStyle;
            let lineWidth = ctx.lineWidth;
            this.canvas.width = newWidth;
            this.canvas.height = newHeight;
            ctx.setTransform(fontScale, 0, 0, fontScale, 0, 0);
            ctx.font = fontStr;
            ctx.textBaseline = "middle";
            ctx.lineJoin = "round";
            ctx.fillStyle = fillStyle;
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = lineWidth;
        }
        createIsoTexture(w, h) {
            let i = this.freeIsoTextures.findIndex(t => t != null && t.width >= w && t.width <= w + h && t.height >= h && t.height <= h + h);
            if (i !== -1) {
                let tex = this.freeIsoTextures[i];
                this.freeIsoTextures[i] = null;
                if (++freeIsoTextureNullCnt > 50) {
                    this.freeIsoTextures = this.freeIsoTextures.filter(t => t != null);
                    freeIsoTextureNullCnt = 0;
                }
                return tex;
            }
            else
                return this.createTextTexture(w, h);
        }
        addToAtlas(w, h) {
            let i = this.freeRegions.findIndex(r => r != null && r.w >= w && r.w <= w + h && r.h >= h && r.h <= h + h);
            if (i !== -1) {
                let region = this.freeRegions[i];
                this.freeRegions[i] = null;
                if (++freeRegionNullCnt > 50) {
                    this.freeRegions = this.freeRegions.filter(r => r != null);
                    freeRegionNullCnt = 0;
                }
                region.owner.ref++;
                return region;
            }
            let region;
            for (let ele of this.textAtlases) {
                if (region = ele.grid.allocate(w, h)) {
                    region.owner = ele;
                    ele.ref++;
                    return region;
                }
            }
            let size = TextRenderConfig.atlasWidth;
            let atlas = {
                tex: this.createTextTexture(size, size),
                grid: new AtlasGrid(size, size, TextRenderConfig.atlasGridW),
                ref: 1
            };
            this.textAtlases.push(atlas);
            region = atlas.grid.allocate(w, h);
            region.owner = atlas;
            return region;
        }
        createTextTexture(width, height) {
            let tex = new Texture2D(width, height, exports.TextureFormat.R8G8B8A8, false, false, true, true);
            tex.name = "TextTexture";
            tex.setPixelsData(null, true, false);
            tex.lock = true;
            tex.filterMode = exports.FilterMode.Bilinear;
            tex.wrapModeU = exports.WrapMode.Clamp;
            tex.wrapModeV = exports.WrapMode.Clamp;
            return tex;
        }
        setPixelsToTexture(imgdt, tex, x, y, outUv) {
            let data = imgdt.data;
            if (data instanceof Uint8ClampedArray)
                data = new Uint8Array(data.buffer);
            LayaGL.textureContext.setTextureSubPixelsData(tex._texture, data, 0, false, x, y, imgdt.width, imgdt.height, true, false);
            let u0 = (x + blockGap) / tex.width;
            let v0 = (y + blockGap) / tex.height;
            let u1 = (x + imgdt.width - blockGap) / tex.width;
            let v1 = (y + imgdt.height - blockGap) / tex.height;
            outUv[0] = u0, outUv[1] = v0;
            outUv[2] = u1, outUv[3] = v0;
            outUv[4] = u1, outUv[5] = v1;
            outUv[6] = u0, outUv[7] = v1;
        }
        freeRenderInfo(arr) {
            for (let ri of arr) {
                this.free(ri);
            }
            arr.length = 0;
        }
        free(ri) {
            ri.ref--;
            if (ri.ref > 0)
                return;
            if (ri.isChar) {
                if (ri.ref === 0)
                    return;
                this.charMap.delete(ri.key);
            }
            else
                this.textMap.delete(ri.key);
            if (ri.region != null) {
                let atlas = ri.region.owner;
                atlas.ref--;
                if (atlas.ref === 0) {
                    if (this.freeRegions.length > 0)
                        this.freeRegions = this.freeRegions.filter(r => r != null && r.owner !== atlas);
                    freeRegionNullCnt = 0;
                    if (this.textAtlases.length > 2 && this.textAtlases.findIndex((a) => a.ref === 0) !== -1) {
                        atlas.tex.destroy();
                        let idx = this.textAtlases.indexOf(atlas);
                        this.textAtlases.splice(idx, 1);
                    }
                    else {
                        atlas.grid.reset();
                    }
                }
                else
                    this.freeRegions.push(ri.region);
            }
            else {
                this.freeIsoTextures.push(ri.tex);
            }
        }
        getFontHeight(font, fontSize, bold) {
            let inst = this.getFont(font);
            let k = fontSize / TextRenderConfig.standardFontSize;
            let info = bold ? inst.bold : inst.normal;
            return Math.ceil(info.bbxh * k);
        }
        getFont(font) {
            let inst = this.fontMap.get(font);
            if (inst == null) {
                inst = {
                    id: fontIdCounter++,
                    normal: measureFont(this.ctx, font, false),
                    bold: measureFont(this.ctx, font, true)
                };
                this.fontMap.set(font, inst);
            }
            return inst;
        }
        onFontScaleChanged() {
            this.textMap.clear();
            toClearChars.length = 0;
            for (let [_, ri] of this.charMap) {
                if (ri.ref === 0)
                    toClearChars.push(ri);
                else
                    ri.ref--;
            }
            for (let ri of toClearChars) {
                this.free(ri);
            }
            this.charMap.clear();
        }
        GC() {
            if (this.freeIsoTextures.length > 0) {
                for (let tex of this.freeIsoTextures)
                    tex === null || tex === void 0 ? void 0 : tex.destroy();
                this.freeIsoTextures.length = 0;
                freeIsoTextureNullCnt = 0;
            }
            toClearChars.length = 0;
            for (let [_, ri] of this.charMap) {
                if (ri.ref === 0)
                    toClearChars.push(ri);
            }
            for (let ri of toClearChars) {
                this.free(ri);
            }
        }
    }
    const blockGap = 1;
    const emojiTest$1 = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
    var fontIdCounter = 0;
    var fontScale = 1.0;
    var fontSizeH = 0;
    var fontSizeOffX = 0;
    var fontSizeOffY = 0;
    var italicDeg = 0;
    var freeRegionNullCnt = 0;
    var freeIsoTextureNullCnt = 0;
    var toClearChars = [];

    exports.BufferTargetType = void 0;
    (function (BufferTargetType) {
        BufferTargetType[BufferTargetType["ARRAY_BUFFER"] = 0] = "ARRAY_BUFFER";
        BufferTargetType[BufferTargetType["ELEMENT_ARRAY_BUFFER"] = 1] = "ELEMENT_ARRAY_BUFFER";
        BufferTargetType[BufferTargetType["UNIFORM_BUFFER"] = 2] = "UNIFORM_BUFFER";
        BufferTargetType[BufferTargetType["COPY_READ_BUFFER"] = 3] = "COPY_READ_BUFFER";
        BufferTargetType[BufferTargetType["COPY_WRITE_BUFFER"] = 4] = "COPY_WRITE_BUFFER";
        BufferTargetType[BufferTargetType["TRANSFORM_FEEDBACK_BUFFER"] = 5] = "TRANSFORM_FEEDBACK_BUFFER";
    })(exports.BufferTargetType || (exports.BufferTargetType = {}));
    exports.BufferUsage = void 0;
    (function (BufferUsage) {
        BufferUsage[BufferUsage["Static"] = 0] = "Static";
        BufferUsage[BufferUsage["Dynamic"] = 1] = "Dynamic";
        BufferUsage[BufferUsage["Stream"] = 2] = "Stream";
    })(exports.BufferUsage || (exports.BufferUsage = {}));

    exports.IndexFormat = void 0;
    (function (IndexFormat) {
        IndexFormat[IndexFormat["UInt8"] = 0] = "UInt8";
        IndexFormat[IndexFormat["UInt16"] = 1] = "UInt16";
        IndexFormat[IndexFormat["UInt32"] = 2] = "UInt32";
    })(exports.IndexFormat || (exports.IndexFormat = {}));

    class Graphic2DDynamicVIBuffer {
        get vertexBuffer() {
            return this._vertexBuffer;
        }
        get indexBuffer() {
            return this._indexBuffer;
        }
        get bufferState() {
            return this._bufferState;
        }
        constructor(vertexBlockSize, vertexDeclaration) {
            this._vertexViews = [];
            this._indexBufferLength = 0;
            this._indexBufferMaxLength = 0;
            this._vertexFreeBlocks = [];
            this._vertexBlockSize = vertexBlockSize;
            this._vertexBuffer = LayaGL.renderDeviceFactory.createVertexBuffer(exports.BufferUsage.Dynamic);
            this._wholeVertex = LayaGL.render2DRenderPassFactory.create2DGraphicVertexBuffer();
            this._wholeVertex.buffer = this._vertexBuffer;
            this._indexBuffer = LayaGL.renderDeviceFactory.createIndexBuffer(exports.BufferUsage.Dynamic);
            this._indexBuffer.indexType = exports.IndexFormat.UInt16;
            this._wholeIndex = LayaGL.render2DRenderPassFactory.create2DGraphicIndexBuffer();
            this._wholeIndex.buffer = this._indexBuffer;
            this._bufferState = LayaGL.renderDeviceFactory.createBufferState();
            this._vertexBuffer.vertexDeclaration = vertexDeclaration;
            this._vertexDeclaration = vertexDeclaration;
            this._vertexStride = vertexDeclaration.vertexStride;
            this._vertexElementLength = this._vertexStride / 4;
            this._vertexBlockLength = this._vertexBlockSize * this._vertexElementLength;
            this._bufferState.applyState([this._vertexBuffer], this._indexBuffer);
            let vbsize = Graphic2DDynamicVIBuffer.MAX_VERTEX / this._vertexBlockSize;
            this.resizeVertexBuffer(vbsize);
            let ibsize = Graphic2DDynamicVIBuffer.DEFAULT_BLOCK_SIZE;
            this.resizeIndexBuffer(ibsize);
            this._tempVertexData = new Float32Array(this._vertexBlockSize * this._vertexElementLength);
        }
        resizeVertexBuffer(blockSize) {
            let byteLength = blockSize * this._vertexBlockSize * this._vertexStride;
            this._wholeVertex.resetData(byteLength);
            this._vertexBuffer.setDataLength(byteLength);
            this._canVBlockCount = blockSize;
        }
        resizeIndexBuffer(size) {
            let byteLength = size * 2;
            this._wholeIndex.resetData(byteLength);
            this._indexBuffer._setIndexDataLength(byteLength);
            this._indexBufferMaxLength = size;
        }
        indexExtendBlock(length) {
            let nMaxLength = Math.ceil((this._indexBufferLength + length) / Graphic2DDynamicVIBuffer.DEFAULT_BLOCK_SIZE) * Graphic2DDynamicVIBuffer.DEFAULT_BLOCK_SIZE;
            this.resizeIndexBuffer(nMaxLength);
        }
        checkVertexBuffer(vertexCount) {
            let requiredBlocks = Math.ceil(vertexCount / this._vertexBlockSize);
            let requiredExtendBlockCount = requiredBlocks - (this._vertexFreeBlocks.length + (this._canVBlockCount - this._vertexViews.length));
            if (requiredExtendBlockCount > 0) {
                return null;
            }
            let usedBlocks = [];
            let usedViews = [];
            let remainingBlocks = requiredBlocks;
            while (remainingBlocks > 0 && this._vertexFreeBlocks.length > 0) {
                let block = this._vertexFreeBlocks.shift();
                usedBlocks.push(block);
                usedViews.push(this._vertexViews[block]);
                remainingBlocks--;
            }
            while (remainingBlocks > 0) {
                let newBlockIndex = this._vertexViews.length;
                usedBlocks.push(newBlockIndex);
                let view = LayaGL.render2DRenderPassFactory.create2DGraphicVertexDataView(this._wholeVertex, newBlockIndex * this._vertexBlockLength, this._vertexBlockLength, this._vertexElementLength);
                this._vertexViews[newBlockIndex] = view;
                usedViews.push(view);
                remainingBlocks--;
            }
            return { buffer: this, vertexViews: usedViews, vertexBlocks: usedBlocks };
        }
        checkIndexBuffer(length) {
            let view;
            if (this._indexBufferLength + length > this._indexBufferMaxLength) {
                this.indexExtendBlock(length);
            }
            view = LayaGL.render2DRenderPassFactory.create2DGraphicIndexDataView(this._wholeIndex, length);
            this._indexBufferLength += length;
            return view;
        }
        _releaseBlocks(blocks, list, freeBlocks) {
            if (!blocks || blocks.length === 0)
                return;
            freeBlocks.push(...blocks);
        }
        releaseVertexBlocks(blocks) {
            this._releaseBlocks(blocks, this._vertexViews, this._vertexFreeBlocks);
        }
        releaseIndexView(indexView) {
            this._indexBufferLength -= indexView.length;
            this._wholeIndex.removeDataView(indexView);
        }
        clear() {
            this._vertexViews.forEach(view => null);
            this._vertexFreeBlocks = [];
        }
        destroy() {
            this.clear();
            this._vertexBuffer.destroy();
            this._indexBuffer.destroy();
        }
    }
    Graphic2DDynamicVIBuffer.MAX_VERTEX = 32768;
    Graphic2DDynamicVIBuffer.DEFAULT_BLOCK_SIZE = 1024;

    class GraphicsMesh {
        static __init__() {
            GraphicsMesh.vertexDeclarition = new VertexDeclaration(64, [
                new VertexElement(0, VertexElementFormat.Vector4, 0),
                new VertexElement(16, VertexElementFormat.Vector4, 1),
                new VertexElement(32, VertexElementFormat.Vector4, 2),
                new VertexElement(48, VertexElementFormat.Vector4, 3),
            ]);
            GraphicsMesh.stride = GraphicsMesh.vertexDeclarition.vertexStride / 4;
        }
        get bufferState() {
            return this._buffer.bufferState;
        }
        constructor() {
            this._buffer = new Graphic2DDynamicVIBuffer(4, GraphicsMesh.vertexDeclarition);
        }
        checkVertex(vertexCount) {
            let vbResult = this._buffer.checkVertexBuffer(vertexCount);
            if (!vbResult)
                return null;
            return {
                mesh: this,
                vertexBlocks: vbResult.vertexBlocks,
                vertexViews: vbResult.vertexViews
            };
        }
        checkIndex(indexCount) {
            return this._buffer.checkIndexBuffer(indexCount);
        }
        clearBlocks(vertexBlocks) {
            this._buffer.releaseVertexBlocks(vertexBlocks);
        }
        clearIndexView(indexView) {
            this._buffer.releaseIndexView(indexView);
        }
        clear() {
            this._buffer.clear();
        }
        destroy() {
            this._buffer.destroy();
            this._buffer = null;
        }
    }
    GraphicsMesh.stride = 0;

    exports.MeshTopology = void 0;
    (function (MeshTopology) {
        MeshTopology[MeshTopology["Points"] = 0] = "Points";
        MeshTopology[MeshTopology["Lines"] = 1] = "Lines";
        MeshTopology[MeshTopology["LineLoop"] = 2] = "LineLoop";
        MeshTopology[MeshTopology["LineStrip"] = 3] = "LineStrip";
        MeshTopology[MeshTopology["Triangles"] = 4] = "Triangles";
        MeshTopology[MeshTopology["TriangleStrip"] = 5] = "TriangleStrip";
        MeshTopology[MeshTopology["TriangleFan"] = 6] = "TriangleFan";
    })(exports.MeshTopology || (exports.MeshTopology = {}));

    exports.DrawType = void 0;
    (function (DrawType) {
        DrawType[DrawType["DrawArray"] = 0] = "DrawArray";
        DrawType[DrawType["DrawArrayInstance"] = 1] = "DrawArrayInstance";
        DrawType[DrawType["DrawArrayIndirect"] = 2] = "DrawArrayIndirect";
        DrawType[DrawType["DrawElement"] = 3] = "DrawElement";
        DrawType[DrawType["DrawElementInstance"] = 4] = "DrawElementInstance";
        DrawType[DrawType["DrawElementIndirect"] = 5] = "DrawElementIndirect";
    })(exports.DrawType || (exports.DrawType = {}));

    const defaultClipMatrix = new Matrix(Const.MAX_CLIP_SIZE, 0, 0, Const.MAX_CLIP_SIZE, 0, 0);
    const tmpMat = new Matrix();
    const _drawTexToDrawTri_Vert = new Float32Array(8);
    const _drawTexToDrawTri_Index = new Uint16Array([0, 1, 2, 0, 2, 3]);
    const _drawTexToQuad_Index = new Uint16Array([0, 2, 1, 0, 3, 2]);
    class GraphicsRunner {
        constructor() {
            this._alpha = 1.0;
            this._material = null;
            this._fillStyle = DrawStyle.DEFAULT;
            this._strokeStyle = DrawStyle.DEFAULT;
            this._tempUV = new Float32Array(8);
            this._drawTriUseAbsMatrix = false;
            this._other = null;
            this._path = null;
            this._curSubmit = null;
            this._submitKey = new SubmitKey();
            this._graphicsData = null;
            this._transedPoints = new Array(8);
            this._temp4Points = new Array(8);
            this._clipRect = SaveClipRect.MAX;
            this._globalClipMatrix = defaultClipMatrix.clone();
            this._clip_x = 0;
            this._clip_y = 0;
            this._clipInfoID = 0;
            this._clipID_Gen = 0;
            this._meshPool = [];
            this._matrixChanged = false;
            this._matBuffer = new Float32Array(6);
            this._lastMatScaleX = 1.0;
            this._lastMatScaleY = 1.0;
            this._lastMat_a = 1.0;
            this._lastMat_b = 0.0;
            this._lastMat_c = 0.0;
            this._lastMat_d = 1.0;
            this._nBlendType = exports.BlendMode.normal;
            this._save = null;
            this._saveMark = null;
            this.sprite = null;
            this._lastTex = null;
            this._defTexture = null;
            this._defTexture = new Texture(Texture2D.whiteTexture);
            this._textRender = new TextRender(this);
            this._other = ContextParams.DEFAULT;
            this._curMat = Matrix.create();
            this._save = [SaveMark.Create(this)];
            this._save.length = 10;
            this.clear();
            this.initDefalutMesh();
        }
        get lineJoin() {
            return '';
        }
        set lineJoin(value) {
        }
        get lineCap() {
            return '';
        }
        set lineCap(value) {
        }
        get miterLimit() {
            return '';
        }
        set miterLimit(value) {
        }
        transformByMatrix(matrix, tx, ty) {
            this.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx + tx, matrix.ty + ty);
        }
        drawRect(x, y, width, height, fillColor, lineColor, lineWidth) {
            var runner = this;
            if (fillColor != null) {
                runner.fillStyle = fillColor;
                runner.fillRect(x, y, width, height);
            }
            if (lineColor != null) {
                runner.strokeStyle = lineColor;
                runner.lineWidth = lineWidth;
                runner.strokeRect(x, y, width, height);
            }
        }
        alpha(value) {
            this.globalAlpha *= value;
        }
        _transform(mat, pivotX, pivotY) {
            this.translate(pivotX, pivotY);
            this.transform(mat.a, mat.b, mat.c, mat.d, mat.tx, mat.ty);
            this.translate(-pivotX, -pivotY);
        }
        _rotate(angle, pivotX, pivotY) {
            this.translate(pivotX, pivotY);
            this.rotate(angle);
            this.translate(-pivotX, -pivotY);
        }
        _scale(scaleX, scaleY, pivotX, pivotY) {
            this.translate(pivotX, pivotY);
            this.scale(scaleX, scaleY);
            this.translate(-pivotX, -pivotY);
        }
        _drawLine(x, y, fromX, fromY, toX, toY, lineColor, lineWidth, vid) {
            this.beginPath();
            this.strokeStyle = lineColor;
            this.lineWidth = lineWidth;
            this.moveTo(x + fromX, y + fromY);
            this.lineTo(x + toX, y + toY);
            this.stroke();
        }
        _drawLines(x, y, points, lineColor, lineWidth, vid) {
            this.beginPath();
            this.strokeStyle = lineColor;
            this.lineWidth = lineWidth;
            this.addPath(points.slice(), false, false, x, y);
            this.stroke();
        }
        drawCurves(x, y, points, lineColor, lineWidth) {
            this.beginPath();
            this.strokeStyle = lineColor;
            this.lineWidth = lineWidth;
            this.moveTo(x + points[0], y + points[1]);
            var i = 2, n = points.length;
            while (i < n) {
                this.quadraticCurveTo(x + points[i++], y + points[i++], x + points[i++], y + points[i++]);
            }
            this.stroke();
        }
        _fillAndStroke(fillColor, strokeColor, lineWidth, isConvexPolygon = false) {
            if (fillColor != null) {
                this.fillStyle = fillColor;
                this.fill();
            }
            if (strokeColor != null && lineWidth > 0) {
                this.strokeStyle = strokeColor;
                this.lineWidth = lineWidth;
                this.stroke();
            }
        }
        _drawCircle(x, y, radius, fillColor, lineColor, lineWidth, vid) {
            this.beginPath(true);
            this.arc(x, y, radius, radius, 0, 2 * Math.PI, false, true, 40);
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth);
        }
        _drawEllipse(x, y, width, height, fillColor, lineColor, lineWidth) {
            this.beginPath(true);
            this.arc(x, y, width, height, 0, 2 * Math.PI, false, true, 40);
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth);
        }
        _drawRoundRect(x, y, width, height, lt, rt, lb, rb, fillColor, lineColor, lineWidth) {
            if (width <= 0)
                return;
            if (height <= 0)
                return;
            this.beginPath(true);
            var tPath = this._getPath();
            if (0 >= lt) {
                tPath.addPoint(x, y);
            }
            else {
                let st = Math.PI;
                let ed = 1.5 * Math.PI;
                if (width < lt + rt) {
                    let dxlt = lt * (lt + rt - width) / (lt + rt);
                    let hity = Math.sqrt(lt * lt - dxlt * dxlt);
                    let ang = Math.atan2(hity, dxlt);
                    let dAng = 0.5 * Math.PI - ang;
                    ed -= dAng;
                }
                if (height < lt + lb) {
                    let dylt = lt * (lt + lb - height) / (lt + lb);
                    let hitx = Math.sqrt(lt * lt - dylt * dylt);
                    let ang = Math.atan2(dylt, hitx);
                    st += ang;
                }
                if (st > ed) ;
                else {
                    this.arc(x + lt, y + lt, lt, lt, st, ed, false, true, 5);
                }
            }
            let startX = x + width - rt;
            if (0 >= rt) {
                tPath.addPoint(startX, y);
            }
            else {
                let st = 1.5 * Math.PI;
                let ed = 2 * Math.PI;
                if (width < lt + rt) {
                    let dxlt = rt * (lt + rt - width) / (lt + rt);
                    let hity = Math.sqrt(lt * lt - dxlt * dxlt);
                    let ang = Math.atan2(hity, dxlt);
                    let dAng = 0.5 * Math.PI - ang;
                    st += dAng;
                }
                if (height < rt + rb) {
                    let dyrt = rt * (rt + rb - height) / (rt + rb);
                    let hitx = Math.sqrt(rt * rt - dyrt * dyrt);
                    let ang = Math.atan2(dyrt, hitx);
                    ed -= ang;
                }
                if (st > ed) ;
                else {
                    this.arc(startX, y + rt, rt, rt, st, ed, false, true, 5);
                }
            }
            startX = x + width - rb;
            let startY = y + height - rb;
            if (0 >= rb) {
                tPath.addPoint(startX, startY);
            }
            else {
                let st = 0;
                let ed = 0.5 * Math.PI;
                if (width < lb + rb) {
                    let dxlb = rb * (lb + rb - width) / (lb + rb);
                    let hity = Math.sqrt(lb * lb - dxlb * dxlb);
                    let ang = Math.atan2(hity, dxlb);
                    let dAng = 0.5 * Math.PI - ang;
                    ed -= dAng;
                }
                if (height < rt + rb) {
                    let dyrt = rb * (rt + rb - height) / (rt + rb);
                    let hitx = Math.sqrt(rb * rb - dyrt * dyrt);
                    let ang = Math.atan2(dyrt, hitx);
                    st += ang;
                }
                if (st > ed) ;
                else {
                    this.arc(startX, startY, rb, rb, st, ed, false, true, 5);
                }
            }
            startX = x + lb;
            startY = y + height - lb;
            if (0 >= lb) {
                tPath.addPoint(startX, startY);
            }
            else {
                let st = 0.5 * Math.PI;
                let ed = Math.PI;
                if (width < lb + rb) {
                    let dxlb = rb * (lb + rb - width) / (lb + rb);
                    let hity = Math.sqrt(lb * lb - dxlb * dxlb);
                    let ang = Math.atan2(hity, dxlb);
                    let dAng = 0.5 * Math.PI - ang;
                    st += dAng;
                }
                if (height < lt + lb) {
                    let dylt = lb * (lt + lb - height) / (lt + lb);
                    let hitx = Math.sqrt(lb * lb - dylt * dylt);
                    let ang = Math.atan2(dylt, hitx);
                    ed -= ang;
                }
                if (st > ed) ;
                else {
                    this.arc(startX, startY, lb, lb, st, ed, false, true, 5);
                }
            }
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth);
        }
        _drawPie(x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth, vid) {
            this.beginPath();
            this.moveTo(x, y);
            this.arc(x, y, radius, radius, startAngle, endAngle);
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth);
        }
        _drawPoly(x, y, points, fillColor, lineColor, lineWidth, isConvexPolygon, vid) {
            this.beginPath();
            this.addPath(points.slice(), true, isConvexPolygon, x, y);
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth, isConvexPolygon);
        }
        _drawPath(x, y, paths, brush, pen) {
            this.beginPath();
            for (var i = 0, n = paths.length; i < n; i++) {
                var path = paths[i];
                switch (path[0]) {
                    case "moveTo":
                        this.moveTo(x + path[1], y + path[2]);
                        break;
                    case "lineTo":
                        this.lineTo(x + path[1], y + path[2]);
                        break;
                    case "arcTo":
                        this.arcTo(x + path[1], y + path[2], x + path[3], y + path[4], path[5]);
                        break;
                    case "closePath":
                        this.closePath();
                        break;
                }
            }
            if (brush != null) {
                this.fillStyle = brush.fillStyle;
                this.fill();
            }
            if (pen != null) {
                this.strokeStyle = pen.strokeStyle;
                this.lineWidth = pen.lineWidth || 1;
                this.lineJoin = pen.lineJoin;
                this.lineCap = pen.lineCap;
                this.miterLimit = pen.miterLimit;
                this.stroke();
            }
        }
        destroy() {
            for (let i = 0; i < this._meshPool.length; i++) {
                this._meshPool[i].destroy();
            }
            this._meshPool = null;
            this.sprite = null;
            this._path = null;
            this._save = null;
        }
        clear() {
            this._submitKey.clear();
            this._curSubmit = SubmitBase.RENDERBASE;
            this._curMat.identity();
            this._other = ContextParams.DEFAULT;
            this._other.clear();
            this._clipRect = SaveClipRect.MAX;
            this._clip_x = 0;
            this._clip_y = 0;
            this._alpha = 1.0;
            this._nBlendType = exports.BlendMode.normal;
            this._fillStyle = this._strokeStyle = DrawStyle.DEFAULT;
            this._lastTex = null;
            this._saveMark = this._save[0];
            this._save._length = 1;
        }
        getCurrentScaleX() {
            let scaleX = this.getMatScaleX();
            if (this.sprite && this.sprite.globalTrans) {
                const matrix = this.sprite.globalTrans.getMatrix();
                scaleX *= Math.hypot(matrix.a, matrix.b);
            }
            return Math.abs(scaleX);
        }
        getCurrentScaleY() {
            let scaleY = this.getMatScaleY();
            if (this.sprite && this.sprite.globalTrans) {
                const matrix = this.sprite.globalTrans.getMatrix();
                scaleY *= Math.hypot(matrix.c, matrix.d);
            }
            return Math.abs(scaleY);
        }
        getMatScaleX() {
            if (this._lastMat_a === this._curMat.a && this._lastMat_b === this._curMat.b)
                return this._lastMatScaleX;
            this._lastMatScaleX = this._curMat.getScaleX();
            this._lastMat_a = this._curMat.a;
            this._lastMat_b = this._curMat.b;
            return this._lastMatScaleX;
        }
        getMatScaleY() {
            if (this._lastMat_c === this._curMat.c && this._lastMat_d === this._curMat.d)
                return this._lastMatScaleY;
            this._lastMatScaleY = this._curMat.getScaleY();
            this._lastMat_c = this._curMat.c;
            this._lastMat_d = this._curMat.d;
            return this._lastMatScaleY;
        }
        set fillStyle(value) {
            if (!this._fillStyle.equal(value)) {
                SaveStyle.save(this, "fillStyle");
                this._fillStyle = DrawStyle.create(value);
                this._submitKey.other = -this._fillStyle._color.numColor;
            }
        }
        get fillStyle() {
            return this._fillStyle;
        }
        set globalAlpha(value) {
            value = Math.floor(value * 1000) / 1000;
            if (value != this._alpha) {
                SaveBase.save(this, SaveBase.TYPE_ALPHA, this, false);
                this._alpha = value;
            }
        }
        get globalAlpha() {
            return this._alpha;
        }
        set textAlign(value) {
            (this._other.textAlign === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_TEXTALIGN, this._other, false), this._other.textAlign = value);
        }
        get textAlign() {
            return this._other.textAlign;
        }
        set textBaseline(value) {
            (this._other.textBaseline === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_TEXTBASELINE, this._other, false), this._other.textBaseline = value);
        }
        get textBaseline() {
            return this._other.textBaseline;
        }
        set globalCompositeOperation(value) {
            value == null || (this._nBlendType === value) || (SaveBase.save(this, SaveBase.TYPE_GLOBALCOMPOSITEOPERATION, this, true), this._curSubmit = SubmitBase.RENDERBASE, this._nBlendType = value);
        }
        get globalCompositeOperation() {
            return this._nBlendType;
        }
        set strokeStyle(value) {
            this._strokeStyle.equal(value) || (SaveStyle.save(this, "strokeStyle"), this._strokeStyle = DrawStyle.create(value), this._submitKey.other = -this._strokeStyle._color.numColor);
        }
        get strokeStyle() {
            return this._strokeStyle;
        }
        translate(x, y) {
            if (x !== 0 || y !== 0) {
                SaveTranslate.save(this);
                if (this._curMat._bTransform) {
                    SaveTransform.save(this);
                    this._curMat.tx += (x * this._curMat.a + y * this._curMat.c);
                    this._curMat.ty += (x * this._curMat.b + y * this._curMat.d);
                }
                else {
                    this._curMat.tx = x;
                    this._curMat.ty = y;
                }
                this._matrixChanged = true;
            }
        }
        set lineWidth(value) {
            (this._other.lineWidth === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_LINEWIDTH, this._other, false), this._other.lineWidth = value);
        }
        get lineWidth() {
            return this._other.lineWidth;
        }
        save() {
            this._save[this._save._length++] = SaveMark.Create(this);
        }
        restore() {
            var sz = this._save._length;
            var lastBlend = this._nBlendType;
            if (sz < 1)
                return;
            for (var i = sz - 1; i >= 0; i--) {
                var o = this._save[i];
                o.restore(this);
                if (o.isSaveMark()) {
                    this._save._length = i;
                    return;
                }
            }
            if (lastBlend != this._nBlendType) {
                this.breakNextMerge();
            }
        }
        _fillRect(x, y, width, height, rgba) {
            var submit = this._curSubmit;
            this.transformQuad(x, y, width, height, 0, this._curMat, this._transedPoints);
            let vertexResult = this.acquire(4);
            let mesh = vertexResult.mesh;
            var sameKey = submit && (submit.mesh === mesh
                && submit._key.blendShader === this._nBlendType);
            sameKey && (sameKey = sameKey && this.isSameClipInfo(submit));
            if (!this.clipedOff(this._transedPoints)) {
                if (!sameKey) {
                    submit = this._curSubmit = this.createSubmit(mesh);
                    let material = submit._internalInfo;
                    this._setClipInfo(material);
                    submit.clipInfoID = this._clipInfoID;
                    material.textureHost = this._lastTex;
                    submit._key.other = (this._lastTex && this._lastTex.bitmap) ? this._lastTex.bitmap.id : -1;
                }
                this.appendData(this._transedPoints, _drawTexToQuad_Index, vertexResult, submit, null, rgba, null, null, false);
                this._appendBlockInfo(vertexResult);
            }
        }
        _appendBlockInfo(info) {
            this._curSubmit.appendData(info);
        }
        fillRect(x, y, width, height, fillStyle = null) {
            var drawstyle = fillStyle ? DrawStyle.create(fillStyle) : this._fillStyle;
            var rgba = this.mixRGBandAlpha(drawstyle._color.numColor);
            this._fillRect(x, y, width, height, rgba);
        }
        fillTexture(texture, x, y, width, height, type, offset, color) {
            if (!this._getImageSource(texture)) {
                return;
            }
            this._graphicsData.addResRef(texture);
            this._fillTexture(texture, texture.width, texture.height, texture.uvrect, x, y, width, height, type, offset.x, offset.y, color);
        }
        _fillTexture(texture, texw, texh, texuvRect, x, y, width, height, type, offsetx, offsety, color) {
            var submit = this._curSubmit;
            let vertexResult = this.acquire(4);
            let mesh = vertexResult.mesh;
            var repeatx = true;
            var repeaty = true;
            switch (type) {
                case "repeat": break;
                case "repeat-x":
                    repeaty = false;
                    break;
                case "repeat-y":
                    repeatx = false;
                    break;
                case "no-repeat":
                    repeatx = repeaty = false;
                    break;
            }
            var uv = this._temp4Points;
            var stu = 0;
            var stv = 0;
            var stx = 0, sty = 0, edx = 0, edy = 0;
            if (offsetx < 0) {
                stx = x;
                stu = (-offsetx % texw) / texw;
            }
            else {
                stx = x + offsetx;
            }
            if (offsety < 0) {
                sty = y;
                stv = (-offsety % texh) / texh;
            }
            else {
                sty = y + offsety;
            }
            edx = x + width;
            edy = y + height;
            (!repeatx) && (edx = Math.min(edx, x + offsetx + texw));
            (!repeaty) && (edy = Math.min(edy, y + offsety + texh));
            if (edx < x || edy < y)
                return;
            if (stx > edx || sty > edy)
                return;
            var edu = (edx - x - offsetx) / texw;
            var edv = (edy - y - offsety) / texh;
            this.transformQuad(stx, sty, edx - stx, edy - sty, 0, this._curMat, this._transedPoints);
            uv[0] = stu;
            uv[1] = stv;
            uv[2] = edu;
            uv[3] = stv;
            uv[4] = edu;
            uv[5] = edv;
            uv[6] = stu;
            uv[7] = edv;
            if (!this.clipedOff(this._transedPoints)) {
                submit = this._curSubmit = this.createSubmit(mesh);
                let material = submit._internalInfo;
                material.fillTexture = true;
                var arry = texuvRect.concat();
                Vector4.TEMP.setValue(arry[0], arry[1], arry[2], arry[3]);
                material.u_TexRange = Vector4.TEMP;
                this._setClipInfo(material);
                submit.clipInfoID = this._clipInfoID;
                submit._internalInfo.textureHost = texture;
                var rgba = this._mixRGBandAlpha(color, this._alpha);
                this.appendData(this._transedPoints, _drawTexToQuad_Index, vertexResult, submit, uv, rgba, null, null, true);
                this._appendBlockInfo(vertexResult);
            }
            this.breakNextMerge();
        }
        createSubmit(mesh) {
            return this._graphicsData.createSubmit(this, mesh, this._material);
        }
        drawTexture(tex, x, y, width, height, color = 0xffffffff) {
            this._drawTextureM(tex, x, y, width, height, null, 1, null, color);
        }
        drawTextures(tex, pos, tx, ty, colors) {
            if (!this._getImageSource(tex)) {
                return;
            }
            this._graphicsData.addResRef(tex);
            var n = pos.length / 2;
            var ipos = 0;
            var bmpid = tex.bitmap.id;
            for (var i = 0; i < n; i++) {
                const color = typeof colors[i] === 'number' ? colors[i] : 0xffffffff;
                this._inner_drawTexture(tex, bmpid, pos[ipos++] + tx, pos[ipos++] + ty, 0, 0, null, null, 1.0, color);
            }
        }
        _drawTextureM(tex, x, y, width, height, m, alpha, uv, color) {
            if (!this._getImageSource(tex)) {
                return false;
            }
            this._graphicsData.addResRef(tex);
            return this._inner_drawTexture(tex, tex.bitmap.id, x, y, width, height, m, uv, alpha, color);
        }
        _setClipInfo(material) {
            if (this._clipRect === SaveClipRect.MAX) {
                material.materialClip = false;
                return;
            }
            let clipInfo = this._globalClipMatrix;
            var cm = material.clipMatDir;
            material.materialClip = true;
            cm.x = clipInfo.a;
            cm.y = clipInfo.b;
            cm.z = clipInfo.c;
            cm.w = clipInfo.d;
            material.clipMatDir = cm;
            var cmp = material.clipMatPos;
            cmp.x = clipInfo.tx;
            cmp.y = clipInfo.ty, cmp.z = this._clip_x, cmp.w = this._clip_y;
            material.clipMatPos = cmp;
        }
        isSameClipInfo(submit) {
            return submit.clipInfoID !== this._clipInfoID;
        }
        _inner_drawTexture(tex, imgid, x, y, width, height, m, uv, alpha, color, italicDeg, pixelSnap) {
            if (width <= 0 || height <= 0) {
                return false;
            }
            if (italicDeg == null)
                italicDeg = 0;
            var preKey = this._curSubmit._key;
            uv = uv || tex._uv;
            if (preKey.other === imgid) {
                let xoff = 0;
                if (italicDeg !== 0) {
                    xoff = Math.tan(italicDeg * Math.PI / 180) * height;
                }
                var tv = _drawTexToDrawTri_Vert;
                tv[0] = x + xoff;
                tv[1] = y;
                tv[2] = x + width + xoff, tv[3] = y, tv[4] = x + width, tv[5] = y + height, tv[6] = x, tv[7] = y + height;
                this._drawTriUseAbsMatrix = true;
                var tuv = this._tempUV;
                tuv[0] = uv[0];
                tuv[1] = uv[1];
                tuv[2] = uv[2];
                tuv[3] = uv[3];
                tuv[4] = uv[4];
                tuv[5] = uv[5];
                tuv[6] = uv[6];
                tuv[7] = uv[7];
                this.drawTriangles(tex, 0, 0, tv, tuv, _drawTexToDrawTri_Index, m || this._curMat, alpha, null, color);
                this._drawTriUseAbsMatrix = false;
                return true;
            }
            var submit = this._curSubmit;
            var ops = this._transedPoints;
            this.transformQuad(x, y, width || tex.width, height || tex.height, italicDeg, m || this._curMat, ops);
            if (pixelSnap) {
                var round = Math.round;
                ops[0] = round(ops[0]);
                ops[1] = round(ops[1]);
                ops[2] = round(ops[2]);
                ops[3] = round(ops[3]);
                ops[4] = round(ops[4]);
                ops[5] = round(ops[5]);
                ops[6] = round(ops[6]);
                ops[7] = round(ops[7]);
            }
            var rgba = this._mixRGBandAlpha(color, this._alpha * alpha);
            let vertexResult = this.acquire(4);
            let mesh = vertexResult.mesh;
            let sameKey = (imgid >= 0
                && submit.mesh === mesh
                && preKey.other === imgid)
                && !this.isSameClipInfo(this._curSubmit);
            this._lastTex = tex;
            if (!sameKey) {
                this._curSubmit = submit = this.createSubmit(mesh);
                let material = submit._internalInfo;
                this._setClipInfo(material);
                material.textureHost = tex;
                submit._key.other = imgid;
                submit.clipInfoID = this._clipInfoID;
            }
            this.appendData(ops, _drawTexToQuad_Index, vertexResult, submit, uv, rgba, null, null, true);
            this._appendBlockInfo(vertexResult);
            return true;
        }
        clipedOff(pt) {
            if (this._clipRect.width <= 0 || this._clipRect.height <= 0)
                return true;
            return false;
        }
        transformQuad(x, y, w, h, italicDeg, m, out) {
            var xoff = 0;
            if (italicDeg != 0) {
                xoff = Math.tan(italicDeg * Math.PI / 180) * h;
            }
            var maxx = x + w;
            var maxy = y + h;
            var tx = m.tx;
            var ty = m.ty;
            var ma = m.a;
            var mb = m.b;
            var mc = m.c;
            var md = m.d;
            var a0 = x + xoff;
            var a1 = y;
            var a2 = maxx + xoff;
            var a3 = y;
            var a4 = maxx;
            var a5 = maxy;
            var a6 = x;
            var a7 = maxy;
            if (m !== this._curMat
                || this._matrixChanged) {
                if (m._bTransform) {
                    out[0] = a0 * ma + a1 * mc + tx;
                    out[1] = a0 * mb + a1 * md + ty;
                    out[2] = a2 * ma + a3 * mc + tx;
                    out[3] = a2 * mb + a3 * md + ty;
                    out[4] = a4 * ma + a5 * mc + tx;
                    out[5] = a4 * mb + a5 * md + ty;
                    out[6] = a6 * ma + a7 * mc + tx;
                    out[7] = a6 * mb + a7 * md + ty;
                }
                else {
                    out[0] = a0 + tx;
                    out[1] = a1 + ty;
                    out[2] = a2 + tx;
                    out[3] = a3 + ty;
                    out[4] = a4 + tx;
                    out[5] = a5 + ty;
                    out[6] = a6 + tx;
                    out[7] = a7 + ty;
                }
            }
            else {
                out[0] = a0;
                out[1] = a1;
                out[2] = a2;
                out[3] = a3;
                out[4] = a4;
                out[5] = a5;
                out[6] = a6;
                out[7] = a7;
            }
        }
        breakNextMerge() {
            this._curSubmit = SubmitBase.RENDERBASE;
        }
        drawTextureWithTransform(tex, x, y, width, height, transform, tx, ty, alpha, blendMode, uv, color = 0xffffffff) {
            var _a;
            var oldcomp;
            var curMat = this._curMat;
            if (blendMode != null) {
                if (typeof blendMode == "string")
                    blendMode = (_a = exports.BlendMode[blendMode]) !== null && _a !== void 0 ? _a : (blendMode === "destination-out" ? exports.BlendMode.destinationOut : 0);
                oldcomp = this.globalCompositeOperation;
                this.globalCompositeOperation = blendMode;
            }
            if (!transform) {
                this._drawTextureM(tex, x + tx, y + ty, width, height, curMat, alpha, uv, color);
                if (blendMode) {
                    this.globalCompositeOperation = oldcomp;
                }
                return;
            }
            tmpMat.a = transform.a;
            tmpMat.b = transform.b;
            tmpMat.c = transform.c;
            tmpMat.d = transform.d;
            tmpMat.tx = transform.tx + tx;
            tmpMat.ty = transform.ty + ty;
            tmpMat._bTransform = transform._bTransform;
            if (transform && curMat._bTransform) {
                Matrix.mul(tmpMat, curMat, tmpMat);
                transform = tmpMat;
                transform._bTransform = true;
            }
            else {
                tmpMat.tx += curMat.tx;
                tmpMat.ty += curMat.ty;
                transform = tmpMat;
            }
            this._drawTextureM(tex, x, y, width, height, transform, alpha, uv, color);
            if (blendMode != null)
                this.globalCompositeOperation = oldcomp;
        }
        drawTriangles(tex, x, y, vertices, uvs, indices, matrix, alpha, blendMode, colorNum, colors, uvRange) {
            var _a;
            if (tex) {
                if (!this._getImageSource(tex)) {
                    return;
                }
                this._graphicsData.addResRef(tex);
            }
            if (alpha == null)
                alpha = 1.0;
            if (colorNum == null)
                colorNum = 0xffffffff;
            let oldcomp = null;
            if (blendMode != null) {
                if (typeof blendMode == "string")
                    blendMode = (_a = exports.BlendMode[blendMode]) !== null && _a !== void 0 ? _a : (blendMode === "destination-out" ? exports.BlendMode.destinationOut : 0);
                oldcomp = this.globalCompositeOperation;
                this.globalCompositeOperation = blendMode;
            }
            let vertexCount = vertices.length / 2;
            let vertexResult = this.acquire(vertexCount);
            let mesh = vertexResult.mesh;
            var webGLImg = tex instanceof Texture ? tex.bitmap : tex;
            var preKey = this._curSubmit._key;
            var sameKey = this._curSubmit.mesh === mesh
                && (!webGLImg || preKey.other === webGLImg.id)
                && preKey.blendShader === this._nBlendType;
            let submit = this._curSubmit;
            if (!sameKey) {
                submit = this._curSubmit = this.createSubmit(mesh);
                submit._internalInfo.textureHost = tex;
                this._setClipInfo(submit._internalInfo);
                submit._key.other = webGLImg ? webGLImg.id : -1;
                submit.clipInfoID = this._clipInfoID;
            }
            var rgba = this._mixRGBandAlpha(colorNum, this._alpha * alpha);
            if (!this._drawTriUseAbsMatrix) {
                if (!matrix) {
                    tmpMat.a = 1;
                    tmpMat.b = 0;
                    tmpMat.c = 0;
                    tmpMat.d = 1;
                    tmpMat.tx = x;
                    tmpMat.ty = y;
                }
                else {
                    tmpMat.a = matrix.a;
                    tmpMat.b = matrix.b;
                    tmpMat.c = matrix.c;
                    tmpMat.d = matrix.d;
                    tmpMat.tx = matrix.tx + x;
                    tmpMat.ty = matrix.ty + y;
                }
                Matrix.mul(tmpMat, this._curMat, tmpMat);
                this.appendData(vertices, indices, vertexResult, submit, uvs, rgba, tmpMat, null, !!tex, colors, uvRange);
            }
            else {
                let m = this._curMat == matrix ? (this._matrixChanged ? this._curMat : null) : matrix;
                this.appendData(vertices, indices, vertexResult, submit, uvs, rgba, m, null, !!tex, colors, uvRange);
            }
            this._appendBlockInfo(vertexResult);
            if (blendMode != null) {
                this.globalCompositeOperation = oldcomp;
            }
        }
        transform(a, b, c, d, tx, ty) {
            SaveTransform.save(this);
            Matrix.mul(Matrix.TEMP.setTo(a, b, c, d, tx, ty), this._curMat, this._curMat);
            this._curMat._checkTransform();
            this._matrixChanged = true;
        }
        rotate(angle) {
            SaveTransform.save(this);
            this._curMat.rotateEx(angle);
            this._matrixChanged = true;
        }
        scale(scaleX, scaleY) {
            SaveTransform.save(this);
            this._curMat.scaleEx(scaleX, scaleY);
            this._matrixChanged = true;
        }
        clipRect(x, y, width, height, escape) {
            SaveClipRect.save(this);
            if (this._clipRect === SaveClipRect.MAX) {
                this._clipRect = new Rectangle(x, y, width, height);
            }
            else {
                this._clipRect.width = width;
                this._clipRect.height = height;
                this._clipRect.x = x;
                this._clipRect.y = y;
            }
            this._clipID_Gen++;
            this._clipID_Gen %= 10000;
            this._clipInfoID = this._clipID_Gen;
            if (escape) {
                defaultClipMatrix.copyTo(this._globalClipMatrix);
                return;
            }
            var cm = this._globalClipMatrix;
            var minx = cm.tx;
            var miny = cm.ty;
            var maxx = minx + cm.a;
            var maxy = miny + cm.d;
            let mat = this.sprite.globalTrans.getMatrix();
            if (this._clipRect.width >= Const.MAX_CLIP_SIZE) {
                cm.a = cm.d = Const.MAX_CLIP_SIZE;
                cm.b = cm.c = cm.tx = cm.ty = 0;
            }
            else {
                let { x, y, width, height } = this._clipRect;
                cm.tx = x * mat.a + y * mat.c + mat.tx;
                cm.ty = x * mat.b + y * mat.d + mat.ty;
                cm.a = width * mat.a;
                cm.b = width * mat.b;
                cm.c = height * mat.c;
                cm.d = height * mat.d;
            }
            if (cm.a > 0 && cm.d > 0) {
                var cmaxx = cm.tx + cm.a;
                var cmaxy = cm.ty + cm.d;
                if (cmaxx <= minx || cmaxy <= miny || cm.tx >= maxx || cm.ty >= maxy) {
                    cm.a = -0.1;
                    cm.d = -0.1;
                }
                else {
                    if (cm.tx < minx) {
                        cm.a -= (minx - cm.tx);
                        cm.tx = minx;
                    }
                    if (cmaxx > maxx) {
                        cm.a -= (cmaxx - maxx);
                    }
                    if (cm.ty < miny) {
                        cm.d -= (miny - cm.ty);
                        cm.ty = miny;
                    }
                    if (cmaxy > maxy) {
                        cm.d -= (cmaxy - maxy);
                    }
                    if (cm.a <= 0)
                        cm.a = -0.1;
                    if (cm.d <= 0)
                        cm.d = -0.1;
                }
            }
            this._clip_x = mat.tx;
            this._clip_y = mat.ty;
        }
        beginPath(convex = false) {
            this._getPath().beginPath(convex);
        }
        closePath() {
            this._path.closePath();
        }
        addPath(points, close, convex, dx, dy) {
            let sz = points.length;
            for (let i = 0; i < sz - 1; i += 2) {
                points[i] += dx;
                points[i + 1] += dy;
            }
            if (close && sz > 5 && (points[sz - 2] != points[0] || points[sz - 1] != points[1])) {
                points.push(points[0], points[1]);
            }
            this._getPath().push(points, convex);
        }
        fill() {
            var m = this._curMat;
            var tPath = this._getPath();
            var submit = this._curSubmit;
            let mesh;
            var sameKey = (submit._key.blendShader === this._nBlendType)
                && !this.isSameClipInfo(submit);
            var rgba = this.mixRGBandAlpha(this._fillStyle._color.numColor);
            var curEleNum = 0;
            var idx;
            let curvert = 0;
            for (var i = 0, sz = tPath.paths.length; i < sz; i++) {
                var p = tPath.paths[i];
                var vertNum = p.path.length / 2;
                if (vertNum < 3 || (vertNum === 3 && !p.convex))
                    continue;
                let cpath = p.path.concat();
                let pi = 0;
                let xp, yp;
                let _x, _y;
                if (this._matrixChanged) {
                    if (m._bTransform) {
                        for (pi = 0; pi < vertNum; pi++) {
                            xp = pi << 1;
                            yp = xp + 1;
                            _x = cpath[xp];
                            _y = cpath[yp];
                            cpath[xp] = m.a * _x + m.c * _y + m.tx;
                            cpath[yp] = m.b * _x + m.d * _y + m.ty;
                        }
                    }
                    else {
                        for (pi = 0; pi < vertNum; pi++) {
                            xp = pi << 1;
                            yp = xp + 1;
                            _x = cpath[xp];
                            _y = cpath[yp];
                            cpath[xp] = _x + m.tx;
                            cpath[yp] = _y + m.ty;
                        }
                    }
                }
                let vertexResult;
                if (mesh) {
                    vertexResult = mesh.checkVertex(vertNum);
                }
                if (!sameKey
                    || !vertexResult) {
                    curEleNum = 0;
                    curvert = 0;
                    vertexResult = this.acquire(vertNum);
                    mesh = vertexResult.mesh;
                    if (!sameKey || this._curSubmit.mesh !== mesh) {
                        submit = this._curSubmit = this.addVGSubmit(mesh);
                        sameKey = true;
                    }
                }
                if (p.convex) {
                    var faceNum = vertNum - 2;
                    idx = new Array(faceNum * 3);
                    var idxpos = 0;
                    for (var fi = 0; fi < faceNum; fi++) {
                        idx[idxpos++] = curvert;
                        idx[idxpos++] = fi + 1 + curvert;
                        idx[idxpos++] = fi + 2 + curvert;
                    }
                }
                else {
                    idx = Earcut.earcut(cpath, null, 2);
                    if (curvert > 0) {
                        for (var ii = 0; ii < idx.length; ii++) {
                            idx[ii] += curvert;
                        }
                    }
                }
                this.appendData(cpath, idx, vertexResult, submit, null, rgba, null, null, false);
                curEleNum += idx.length;
                this._appendBlockInfo(vertexResult);
            }
        }
        addVGSubmit(mesh) {
            var submit = this.createSubmit(mesh);
            this._setClipInfo(submit._internalInfo);
            submit.clipInfoID = this._clipInfoID;
            return submit;
        }
        stroke() {
            if (this.lineWidth <= 0)
                return;
            var rgba = this.mixRGBandAlpha(this.strokeStyle._color.numColor);
            var tPath = this._getPath();
            var submit = this._curSubmit;
            var sameKey = (submit._key.blendShader === this._nBlendType)
                && !this.isSameClipInfo(submit);
            let mesh = this._meshPool[this._currentMeshIndex];
            var curEleNum = 0;
            let m = this._curMat;
            for (var i = 0, sz = tPath.paths.length; i < sz; i++) {
                var p = tPath.paths[i];
                if (p.path.length <= 0)
                    continue;
                var idx = [];
                var vertex = [];
                var maxVertexNum = p.path.length * 2;
                if (maxVertexNum < 2)
                    continue;
                BasePoly.createLine2(p.path, idx, this.lineWidth, 0, vertex, p.loop);
                let ptnum = vertex.length / 2;
                let vertexResult;
                if (mesh) {
                    vertexResult = mesh.checkVertex(ptnum);
                }
                if (!sameKey
                    || !vertexResult) {
                    curEleNum = 0;
                    vertexResult = this.acquire(ptnum);
                    mesh = vertexResult.mesh;
                    if (!sameKey || this._curSubmit.mesh !== mesh) {
                        submit = this._curSubmit = this.addVGSubmit(mesh);
                        sameKey = true;
                    }
                }
                let pi = 0;
                let xp, yp;
                let _x, _y;
                if (this._matrixChanged) {
                    if (m._bTransform) {
                        for (pi = 0; pi < ptnum; pi++) {
                            xp = pi << 1;
                            yp = xp + 1;
                            _x = vertex[xp];
                            _y = vertex[yp];
                            vertex[xp] = m.a * _x + m.c * _y + m.tx;
                            vertex[yp] = m.b * _x + m.d * _y + m.ty;
                        }
                    }
                    else {
                        for (pi = 0; pi < ptnum; pi++) {
                            xp = pi << 1;
                            yp = xp + 1;
                            _x = vertex[xp];
                            _y = vertex[yp];
                            vertex[xp] = _x + m.tx;
                            vertex[yp] = _y + m.ty;
                        }
                    }
                }
                this.appendData(vertex, idx, vertexResult, submit, null, rgba, null, null, false);
                curEleNum += idx.length;
                this._appendBlockInfo(vertexResult);
            }
        }
        moveTo(x, y) {
            var tPath = this._getPath();
            tPath.newPath();
            tPath._lastOriX = x;
            tPath._lastOriY = y;
            tPath.addPoint(x, y);
        }
        lineTo(x, y) {
            var tPath = this._getPath();
            if (Math.abs(x - tPath._lastOriX) < 1e-3 && Math.abs(y - tPath._lastOriY) < 1e-3)
                return;
            tPath._lastOriX = x;
            tPath._lastOriY = y;
            tPath.addPoint(x, y);
        }
        arcTo(x1, y1, x2, y2, r) {
            var i = 0;
            var x = 0, y = 0;
            var dx = this._path._lastOriX - x1;
            var dy = this._path._lastOriY - y1;
            var len1 = Math.sqrt(dx * dx + dy * dy);
            if (len1 <= 0.000001) {
                return;
            }
            var ndx = dx / len1;
            var ndy = dy / len1;
            var dx2 = x2 - x1;
            var dy2 = y2 - y1;
            var len22 = dx2 * dx2 + dy2 * dy2;
            var len2 = Math.sqrt(len22);
            if (len2 <= 0.000001) {
                return;
            }
            var ndx2 = dx2 / len2;
            var ndy2 = dy2 / len2;
            var odx = ndx + ndx2;
            var ody = ndy + ndy2;
            var olen = Math.sqrt(odx * odx + ody * ody);
            if (olen <= 0.000001) {
                return;
            }
            var nOdx = odx / olen;
            var nOdy = ody / olen;
            var alpha = Math.acos(nOdx * ndx + nOdy * ndy);
            var halfAng = Math.PI / 2 - alpha;
            len1 = r * Math.tan(halfAng);
            var ptx1 = len1 * ndx + x1;
            var pty1 = len1 * ndy + y1;
            var orilen = Math.sqrt(len1 * len1 + r * r);
            var orix = x1 + nOdx * orilen;
            var oriy = y1 + nOdy * orilen;
            var dir = ndx * ndy2 - ndy * ndx2;
            var fChgAng = 0;
            var sinx = 0.0;
            var cosx = 0.0;
            if (dir >= 0) {
                fChgAng = halfAng * 2;
                var fda = fChgAng / GraphicsRunner.SEGNUM;
                sinx = Math.sin(fda);
                cosx = Math.cos(fda);
            }
            else {
                fChgAng = -halfAng * 2;
                fda = fChgAng / GraphicsRunner.SEGNUM;
                sinx = Math.sin(fda);
                cosx = Math.cos(fda);
            }
            var lastx = this._path._lastOriX, lasty = this._path._lastOriY;
            var _x1 = ptx1, _y1 = pty1;
            if (Math.abs(_x1 - this._path._lastOriX) > 0.1 || Math.abs(_y1 - this._path._lastOriY) > 0.1) {
                x = _x1;
                y = _y1;
                lastx = _x1;
                lasty = _y1;
                this._path._lastOriX = x;
                this._path._lastOriY = y;
                this._path.addPoint(x, y);
            }
            var cvx = ptx1 - orix;
            var cvy = pty1 - oriy;
            for (i = 0; i < GraphicsRunner.SEGNUM; i++) {
                var cx = cvx * cosx + cvy * sinx;
                var cy = -cvx * sinx + cvy * cosx;
                x = cx + orix;
                y = cy + oriy;
                if (Math.abs(lastx - x) > 0.1 || Math.abs(lasty - y) > 0.1) {
                    this._path._lastOriX = x;
                    this._path._lastOriY = y;
                    this._path.addPoint(x, y);
                    lastx = x;
                    lasty = y;
                }
                cvx = cx;
                cvy = cy;
            }
        }
        arc(cx, cy, rx, ry, startAngle, endAngle, counterclockwise = false, b = true, minNum = 20) {
            if (startAngle > endAngle) {
                [startAngle, endAngle] = [endAngle, startAngle];
            }
            var sx = this.getCurrentScaleX();
            var sy = this.getCurrentScaleY();
            var sr = rx * (sx > sy ? sx : sy);
            var cl = 2 * Math.PI * sr;
            let ndivs = (Math.max(cl / 5, minNum)) | 0;
            let stepAng = Math.PI * 2 / ndivs;
            var tPath = this._getPath();
            let x = cx + Math.cos(startAngle) * rx;
            let y = cy + Math.sin(startAngle) * ry;
            if (x != this._path._lastOriX || y != this._path._lastOriY) {
                tPath.addPoint(x, y);
            }
            let curAng = Math.ceil(startAngle / stepAng) * stepAng;
            while (endAngle - curAng >= stepAng) {
                x = cx + Math.cos(curAng) * rx;
                y = cy + Math.sin(curAng) * ry;
                tPath.addPoint(x, y);
                curAng += stepAng;
            }
            x = cx + Math.cos(endAngle) * rx;
            y = cy + Math.sin(endAngle) * ry;
            if (x != this._path._lastOriX || y != this._path._lastOriY) {
                tPath.addPoint(x, y);
            }
        }
        quadraticCurveTo(cpx, cpy, x, y) {
            var tArray = Bezier.getPoints([this._path._lastOriX, this._path._lastOriY, cpx, cpy, x, y], 30, 2);
            for (var i = 0, n = tArray.length / 2; i < n; i++) {
                this.lineTo(tArray[i * 2], tArray[i * 2 + 1]);
            }
            this.lineTo(x, y);
        }
        mixRGBandAlpha(color) {
            return this._mixRGBandAlpha(color, this._alpha);
        }
        _mixRGBandAlpha(color, alpha) {
            if (alpha >= 1) {
                return color;
            }
            var a = ((color & 0xff000000) >>> 24);
            if (a != 0) {
                a *= alpha;
            }
            else {
                a = alpha * 255;
            }
            return (color & 0x00ffffff) | (a << 24);
        }
        strokeRect(x, y, width, height, parameterLineWidth = 0) {
            if (this.lineWidth > 0) {
                var rgba = this.mixRGBandAlpha(this.strokeStyle._color.numColor);
                var hw = this.lineWidth / 2;
                this._fillRect(x - hw, y - hw, width + this.lineWidth, this.lineWidth, rgba);
                this._fillRect(x - hw, y - hw + height, width + this.lineWidth, this.lineWidth, rgba);
                this._fillRect(x - hw, y + hw, this.lineWidth, height - this.lineWidth, rgba);
                this._fillRect(x - hw + width, y + hw, this.lineWidth, height - this.lineWidth, rgba);
            }
        }
        drawParticle(x, y, pt) {
        }
        _getPath() {
            return this._path || (this._path = new Path());
        }
        _getImageSource(texture) {
            let cs = this.sprite;
            return texture._getSource(function () {
                if (cs) {
                    if (cs._graphics)
                        cs._graphics.repaint();
                    else
                        cs.repaint();
                }
            });
        }
        acquire(vertexCount) {
            let meshes = this._meshPool;
            for (let i = 0; i < meshes.length; i++) {
                let mesh = meshes[i];
                let result = mesh.checkVertex(vertexCount);
                if (result) {
                    this._currentMeshIndex = i;
                    return result;
                }
            }
            let mesh = new GraphicsMesh();
            this._meshPool.push(mesh);
            this._currentMeshIndex = this._meshPool.length - 1;
            let result = mesh.checkVertex(vertexCount);
            return result;
        }
        appendData(vertices, indices, result, submit, uvs, rgba, matrix, uvrect, useTex, colors, uvRange) {
            let vertexCount = vertices.length / 2;
            let uvminx = 0;
            let uvminy = 0;
            let uvu = 1;
            let uvv = 1;
            if (uvrect) {
                uvminx = uvrect[0];
                uvminy = uvrect[1];
                uvu = uvrect[2];
                uvv = uvrect[3];
            }
            let m00, m01, m10, m11, tx, ty;
            if (matrix) {
                m00 = matrix.a;
                m01 = matrix.b;
                m10 = matrix.c;
                m11 = matrix.d;
                tx = matrix.tx;
                ty = matrix.ty;
            }
            let r = (rgba & 0xff) / 255.0;
            let b = ((rgba >>> 16) & 0xff) / 255.0;
            let g = ((rgba >>> 8) & 0xff) / 255.0;
            let a = (rgba >>> 24) / 255.0;
            let useTexByte = useTex ? 0xff : 0;
            let useClipByte = uvRange ? 0xff : 0;
            let dataViewIndex = 0;
            let vertexViews = result.vertexViews;
            let indexsMap = [];
            let dataView;
            let offset = 0;
            let positions = [];
            let vbdata = result.mesh._buffer._tempVertexData;
            let vertexLength = GraphicsMesh.stride;
            for (let i = 0, pi = 0, ci = 0, vi = 0; i < vertexCount; i++) {
                if (!dataView || dataView.length <= vi) {
                    if (dataView) {
                        dataView.setData(vbdata);
                    }
                    dataView = vertexViews[dataViewIndex];
                    dataViewIndex++;
                    vi = 0;
                    offset = dataView.start / dataView.stride;
                }
                let x = vertices[pi], y = vertices[pi + 1];
                if (matrix) {
                    if (matrix._bTransform) {
                        vbdata[vi] = positions[pi] = x * m00 + y * m10 + tx;
                        vbdata[vi + 1] = positions[pi + 1] = x * m01 + y * m11 + ty;
                    }
                    else {
                        vbdata[vi] = positions[pi] = x + tx;
                        vbdata[vi + 1] = positions[pi + 1] = y + ty;
                    }
                }
                else {
                    vbdata[vi] = positions[pi] = x;
                    vbdata[vi + 1] = positions[pi + 1] = y;
                }
                if (uvs) {
                    vbdata[vi + 2] = uvminx + uvs[pi] * uvu;
                    vbdata[vi + 3] = uvminy + uvs[pi + 1] * uvv;
                }
                if (colors != null) {
                    vbdata[vi + 4] = colors[ci];
                    vbdata[vi + 5] = colors[ci + 1];
                    vbdata[vi + 6] = colors[ci + 2];
                    vbdata[vi + 7] = colors[ci + 3];
                }
                else {
                    vbdata[vi + 4] = r;
                    vbdata[vi + 5] = g;
                    vbdata[vi + 6] = b;
                    vbdata[vi + 7] = a;
                }
                vbdata[vi + 8] = useTexByte;
                vbdata[vi + 9] = useClipByte;
                if (uvRange) {
                    vbdata[vi + 12] = uvRange[0];
                    vbdata[vi + 13] = uvRange[1];
                    vbdata[vi + 14] = uvRange[2];
                    vbdata[vi + 15] = uvRange[3];
                }
                vi += vertexLength;
                pi += 2;
                ci += 4;
                indexsMap[i] = offset++;
            }
            if (dataView) {
                dataView.setData(vbdata);
            }
            result.positions = positions;
            let indexOffset = submit.indexCount;
            let indexCount = indices.length;
            let ibdata = submit.indices;
            for (let i = 0; i < indexCount; i++) {
                ibdata[i + indexOffset] = indexsMap[indices[i]];
            }
            submit.indexCount += indexCount;
        }
        initDefalutMesh() {
            if (!this.def_geometry) {
                let length = 4 * GraphicsMesh.stride;
                let def_vertices = new Float32Array(length);
                let inv_vertices = new Float32Array(length);
                let def_uv = Texture.DEF_UV;
                let inv_uv = Texture.INV_UV;
                let positions = [0, 0, 1, 0, 1, 1, 0, 1];
                let offset = 0;
                for (let i = 0; i < 4; i++) {
                    let index = i * GraphicsMesh.stride;
                    inv_vertices[index] = def_vertices[index] = positions[offset];
                    inv_vertices[index + 1] = def_vertices[index + 1] = positions[offset + 1];
                    def_vertices[index + 2] = def_uv[offset];
                    def_vertices[index + 3] = def_uv[offset + 1];
                    inv_vertices[index + 2] = inv_uv[offset];
                    inv_vertices[index + 3] = inv_uv[offset + 1];
                    inv_vertices[index + 4] = def_vertices[index + 4] = 1;
                    inv_vertices[index + 5] = def_vertices[index + 5] = 1;
                    inv_vertices[index + 6] = def_vertices[index + 6] = 1;
                    inv_vertices[index + 7] = def_vertices[index + 7] = 1;
                    inv_vertices[index + 8] = def_vertices[index + 8] = 0xff;
                    offset += 2;
                }
                let indices = _drawTexToQuad_Index;
                let indexBuffer = LayaGL.renderDeviceFactory.createIndexBuffer(exports.BufferUsage.Static);
                indexBuffer.indexType = exports.IndexFormat.UInt16;
                indexBuffer.indexCount = indices.length;
                indexBuffer._setIndexDataLength(indices.byteLength);
                indexBuffer._setIndexData(indices, 0);
                let defaultBuffer = LayaGL.renderDeviceFactory.createVertexBuffer(exports.BufferUsage.Static);
                defaultBuffer.vertexDeclaration = GraphicsMesh.vertexDeclarition;
                defaultBuffer.setDataLength(def_vertices.byteLength);
                defaultBuffer.setData(def_vertices.buffer, 0, 0, def_vertices.byteLength);
                let invertBuffer = LayaGL.renderDeviceFactory.createVertexBuffer(exports.BufferUsage.Static);
                invertBuffer.vertexDeclaration = GraphicsMesh.vertexDeclarition;
                invertBuffer.setDataLength(inv_vertices.byteLength);
                invertBuffer.setData(inv_vertices.buffer, 0, 0, inv_vertices.byteLength);
                this.def_geometry = LayaGL.renderDeviceFactory.createRenderGeometryElement(exports.MeshTopology.Triangles, exports.DrawType.DrawElement);
                let defaultState = LayaGL.renderDeviceFactory.createBufferState();
                defaultState.applyState([defaultBuffer], indexBuffer);
                this.def_geometry.bufferState = defaultState;
                this.def_geometry.indexFormat = exports.IndexFormat.UInt16;
                this.def_geometry.setDrawElemenParams(6, 0);
                this.inv_geometry = LayaGL.renderDeviceFactory.createRenderGeometryElement(exports.MeshTopology.Triangles, exports.DrawType.DrawElement);
                let invertState = LayaGL.renderDeviceFactory.createBufferState();
                invertState.applyState([invertBuffer], indexBuffer);
                this.inv_geometry.bufferState = invertState;
                this.inv_geometry.indexFormat = exports.IndexFormat.UInt16;
                this.inv_geometry.setDrawElemenParams(6, 0);
            }
        }
    }
    GraphicsRunner.SEGNUM = 32;
    class ContextParams {
        constructor() {
            this.lineWidth = 1;
        }
        clear() {
            this.lineWidth = 1;
            this.textAlign = this.textBaseline = null;
        }
        make() {
            return this === ContextParams.DEFAULT ? new ContextParams() : this;
        }
    }
    ContextParams.DEFAULT = new ContextParams();

    class Render2DProcessor {
        static __init__() {
            Render2DProcessor.runner = new GraphicsRunner();
            Render2DProcessor.rendercontext2D = LayaGL.render2DRenderPassFactory.createRenderContext2D();
        }
        get basePass() {
            return this._basePass;
        }
        constructor() {
            this._basePass = LayaGL.render2DRenderPassFactory.createRender2DPass();
            this._manager = LayaGL.render2DRenderPassFactory.createRender2DPassManager();
            this._basePass.doClearColor = false;
            this._basePass.priority = 0;
            this.addPass(this._basePass);
        }
        addPass(pass) {
            this._manager.addPass(pass);
        }
        removePass(pass) {
            this._manager.removePass(pass);
        }
        apply(context2D) {
            let t = performance.now();
            this._manager.apply(context2D);
            LayaGL.statAgent.recordTimeData(exports.StatElement.T_2DPass, performance.now() - t);
        }
        clear() {
            this._manager.clear();
        }
    }

    const className$7 = "FillTextCmd";
    class FillTextCmd {
        constructor() {
            this.x = 0;
            this.y = 0;
            this.color = '#ffffff';
            this.strokeColor = '#000000';
            this.stroke = 0;
            this.align = 'left';
            this.fontSize = 20;
        }
        static create(text, x, y, font, color, align, stroke, strokeColor) {
            let cmd = Pool.getItemByClass(className$7, FillTextCmd);
            cmd.text = null;
            cmd.x = x;
            cmd.y = y;
            cmd.font = font;
            cmd.color = color !== null && color !== void 0 ? color : '#ffffff';
            cmd.stroke = stroke !== null && stroke !== void 0 ? stroke : 0;
            cmd.strokeColor = strokeColor !== null && strokeColor !== void 0 ? strokeColor : '#000000';
            cmd.text = text;
            cmd.align = align !== null && align !== void 0 ? align : 'left';
            cmd.singleCharRender = false;
            cmd._preMeasuredWidth = null;
            return cmd;
        }
        get font() {
            if (!this._font)
                this._font = (this.bold ? "bold " : "") + this.fontSize + "px " + (this.fontFamily ? this.fontFamily : Config.defaultFont);
            return this._font;
        }
        set font(value) {
            this._font = value;
            if (!value) {
                this.fontFamily = null;
                this.fontSize = Config.defaultFontSize;
                return;
            }
            let words = value.split(' ');
            let l = words.length;
            if (l < 2) {
                if (l == 1) {
                    if (words[0].indexOf('px') > 0) {
                        this.fontSize = parseInt(words[0]);
                    }
                }
                this.fontFamily = null;
                return;
            }
            let szpos = -1;
            for (let i = 0; i < l; i++) {
                if (words[i].indexOf('px') > 0 || words[i].indexOf('pt') > 0) {
                    szpos = i;
                    this.fontSize = parseInt(words[i]);
                    if (this.fontSize <= 0) {
                        console.debug('font parse error:' + value);
                        this.fontSize = 20;
                    }
                    break;
                }
            }
            let fpos = szpos + 1;
            let familys = words[fpos];
            fpos++;
            for (; fpos < l; fpos++) {
                familys += ' ' + words[fpos];
            }
            this.fontFamily = (familys.split(','))[0];
            this.italic = words.indexOf('italic') >= 0;
            this.bold = words.indexOf('bold') >= 0;
        }
        recover() {
            Pool.recover(className$7, this);
            this._preMeasuredWidth = null;
            if (this._renderInfo)
                Render2DProcessor.runner._textRender.freeRenderInfo(this._renderInfo);
        }
        get cmdID() {
            return FillTextCmd.ID;
        }
        run(runner, gx, gy) {
            if (!this.text) {
                if (this._renderInfo)
                    runner._textRender.freeRenderInfo(this._renderInfo);
                return;
            }
            let tw = this.getTextWidth();
            switch (this.align) {
                case "center":
                    gx -= tw / 2;
                    break;
                case "right":
                    gx -= tw;
                    break;
            }
            this._renderInfo = runner._textRender.draw(this.text, this.x + gx, this.y + gy, this.fontFamily ? this.fontFamily : Config.defaultFont, this.fontSize, this.bold, this.italic, this.color, this.stroke, this.strokeColor, this.singleCharRender, tw, this._renderInfo);
        }
        getTextWidth() {
            if (this._preMeasuredWidth != null)
                return this._preMeasuredWidth;
            let ctx = Browser.context;
            ctx.font = this.font;
            return ctx.measureText(this.text).width;
        }
        getBounds(assembler) {
            let tw = this.getTextWidth();
            let x = this.x;
            let y = this.y;
            switch (this.align) {
                case "center":
                    x -= tw / 2;
                    break;
                case "right":
                    x -= tw;
                    break;
            }
            x -= 4;
            y -= this.fontSize / 2;
            Rectangle.TEMP.setTo(x, y, tw + 8, this.fontSize * 2).getBoundPoints(assembler.points);
        }
    }
    FillTextCmd.ID = className$7;
    ClassUtils.regClass(className$7, FillTextCmd);

    const className$6 = "FillTextureCmd";
    class FillTextureCmd {
        constructor() {
            this.x = 0;
            this.y = 0;
            this.width = 1;
            this.height = 1;
            this.type = "repeat";
            this.percent = true;
            this.color = 0xffffffff;
        }
        static create(texture, x, y, width, height, type, offset, color, percent) {
            if (width == null)
                width = texture.width;
            if (height == null)
                height = texture.height;
            var cmd = Pool.getItemByClass(className$6, FillTextureCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.type = type;
            cmd.offset = offset;
            cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
            cmd.percent = percent;
            return cmd;
        }
        recover() {
            this.texture && this.texture._removeReference();
            this.texture = null;
            this.offset = null;
            Pool.recover(className$6, this);
        }
        run(runner, gx, gy) {
            if (!this.texture)
                return;
            if (this.percent && runner.sprite) {
                let w = runner.sprite.width;
                let h = runner.sprite.height;
                runner.fillTexture(this.texture, this.x * w + gx, this.y * h + gy, this.width * w, this.height * h, this.type, this.offset || Point.EMPTY, this.color);
            }
            else
                runner.fillTexture(this.texture, this.x + gx, this.y + gy, this.width, this.height, this.type, this.offset || Point.EMPTY, this.color);
        }
        getBounds(assembler) {
            let rect = Rectangle.TEMP.setTo(this.x, this.y, this.width, this.height);
            if (this.percent) {
                rect.scale(assembler.width, assembler.height);
            }
            rect.getBoundPoints(assembler.points);
        }
        get cmdID() {
            return FillTextureCmd.ID;
        }
    }
    FillTextureCmd.ID = className$6;
    ClassUtils.regClass(className$6, FillTextureCmd);

    const className$5 = "RotateCmd";
    class RotateCmd {
        static create(angle, pivotX, pivotY) {
            var cmd = Pool.getItemByClass(className$5, RotateCmd);
            cmd.angle = angle;
            cmd.pivotX = pivotX;
            cmd.pivotY = pivotY;
            return cmd;
        }
        recover() {
            Pool.recover(className$5, this);
        }
        run(runner, gx, gy) {
            runner._rotate(this.angle, this.pivotX + gx, this.pivotY + gy);
        }
        getBounds(assembler) {
            tempMatrix$3.identity();
            tempMatrix$3.translate(-this.pivotX, -this.pivotY);
            tempMatrix$3.rotate(this.angle);
            tempMatrix$3.translate(this.pivotX, this.pivotY);
            assembler.concatMatrix(tempMatrix$3);
        }
        get cmdID() {
            return RotateCmd.ID;
        }
    }
    RotateCmd.ID = className$5;
    const tempMatrix$3 = new Matrix();

    const className$4 = "ScaleCmd";
    class ScaleCmd {
        static create(scaleX, scaleY, pivotX, pivotY) {
            var cmd = Pool.getItemByClass(className$4, ScaleCmd);
            cmd.scaleX = scaleX;
            cmd.scaleY = scaleY;
            cmd.pivotX = pivotX;
            cmd.pivotY = pivotY;
            return cmd;
        }
        recover() {
            Pool.recover(className$4, this);
        }
        run(runner, gx, gy) {
            runner._scale(this.scaleX, this.scaleY, this.pivotX + gx, this.pivotY + gy);
        }
        getBounds(assembler) {
            tempMatrix$2.identity();
            tempMatrix$2.translate(-this.pivotX, -this.pivotY);
            tempMatrix$2.scale(this.scaleX, this.scaleY);
            tempMatrix$2.translate(this.pivotX, this.pivotY);
            assembler.concatMatrix(tempMatrix$2);
        }
        get cmdID() {
            return ScaleCmd.ID;
        }
    }
    ScaleCmd.ID = className$4;
    const tempMatrix$2 = new Matrix();

    const className$3 = "TransformCmd";
    class TransformCmd {
        static create(matrix, pivotX, pivotY) {
            var cmd = Pool.getItemByClass(className$3, TransformCmd);
            cmd.matrix = matrix;
            cmd.pivotX = pivotX;
            cmd.pivotY = pivotY;
            return cmd;
        }
        recover() {
            this.matrix = null;
            Pool.recover(className$3, this);
        }
        run(runner, gx, gy) {
            runner._transform(this.matrix, this.pivotX + gx, this.pivotY + gy);
        }
        getBounds(assembler) {
            tempMatrix$1.identity();
            tempMatrix$1.translate(-this.pivotX, -this.pivotY);
            tempMatrix$1.concat(this.matrix);
            tempMatrix$1.translate(this.pivotX, this.pivotY);
            assembler.concatMatrix(tempMatrix$1);
        }
        get cmdID() {
            return TransformCmd.ID;
        }
    }
    TransformCmd.ID = className$3;
    const tempMatrix$1 = new Matrix();

    const className$2 = "TranslateCmd";
    class TranslateCmd {
        static create(tx, ty) {
            var cmd = Pool.getItemByClass(className$2, TranslateCmd);
            cmd.tx = tx;
            cmd.ty = ty;
            return cmd;
        }
        recover() {
            Pool.recover(className$2, this);
        }
        run(context) {
            context.translate(this.tx, this.ty);
        }
        getBounds(assembler) {
            tempMatrix.identity();
            tempMatrix.translate(this.tx, this.ty);
            assembler.concatMatrix(tempMatrix);
        }
        get cmdID() {
            return TranslateCmd.ID;
        }
    }
    TranslateCmd.ID = className$2;
    const tempMatrix = new Matrix();

    const className$1 = "DrawEllipseCmd";
    class DrawEllipseCmd {
        constructor() {
            this.lineWidth = 0;
        }
        static create(x, y, width, height, fillColor, lineColor, lineWidth, percent) {
            var cmd = Pool.getItemByClass(className$1, DrawEllipseCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            cmd.percent = percent;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover(className$1, this);
        }
        run(runner, gx, gy) {
            let offset = (this.lineWidth >= 1 && this.lineColor) ? this.lineWidth / 2 : 0;
            if (this.percent && runner.sprite) {
                let w = runner.sprite.width;
                let h = runner.sprite.height;
                runner._drawEllipse(this.x * w + gx, this.y * h + gy, this.width * w - offset, this.height * h - offset, this.fillColor, this.lineColor, this.lineWidth);
            }
            else {
                runner._drawEllipse(this.x + gx, this.y + gy, this.width - offset, this.height - offset, this.fillColor, this.lineColor, this.lineWidth);
            }
        }
        get cmdID() {
            return DrawEllipseCmd.ID;
        }
        getBounds(assembler) {
            let rect = Rectangle.TEMP.setTo(this.x - this.width, this.y - this.height, this.width * 2, this.height * 2);
            if (this.percent) {
                rect.scale(assembler.width, assembler.height);
            }
            rect.getBoundPoints(assembler.points);
        }
    }
    DrawEllipseCmd.ID = className$1;
    ClassUtils.regClass(className$1, DrawEllipseCmd);

    const className = "DrawRoundRectCmd";
    class DrawRoundRectCmd {
        constructor() {
            this.x = 0;
            this.y = 0;
            this.width = 1;
            this.height = 1;
            this.lt = 6;
            this.rt = 6;
            this.lb = 6;
            this.rb = 6;
            this.lineWidth = 0;
            this.percent = true;
        }
        static create(x, y, width, height, lt, rt, lb, rb, fillColor, lineColor, lineWidth, percent) {
            var cmd = Pool.getItemByClass(className, DrawRoundRectCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.lt = lt;
            cmd.rt = rt;
            cmd.lb = lb;
            cmd.rb = rb;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            cmd.percent = percent;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover(className, this);
        }
        run(runner, gx, gy) {
            let offset = (this.lineWidth >= 1 && this.lineColor) ? this.lineWidth / 2 : 0;
            let lineOffset = this.lineColor ? this.lineWidth : 0;
            if (this.percent && runner.sprite) {
                let w = runner.sprite.width;
                let h = runner.sprite.height;
                runner._drawRoundRect(this.x * w + offset + gx, this.y * h + offset + gy, this.width * w - lineOffset, this.height * h - lineOffset, this.lt, this.rt, this.lb, this.rb, this.fillColor, this.lineColor, this.lineWidth);
            }
            else {
                runner._drawRoundRect(this.x + offset + gx, this.y + offset + gy, this.width - lineOffset, this.height - lineOffset, this.lt, this.rt, this.lb, this.rb, this.fillColor, this.lineColor, this.lineWidth);
            }
        }
        get cmdID() {
            return DrawRoundRectCmd.ID;
        }
        getBounds(assembler) {
            let rect = Rectangle.TEMP.setTo(this.x, this.y, this.width, this.height);
            if (this) {
                rect.scale(assembler.width, assembler.height);
            }
            rect.getBoundPoints(assembler.points);
        }
    }
    DrawRoundRectCmd.ID = className;
    ClassUtils.regClass(className, DrawRoundRectCmd);

    class Graphics {
        static add2DGlobalUniformData(propertyID, propertyKey, uniformtype) {
            let sceneUniformMap = LayaGL.renderDeviceFactory.createGlobalUniformMap("Sprite2DGlobal");
            sceneUniformMap.addShaderUniform(propertyID, propertyKey, uniformtype);
        }
        get useSpriteState() {
            return this._useSpriteState;
        }
        set useSpriteState(value) {
            if (this._useSpriteState == value)
                return;
            this._useSpriteState = value;
            this.repaint();
        }
        constructor() {
            this.owner = null;
            this._useSpriteState = true;
            this._useSpriteRect = false;
            this._cmds = [];
            this._graphicBounds = null;
            this._modified = false;
            this._display = false;
            this._renderDataHandle = LayaGL.render2DRenderPassFactory.create2D2DPrimitiveDataHandle();
        }
        destroy() {
            if (this.owner && this.owner._graphics === this)
                this.owner.setGraphics(null, false);
            for (let cmd of this._cmds) {
                if (!cmd.lock)
                    cmd.recover();
            }
            this._cmds.length = 0;
            if (this._material) {
                this._material._removeReference();
                this._material = null;
            }
            this._graphicBounds && this._graphicBounds.destroy();
            this._graphicBounds = null;
            this._renderDataHandle && this._renderDataHandle.destroy();
            this._data = null;
            this.owner = null;
        }
        clear(recoverCmds, exclude) {
            if (this._cmds.length === 0)
                return;
            if (recoverCmds || recoverCmds == null) {
                for (let cmd of this._cmds) {
                    if (!cmd.lock && cmd != exclude)
                        cmd.recover();
                }
            }
            if (exclude) {
                this._cmds[0] = exclude;
                this._cmds.length = 1;
            }
            else
                this._cmds.length = 0;
            if (this._data) {
                this._data.clear();
            }
            this.repaint();
        }
        _repaint() {
            this.repaint();
        }
        repaint() {
            var _a, _b;
            this._modified = true;
            (_a = this._graphicBounds) === null || _a === void 0 ? void 0 : _a.reset();
            this._checkDisplay();
            (_b = this.owner) === null || _b === void 0 ? void 0 : _b.repaint(exports.RepaintFlag.Graphics);
        }
        get cmds() {
            return this._cmds;
        }
        set cmds(value) {
            if (this._cmds.length > 0) {
                this._cmds.filter(cmd => !value.includes(cmd)).forEach(cmd => {
                    if (!cmd.lock)
                        cmd.recover();
                });
            }
            this._cmds = value;
            this.repaint();
        }
        addCmd(cmd, index) {
            if (cmd == null)
                throw new Error("null cmd");
            if (index == null || index >= this._cmds.length)
                this._cmds.push(cmd);
            else
                this._cmds.splice(index, 0, cmd);
            this.repaint();
            return cmd;
        }
        removeCmd(cmd, recover) {
            let i = this.cmds.indexOf(cmd);
            if (i != -1) {
                this._cmds.splice(i, 1);
                this.repaint();
            }
            if (recover) {
                cmd.lock = false;
                cmd.recover();
            }
        }
        replaceCmd(oldCmd, newCmd, recover) {
            let index = this._cmds.indexOf(oldCmd);
            if (newCmd != null) {
                if (index !== -1)
                    this._cmds[index] = newCmd;
                else
                    this._cmds.push(newCmd);
                this.repaint();
            }
            else if (index != -1) {
                this._cmds.splice(index, 1);
                this.repaint();
            }
            if (oldCmd && recover) {
                oldCmd.lock = false;
                oldCmd.recover();
            }
            return newCmd;
        }
        _checkDisplay() {
            if (!this.owner || this.owner.destroyed) {
                this._display = false;
                return;
            }
            let value = !this.owner._renderNode && (this._cmds.length > 0 || this.owner._texture != null);
            if (this._display === value)
                return;
            this._display = value;
            let struct = this.owner._struct;
            if (value) {
                this._modified = true;
                this.owner._initShaderData();
                this.owner._renderType |= SpriteConst.GRAPHICS;
                struct.renderType = exports.BaseRender2DType.graphics;
                struct.renderDataHandler = this._renderDataHandle;
                struct.renderElements = this._data._renderElements;
                this.owner._updateStruct();
            }
            else {
                this.owner._renderType &= ~SpriteConst.GRAPHICS;
                if (struct.renderElements === this._data._renderElements) {
                    struct.renderElements = [];
                }
                if (this._data) {
                    this._data.clear();
                }
                struct.renderType = -1;
                struct.renderDataHandler = null;
            }
        }
        getBounds() {
            if (!this._graphicBounds)
                this._graphicBounds = GraphicsBounds.create();
            return this._graphicBounds.getBounds(this);
        }
        getBoundPoints() {
            if (!this._graphicBounds)
                this._graphicBounds = GraphicsBounds.create();
            return this._graphicBounds.getBoundPoints(this);
        }
        get material() {
            return this._material;
        }
        set material(value) {
            if (value && !value.checkType(exports.ShaderFeatureType.D2_TextureSV))
                return;
            if (this._material == value)
                return;
            this._material && this._material._removeReference();
            this._material = value;
            this.repaint();
            if (value != null)
                value._addReference();
        }
        drawImage(texture, x = 0, y = 0, width = null, height = null, color = null) {
            if (!texture)
                return null;
            if (!texture.bitmap)
                return null;
            return this.addCmd(DrawImageCmd.create(texture, x, y, width, height, color));
        }
        drawTexture(texture, x = 0, y = 0, width = null, height = null, matrix = null, alpha = 1, color = null, blendMode = null, uv) {
            if (!texture || alpha < 0.01)
                return null;
            if (!texture.bitmap)
                return null;
            return this.addCmd(DrawTextureCmd.create(texture, x, y, width, height, matrix, alpha, color, blendMode, uv));
        }
        drawTextures(texture, pos, colors) {
            if (!texture)
                return null;
            return this.addCmd(DrawTexturesCmd.create(texture, pos, colors));
        }
        drawTriangles(texture, x, y, vertices, uvs, indices, matrix = null, alpha = 1, color = null, blendMode = null) {
            return this.addCmd(DrawTrianglesCmd.create(texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode));
        }
        fillTexture(texture, x, y, width = 0, height = 0, type = "repeat", offset = null, color = null, percent = false) {
            if (texture && texture.bitmap)
                return this.addCmd(FillTextureCmd.create(texture, x, y, width, height, type, offset || Point.EMPTY, color, percent));
            else
                return null;
        }
        clipRect(x, y, width, height) {
            return this.addCmd(ClipRectCmd.create(x, y, width, height));
        }
        fillText(text, x, y, font, color, textAlign) {
            return this.addCmd(FillTextCmd.create(text, x, y, font, color, textAlign, 0, ""));
        }
        fillBorderText(text, x, y, font, fillColor, textAlign, lineWidth, borderColor) {
            return this.addCmd(FillTextCmd.create(text, x, y, font, fillColor, textAlign, lineWidth, borderColor));
        }
        strokeText(text, x, y, font, color, lineWidth, textAlign) {
            return this.addCmd(FillTextCmd.create(text, x, y, font, null, textAlign, lineWidth, color));
        }
        alpha(alpha) {
            return this.addCmd(AlphaCmd.create(alpha));
        }
        transform(matrix, pivotX = 0, pivotY = 0) {
            return this.addCmd(TransformCmd.create(matrix, pivotX, pivotY));
        }
        rotate(angle, pivotX = 0, pivotY = 0) {
            return this.addCmd(RotateCmd.create(angle, pivotX, pivotY));
        }
        scale(scaleX, scaleY, pivotX = 0, pivotY = 0) {
            return this.addCmd(ScaleCmd.create(scaleX, scaleY, pivotX, pivotY));
        }
        translate(tx, ty) {
            return this.addCmd(TranslateCmd.create(tx, ty));
        }
        save() {
            return this.addCmd(SaveCmd.create());
        }
        restore() {
            return this.addCmd(RestoreCmd.create());
        }
        replaceTextColor(color) {
            this.repaint();
            let cmds = this._cmds;
            for (let i = cmds.length - 1; i > -1; i--) {
                let cmd = cmds[i];
                var cmdID = cmd.cmdID;
                switch (cmdID) {
                    case FillTextCmd.ID:
                        cmd.color = color;
                        break;
                    case DrawImageCmd.ID:
                        cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
                        break;
                }
            }
        }
        loadImage(url, x = 0, y = 0, width = null, height = null, complete = null) {
            let tex = ILaya.loader.getRes(url);
            if (tex) {
                this.drawImage(tex, x, y, width, height);
                complete && complete.call(this.owner);
            }
            else {
                ILaya.loader.load(url).then((tex) => {
                    this.drawImage(tex, x, y, width, height);
                    complete && complete.call(this.owner);
                });
            }
        }
        _render(runner, x = 0, y = 0) {
            if (!this.owner || this.owner.destroyed || this.owner._struct.renderType !== exports.BaseRender2DType.graphics)
                return;
            if (!this._modified
                && this._check()) {
                this._data.setRenderElement(this.owner._struct, this._renderDataHandle);
                return;
            }
            this._data.clear();
            runner.clear();
            runner.sprite = this.owner;
            runner._graphicsData = this._data;
            runner._material = this._material;
            let oldBlendMode = runner.globalCompositeOperation;
            runner.globalCompositeOperation = this.owner._struct.blendMode;
            var cmds = this._cmds;
            for (let i = 0, n = cmds.length; i < n; i++) {
                cmds[i].run(runner, x, y);
            }
            this._renderSpriteTexture(runner, x, y);
            this._data.updateRenderElement(this, this.owner._struct, this._renderDataHandle);
            runner.globalCompositeOperation = oldBlendMode;
            runner._material = null;
            runner._graphicsData = null;
            runner.sprite = null;
            this._modified = false;
        }
        _check() {
            let len = this._data._submits.length;
            for (let i = 0; i < len; i++) {
                let submit = this._data._submits.elements[i];
                let texture = submit._internalInfo.textureHost;
                if (!texture)
                    continue;
                let bitmap = texture.bitmap;
                if (bitmap && bitmap.destroyed) {
                    return false;
                }
            }
            return true;
        }
        _renderSpriteTexture(runner, x, y) {
            let sprite = this.owner;
            let tex = sprite._texture;
            if (!tex)
                return;
            if (tex._getSource(() => {
                this.owner.graphics.repaint();
            })) {
                var width = sprite._isWidthSet ? sprite._width : tex.sourceWidth;
                var height = sprite._isHeightSet ? sprite._height : tex.sourceHeight;
                var wRate = width / tex.sourceWidth;
                var hRate = height / tex.sourceHeight;
                width = tex.width * wRate;
                height = tex.height * hRate;
                if (width > 0 && height > 0) {
                    let px = x + tex.offsetX * wRate;
                    let py = y + tex.offsetY * hRate;
                    runner.drawTexture(tex, px, py, width, height, 0xffffffff);
                }
            }
        }
        drawLine(fromX, fromY, toX, toY, lineColor, lineWidth = 1) {
            return this.addCmd(DrawLineCmd.create(fromX, fromY, toX, toY, lineColor, lineWidth));
        }
        drawLines(x, y, points, lineColor, lineWidth = 1) {
            if (!points || points.length < 4)
                return null;
            return this.addCmd(DrawLinesCmd.create(x, y, points, lineColor, lineWidth));
        }
        drawCurves(x, y, points, lineColor, lineWidth = 1) {
            return this.addCmd(DrawCurvesCmd.create(x, y, points, lineColor, lineWidth));
        }
        drawRect(x, y, width, height, fillColor, lineColor = null, lineWidth = 1, percent) {
            return this.addCmd(DrawRectCmd.create(x, y, width, height, fillColor, lineColor, lineWidth, percent));
        }
        drawRoundRect(x, y, width, height, lt, rt, lb, rb, fillColor, lineColor = null, lineWidth = 1, percent) {
            return this.addCmd(DrawRoundRectCmd.create(x, y, width, height, lt, rt, lb, rb, fillColor, lineColor, lineWidth, percent));
        }
        drawCircle(x, y, radius, fillColor, lineColor = null, lineWidth = 1, percent) {
            return this.addCmd(DrawCircleCmd.create(x, y, radius, fillColor, lineColor, lineWidth, percent));
        }
        drawEllipse(x, y, width, height, fillColor, lineColor, lineWidth, percent) {
            return this.addCmd(DrawEllipseCmd.create(x, y, width, height, fillColor, lineColor, lineWidth, percent));
        }
        drawPie(x, y, radius, startAngle, endAngle, fillColor, lineColor = null, lineWidth = 1) {
            return this.addCmd(DrawPieCmd.create(x, y, radius, Utils.toRadian(startAngle), Utils.toRadian(endAngle), fillColor, lineColor, lineWidth));
        }
        drawPoly(x, y, points, fillColor, lineColor = null, lineWidth = 1) {
            return this.addCmd(DrawPolyCmd.create(x, y, points, fillColor, lineColor, lineWidth));
        }
        drawPath(x, y, paths, brush = null, pen = null) {
            return this.addCmd(DrawPathCmd.create(x, y, paths, brush, pen));
        }
        draw9Grid(texture, x = 0, y = 0, width = 0, height = 0, sizeGrid, color) {
            this.addCmd(Draw9GridTextureCmd.create(texture, x, y, width, height, sizeGrid, false, color));
        }
    }

    const ARRAY_EMPTY = [];
    const initBits = NodeFlags.ACTIVE;
    const reactiveBits = NodeFlags.DISPLAY;
    class Node extends EventDispatcher {
        get url() {
            return this._url;
        }
        set url(path) {
            this._url = path;
        }
        get hideFlags() {
            return this._hideFlags;
        }
        set hideFlags(value) {
            this._hideFlags = value;
        }
        get is3D() {
            return this._nodeType === 1;
        }
        get destroyed() {
            return this._destroyed;
        }
        constructor() {
            super();
            this._bits = 0;
            this._reactiveBits = 0;
            this._hideFlags = 0;
            this._parent = null;
            this._destroyed = false;
            this._nodeType = 0;
            this.name = "";
            this._bits = initBits;
            this._reactiveBits = reactiveBits;
            this._children = [];
            this._$children = this._children;
            this._$container = this;
            this._initialize();
        }
        _initialize() {
            this._extra = {};
        }
        _setBit(bit, value) {
            if (((this._bits & bit) === 0) === !value)
                return false;
            if (value)
                this._bits |= bit;
            else
                this._bits &= ~bit;
            if ((bit & this._reactiveBits) != 0)
                this._onSetBit(bit, value);
            return true;
        }
        _getBit(bit) {
            return (this._bits & bit) !== 0;
        }
        _onSetBit(bit, value) {
            if ((bit & NodeFlags.DISPLAY) !== 0) {
                let ele = this._parent;
                let stage = ILaya.stage;
                let displayedInStage = this === stage;
                while (ele) {
                    if ((ele._bits & NodeFlags.DISPLAY) !== 0) {
                        displayedInStage = (ele._bits & NodeFlags.DISPLAYED_INSTAGE) !== 0;
                        break;
                    }
                    if (ele === stage) {
                        displayedInStage = true;
                        break;
                    }
                    ele = ele._parent;
                }
                this._setBit(NodeFlags.DISPLAYED_INSTAGE, displayedInStage);
            }
        }
        _setBitUp(type) {
            let ele = this;
            ele._setBit(type, true);
            ele = ele._parent;
            while (ele) {
                if ((ele._bits & type) !== 0)
                    return;
                ele._setBit(type, true);
                ele = ele._parent;
            }
        }
        onStartListeningToType(type) {
            if ((type === Event.DISPLAY || type === Event.UNDISPLAY) && (this._bits & NodeFlags.DISPLAY) === 0) {
                this._setBitUp(NodeFlags.DISPLAY);
            }
        }
        bubbleEvent(type, data) {
            let arr = [];
            arr.length = 0;
            let obj = this;
            while (obj) {
                if (obj.activeInHierarchy)
                    arr.push(obj);
                obj = obj._parent;
            }
            let evt;
            if (data instanceof Event) {
                evt = data;
                evt._stopped = false;
            }
            for (let obj of arr) {
                if (evt) {
                    evt.setTo(type, obj, this);
                    obj.event(type, data);
                    if (evt._stopped)
                        break;
                }
                else
                    obj.event(type, data);
            }
        }
        hasHideFlag(flag) {
            return (this._hideFlags & flag) != 0;
        }
        destroy(destroyChild = true) {
            if (this._destroyed)
                return;
            this._destroyed = true;
            this.destroyAllComponent();
            this._parent && this._parent._removeChild(this);
            for (let i = 0, n = this._children.length; i < n; i++) {
                let node = this._children[0];
                this._children.shift();
                if (!node)
                    continue;
                node._setParent(null);
                if (destroyChild)
                    node.destroy();
            }
            this.onDestroy();
            this.offAll();
        }
        onDestroy() {
        }
        destroyChildren() {
            for (let i = 0, n = this._$children.length; i < n; i++) {
                this._$children[0].destroy(true);
            }
        }
        get children() {
            return this._$children;
        }
        addChild(node) {
            return this.addChildAt(node, this._$children.length);
        }
        addChildren(...args) {
            let i = 0, n = args.length;
            while (i < n) {
                this.addChildAt(args[i++], this._$children.length);
            }
        }
        addChildAt(node, index) {
            if (index >= 0 && index <= this._$children.length) {
                if (node._$parent === this) {
                    this.setChildIndex(node, index);
                }
                else {
                    node._parent && node._parent.removeChild(node);
                    this._$children.splice(index, 0, node);
                    node._$parent = this;
                    node._setParent(this._$container);
                }
                return node;
            }
            else {
                throw new OutOfRangeError(index);
            }
        }
        getChildIndex(node) {
            return this._$children.indexOf(node);
        }
        getChild(name, classType) {
            for (let child of this._$children) {
                if (child.name === name)
                    return child;
            }
            return null;
        }
        getChildByName(name, classType) {
            return this.getChild(name, classType);
        }
        getChildAt(index, classType) {
            if (index >= 0 && index < this.numChildren)
                return this._$children[index];
            else
                throw new OutOfRangeError(index);
        }
        getChildByPath(path, classType) {
            let arr = path.split(".");
            let cnt = arr.length;
            let p = this;
            let obj;
            for (let i = 0; i < cnt; ++i) {
                obj = p.getChild(arr[i], classType);
                if (!obj)
                    break;
                p = obj;
            }
            return obj;
        }
        findChild(name, classType) {
            for (let c of this._$children) {
                if (c.name == name)
                    return c;
                if (!c.url) {
                    c = c.findChild(name, classType);
                    if (c)
                        return c;
                }
            }
            return null;
        }
        setChildIndex(node, index) {
            let oldIndex = this._$children.indexOf(node);
            if (oldIndex < 0)
                throw new Error("not a child of this node");
            this._setChildIndex(node, oldIndex, index);
            return node;
        }
        setChildIndexBefore(node, index) {
            let oldIndex = this._$children.indexOf(node);
            if (oldIndex == -1)
                throw new Error("not a child of this node");
            if (oldIndex < index)
                return this._setChildIndex(node, oldIndex, index - 1);
            else
                return this._setChildIndex(node, oldIndex, index);
        }
        _setChildIndex(node, oldIndex, index) {
            let cnt = this._$children.length;
            if (index > cnt)
                index = cnt;
            if (oldIndex == index)
                return oldIndex;
            this._$children.splice(oldIndex, 1);
            if (index >= this._$children.length)
                this._$children.push(node);
            else
                this._$children.splice(index, 0, node);
            this._$container._childChanged();
            return index;
        }
        _childChanged(child) {
        }
        removeChild(node, destroy) {
            let index = this._$children.indexOf(node);
            if (index == -1)
                throw new Error("not a child of this node");
            this._$children.splice(index, 1);
            node._setParent(null);
            if (destroy)
                node.destroy();
            return node;
        }
        removeSelf() {
            this._parent && this._parent._removeChild(this);
            return this;
        }
        removeChildByName(name, destroy) {
            let node = this.getChild(name);
            node && this.removeChild(node, destroy);
            return node;
        }
        removeChildAt(index, destroy) {
            let node = this._$children[index];
            this._$children.splice(index, 1);
            node._setParent(null);
            if (destroy)
                node.destroy();
            return node;
        }
        removeChildren(beginIndex, endIndex, destroy) {
            beginIndex = beginIndex || 0;
            if (endIndex == null)
                endIndex = -1;
            if (endIndex < 0 || endIndex >= this._$children.length)
                endIndex = this._$children.length - 1;
            for (let i = beginIndex; i <= endIndex; ++i)
                this.removeChildAt(beginIndex, destroy);
        }
        replaceChild(newNode, oldNode) {
            let index = this._$children.indexOf(oldNode);
            if (index == -1)
                throw new Error("not a child of this node");
            this.removeChildAt(index);
            return this.addChildAt(newNode, index);
        }
        _setContainer(container) {
            this._$container = container;
            this._$children = container._children;
        }
        _addChild(node, index) {
            let children = this._children;
            if (index == null)
                index = children.length;
            if (index >= 0 && index <= children.length) {
                if (node._parent === this) {
                    let oldIndex = children.indexOf(node);
                    children.splice(oldIndex, 1);
                    if (index >= children.length)
                        children.push(node);
                    else
                        children.splice(index, 0, node);
                    this._childChanged(node);
                }
                else {
                    node._parent && node._parent.removeChild(node);
                    children.splice(index, 0, node);
                    node._$parent = this;
                    node._setParent(this);
                }
                return node;
            }
            else {
                throw new OutOfRangeError(index);
            }
        }
        _removeChild(node) {
            let index = this._children.indexOf(node);
            if (index == -1)
                throw new Error("not a child of this node");
            this._children.splice(index, 1);
            node._setParent(null);
            return node;
        }
        get numChildren() {
            return this._$children.length;
        }
        get parent() {
            return this._$parent;
        }
        isAncestorOf(node) {
            if (!node)
                return false;
            let p = node._parent;
            while (p) {
                if (p == this)
                    return true;
                p = p._parent;
            }
            return false;
        }
        _setParent(value) {
            if (value) {
                this._parent = value;
                this._onAdded();
                this.event(Event.ADDED);
                if ((this._bits & NodeFlags.DISPLAY) !== 0) {
                    this._setBitUp(NodeFlags.DISPLAY);
                    if (value.displayedInStage)
                        this._displayChild(this, true);
                }
                value._childChanged(this);
            }
            else {
                this._onRemoved();
                this.event(Event.REMOVED);
                let p = this._parent;
                if ((this._bits & NodeFlags.DISPLAY) !== 0)
                    this._displayChild(this, false);
                this._parent = null;
                this._$parent = null;
                if (!p._destroyed)
                    p._childChanged(this);
            }
        }
        get displayedInStage() {
            if ((this._bits & NodeFlags.DISPLAY) === 0)
                this._setBitUp(NodeFlags.DISPLAY);
            return (this._bits & NodeFlags.DISPLAYED_INSTAGE) !== 0;
        }
        _setDisplay(value) {
            if (((this._bits & NodeFlags.DISPLAYED_INSTAGE) !== 0) !== value) {
                this._setBit(NodeFlags.DISPLAYED_INSTAGE, value);
                if (value)
                    this.event(Event.DISPLAY);
                else
                    this.event(Event.UNDISPLAY);
            }
        }
        _displayChild(node, display) {
            for (let child of node._children) {
                if ((child._bits & NodeFlags.DISPLAY) === 0)
                    continue;
                if (child._children.length > 0) {
                    this._displayChild(child, display);
                }
                else {
                    child._setDisplay(display);
                }
            }
            node._setDisplay(display);
        }
        contains(node) {
            if (node === this)
                return true;
            while (node) {
                if (node._parent === this)
                    return true;
                node = node._parent;
            }
            return false;
        }
        timerLoop(delay, caller, method, args = null, coverBefore = true, jumpFrame = false) {
            this.timer.loop(delay, caller, method, args, coverBefore, jumpFrame);
        }
        timerOnce(delay, caller, method, args = null, coverBefore = true) {
            this.timer._create(false, false, delay, caller, method, args, coverBefore);
        }
        frameLoop(delay, caller, method, args = null, coverBefore = true) {
            this.timer._create(true, true, delay, caller, method, args, coverBefore);
        }
        frameOnce(delay, caller, method, args = null, coverBefore = true) {
            this.timer._create(true, false, delay, caller, method, args, coverBefore);
        }
        clearTimer(caller, method) {
            this.timer.clear(caller, method);
        }
        callLater(method, args = null) {
            this.timer.callLater(this, method, args);
        }
        runCallLater(method) {
            this.timer.runCallLater(this, method);
        }
        get scene() {
            return this._scene;
        }
        get stage() {
            return ILaya.stage;
        }
        get active() {
            return (this._bits & NodeFlags.ACTIVE) !== 0;
        }
        set active(value) {
            var _a;
            value = !!value;
            if (((this._bits & NodeFlags.ACTIVE) !== 0) !== value) {
                if (this._activeChangeScripts && this._activeChangeScripts.length !== 0)
                    throw new Error("recursive set active");
                this._setBit(NodeFlags.ACTIVE, value);
                if (((_a = this._parent) === null || _a === void 0 ? void 0 : _a.activeInHierarchy) && (this._bits & NodeFlags.NOT_IN_PAGE) == 0) {
                    this._processActive(value, true);
                }
            }
        }
        get activeInHierarchy() {
            return (this._bits & NodeFlags.ACTIVE_INHIERARCHY) !== 0;
        }
        _onActive() {
        }
        _onInActive() {
        }
        _onActiveInScene() {
        }
        _onInActiveInScene() {
        }
        onAwake() {
        }
        onEnable() {
        }
        onDisable() {
        }
        _parse(data, spriteMap) {
        }
        _setBelongScene(scene) {
            if (!this._scene || this._scene != scene) {
                this._scene = scene;
                this._onActiveInScene();
                for (let child of this._children)
                    child._setBelongScene(scene);
            }
        }
        _setUnBelongScene() {
            if (this._scene !== this) {
                this._onInActiveInScene();
                this._scene = null;
                for (let child of this._children)
                    child._setUnBelongScene();
            }
        }
        _processActive(active, fromSetter) {
            (this._activeChangeScripts) || (this._activeChangeScripts = []);
            let arr = this._activeChangeScripts;
            if (active)
                this._activeHierarchy(arr, fromSetter);
            else
                this._inActiveHierarchy(arr, fromSetter);
            for (let i = 0, n = arr.length; i < n; i++) {
                let comp = arr[i];
                comp.owner && comp._setActive(active);
            }
            arr.length = 0;
        }
        _activeHierarchy(activeChangeScripts, fromSetter) {
            this._setBit(NodeFlags.ACTIVE_INHIERARCHY, true);
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let comp = this._components[i];
                    if (comp._isScript())
                        (comp._enabled) && (activeChangeScripts.push(comp));
                    else
                        comp._setActive(true);
                }
            }
            this._onActive();
            LayaGL.statAgent.recordCountData(exports.StatElement.C_Sprite2DCount, 1);
            for (let child of this._children) {
                if ((child._bits & NodeFlags.ACTIVE) !== 0 && (child._bits & NodeFlags.NOT_IN_PAGE) === 0)
                    child._activeHierarchy(activeChangeScripts, fromSetter);
            }
            if ((this._bits & NodeFlags.AWAKED) === 0) {
                this._setBit(NodeFlags.AWAKED, true);
                this.onAwake();
            }
            this.onEnable();
        }
        _inActiveHierarchy(activeChangeScripts, fromSetter) {
            this._onInActive();
            LayaGL.statAgent.recordCountData(exports.StatElement.C_Sprite2DCount, -1);
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let comp = this._components[i];
                    if (comp._isScript())
                        comp._enabled && (activeChangeScripts.push(comp));
                    else
                        comp._setActive(false);
                }
            }
            this._setBit(NodeFlags.ACTIVE_INHIERARCHY, false);
            for (let child of this._children) {
                if ((child._bits & NodeFlags.ACTIVE_INHIERARCHY) !== 0)
                    child._inActiveHierarchy(activeChangeScripts, fromSetter);
            }
            this.onDisable();
        }
        _onAdded() {
            if (this._activeChangeScripts && this._activeChangeScripts.length !== 0) {
                throw new Error("recursive set active");
            }
            else {
                let parentScene = this._parent.scene;
                if (parentScene)
                    this._setBelongScene(parentScene);
                if (this._parent.activeInHierarchy
                    && (this._bits & NodeFlags.ACTIVE) !== 0
                    && (this._bits & NodeFlags.NOT_IN_PAGE) === 0)
                    this._processActive(true);
            }
        }
        _onRemoved() {
            if (this._activeChangeScripts && this._activeChangeScripts.length !== 0) {
                throw new Error("recursive set active");
            }
            else {
                if (this._parent.activeInHierarchy
                    && (this._bits & NodeFlags.ACTIVE) !== 0
                    && (this._bits & NodeFlags.NOT_IN_PAGE) === 0)
                    this._processActive(false);
                if (this._parent.scene)
                    this._setUnBelongScene();
            }
        }
        _addComponentInstance(comp) {
            var _a;
            if (comp._singleton && this.getComponent(comp.constructor)) {
                console.warn("the component is singleton, can't add the second one.", comp);
                return;
            }
            if (!this._components)
                this._components = [];
            this._components.push(comp);
            comp._setOwner(this);
            if (this.activeInHierarchy)
                comp._setActive(true);
            (_a = this._componentsChanged) === null || _a === void 0 ? void 0 : _a.call(this, comp, 0);
        }
        _destroyComponent(comp) {
            var _a;
            if (!this._components)
                return;
            let i = this._components.indexOf(comp);
            if (i != -1) {
                this._components.splice(i, 1);
                comp._destroy();
                (_a = this._componentsChanged) === null || _a === void 0 ? void 0 : _a.call(this, comp, 1);
            }
        }
        destroyAllComponent() {
            var _a;
            if (!this._components)
                return;
            for (let i = 0, n = this._components.length; i < n; i++) {
                let item = this._components[i];
                item && !item.destroyed && item._destroy();
            }
            this._components.length = 0;
            (_a = this._componentsChanged) === null || _a === void 0 ? void 0 : _a.call(this, null, 2);
        }
        _cloneTo(destObject, srcRoot, dstRoot) {
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let destComponent = destObject.addComponent(this._components[i].constructor);
                    this._components[i]._cloneTo(destComponent);
                }
            }
        }
        addComponentInstance(component) {
            if (component.owner)
                throw new Error("the component is belong to other node.");
            this._addComponentInstance(component);
            return component;
        }
        addComponent(componentType) {
            let comp = Pool.createByClass(componentType);
            if (!comp)
                throw new Error("missing " + componentType.toString());
            this._addComponentInstance(comp);
            return comp;
        }
        getComponent(componentType) {
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let comp = this._components[i];
                    if (comp instanceof componentType)
                        return comp;
                }
            }
            return null;
        }
        get components() {
            return this._components || ARRAY_EMPTY;
        }
        getComponents(componentType) {
            let arr = [];
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let comp = this._components[i];
                    if (comp instanceof componentType) {
                        arr = arr || [];
                        arr.push(comp);
                    }
                }
            }
            return arr;
        }
        get timer() {
            return this._scene ? this._scene.timer : ILaya.timer;
        }
        onAfterDeserialize() { }
    }

    class Stat {
        static get FPS() {
            return LayaGL.statAgent.getElementData(exports.StatElement.CT_FPS);
        }
        static show(x, y, views) {
            if (!Stat._statUI)
                Stat._statUI = new Stat._statUIClass();
            this.hide();
            if (views) {
                Stat.elements.length = 0;
                Stat.elements.push(...views);
            }
            if (Stat.elements.length === 0) {
                const statEnum = PlayerConfig.statEnum;
                if (statEnum) {
                    for (let k in statEnum) {
                        if (statEnum[k]) {
                            Stat.elements.push(exports.StatElement[k]);
                        }
                    }
                    Stat.elements.sort();
                }
            }
            if (Stat.elements.length === 0) {
                Stat.elements.push(...defaultElements);
            }
            Stat._show = true;
            Stat._statUI.show(x, y);
            ILaya.systemTimer.frameLoop(1, null, Stat.loop);
        }
        static hide() {
            if (!Stat._show)
                return;
            Stat._show = false;
            Stat._statUI.hide();
            ILaya.systemTimer.clear(null, Stat.loop);
        }
        static loop() {
            if (Stat._show) {
                Stat._statUI.update();
            }
        }
        static render() {
            if (Stat._show)
                Stat._statUI.render();
        }
    }
    Stat.elements = [];
    Stat.loopCount = 0;
    Stat.render2DCount = 0;
    Stat.enableShadow = true;
    Stat.enableMulLight = true;
    Stat.enableLight = true;
    Stat.enableCameraCMD = true;
    Stat.enablePostprocess = true;
    Stat.enableSkin = true;
    Stat.enableTransparent = true;
    Stat.enableParticle = true;
    Stat.enableAnimatorUpdate = true;
    Stat.enablePhysicsUpdate = true;
    Stat.enablemsaa = true;
    Stat.enableOpaque = true;
    const defaultElements = [
        exports.StatElement.CT_FPS,
        exports.StatElement.T_Frame_Time,
        exports.StatElement.C_Sprite2DCount,
        exports.StatElement.C_Sprite3DCount,
        exports.StatElement.CT_DrawCall,
        exports.StatElement.CT_Triangle,
        exports.StatElement.C_BaseRenderCount,
        exports.StatElement.C_SkinnedMeshRenderCount,
        exports.StatElement.C_ShurikenParticleRenderCount,
        exports.StatElement.T_CullMain,
        exports.StatElement.CT_OpaqueDrawCall,
        exports.StatElement.CT_TransDrawCall,
        exports.StatElement.CT_ShadowDrawCall,
        exports.StatElement.CT_DepthCastDrawCall,
        exports.StatElement.CT_Instancing_DrawCall,
        exports.StatElement.M_GPUMemory,
        exports.StatElement.M_AllTexture,
        exports.StatElement.M_RenderTexture,
        exports.StatElement.M_GPUBuffer
    ];
    window.Stat = Stat;

    class RenderTexture2D extends BaseTexture {
        static __init__() {
            RenderTexture2D._empty = new RenderTexture2D(1, 1, exports.RenderTargetFormat.R8G8B8, exports.RenderTargetFormat.None);
            RenderTexture2D._empty.width = 0;
            RenderTexture2D._empty.height = 0;
            RenderTexture2D._empty.lock = true;
        }
        static createFromPool(width, height, colorFormat, depthFormat) {
            for (let i = RenderTexture2D._pool.length - 1; i >= 0; i--) {
                let rt = RenderTexture2D._pool[i];
                if (rt.destroyed) {
                    RenderTexture2D._pool.splice(i, 1);
                    let gpuMem = rt._renderTarget ? (rt._renderTarget.gpuMemory / 1024 / 1024) : 0;
                    RenderTexture2D._poolMemory -= gpuMem;
                    RenderTexture2D._poolTimeouts.delete(rt._id);
                    continue;
                }
                if (rt.width == width && rt.height == height && rt.getColorFormat() == colorFormat && rt.depthStencilFormat == depthFormat) {
                    rt._inPool = false;
                    RenderTexture2D._pool.splice(i, 1);
                    RenderTexture2D._poolMemory -= (rt._renderTarget.gpuMemory / 1024 / 1024);
                    RenderTexture2D._poolTimeouts.delete(rt._id);
                    return rt;
                }
            }
            let rt = new RenderTexture2D(width, height, colorFormat, depthFormat);
            rt.lock = true;
            return rt;
        }
        static recoverToPool(rt) {
            if (rt._inPool || rt.destroyed)
                return;
            RenderTexture2D._pool.push(rt);
            RenderTexture2D._poolMemory += (rt._renderTarget.gpuMemory / 1024 / 1024);
            rt._inPool = true;
            RenderTexture2D._poolTimeouts.set(rt.id, performance.now());
        }
        static clearPool() {
            if (RenderTexture2D._poolMemory < 256) {
                return;
            }
            for (var i in RenderTexture2D._pool) {
                RenderTexture2D._pool[i].destroy();
            }
            RenderTexture2D._pool = [];
            RenderTexture2D._poolMemory = 0;
            RenderTexture2D._poolTimeouts.clear();
        }
        static cleanupExpired() {
            let currentFrame = Stat.loopCount;
            if (currentFrame - RenderTexture2D._lastCleanupFrame < RenderTexture2D.cleanupFrameInterval) {
                return -1;
            }
            RenderTexture2D._lastCleanupFrame = currentFrame;
            let timeout = RenderTexture2D.cleanupTimeout;
            let currentTime = performance.now();
            let cleanedCount = 0;
            for (let i = RenderTexture2D._pool.length - 1; i >= 0; i--) {
                let rt = RenderTexture2D._pool[i];
                let poolTime = RenderTexture2D._poolTimeouts.get(rt.id);
                if (poolTime && (currentTime - poolTime) > timeout) {
                    RenderTexture2D._pool.splice(i, 1);
                    RenderTexture2D._poolMemory -= (rt._renderTarget.gpuMemory / 1024 / 1024);
                    RenderTexture2D._poolTimeouts.delete(rt.id);
                    rt.destroy();
                    cleanedCount++;
                }
            }
            return cleanedCount;
        }
        static get currentActive() {
            return RenderTexture2D._currentActive;
        }
        get depthStencilFormat() {
            return this._depthStencilFormat;
        }
        get defaultTexture() {
            return Texture2D.grayTexture;
        }
        getIsReady() {
            return true;
        }
        getColorFormat() {
            return this._colorFormat;
        }
        get sourceWidth() {
            return this._width;
        }
        get sourceHeight() {
            return this._height;
        }
        get offsetX() {
            return 0;
        }
        get offsetY() {
            return 0;
        }
        constructor(width, height, format = exports.RenderTargetFormat.R8G8B8, depthStencilFormat = exports.RenderTargetFormat.None) {
            super(width, height, format);
            this._mgrKey = 0;
            this._invertY = false;
            this._inPool = false;
            this._colorFormat = format;
            this._depthStencilFormat = depthStencilFormat;
            if (width != 0 && height != 0) {
                this._create();
            }
            this.lock = true;
        }
        get isCube() {
            return this._renderTarget._isCube;
        }
        get samples() {
            return this._renderTarget._samples;
        }
        get generateMipmap() {
            return this._renderTarget._generateMipmap;
        }
        _start() {
            throw new NotImplementedError();
        }
        _end() {
            throw new NotImplementedError();
        }
        _create() {
            this._renderTarget = LayaGL.textureContext.createRenderTargetInternal(this.width, this.height, this._colorFormat, this.depthStencilFormat, false, false, 1, false);
            this._texture = this._renderTarget._textures[0];
            this._texture.gammaCorrection = 2.2;
        }
        clear(r = 0.0, g = 0.0, b = 0.0, a = 1.0) {
            RenderTexture2D._clearColor.r = r;
            RenderTexture2D._clearColor.g = g;
            RenderTexture2D._clearColor.b = b;
            RenderTexture2D._clearColor.a = a;
            RenderTexture2D._clear = true;
        }
        getData(x, y, width, height) {
            const pixelCount = width * height * 4;
            let pixelArray;
            switch (this._renderTarget.colorFormat) {
                case exports.RenderTargetFormat.R8G8B8:
                case exports.RenderTargetFormat.R8G8B8A8:
                    pixelArray = new Uint8Array(pixelCount);
                    break;
                case exports.RenderTargetFormat.R16G16B16A16:
                    pixelArray = new Float32Array(pixelCount);
                    break;
                default:
                    throw new Error("getData is not supported " + this._renderTarget.colorFormat.toString() + "format");
            }
            LayaGL.textureContext.readRenderTargetPixelData(this._renderTarget, x, y, width, height, pixelArray);
            return pixelArray;
        }
        getDataAsync(xOffset, yOffset, width, height, out) {
            return LayaGL.textureContext.readRenderTargetPixelDataAsync(this._renderTarget, xOffset, yOffset, width, height, out);
        }
        recycle() {
        }
        _disposeResource() {
            this._renderTarget && this._renderTarget.dispose();
        }
    }
    RenderTexture2D._pool = [];
    RenderTexture2D._poolMemory = 0;
    RenderTexture2D._poolTimeouts = new Map();
    RenderTexture2D.cleanupTimeout = 30000;
    RenderTexture2D.cleanupFrameInterval = 360;
    RenderTexture2D._lastCleanupFrame = 0;
    RenderTexture2D._clearColor = new Color(0, 0, 0, 0);
    RenderTexture2D._clear = false;

    var Ease = {
        linear,
        linearNone: linear,
        linearIn,
        linearInOut,
        linearOut,
        bounceIn,
        bounceInOut,
        bounceOut,
        backIn,
        backInOut,
        backOut,
        elasticIn,
        elasticInOut,
        elasticOut,
        strongIn,
        strongInOut,
        strongOut,
        sineInOut,
        sineIn,
        sineOut,
        quintIn,
        quintInOut,
        quintOut,
        quartIn,
        quartInOut,
        quartOut,
        cubicIn,
        cubicInOut,
        cubicOut,
        quadIn,
        quadInOut,
        quadOut,
        expoIn,
        expoInOut,
        expoOut,
        circIn,
        circInOut,
        circOut,
    };
    const HALF_PI = Math.PI * 0.5;
    const PI2 = Math.PI * 2;
    function linear(t, b, c, d) {
        return c * t / d + b;
    }
    function linearIn(t, b, c, d) {
        return c * t / d + b;
    }
    function linearInOut(t, b, c, d) {
        return c * t / d + b;
    }
    function linearOut(t, b, c, d) {
        return c * t / d + b;
    }
    function bounceIn(t, b, c, d) {
        return c - Ease.bounceOut(d - t, 0, c, d) + b;
    }
    function bounceInOut(t, b, c, d) {
        if (t < d * 0.5)
            return Ease.bounceIn(t * 2, 0, c, d) * .5 + b;
        else
            return Ease.bounceOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
    }
    function bounceOut(t, b, c, d) {
        if ((t /= d) < (1 / 2.75))
            return c * (7.5625 * t * t) + b;
        else if (t < (2 / 2.75))
            return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
        else if (t < (2.5 / 2.75))
            return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
        else
            return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
    }
    function backIn(t, b, c, d, s = 1.70158) {
        return c * (t /= d) * t * ((s + 1) * t - s) + b;
    }
    function backInOut(t, b, c, d, s = 1.70158) {
        if ((t /= d * 0.5) < 1)
            return c * 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
        return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
    }
    function backOut(t, b, c, d, s = 1.70158) {
        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    }
    function elasticIn(t, b, c, d, a = 0, p = 0) {
        var s;
        if (t == 0)
            return b;
        if ((t /= d) == 1)
            return b + c;
        if (!p)
            p = d * .3;
        if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
            a = c;
            s = p / 4;
        }
        else
            s = p / PI2 * Math.asin(c / a);
        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * PI2 / p)) + b;
    }
    function elasticInOut(t, b, c, d, a = 0, p = 0) {
        var s;
        if (t == 0)
            return b;
        if ((t /= d * 0.5) == 2)
            return b + c;
        if (!p)
            p = d * (.3 * 1.5);
        if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
            a = c;
            s = p / 4;
        }
        else
            s = p / PI2 * Math.asin(c / a);
        if (t < 1)
            return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * PI2 / p)) + b;
        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * PI2 / p) * .5 + c + b;
    }
    function elasticOut(t, b, c, d, a = 0, p = 0) {
        var s;
        if (t == 0)
            return b;
        if ((t /= d) == 1)
            return b + c;
        if (!p)
            p = d * .3;
        if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
            a = c;
            s = p / 4;
        }
        else
            s = p / PI2 * Math.asin(c / a);
        return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * PI2 / p) + c + b);
    }
    function strongIn(t, b, c, d) {
        return c * (t /= d) * t * t * t * t + b;
    }
    function strongInOut(t, b, c, d) {
        if ((t /= d * 0.5) < 1)
            return c * 0.5 * t * t * t * t * t + b;
        return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b;
    }
    function strongOut(t, b, c, d) {
        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    }
    function sineInOut(t, b, c, d) {
        return -c * 0.5 * (Math.cos(Math.PI * t / d) - 1) + b;
    }
    function sineIn(t, b, c, d) {
        return -c * Math.cos(t / d * HALF_PI) + c + b;
    }
    function sineOut(t, b, c, d) {
        return c * Math.sin(t / d * HALF_PI) + b;
    }
    function quintIn(t, b, c, d) {
        return c * (t /= d) * t * t * t * t + b;
    }
    function quintInOut(t, b, c, d) {
        if ((t /= d * 0.5) < 1)
            return c * 0.5 * t * t * t * t * t + b;
        return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b;
    }
    function quintOut(t, b, c, d) {
        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    }
    function quartIn(t, b, c, d) {
        return c * (t /= d) * t * t * t + b;
    }
    function quartInOut(t, b, c, d) {
        if ((t /= d * 0.5) < 1)
            return c * 0.5 * t * t * t * t + b;
        return -c * 0.5 * ((t -= 2) * t * t * t - 2) + b;
    }
    function quartOut(t, b, c, d) {
        return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    }
    function cubicIn(t, b, c, d) {
        return c * (t /= d) * t * t + b;
    }
    function cubicInOut(t, b, c, d) {
        if ((t /= d * 0.5) < 1)
            return c * 0.5 * t * t * t + b;
        return c * 0.5 * ((t -= 2) * t * t + 2) + b;
    }
    function cubicOut(t, b, c, d) {
        return c * ((t = t / d - 1) * t * t + 1) + b;
    }
    function quadIn(t, b, c, d) {
        return c * (t /= d) * t + b;
    }
    function quadInOut(t, b, c, d) {
        if ((t /= d * 0.5) < 1)
            return c * 0.5 * t * t + b;
        return -c * 0.5 * ((--t) * (t - 2) - 1) + b;
    }
    function quadOut(t, b, c, d) {
        return -c * (t /= d) * (t - 2) + b;
    }
    function expoIn(t, b, c, d) {
        return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b - c * 0.001;
    }
    function expoInOut(t, b, c, d) {
        if (t == 0)
            return b;
        if (t == d)
            return b + c;
        if ((t /= d * 0.5) < 1)
            return c * 0.5 * Math.pow(2, 10 * (t - 1)) + b;
        return c * 0.5 * (-Math.pow(2, -10 * --t) + 2) + b;
    }
    function expoOut(t, b, c, d) {
        return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
    }
    function circIn(t, b, c, d) {
        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
    }
    function circInOut(t, b, c, d) {
        if ((t /= d * 0.5) < 1)
            return -c * 0.5 * (Math.sqrt(1 - t * t) - 1) + b;
        return c * 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
    }
    function circOut(t, b, c, d) {
        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
    }

    class TweenValue {
        constructor(props) {
            this._props = props;
            this.nums = [];
        }
        get(name) {
            let prop = this._props.find(e => e.name == name);
            if (!prop)
                throw new Error(`Property '${name}' is not in tween.`);
            return this.read(prop.type, prop.offset);
        }
        set(name, value) {
            let prop = this._props.find(e => e.name == name);
            if (!prop)
                throw new Error(`Property '${name}' is not in tween.`);
            this.write(prop.type, prop.offset, value);
        }
        getAt(index) {
            let prop = this._props[index];
            if (!prop)
                throw new OutOfRangeError(index);
            return this.read(prop.type, prop.offset);
        }
        setAt(index, value) {
            let prop = this._props[index];
            if (!prop)
                throw new OutOfRangeError(index);
            this.write(prop.type, prop.offset, value);
        }
        get count() {
            return this._props.length;
        }
        copy(source) {
            this.nums.length = 0;
            this.nums.push(...source.nums);
            return this;
        }
        read(type, offset) {
            switch (type) {
                case 0:
                    return this.nums[offset];
                case 1:
                    return !!this.nums[offset];
                case 2:
                    return Color.hexToString(this.nums[offset]);
                default:
                    return type.read(this.nums, offset);
            }
        }
        write(type, offset, value) {
            switch (type) {
                case 0:
                    this.nums[offset] = value;
                    break;
                case 1:
                    this.nums[offset] = value ? 1 : 0;
                    break;
                case 2:
                    this.nums[offset] = Color.stringToHex(value);
                    break;
                default: {
                    if (offset === this.nums.length)
                        type.write(this.nums, value);
                    else {
                        tmpArr.length = 0;
                        type.write(tmpArr, value);
                        tmpArr.forEach((v, i) => this.nums[offset + i] = v);
                    }
                }
            }
        }
    }
    const tmpArr = [];
    function write(array, value) {
        value.writeTo(array, array.length);
    }
    const TweenValueAdapterKey = Symbol();
    const vec2 = new Vector2();
    Vector2.prototype[TweenValueAdapterKey] = {
        write,
        read: (array, offset) => {
            return vec2.setValue(array[offset], array[offset + 1]);
        },
    };
    const vec3 = new Vector3();
    Vector3.prototype[TweenValueAdapterKey] = {
        write,
        read: (array, offset) => {
            return vec3.setValue(array[offset], array[offset + 1], array[offset + 2]);
        },
    };
    const vec4 = new Vector4();
    Vector4.prototype[TweenValueAdapterKey] = {
        write,
        read: (array, offset) => {
            return vec4.setValue(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
        },
    };
    const color = new Color();
    Color.prototype[TweenValueAdapterKey] = {
        write,
        read: (array, offset) => {
            return color.setValue(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
        },
    };
    const pt = new Point();
    Point.prototype[TweenValueAdapterKey] = {
        write: (array, value) => {
            array.push(value.x, value.y);
        },
        read: (array, offset) => {
            return pt.setTo(array[offset], array[offset + 1]);
        },
    };

    class Tweener {
        static create(owner) {
            let tweener = Tweener._pool.take();
            _activeTweens[_totalActiveTweens++] = tweener;
            tweener.owner = owner;
            return tweener;
        }
        static getTween(id) {
            return _activeTweenMap.get(id);
        }
        static isTweening(target) {
            if (target == null)
                return false;
            for (let i = 0; i < _totalActiveTweens; i++) {
                let tweener = _activeTweens[i];
                if (tweener && tweener.target == target && !tweener._killed)
                    return true;
            }
            return false;
        }
        static getTweens(target, out) {
            out = out || [];
            if (target == null)
                return out;
            let cnt = _totalActiveTweens;
            for (let i = 0; i < cnt; i++) {
                let tweener = _activeTweens[i];
                if (tweener && tweener.target == target && !tweener._killed) {
                    out.push(tweener.owner);
                }
            }
            return out;
        }
        static kill(tweenId, complete) {
            let tween = _activeTweenMap.get(tweenId);
            if (!tween || tween._killed)
                return false;
            tween.kill(complete);
            return true;
        }
        static killAll(target, completed) {
            if (target == null)
                return false;
            let flag = false;
            let cnt = _totalActiveTweens;
            for (let i = 0; i < cnt; i++) {
                let tweener = _activeTweens[i];
                if (tweener && tweener.target == target && !tweener._killed) {
                    tweener.kill(completed);
                    flag = true;
                }
            }
            return flag;
        }
        constructor() {
            this.props = [];
            this.easeArgs = [];
            this.interpArgs = [];
            this.startValue = new TweenValue(this.props);
            this.endValue = new TweenValue(this.props);
            this.value = new TweenValue(this.props);
            this.deltaValue = new TweenValue(this.props);
        }
        go(propName, startValue, endValue) {
            let prop = _propsPool.take();
            this.props.push(prop);
            prop.name = propName;
            prop.offset = this.startValue.nums.length;
            if (this._active) {
                prop.renewFlags = 0;
                if (startValue === undefined)
                    startValue = this.target[propName];
                if (endValue === undefined)
                    endValue = this.target[propName];
            }
            else
                prop.renewFlags = startValue === undefined ? 1 : endValue === undefined ? 2 : 0;
            const type = startValue != null ? typeof (startValue) : typeof (endValue);
            let adapter;
            if (type === "number")
                prop.type = 0;
            else if (type === "string")
                prop.type = 2;
            else if (type == "object" && (adapter = startValue[TweenValueAdapterKey]) != null)
                prop.type = adapter;
            else
                prop.type = 1;
            this.startValue.write(prop.type, prop.offset, startValue !== undefined ? startValue : endValue);
            this.endValue.write(prop.type, prop.offset, endValue !== undefined ? endValue : startValue);
            return this;
        }
        get normalizedTime() {
            return this._normalizedTime;
        }
        get breaking() {
            return this._ended == 1;
        }
        get remainTime() {
            if (this.breakpoint >= 0)
                return this.delay + this.breakpoint - this._elapsedTime;
            else if (this.repeat >= 0)
                return this.delay + this.duration * (this.repeat + 1) - this._elapsedTime;
            else
                return this.delay + this.duration * 2 - this._elapsedTime;
        }
        activate() {
            this._active = true;
            this._startFrame = ILaya.timer.currFrame;
            for (let prop of this.props) {
                if (prop.renewFlags == 1)
                    this.startValue.write(prop.type, prop.offset, this.target[prop.name]);
                else if (prop.renewFlags == 2)
                    this.endValue.write(prop.type, prop.offset, this.target[prop.name]);
            }
        }
        seek(time) {
            if (this._killed)
                return;
            this._elapsedTime = time;
            if (this._elapsedTime < this.delay) {
                if (this._started)
                    this._elapsedTime = this.delay;
                else
                    return;
            }
            this.update2();
        }
        kill(complete) {
            if (this._killed)
                return;
            if (complete) {
                if (this._ended == 0) {
                    this._elapsedTime = 0;
                    this._elapsedTime = this.remainTime;
                    this.update2();
                }
                this.callCompleteCallback();
            }
            else if (this.onCompleteResolvers)
                this.onCompleteResolvers.forEach(f => f());
            this._killed = true;
        }
        init() {
            _idCounter$1++;
            if (_idCounter$1 < 1)
                _idCounter$1 = 1;
            this.id = _idCounter$1;
            _activeTweenMap.set(this.id, this);
            this.name = null;
            this.delay = 0;
            this.duration = 0;
            this.breakpoint = -1;
            this.startValue.nums.length = 0;
            this.endValue.nums.length = 0;
            this.value.nums.length = 0;
            this.ease = Ease.linear;
            this.easeArgs.length = 0;
            this.timeScale = 1;
            this.snapping = false;
            this.repeat = 0;
            this.yoyo = false;
            this.interp = null;
            this.interpArgs.length = 0;
            this._started = false;
            this.paused = false;
            this._killed = false;
            this._startFrame = ILaya.timer.currFrame;
            this._elapsedTime = 0;
            this._normalizedTime = 0;
            this._ended = 0;
            this._active = false;
        }
        reset() {
            this.id = -1;
            this.owner = null;
            this.target = null;
            this.lifecycleOwner = null;
            this.userData = null;
            _propsPool.recover(this.props);
            this.onStart = this.onUpdate = this.onComplete = this.onCompleteResolvers = null;
            this.onStartCaller = this.onUpdateCaller = this.onCompleteCaller = null;
        }
        update(dt) {
            if (this.timeScale != 1)
                dt *= this.timeScale;
            if (dt == 0)
                return;
            if (this._ended != 0) {
                this.callCompleteCallback();
                this._killed = true;
                return;
            }
            this._elapsedTime += dt;
            this.update2();
            if (this._ended != 0) {
                if (!this._killed) {
                    this.callCompleteCallback();
                    this._killed = true;
                }
            }
        }
        update2() {
            this._ended = 0;
            if (!this._started) {
                if (this._elapsedTime < this.delay)
                    return;
                this._started = true;
                this.value.copy(this.startValue);
                this.deltaValue.nums.length = this.startValue.nums.length;
                this.deltaValue.nums.fill(0);
                this.callStartCallback();
                if (this._killed)
                    return;
            }
            let reversed = false;
            let dur = this.duration;
            let tt = this._elapsedTime - this.delay;
            if (this.breakpoint >= 0 && tt >= this.breakpoint) {
                tt = this.breakpoint;
                this._ended = 2;
            }
            if (this.repeat != 0) {
                let round = Math.floor(tt / dur);
                tt -= dur * round;
                if (this.yoyo)
                    reversed = round % 2 == 1;
                if (this.repeat > 0 && this.repeat - round < 0) {
                    if (this.yoyo)
                        reversed = this.repeat % 2 == 1;
                    tt = dur;
                    this._ended = 1;
                }
            }
            else if (tt >= dur) {
                tt = dur;
                this._ended = 1;
            }
            let t = dur > 0 ? this.ease(reversed ? (dur - tt) : tt, 0, 1, dur, ...this.easeArgs) : 1;
            this._normalizedTime = t;
            let startNums = this.startValue.nums;
            let endNums = this.endValue.nums;
            let valueNums = this.value.nums;
            let deltaNums = this.deltaValue.nums;
            valueNums.fill(0);
            deltaNums.fill(0);
            if (this.interp) {
                this.interp(t, startNums, endNums, valueNums, ...this.interpArgs);
                for (let i = 0, n = startNums.length; i < n; i++) {
                    let f = valueNums[i];
                    if (this.snapping)
                        f = Math.round(f);
                    deltaNums[i] = f - valueNums[i];
                }
            }
            else {
                for (let i = 0, n = startNums.length; i < n; i++) {
                    let n1 = startNums[i];
                    let n2 = endNums[i];
                    let f = n1 + (n2 - n1) * t;
                    if (this.snapping)
                        f = Math.round(f);
                    deltaNums[i] = f - valueNums[i];
                    valueNums[i] = f;
                }
            }
            if (this.target != null) {
                for (let prop of this.props) {
                    if (prop.name) {
                        let v = prop.type === 1 ? (this._ended === 1 ? this.endValue.read(prop.type, prop.offset)
                            : this.startValue.read(prop.type, prop.offset))
                            : this.value.read(prop.type, prop.offset);
                        if ((prop.type === 0 || prop.type === 1 || prop.type === 2)
                            && this.target[prop.name] === v)
                            continue;
                        this.target[prop.name] = v;
                    }
                }
            }
            this.callUpdateCallback();
        }
        callStartCallback() {
            if (this.onStart) {
                try {
                    this.onStart.call(this.onStartCaller, this);
                }
                catch (err) {
                    console.error("error in start callback > ", err);
                }
            }
        }
        callUpdateCallback() {
            if (this.onUpdate) {
                try {
                    this.onUpdate.call(this.onUpdateCaller, this);
                }
                catch (err) {
                    console.error("error in update callback > ", err);
                }
            }
        }
        callCompleteCallback() {
            if (this.onComplete) {
                try {
                    this.onComplete.call(this.onCompleteCaller, this);
                }
                catch (err) {
                    console.error("error in complete callback > ", err);
                }
            }
            if (this.onCompleteResolvers)
                this.onCompleteResolvers.forEach(f => f());
        }
        static _runAll() {
            var _a;
            let cnt = _totalActiveTweens;
            if (cnt == 0)
                return;
            let frame = ILaya.timer.currFrame;
            let dt = ILaya.timer.delta;
            let udt = ILaya.timer.unscaledDelta;
            let freePosStart = -1;
            for (let i = 0; i < cnt; i++) {
                let tweener = _activeTweens[i];
                if (tweener == null) {
                    if (freePosStart == -1)
                        freePosStart = i;
                }
                else if (tweener._killed) {
                    _activeTweenMap.delete(tweener.id);
                    (_a = tweener.owner) === null || _a === void 0 ? void 0 : _a._check();
                    Tweener._pool.recover(tweener);
                    _activeTweens[i] = null;
                    if (freePosStart == -1)
                        freePosStart = i;
                }
                else {
                    if (tweener.target && tweener.target.destroyed
                        || tweener.lifecycleOwner && tweener.lifecycleOwner.destroyed)
                        tweener._killed = true;
                    else if (!tweener.paused && tweener._active)
                        tweener.update(tweener._startFrame == frame ? 0 : tweener.ignoreEngineTimeScale ? udt : dt);
                    if (freePosStart != -1) {
                        _activeTweens[freePosStart] = tweener;
                        _activeTweens[i] = null;
                        freePosStart++;
                    }
                }
            }
            if (freePosStart >= 0) {
                if (_totalActiveTweens != cnt) {
                    let j = cnt;
                    cnt = _totalActiveTweens - cnt;
                    for (let i = 0; i < cnt; i++) {
                        _activeTweens[freePosStart++] = _activeTweens[j];
                        _activeTweens[j] = null;
                        j++;
                    }
                }
                _totalActiveTweens = freePosStart;
            }
        }
        static _getMap() {
            return _activeTweenMap;
        }
    }
    Tweener._pool = Pool.createPool(Tweener, e => e.init(), e => e.reset());
    var _idCounter$1 = 0;
    var _totalActiveTweens = 0;
    const _activeTweens = [];
    const _activeTweenMap = new Map();
    const _propsPool = Pool.createPool(Object);

    class Tween {
        static create(target, lifecycleOwner) {
            let tween = Tween._pool.take();
            tween._target = target;
            tween._lo = lifecycleOwner;
            return tween;
        }
        static isTweening(target) {
            return Tweener.isTweening(target);
        }
        static getTween(target) {
            tmpArray.length = 0;
            this.getTweens(target, tmpArray);
            return tmpArray.length > 0 ? tmpArray[0] : null;
        }
        static getTweens(target, out) {
            return Tweener.getTweens(target, out);
        }
        static kill(tween) {
            if (tween)
                tween.kill();
        }
        static clear(tween) {
            if (tween)
                tween.kill();
        }
        static killAll(target, completed) {
            return Tweener.killAll(target, completed);
        }
        static clearAll(target) {
            Tween.killAll(target);
        }
        static to(target, props, duration, ease, complete, delay, coverBefore) {
            if (coverBefore)
                Tween.killAll(target);
            let tween = Tween.create(target);
            Tween.tweenLegacy(tween.cur(true), props, duration, ease, complete, delay, true);
            return tween;
        }
        static from(target, props, duration, ease, complete, delay, coverBefore) {
            if (coverBefore)
                Tween.killAll(target);
            let tween = Tween.create(target);
            Tween.tweenLegacy(tween.cur(true), props, duration, ease, complete, delay, false);
            return tween;
        }
        static tweenLegacy(tweener, props, duration, ease, complete, delay, isTo) {
            tweener.duration = duration;
            for (let p in props) {
                if (p == "ease" || p == "easeArgs" || p == "update" || p == "complete")
                    continue;
                let value = props[p];
                if (p in tweener.target) {
                    isTo ? tweener.go(p, tweener.target[p], value) : tweener.go(p, value, tweener.target[p]);
                }
            }
            if (props.ease) {
                tweener.ease = props.ease;
                if (props.easeArgs)
                    tweener.easeArgs.push(...props.easeArgs);
            }
            if (props.update) {
                tweener.onUpdate = props.update.runWith;
                tweener.onUpdateCaller = props.update;
            }
            if (props.complete) {
                tweener.onComplete = props.complete.runWith;
                tweener.onCompleteCaller = props.complete;
            }
            if (ease != null)
                tweener.ease = ease;
            if (delay != null)
                tweener.delay = delay;
            if (complete) {
                tweener.onComplete = complete.runWith;
                tweener.onCompleteCaller = complete;
            }
        }
        to(propName, value) {
            this.cur(true).go(propName, undefined, value);
            return this;
        }
        from(propName, value) {
            this.cur(true).go(propName, value, undefined);
            return this;
        }
        go(propName, startValue, endValue) {
            this.cur(true).go(propName, startValue, endValue);
            return this;
        }
        chain(target, lifecycleOwner) {
            if (target !== undefined) {
                this._target = target;
                this._lo = lifecycleOwner;
            }
            if (this._queue.length == 0)
                return this;
            if (this._par != null) {
                this._queue.push(-2);
                this._par = null;
            }
            this._cur = Tweener.create(this);
            this._cur.target = this._target;
            this._cur.lifecycleOwner = this._lo;
            this._queue.push(this._cur.id);
            return this;
        }
        parallel(target, lifecycleOwner) {
            if (this._queue.length == 0) {
                if (target !== undefined) {
                    this._target = target;
                    this._lo = lifecycleOwner;
                }
                return this;
            }
            if (this._par == null) {
                this._queue.push(-1);
                this._par = this._cur;
            }
            this._cur = Tweener.create(this);
            if (target !== undefined) {
                this._cur.target = target;
                this._cur.lifecycleOwner = lifecycleOwner;
            }
            else {
                this._cur.target = this._par.target;
                this._cur.lifecycleOwner = this._par.lifecycleOwner;
            }
            this._cur.duration = this._par.duration;
            if (this._par._active)
                this._cur.activate();
            this._queue.push(this._cur.id);
            return this;
        }
        delay(value) {
            this.cur(false).delay = value;
            return this;
        }
        duration(value) {
            this.cur(false).duration = value;
            return this;
        }
        breakpoint(value) {
            this.cur(false).breakpoint = value;
            return this;
        }
        ease(value, ...args) {
            let cur = this.cur(false);
            if (typeof (value) === "string")
                cur.ease = Ease[value];
            else
                cur.ease = value;
            cur.easeArgs.length = 0;
            if (args)
                cur.easeArgs.push(...args);
            return this;
        }
        interp(value, ...args) {
            let cur = this.cur(false);
            cur.interp = value;
            cur.interpArgs.length = 0;
            if (args)
                cur.interpArgs.push(...args);
            return this;
        }
        repeat(repeat, yoyo) {
            let cur = this.cur(false);
            cur.repeat = repeat;
            cur.yoyo = yoyo;
            return this;
        }
        timeScale(value) {
            this.cur(false).timeScale = value;
            return this;
        }
        ignoreEngineTimeScale(value) {
            this.cur(false).ignoreEngineTimeScale = value;
            return this;
        }
        snapping(value) {
            this.cur(false).snapping = value;
            return this;
        }
        userData(value) {
            this.cur(false).userData = value;
            return this;
        }
        name(value) {
            this.cur(false).name = value;
            return this;
        }
        onUpdate(callback, callbackThis) {
            let cur = this.cur(false);
            cur.onUpdate = callback;
            cur.onUpdateCaller = callbackThis;
            return this;
        }
        onStart(callback, callbackThis) {
            let cur = this.cur(false);
            cur.onStart = callback;
            cur.onStartCaller = callbackThis;
            return this;
        }
        then(callback, callbackThis) {
            let cur = this.cur(false);
            cur.onComplete = callback;
            cur.onCompleteCaller = callbackThis;
            return this;
        }
        waitForCompletion() {
            return new Promise((resolve) => {
                let cur = this.cur(false);
                if (!cur.onCompleteResolvers)
                    cur.onCompleteResolvers = [];
                cur.onCompleteResolvers.push(resolve);
            });
        }
        seek(time) {
            this.cur(false).seek(time);
            return this;
        }
        pause() {
            forEach(this._queue, tween => tween.paused = true);
            return this;
        }
        resume() {
            forEach(this._queue, tween => tween.paused = false);
            return this;
        }
        findTweener(name) {
            for (let i = 0, n = this._queue.length; i < n; i++) {
                if (i < 0)
                    continue;
                let tween = Tweener.getTween(this._queue[i]);
                if (tween && tween.name == name)
                    return tween;
            }
            return null;
        }
        kill(complete) {
            if (this._queue.length == 0)
                return;
            let arr;
            for (let e of this._queue) {
                if (e > 0) {
                    let tweener = Tweener.getTween(e);
                    if (tweener) {
                        if (!tweener._killed) {
                            if (!arr)
                                arr = [];
                            arr.push(tweener);
                        }
                        tweener.owner = null;
                    }
                }
            }
            this._head = -1;
            this._cur = null;
            this._queue.length = 0;
            if (arr != null)
                arr.forEach(t => t.kill(complete));
        }
        get completed() {
            return this._head >= 0 && this._queue.length === 0;
        }
        complete() {
            this.kill(true);
        }
        clear() {
            this.kill(false);
        }
        recover() {
            this.kill(false);
            Tween._pool.recover(this);
        }
        constructor() {
            this._queue = [];
            this._head = -1;
        }
        cur(call) {
            if (!this._cur) {
                if (this._head != -1) {
                    if (call)
                        this.kill(false);
                    else
                        throw new Error("Tween has been started. clear first!");
                }
                this._cur = Tweener.create(this);
                this._cur.target = this._target;
                this._cur.lifecycleOwner = this._lo;
                this._cur.activate();
                this._queue.push(this._cur.id);
            }
            return this._cur;
        }
        _check() {
            if (this._cur) {
                this._head = 0;
                this._cur = null;
            }
            let i = this._head, cnt = this._queue.length;
            for (; i < cnt; i++) {
                let id = this._queue[i];
                if (id < 0)
                    continue;
                let tween = Tweener.getTween(id);
                if (tween && !tween._killed) {
                    if (tween._active)
                        break;
                    tween.activate();
                    if (this._queue[i + 1] == -1) {
                        for (let j = i + 2; j < cnt; j++) {
                            let id = this._queue[j];
                            if (id < 0)
                                break;
                            let tween = Tweener.getTween(id);
                            if (tween && !tween._killed)
                                tween.activate();
                            else
                                this._queue[i] = -3;
                        }
                    }
                    break;
                }
                else
                    this._queue[i] = -3;
            }
            this._head = i;
            if (i >= cnt)
                this._queue.length = 0;
        }
        static shake(time, start, end, result, amplitude) {
            if (time == 1) {
                result.length = 0;
                result.push(...start);
            }
            else {
                let am = amplitude * (1 - time);
                let am2 = am * (Math.random() > 0.5 ? 1 : -1);
                for (let i = 0; i < start.length; i++)
                    result[i] = start[i] + am2;
            }
        }
        static seperateChannel(time, start, end, result, channels) {
            channels = channels || 3;
            for (let i = 0; i < start.length; i++)
                result[i] = interpByChannel(time, start[i], end[i], channels);
        }
        static useCurvePath(time, start, end, result, path) {
            let pt = path.getPointAt(time);
            result[0] = pt.x;
            if (result.length > 1)
                result[1] = pt.y;
            if (result.length > 2)
                result[2] = pt.z;
        }
    }
    Tween._pool = Pool.createPool(Tween);
    const tmpArray = [];
    function forEach(all, callback) {
        for (let e of all) {
            if (e > 0) {
                let tween = Tweener.getTween(e);
                if (tween && !tween._killed)
                    callback(tween);
            }
        }
    }
    function interpByChannel(time, start, end, channels) {
        let v = 0;
        for (let i = 0; i < channels; i++) {
            let j = i * 8;
            let n0 = (start >> j) & 0xFF;
            let n1 = (end >> j) & 0xFF;
            v += (n0 + (n1 - n0) * time) << j;
        }
        return v;
    }

    class DragSupport {
        constructor(owner) {
            this.ratio = 0.92;
            this.maxOffset = 60;
            this.hasInertia = false;
            this.elasticDistance = 0;
            this.elasticBackTime = 300;
            this.autoStart = false;
            this._testing = false;
            this._dragging = false;
            this.target = owner;
            this.area = new Rectangle();
            this._points = [];
            this.target.on(Event.MOUSE_DOWN, this, this.onMouseDown);
        }
        get dragging() {
            return this._dragging;
        }
        start(data) {
            this.reset();
            this._touchId = ILaya.InputManager.lastTouchId;
            this._dragging = true;
            this._testing = false;
            this._elasticRateX = this._elasticRateY = 1;
            let pt = this.target._parent.getMousePoint();
            this._points.length = 0;
            this._points.push(pt.x, pt.y, performance.now());
            this._data = data;
            ILaya.stage.on(Event.MOUSE_MOVE, this, this.onMouseMove);
            ILaya.stage.on(Event.MOUSE_UP, this, this.onMouseUp);
        }
        reset() {
            this._dragging = false;
            this._testing = false;
            this._data = null;
            ILaya.systemTimer.clear(this, this.tweenMove);
            ILaya.stage.off(Event.MOUSE_MOVE, this, this.onMouseMove);
            ILaya.stage.off(Event.MOUSE_UP, this, this.onMouseUp);
            if (this._tween != null) {
                this._tween.kill();
                this._tween = null;
            }
        }
        stop() {
            if (this._dragging) {
                this._dragging = false;
                if (!this._testing) {
                    this.moveTarget(0, 0);
                    this.clear(true);
                }
                else
                    this.reset();
            }
            else
                this.reset();
        }
        onMouseDown() {
            if (this.autoStart && !this._dragging && !this._testing) {
                this.start();
                this._testing = true;
            }
        }
        onMouseMove(evt) {
            if (!this._testing && !this._dragging)
                return;
            if (this._touchId != evt.touchId)
                return;
            let point = this.target._parent.getMousePoint();
            let mouseX = point.x;
            let mouseY = point.y;
            let offsetX = mouseX - this._points[this._points.length - 3];
            let offsetY = mouseY - this._points[this._points.length - 2];
            if (this._testing) {
                if (Math.abs(offsetX * ILaya.stage._canvasTransform.getScaleX()) < 1 && Math.abs(offsetY * ILaya.stage._canvasTransform.getScaleY()) < 1)
                    return;
                this._dragging = true;
                this.target.event(Event.DRAG_START, this._data);
                if (!this._dragging)
                    return;
                this._testing = false;
            }
            let now = performance.now();
            while (this._points.length > 0 && this._points[2] < now - 100)
                this._points.splice(0, 3);
            this._points.push(mouseX, mouseY, now);
            this.moveTarget(offsetX * this._elasticRateX, offsetY * this._elasticRateY);
            this.target.event(Event.DRAG_MOVE, this._data);
        }
        onMouseUp(evt) {
            if (!this._dragging) {
                this.reset();
                return;
            }
            if (this._touchId != evt.touchId)
                return;
            if (this.hasInertia) {
                let v = DragSupport.computeVelocity(this._points, this.maxOffset);
                this._points[0] = v.x;
                this._points[1] = v.y;
                this._dragging = false;
                ILaya.systemTimer.frameLoop(1, this, this.tweenMove);
            }
            else if (!this.area.isEmpty() && this.elasticDistance > 0) {
                this.checkElastic();
            }
            else {
                this.clear();
            }
        }
        moveTarget(dx, dy) {
            let nx = this.target._x + dx;
            let ny = this.target._y + dy;
            if (this.area.isEmpty())
                this.target.pos(nx, ny);
            else if (this.elasticDistance > 0 && this._dragging) {
                this.target.pos(nx, ny);
                let pt = this.checkArea();
                this._elasticRateX = Math.max(0, 1 - (Math.abs(pt.x) / this.elasticDistance));
                this._elasticRateY = Math.max(0, 1 - (Math.abs(pt.y) / this.elasticDistance));
            }
            else {
                let pt = this.checkArea(dx, dy);
                this.target.pos(nx + pt.x, ny + pt.y);
            }
        }
        checkArea(dx = 0, dy = 0) {
            let tx;
            let ty;
            let rect = Rectangle.TEMP.setTo(this.target.x + dx - this.target.pivotX, this.target.y + dy - this.target.pivotY, this.target.width, this.target.height);
            if (rect.x < this.area.x)
                tx = this.area.x - rect.x;
            else if (rect.right > this.area.right)
                tx = this.area.right - rect.right;
            else
                tx = 0;
            if (rect.y < this.area.y)
                ty = this.area.y - rect.y;
            else if (rect.bottom > this.area.bottom)
                ty = this.area.bottom - rect.bottom;
            else
                ty = 0;
            return tmpPoint$2.setTo(tx, ty);
        }
        checkElastic() {
            let pt = this.checkArea();
            if (pt.x != 0 || pt.y != 0) {
                this._tween = Tween.create(this.target).duration(this.elasticBackTime).ease(Ease.sineOut).then(() => this.clear());
                if (pt.x != 0)
                    this._tween.to("x", this.target.x + pt.x);
                if (pt.y != 0)
                    this._tween.to("y", this.target.y + pt.y);
            }
            else {
                this.clear();
            }
        }
        tweenMove() {
            let n = Math.pow(this.ratio, ILaya.timer.delta / 16.6);
            let s = this.ratio * (1 - n) / (1 - this.ratio);
            let dx = this._points[0] * s * this._elasticRateX;
            let dy = this._points[1] * s * this._elasticRateY;
            this._points[0] = dx;
            this._points[1] = dy;
            if (dx < 0)
                dx = Math.ceil(dx);
            else
                dx = Math.floor(dx);
            if (dy < 0)
                dy = Math.ceil(dy);
            else
                dy = Math.floor(dy);
            if (Math.abs(dx) < 1 && Math.abs(dy) < 1 || this._elasticRateX < 0.5 || this._elasticRateY < 0.5) {
                ILaya.systemTimer.clear(this, this.tweenMove);
                if (!this.area.isEmpty() && this.elasticDistance > 0)
                    this.checkElastic();
                else
                    this.clear();
            }
            else {
                this.moveTarget(dx, dy);
                this.target.event(Event.DRAG_MOVE, this._data);
            }
        }
        clear(cancelled) {
            let d = this._data;
            this.reset();
            this.target.event(Event.DRAG_END, [d, cancelled]);
        }
        static computeVelocity(points, max) {
            let now = performance.now();
            while (points.length > 0 && points[2] < now - 100)
                points.splice(0, 3);
            let len = points.length / 3;
            let x = 0, y = 0;
            let t = 0;
            for (let i = 1; i < len; i++) {
                x += points[i * 3] - points[i * 3 - 3];
                y += points[i * 3 + 1] - points[i * 3 - 2];
                t += points[i * 3 + 2] - points[i * 3 - 1];
            }
            if (t != 0) {
                t = t / 16.6;
                x = x / t;
                y = y / t;
            }
            else
                x = y = 0;
            if (max != null) {
                if (Math.abs(x) > max)
                    x = x > 0 ? max : -max;
                if (Math.abs(y) > max)
                    y = y > 0 ? max : -max;
            }
            tmpPoint$2.setTo(x, y);
            return tmpPoint$2;
        }
    }
    const tmpPoint$2 = new Point();

    class SpriteUtils {
        static getGlobalRecByPoints(sprite, x0, y0, x1, y1, out) {
            let newLTPoint;
            newLTPoint = Point.create().setTo(x0, y0);
            newLTPoint = sprite.localToGlobal(newLTPoint);
            let newRBPoint;
            newRBPoint = Point.create().setTo(x1, y1);
            newRBPoint = sprite.localToGlobal(newRBPoint);
            let rst = Rectangle._getWrapRec([newLTPoint.x, newLTPoint.y, newRBPoint.x, newRBPoint.y], out);
            newLTPoint.recover();
            newRBPoint.recover();
            return rst;
        }
        static getGlobalPosAndScale(sprite) {
            let tmpRect = Rectangle.create();
            SpriteUtils.getGlobalRecByPoints(sprite, 0, 0, 1, 1, tmpRect);
            let ret = { x: tmpRect.x, y: tmpRect.y, scaleX: tmpRect.width, scaleY: tmpRect.height };
            tmpRect.recover();
            return ret;
        }
        static getTransformRelativeToWindow(coordinateSpace, x, y) {
            let stage = ILaya.stage;
            let globalTransform = SpriteUtils.getGlobalPosAndScale(coordinateSpace);
            let canvasMatrix = Matrix.create();
            stage._canvasTransform.copyTo(canvasMatrix);
            let canvasLeft = canvasMatrix.tx;
            let canvasTop = canvasMatrix.ty;
            canvasMatrix.rotate(-Math.PI / 180 * stage.canvasDegree);
            canvasMatrix.scale(stage.clientScaleX, stage.clientScaleY);
            let perpendicular = (stage.canvasDegree % 180 != 0);
            let tx, ty;
            if (perpendicular) {
                tx = y + globalTransform.y;
                ty = x + globalTransform.x;
                tx *= canvasMatrix.d;
                ty *= canvasMatrix.a;
                if (stage.canvasDegree == 90) {
                    tx = canvasLeft - tx;
                    ty += canvasTop;
                }
                else {
                    tx += canvasLeft;
                    ty = canvasTop - ty;
                }
            }
            else {
                tx = x + globalTransform.x;
                ty = y + globalTransform.y;
                tx *= canvasMatrix.a;
                ty *= canvasMatrix.d;
                tx += canvasLeft;
                ty += canvasTop;
            }
            let domScaleX, domScaleY;
            if (perpendicular) {
                domScaleX = canvasMatrix.d * globalTransform.scaleY;
                domScaleY = canvasMatrix.a * globalTransform.scaleX;
            }
            else {
                domScaleX = canvasMatrix.a * globalTransform.scaleX;
                domScaleY = canvasMatrix.d * globalTransform.scaleY;
            }
            canvasMatrix.recover();
            globalTransform.x = Math.round(tx);
            globalTransform.y = Math.round(ty);
            globalTransform.scaleX = Math.round(domScaleX * 100000) / 100000;
            globalTransform.scaleY = Math.round(domScaleY * 100000) / 100000;
            return globalTransform;
        }
        static fitDOMElementInArea(dom, coordinateSpace, x, y, width, height) {
            if (!dom._fitLayaAirInitialized) {
                dom._fitLayaAirInitialized = true;
                PAL.browser.setStyleTransformOrigin(dom.style, "left top");
                dom.style.position = "absolute";
            }
            let transform = SpriteUtils.getTransformRelativeToWindow(coordinateSpace, x, y);
            PAL.browser.setStyleTransform(dom.style, "scale(" + transform.scaleX + "," + transform.scaleY + ") rotate(" + (ILaya.stage.canvasDegree) + "deg)");
            dom.style.width = width + 'px';
            dom.style.height = height + 'px';
            dom.style.left = transform.x + 'px';
            dom.style.top = transform.y + 'px';
        }
        static localToGlobalRect(sp, rect, out) {
            out = out || Rectangle.create();
            let pt = sp.localToGlobal(Point.TEMP.setTo(rect.x, rect.y));
            let x = pt.x;
            let y = pt.y;
            sp.localToGlobal(pt.setTo(rect.right, rect.bottom));
            return out.setTo(x, y, x + pt.x, y + pt.y);
        }
        static globalToLocalRect(sp, rect, out) {
            out = out || Rectangle.create();
            let pt = sp.globalToLocal(Point.TEMP.setTo(rect.x, rect.y));
            let x = pt.x;
            let y = pt.y;
            sp.globalToLocal(pt.setTo(rect.right, rect.bottom));
            return out.setTo(x, y, x + pt.x, y + pt.y);
        }
        static transformRect(sp, rect, targetSpace, out) {
            targetSpace = targetSpace || ILaya.stage;
            tmpPoints.length = 0;
            rect.getBoundPoints(tmpPoints);
            if (targetSpace === sp._parent) {
                for (let i = 0, n = tmpPoints.length; i < n; i += 2) {
                    let pt = sp.toParentPoint(Point.TEMP.setTo(tmpPoints[i], tmpPoints[i + 1]));
                    tmpPoints[i] = pt.x;
                    tmpPoints[i + 1] = pt.y;
                }
            }
            else {
                for (let i = 0, n = tmpPoints.length; i < n; i += 2) {
                    let pt = sp.localToGlobal(Point.TEMP.setTo(tmpPoints[i], tmpPoints[i + 1]));
                    targetSpace.globalToLocal(pt);
                    tmpPoints[i] = pt.x;
                    tmpPoints[i + 1] = pt.y;
                }
            }
            return Rectangle._getWrapRec(tmpPoints, out);
        }
        static getRect(sprite, sizeOnly, out) {
            out = out || Rectangle.create();
            if (sizeOnly == null || sizeOnly)
                out.setTo(0, 0, sprite.width, sprite.height);
            else
                sprite.getSelfBounds(out);
            out.x -= sprite.pivotX;
            out.y -= sprite.pivotY;
            if (sprite.scrollRect) {
                out.x -= sprite.scrollRect.x;
                out.y -= sprite.scrollRect.y;
            }
            out.x = Math.floor(out.x);
            out.y = Math.floor(out.y);
            out.width = Math.floor(out.width);
            out.height = Math.floor(out.height);
            if (out.width < 0)
                out.width = 0;
            if (out.height < 0)
                out.height = 0;
            return out;
        }
        static setRect(sprite, rect) {
            sprite.size(rect.width, rect.height);
            sprite.pos(rect.x + sprite.pivotX, rect.y + sprite.pivotY);
        }
        static getChildrenBounds(sprite, recursive, ignoreInvisibles, ignoreScale, out) {
            out = out || new Rectangle();
            out.setTo(0, 0, 0, 0);
            let children = recursive ? sprite._children : sprite._$children;
            for (let child of children) {
                if (ignoreInvisibles && !child._struct.enabled)
                    continue;
                let w = child.width;
                let h = child.height;
                if (!ignoreScale) {
                    w *= Math.abs(child._scaleX);
                    h *= Math.abs(child._scaleY);
                }
                out.union(tmpRect$1.setTo(child._x - w * child._anchorX, child._y - h * child._anchorY, w, h), out);
                if (recursive && child._children.length > 0) {
                    let rect = SpriteUtils.getChildrenBounds(child, recursive, ignoreInvisibles, ignoreScale);
                    rect.x += child._x;
                    rect.y += child._y;
                    out.union(rect, out);
                }
            }
            return out;
        }
    }
    const tmpRect$1 = new Rectangle();
    const tmpPoints = [];

    class Component {
        get hideFlags() {
            return this._hideFlags;
        }
        set hideFlags(value) {
            this._hideFlags = value;
        }
        constructor() {
            var _a;
            this._hideFlags = 0;
            this._status = 0;
            this._enabled = true;
            this._id = _idCounter++;
            this._singleton = (_a = Object.getPrototypeOf(this)._$singleton) !== null && _a !== void 0 ? _a : true;
            this._initialize();
        }
        _initialize() {
            this._extra = {};
        }
        hasHideFlag(flag) {
            return (this._hideFlags & flag) != 0;
        }
        get id() {
            return this._id;
        }
        get enabled() {
            return this._enabled;
        }
        set enabled(value) {
            if (this._enabled != value) {
                this._enabled = value;
                if (this.owner)
                    this._setActive(value && this.owner.activeInHierarchy);
            }
        }
        get awaked() {
            return this._status > 0;
        }
        get destroyed() {
            return this._status == 4;
        }
        _isScript() {
            return false;
        }
        _resetComp() {
            this._enabled = true;
            this._status = 0;
            this._enableState = false;
            this.owner = null;
        }
        _setOwner(node) {
            if (this._status != 0) {
                throw new Error('reuse a destroyed component');
            }
            this.owner = node;
            if (this._isScript())
                node._setBit(NodeFlags.HAS_SCRIPT, true);
            this._onAdded();
            this.onAdded();
        }
        _onAdded() {
        }
        _onAwake() {
        }
        _onEnable() {
            this.onEnable();
        }
        _onDisable() {
            this.onDisable();
        }
        _onDestroy() {
        }
        _parse(data, interactMap = null) {
        }
        _parseInteractive(data = null, spriteMap = null) {
        }
        _cloneTo(dest) {
        }
        _setActive(value) {
            var _a;
            if (value) {
                if (this._status == 0) {
                    this._status = 1;
                    if (LayaEnv.isPlaying || this.runInEditor) {
                        this._onAwake();
                        this.onAwake();
                    }
                }
                if (this._enabled && !this._enableState) {
                    this._enableState = true;
                    if (LayaEnv.isPlaying || this.runInEditor) {
                        this._driver = ((_a = this.owner._scene) === null || _a === void 0 ? void 0 : _a._componentDriver) || ILaya.stage._componentDriver;
                        this._driver.add(this);
                        if (LayaEnv.isPlaying && this._isScript())
                            this.setupScript();
                        this._onEnable();
                    }
                }
            }
            else if (this._enableState) {
                this._enableState = false;
                if (LayaEnv.isPlaying || this.runInEditor) {
                    if (this._driver)
                        this._driver.remove(this);
                    ILaya.stage.offAllCaller(this);
                    this._onDisable();
                }
            }
        }
        setupScript() {
        }
        destroy() {
            if (this._status == 4)
                return;
            if (this.owner)
                this.owner._destroyComponent(this);
            else if (!this.destroyed)
                this._destroy(true);
        }
        _destroy(second) {
            var _a;
            if (second) {
                if (LayaEnv.isPlaying || this.runInEditor) {
                    this._onDestroy();
                    this.onDestroy();
                    if (this.onReset) {
                        this.onReset();
                        (_a = this.owner) === null || _a === void 0 ? void 0 : _a.offAllCaller(this);
                        this._resetComp();
                        Pool.recoverByClass(this);
                    }
                }
                return;
            }
            this._setActive(false);
            this._status = 4;
            if (LayaEnv.isPlaying || this.runInEditor)
                (this._driver || ILaya.stage._componentDriver)._toDestroys.add(this);
            this._driver = null;
        }
        onAdded() {
        }
        onAwake() {
        }
        onEnable() {
        }
        onDisable() {
        }
        onDestroy() {
        }
    }
    var _idCounter = 0;

    exports.Render2DOrderMode = void 0;
    (function (Render2DOrderMode) {
        Render2DOrderMode[Render2DOrderMode["elementIndex"] = 0] = "elementIndex";
        Render2DOrderMode[Render2DOrderMode["ysort"] = 1] = "ysort";
    })(exports.Render2DOrderMode || (exports.Render2DOrderMode = {}));
    class BaseRenderNode2D extends Component {
        static initBaseRender2DCommandEncoder() {
            BaseRenderNode2D.BASERENDER2DCOLOR = Shader3D.propertyNameToID("u_baseRenderColor");
            BaseRenderNode2D.BASERENDER2DTEXTURE = Shader3D.propertyNameToID("u_baseRender2DTexture");
            BaseRenderNode2D.TILINGOFFSET = Shader3D.propertyNameToID("u_tilingOffset");
            BaseRenderNode2D.NORMAL2DTEXTURE = Shader3D.propertyNameToID("u_normal2DTexture");
            BaseRenderNode2D.NORMAL2DSTRENGTH = Shader3D.propertyNameToID("u_normal2DStrength");
            BaseRenderNode2D.SHADERDEFINE_BASERENDER2D = Shader3D.getDefineByName("BASERENDER2D");
            BaseRenderNode2D.SHADERDEFINE_LIGHT2D_ENABLE = Shader3D.getDefineByName("LIGHT2D_ENABLE");
            BaseRenderNode2D.SHADERDEFINE_LIGHT2D_EMPTY = Shader3D.getDefineByName("LIGHT2D_EMPTY");
            BaseRenderNode2D.SHADERDEFINE_LIGHT2D_ADDMODE = Shader3D.getDefineByName("LIGHT2D_SCENEMODE_ADD");
            BaseRenderNode2D.SHADERDEFINE_LIGHT2D_SUBMODE = Shader3D.getDefineByName("LIGHT2D_SCENEMODE_SUB");
            BaseRenderNode2D.SHADERDEFINE_LIGHT2D_NORMAL_PARAM = Shader3D.getDefineByName("LIGHT2D_NORMAL_PARAM");
            const commandUniform = LayaGL.renderDeviceFactory.createGlobalUniformMap("BaseRender2D");
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_NMATRIX_0, "u_NMatrix_0", exports.ShaderDataType.Vector3);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_NMATRIX_1, "u_NMatrix_1", exports.ShaderDataType.Vector3);
            commandUniform.addShaderUniform(BaseRenderNode2D.BASERENDER2DCOLOR, "u_baseRenderColor", exports.ShaderDataType.Color);
            commandUniform.addShaderUniform(BaseRenderNode2D.BASERENDER2DTEXTURE, "u_baseRender2DTexture", exports.ShaderDataType.Texture2D);
            commandUniform.addShaderUniform(BaseRenderNode2D.TILINGOFFSET, "u_tilingOffset", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(BaseRenderNode2D.NORMAL2DTEXTURE, "u_normal2DTexture", exports.ShaderDataType.Texture2D);
            commandUniform.addShaderUniform(BaseRenderNode2D.NORMAL2DSTRENGTH, "u_normal2DStrength", exports.ShaderDataType.Float);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_CLIPMATDIR, "u_clipMatDir", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_CLIPMATPOS, "u_clipMatPos", exports.ShaderDataType.Vector4);
        }
        static _setRenderElement2DMaterial(element, material) {
            element.subShader = material._shader.getSubShaderAt(0);
            material._setOwner2DElement(element);
            element.materialShaderData = material._shaderValues;
        }
        get renderLayer() {
            return this._renderLayer;
        }
        set renderLayer(value) {
            this._renderLayer = value;
        }
        get rect() {
            if (this._boundsChange) {
                this._boundsChange = false;
            }
            return this._rect;
        }
        get boundsChange() {
            return this._boundsChange;
        }
        set boundsChange(value) {
            this._boundsChange = value;
        }
        _getcommonUniformMap() {
            return ["BaseRender2D"];
        }
        _transformChange() {
            this.boundsChange = true;
        }
        _changeMaterialReference(lastValue, value) {
            (lastValue) && (lastValue._removeReference());
            (value) && (value._addReference());
        }
        constructor() {
            super();
            this._renderType = exports.BaseRender2DType.baseRenderNode;
            this._renderUpdateMask = 0;
            this._layer = 0;
            this._rtsize = new Vector2();
            this._lightReceive = false;
            this._lightUpdateMark = 0;
            this._lightRecord = false;
            this._renderLayer = 1;
            this._rect = new Vector4();
            this._boundsChange = false;
            this._renderid = BaseRenderNode2D._uniqueIDCounter++;
            this._renderType = exports.BaseRender2DType.baseRenderNode;
            this._ordingMode = exports.Render2DOrderMode.elementIndex;
            this._renderHandle = this._createRenderHandle();
        }
        _onAdded() {
            this.owner._initShaderData();
            this.owner.renderNode2D = this;
            this._struct = this.owner._struct;
            this._spriteShaderData = this._struct.spriteShaderData;
            this.owner._struct.renderDataHandler = this._renderHandle;
            this.owner._struct.renderElements = this._renderElements;
            this.owner._struct.renderType = this._renderType;
            this.owner._updateStruct();
            this._initDefaultRenderData && this._initDefaultRenderData();
        }
        _onEnable() {
            this.owner.renderNode2D = this;
            super._onEnable();
            this.owner.globalTrans._spTransChanged(exports.TransformKind.TRS);
            if (this._lightReceive)
                this._addRenderToLightManager();
        }
        _onDisable() {
            this.owner.renderNode2D = null;
            if (this._lightReceive)
                this._removeRenderFromLightManager();
            super._onDisable();
        }
        _onDestroy() {
            for (var i = 0, n = this._materials.length; i < n; i++) {
                let m = this._materials[i];
                m && !m.destroyed && m._removeReference();
            }
            this._renderHandle.destroy();
        }
        _getRenderHandle() {
            return this._renderHandle;
        }
        _createRenderHandle() {
            return LayaGL.render2DRenderPassFactory.create2DBaseRenderDataHandle();
        }
        _isMaterialVaild(value) {
            return true;
        }
        get layer() {
            return this._layer;
        }
        set layer(value) {
            if (this._layer !== value) {
                if (value >= 0 && value <= 30) {
                    this._removeRenderFromLightManager();
                    this._layer = value;
                    this._addRenderToLightManager();
                    this._resetUpdateMark();
                }
                else {
                    throw new Error("Layer value must be 0-30.");
                }
            }
        }
        set lightReceive(value) {
            if (value === this._lightReceive)
                return;
            this._lightReceive = value;
            if (value) {
                this._addRenderToLightManager();
            }
            else {
                this._removeRenderFromLightManager();
            }
            this._renderHandle.lightReceive = value;
            this._resetUpdateMark();
        }
        get lightReceive() {
            return this._lightReceive;
        }
        _resetUpdateMark() {
            this._lightUpdateMark = 0;
        }
        _updateLight() {
            if (!this.lightReceive || !this.owner.scene || !this.owner.scene._light2DManager)
                return;
            const light2DManager = this.owner.scene._light2DManager;
            const updateMark = light2DManager._getLayerUpdateMark(this.layer);
            if (this._lightUpdateMark !== updateMark) {
                this._lightUpdateMark = updateMark;
                light2DManager._updateShaderDataByLayer(this.layer, this.owner._struct.spriteShaderData);
            }
        }
        _addRenderToLightManager() {
            if (this.owner.scene) {
                let light2DManager = this.owner.scene._light2DManager;
                if (light2DManager && !this._lightRecord) {
                    light2DManager.addRender(this);
                    this._lightRecord = true;
                }
            }
        }
        _removeRenderFromLightManager() {
            if (this.owner.scene) {
                const light2DManager = this.owner.scene._light2DManager;
                if (light2DManager && this._lightRecord) {
                    light2DManager.removeRender(this);
                    this._lightRecord = false;
                }
            }
        }
        get sharedMaterial() {
            return this._materials[0];
        }
        set sharedMaterial(value) {
            if (value && !this._isMaterialVaild(value))
                return;
            const lastValue = this._materials[0];
            if (lastValue !== value) {
                this._materials[0] = value;
                this._changeMaterialReference(lastValue, value);
                this._renderElements[0] && BaseRenderNode2D._setRenderElement2DMaterial(this._renderElements[0], value);
            }
        }
        _getRenderElements() {
            return this._renderElements;
        }
        getRenderID() {
            return this._renderid;
        }
        clear() {
            this._renderElements.length = 0;
        }
    }
    BaseRenderNode2D._uniqueIDCounter = 0;

    class SpriteGlobalTransform {
        constructor(sp) {
            this._flags = 0;
            this._x = 0.0;
            this._y = 0.0;
            this._rot = 0.0;
            this._scaleX = 1.0;
            this._scaleY = 1.0;
            this._modifiedFrame = 0;
            this._sp = sp;
            this.cache = true;
            this._notifyRenderSpriteTransChange();
        }
        get cache() {
            return this._cache;
        }
        set cache(value) {
            if (value) {
                this._setFlag(exports.TransformKind.Matrix | exports.TransformKind.TRS, true);
            }
            this._cache = value;
        }
        getMatrix() {
            if (this._matrix == null)
                this._matrix = new Matrix();
            if (this._cache && !this._getFlag(exports.TransformKind.Matrix))
                return this._matrix;
            let sp = this._sp;
            this._matrix.setMatrix(sp._x, sp._y, sp._scaleX, sp._scaleY, sp._rotation, sp._skewX, sp._skewY, sp._pivotX, sp._pivotY);
            if (sp._parent) {
                Matrix.mul(this._matrix, sp._parent.globalTrans.getMatrix(), this._matrix);
                this._setFlag(exports.TransformKind.Matrix, false);
            }
            else if (sp._maskParent) {
                Matrix.mul(this._matrix, sp._maskParent.globalTrans.getMatrix(), this._matrix);
                this._setFlag(exports.TransformKind.Matrix, false);
            }
            return this._matrix;
        }
        getMatrixInv(out) {
            this.getMatrix().copyTo(out);
            out.invert();
            return out;
        }
        get x() {
            return this.getPos(tmpPoint$1).x;
        }
        get y() {
            return this.getPos(tmpPoint$1).y;
        }
        getSceneMatrix(out) {
            if (!this._sp.scene)
                return this.getMatrix();
            this._sp.scene.globalTrans.getMatrixInv(tmpMarix).copyTo(out);
            Matrix.mul(this.getMatrix(), out, out);
            return out;
        }
        getScenePos(out) {
            if (!this._sp.scene)
                return this.getPos(out);
            return this._sp.scene.globalTrans.getMatrixInv(tmpMarix).transformPoint(this.getPos(out));
        }
        getSceneScale(out) {
            out.x = this.scaleX;
            out.y = this.scaleY;
            if (this._sp.scene) {
                const mat = this._sp.scene.globalTrans.getMatrix();
                out.x /= mat.getScaleX();
                out.y /= mat.getScaleY();
            }
            return out;
        }
        getSceneRotation() {
            let angle = this.rotation;
            if (this._sp.scene)
                angle -= this._sp.scene.globalTrans.rotation;
            return angle;
        }
        getPos(out) {
            if (this._cache) {
                this._cachePos();
                out.x = this._x;
                out.y = this._y;
            }
            else {
                this._sp.localToGlobal(out.setTo(0, 0), false, null);
            }
            return out;
        }
        setPos(x, y) {
            let sp = this._sp;
            if (this._cache) {
                this._cachePos();
                if (x == this._x && y == this._y)
                    return;
                let point = sp._parent.globalTrans.getMatrix().invertTransformPoint(tmpPoint$1.setTo(x, y));
                this._cache = false;
                sp.pos(point.x, point.y);
                this._cache = true;
                this._x = x;
                this._y = y;
                this._setFlag(exports.TransformKind.Pos, false);
                this._setFlag(exports.TransformKind.Matrix, true);
                this._syncFlag(exports.TransformKind.Pos | exports.TransformKind.Matrix, true);
            }
            else {
                tmpPoint$1.setTo(x, y);
                let point = sp.globalToLocal(tmpPoint$1, false, null);
                point = sp.toParentPoint(point);
                sp.pos(point.x, point.y);
            }
        }
        get rotation() {
            let sp = this._sp;
            if (this._cache) {
                if (this._getFlag(exports.TransformKind.Rotation)) {
                    this._setFlag(exports.TransformKind.Rotation, false);
                    if (sp._parent == sp._scene || !sp._parent)
                        this._rot = sp._rotation;
                    else
                        this._rot = sp._rotation + sp._parent.globalTrans.rotation;
                }
                return this._rot;
            }
            else {
                let angle = 0;
                let ele = sp;
                while (ele) {
                    if (ele === sp._scene)
                        break;
                    angle += ele._rotation;
                    ele = ele._parent;
                }
                return angle;
            }
        }
        set rotation(value) {
            if (value == this.rotation) {
                return;
            }
            let sp = this._sp;
            if (sp._parent == sp._scene || !sp._parent) {
                sp.rotation = value;
            }
            else {
                sp.rotation = value - sp._parent.globalTrans.rotation;
            }
            if (this._cache) {
                this._rot = value;
                this._setFlag(exports.TransformKind.Rotation, false);
                this._setFlag(exports.TransformKind.Matrix, true);
                this._syncFlag(exports.TransformKind.Matrix, true);
            }
        }
        get scaleX() {
            if (this._cache) {
                this._cacheScale();
                return this._scaleX;
            }
            else {
                let scale = 1;
                let ele = this._sp;
                while (ele) {
                    if (ele === ILaya.stage)
                        break;
                    scale *= ele._scaleX;
                    ele = ele._parent;
                }
                return scale;
            }
        }
        get scaleY() {
            if (this._cache) {
                this._cacheScale();
                return this._scaleY;
            }
            else {
                let scale = 1;
                let ele = this._sp;
                while (ele) {
                    if (ele === ILaya.stage)
                        break;
                    scale *= ele._scaleY;
                    ele = ele._parent;
                }
                return scale;
            }
        }
        _cachePos() {
            if (this._getFlag(exports.TransformKind.Matrix | exports.TransformKind.Pos)) {
                this._setFlag(exports.TransformKind.Pos, false);
                let p = this.getMatrix().transformPoint(tmpPoint$1.setTo(this._sp.pivotX, this._sp.pivotY));
                this._x = p.x;
                this._y = p.y;
            }
        }
        _cacheScale() {
            if (this._getFlag(exports.TransformKind.Matrix | exports.TransformKind.Scale)) {
                this._setFlag(exports.TransformKind.Scale, false);
                let mat = this.getMatrix();
                this._scaleX = mat.getScaleX();
                this._scaleY = mat.getScaleY();
            }
        }
        _getFlag(type) {
            return (this._flags & type) != 0;
        }
        _setFlag(type, value, notify = true) {
            if (value)
                this._flags |= type;
            else
                this._flags &= ~type;
            if (value) {
                this._sp.event(SpriteGlobalTransform.CHANGED, type);
                if (notify) {
                    this._notifyRenderSpriteTransChange();
                }
            }
        }
        _notifyRenderSpriteTransChange() {
            if ((this._sp._renderType & SpriteConst.UPDATETRANS)) {
                ILaya.stage._tranMatrixUpdateList.add(this._sp);
                this._modifiedFrame = Stat.loopCount;
            }
        }
        _syncFlag(flag, value) {
            if (this._cache) {
                for (let child of this._sp._children) {
                    let globaltrans = child.globalTrans;
                    if (globaltrans) {
                        globaltrans._setFlag(flag, value);
                        globaltrans._syncFlag(flag, value);
                    }
                }
            }
        }
        _spTransChanged(kind) {
            if (this._cache)
                this._setFlag(kind | exports.TransformKind.Matrix, true);
            this._syncFlag(kind | exports.TransformKind.Matrix, true);
        }
        localToGlobal(x, y) {
            if (this._cache) {
                return this.getMatrix().transformPoint(tmpPoint$1.setTo(this._sp.pivotX + x, this._sp.pivotY + y));
            }
            else {
                return this._sp.localToGlobal(tmpPoint$1.setTo(x, y));
            }
        }
        globalToLocal(x, y) {
            if (this._cache) {
                let point = this.getMatrix().invertTransformPoint(tmpPoint$1.setTo(x, y));
                point.x -= this._sp.pivotX;
                point.y -= this._sp.pivotY;
                return point;
            }
            else {
                return this._sp.globalToLocal(tmpPoint$1.setTo(x, y));
            }
        }
    }
    SpriteGlobalTransform.CHANGED = "globalTransChanged";
    const tmpPoint$1 = new Point();
    const tmpMarix = new Matrix();

    class SingletonList {
        constructor() {
            this.elements = [];
            this.length = 0;
        }
        add(element) {
            let index = this.elements.indexOf(element);
            if (index != -1 && index < this.length)
                return;
            this.elements[this.length++] = element;
        }
        addList(list) {
            let len = this.length;
            let len2 = list.length;
            this.length = len + len2;
            let arr1 = this.elements;
            let arr2 = list.elements;
            if (arr1.length < this.length)
                arr1.length = this.length;
            for (let i = 0; i < len2; i++) {
                arr1[len + i] = arr2[i];
            }
        }
        indexof(element) {
            let index = this.elements.indexOf(element);
            if (index != -1 && index < this.length)
                return index;
            return -1;
        }
        remove(element) {
            let index = this.elements.indexOf(element);
            if (index != -1 && index < this.length) {
                this.elements[index] = this.elements[this.length - 1];
                this.elements[this.length - 1] = null;
                this.length--;
            }
        }
        clear() {
            this.elements.length = 0;
            this.length = 0;
        }
        clean() {
            this.elements.length = this.length;
        }
        cloneTo(out) {
            out.length = this.length;
            out.elements = this.elements.slice();
        }
        destroy() {
            this.elements = null;
        }
    }
    class FastSinglelist extends SingletonList {
        add(element) {
            this.elements[this.length++] = element;
        }
    }

    var texture_ps = "#define SHADER_NAME TextureFS2D\n#if defined(GL_FRAGMENT_PRECISION_HIGH)\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"Sprite2DFrag.glsl\";\nvoid main(){clip();vec4 color=getSpriteTextureColor();setglColor(color);}";

    var texture_vs = "#define SHADER_NAME TextureVS2D\n#include \"Sprite2DVertex.glsl\";\nvoid main(){vertexInfo info;getVertexInfo(info);v_texcoordAlpha=info.texcoordAlpha;v_color=info.color;v_useTex=info.useTex;v_useClip=info.useClip;v_customs=info.customs;gl_Position=getPosition(info.pos);}";

    var baseRender2D_vs = "#define SHADER_NAME BaseRender2DVS\n#include \"Sprite2DVertex.glsl\";\nvoid main(){vertexInfo info;getVertexInfo(info);v_texcoord=info.uv;v_color=info.color;\n#ifdef LIGHT2D_ENABLE\nlightAndShadow(info);\n#endif\ngl_Position=getPosition(info.pos);}";

    var baseRender2D_ps = "#define SHADER_NAME BaseRender2DPS\n#if defined(GL_FRAGMENT_PRECISION_HIGH)\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"Sprite2DFrag.glsl\";\nvoid main(){clip();vec2 texcoord=v_texcoord.xy*u_tilingOffset.zw+u_tilingOffset.xy;vec4 textureColor=texture2D(u_baseRender2DTexture,texcoord);\n#ifdef LIGHT2D_ENABLE\nlightAndShadow(textureColor);\n#endif\ntextureColor=transspaceColor(textureColor);setglColor(textureColor);}";

    var ColorGLSL = "#if !defined(Color_lib)\n#define Color_lib\n#include \"Math.glsl\";\nvec3 linearToGamma(in vec3 value){return pow(value,vec3(1.0/2.2));}vec4 linearToGamma(in vec4 value){return vec4(linearToGamma(value.rgb),value.a);}vec3 gammaToLinear(in vec3 value){return pow(value,vec3(2.2));}vec4 gammaToLinear(in vec4 value){return vec4(gammaToLinear(value.rgb),value.a);}const float c_RGBDMaxRange=255.0;vec4 encodeRGBD(in vec3 color){float maxRGB=max(vecmax(color),FLT_EPS);float d=max(1.0,c_RGBDMaxRange/maxRGB);d=saturate(d/255.0);vec3 rgb=color.rgb*d;rgb=saturate(rgb);return vec4(rgb,d);}vec3 decodeRGBD(in vec4 rgbd){vec3 color=rgbd.rgb*(1.0/rgbd.a);return color;}vec4 encodeRGBM(in vec3 color,float range){color*=1.0/range;float maxRGB=max(vecmax(color),FLT_EPS);float m=ceil(maxRGB*255.0)/255.0;vec3 rgb=color.rgb*1.0/m;vec4 rgbm=vec4(rgb,m);return rgbm;}vec3 decodeRGBM(in vec4 rgbm,float range){return range*rgbm.rgb*rgbm.a;}\n#include \"OutputTransform.glsl\";\n#endif\n";

    var MathGLSL = "#if !defined(Math_lib)\n#define Math_lib\n#ifndef GRAPHICS_API_GLES3\nmat2 inverse(mat2 m){return mat2(m[1][1],-m[0][1],-m[1][0],m[0][0])/(m[0][0]*m[1][1]-m[0][1]*m[1][0]);}mat3 inverse(mat3 m){float a00=m[0][0],a01=m[0][1],a02=m[0][2];float a10=m[1][0],a11=m[1][1],a12=m[1][2];float a20=m[2][0],a21=m[2][1],a22=m[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}mat4 inverse(mat4 m){float a00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],a10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],a20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],a30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],b00=a00*a11-a01*a10,b01=a00*a12-a02*a10,b02=a00*a13-a03*a10,b03=a01*a12-a02*a11,b04=a01*a13-a03*a11,b05=a02*a13-a03*a12,b06=a20*a31-a21*a30,b07=a20*a32-a22*a30,b08=a20*a33-a23*a30,b09=a21*a32-a22*a31,b10=a21*a33-a23*a31,b11=a22*a33-a23*a32,det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;return mat4(a11*b11-a12*b10+a13*b09,a02*b10-a01*b11-a03*b09,a31*b05-a32*b04+a33*b03,a22*b04-a21*b05-a23*b03,a12*b08-a10*b11-a13*b07,a00*b11-a02*b08+a03*b07,a32*b02-a30*b05-a33*b01,a20*b05-a22*b02+a23*b01,a10*b10-a11*b08+a13*b06,a01*b08-a00*b10-a03*b06,a30*b04-a31*b02+a33*b00,a21*b02-a20*b04-a23*b00,a11*b07-a10*b09-a12*b06,a00*b09-a01*b07+a02*b06,a31*b01-a30*b03-a32*b00,a20*b03-a21*b01+a22*b00)/det;}mat4 transpose(mat4 m){return mat4(m[0][0],m[1][0],m[2][0],m[3][0],m[0][1],m[1][1],m[2][1],m[3][1],m[0][2],m[1][2],m[2][2],m[3][2],m[0][3],m[1][3],m[2][3],m[3][3]);}mat3 transpose(mat3 m){return mat3(m[0][0],m[1][0],m[2][0],m[0][1],m[1][1],m[2][1],m[0][2],m[1][2],m[2][2]);}\n#endif\n#define PI 3.14159265359\n#define INVERT_PI 0.31830988618\n#define HALF_PI 1.570796327\n#define MEDIUMP_FLT_MAX 65504.0\n#define MEDIUMP_FLT_MIN 0.00006103515625\n#if defined(GL_FRAGMENT_PRECISION_HIGH)\n#define FLT_EPS 1e-5\n#define saturateMediump(x) x\n#else\n#define FLT_EPS MEDIUMP_FLT_MIN\n#define saturateMediump(x) min(x, MEDIUMP_FLT_MAX)\n#endif\n#define saturate(x) clamp(x, 0.0, 1.0)\nfloat pow2(float x){return x*x;}vec3 pow2(vec3 x){return x*x;}float pow5(float x){float x2=x*x;return x2*x2*x;}const float INVERT_LOG10=0.43429448190325176;float log10(float x){return log(x)*INVERT_LOG10;}float vecmax(const vec2 v){return max(v.x,v.y);}float vecmax(const vec3 v){return max(v.x,max(v.y,v.z));}float vecmax(const vec4 v){return max(max(v.x,v.y),max(v.z,v.w));}float vecmin(const vec2 v){return min(v.x,v.y);}float vecmin(const vec3 v){return min(v.x,min(v.y,v.z));}float vecmin(const vec4 v){return min(min(v.x,v.y),min(v.z,v.w));}vec3 SafeNormalize(in vec3 inVec){float dp3=max(0.001,dot(inVec,inVec));return inVec*inversesqrt(dp3);}vec3 normalScale(in vec3 normal,in float scale){normal*=vec3(scale,scale,1.0);return normalize(normal);}float acosFast(float x){float y=abs(x);float p=-0.1565827*y+1.570796;p*=sqrt(1.0-y);return x>=0.0 ? p : PI-p;}float acosFastPositive(float x){float p=-0.1565827*x+1.570796;return p*sqrt(1.0-x);}float interleavedGradientNoise(const highp vec2 w){const vec3 m=vec3(0.06711056,0.00583715,52.9829189);return fract(m.z*fract(dot(w,m.xy)));}vec3 rotationByEuler(in vec3 vector,in vec3 rot){float halfRoll=rot.z*0.5;float halfPitch=rot.x*0.5;float halfYaw=rot.y*0.5;float sinRoll=sin(halfRoll);float cosRoll=cos(halfRoll);float sinPitch=sin(halfPitch);float cosPitch=cos(halfPitch);float sinYaw=sin(halfYaw);float cosYaw=cos(halfYaw);float quaX=(cosYaw*sinPitch*cosRoll)+(sinYaw*cosPitch*sinRoll);float quaY=(sinYaw*cosPitch*cosRoll)-(cosYaw*sinPitch*sinRoll);float quaZ=(cosYaw*cosPitch*sinRoll)-(sinYaw*sinPitch*cosRoll);float quaW=(cosYaw*cosPitch*cosRoll)+(sinYaw*sinPitch*sinRoll);float x=quaX+quaX;float y=quaY+quaY;float z=quaZ+quaZ;float wx=quaW*x;float wy=quaW*y;float wz=quaW*z;float xx=quaX*x;float xy=quaX*y;float xz=quaX*z;float yy=quaY*y;float yz=quaY*z;float zz=quaZ*z;return vec3(((vector.x*((1.0-yy)-zz))+(vector.y*(xy-wz)))+(vector.z*(xz+wy)),((vector.x*(xy+wz))+(vector.y*((1.0-xx)-zz)))+(vector.z*(yz-wx)),((vector.x*(xz-wy))+(vector.y*(yz+wx)))+(vector.z*((1.0-xx)-yy)));}vec3 rotationByAxis(in vec3 vector,in vec3 axis,in float angle){float halfAngle=angle*0.5;float sinf=sin(halfAngle);float quaX=axis.x*sinf;float quaY=axis.y*sinf;float quaZ=axis.z*sinf;float quaW=cos(halfAngle);float x=quaX+quaX;float y=quaY+quaY;float z=quaZ+quaZ;float wx=quaW*x;float wy=quaW*y;float wz=quaW*z;float xx=quaX*x;float xy=quaX*y;float xz=quaX*z;float yy=quaY*y;float yz=quaY*z;float zz=quaZ*z;return vec3(((vector.x*((1.0-yy)-zz))+(vector.y*(xy-wz)))+(vector.z*(xz+wy)),((vector.x*(xy+wz))+(vector.y*((1.0-xx)-zz)))+(vector.z*(yz-wx)),((vector.x*(xz-wy))+(vector.y*(yz+wx)))+(vector.z*((1.0-xx)-yy)));}vec3 rotationByQuaternions(in vec3 v,in vec4 q){return v+2.0*cross(q.xyz,cross(q.xyz,v)+q.w*v);}\n#endif\n";

    var Sprite2DFrag = "vec3 gammaToLinear(in vec3 value){return pow((value+0.055)/1.055,vec3(2.4));}vec4 gammaToLinear(in vec4 value){return vec4(gammaToLinear(value.rgb),value.a);}vec3 linearToGamma(in vec3 value){return vec3(mix(pow(value.rgb,vec3(0.41666))*1.055-vec3(0.055),value.rgb*12.92,vec3(lessThanEqual(value.rgb,vec3(0.0031308)))));}vec4 linearToGamma(in vec4 value){return vec4(linearToGamma(value.rgb),value.a);}vec4 transspaceColor(vec4 color){\n#ifndef GAMMATEXTURE\n#ifdef GAMMASPACE\ncolor.xyz=linearToGamma(color.xyz);\n#endif\n#else\n#ifndef GAMMASPACE\ncolor.xyz=gammaToLinear(color.xyz);\n#endif\n#endif\nreturn color;}varying vec2 v_cliped;\n#ifdef TEXTUREVS\nvarying vec4 v_texcoordAlpha;varying vec4 v_color;varying float v_useTex;varying float v_useClip;varying vec4 v_customs;uniform sampler2D u_spriteTexture;\n#ifdef FILLTEXTURE\nuniform vec4 u_TexRange;\n#endif\nvec4 getSpriteTextureColor(){\n#ifdef FILLTEXTURE\nvec4 color=texture2D(u_spriteTexture,fract(v_texcoordAlpha.xy)*u_TexRange.zw+u_TexRange.xy);\n#else\nvec4 color=texture2D(u_spriteTexture,v_texcoordAlpha.xy);\n#endif\nreturn transspaceColor(color);}void setglColor(in vec4 color){float useTex=step(1.0,v_useTex);color=mix(vec4(1.,1.,1.,1.),color,useTex);vec4 clampedRange=v_customs;clampedRange.xy=max(v_customs.xy,vec2(0.0,0.0));clampedRange.zw=min(v_customs.xy+v_customs.zw,vec2(1.0,1.0));vec2 inRange=step(clampedRange.xy,v_texcoordAlpha.xy)*step(v_texcoordAlpha.xy,clampedRange.zw);float useTexture=inRange.x*inRange.y;float useClip=step(1.0,v_useClip);float clipAlpha=mix(1.0,useTexture,useClip);color*=clipAlpha;color.a*=v_color.w;vec4 transColor=v_color;\n#ifndef GAMMASPACE\ntransColor=gammaToLinear(v_color);\n#endif\ncolor.rgb*=transColor.rgb;gl_FragColor=color;}\n#endif\n#ifdef BASERENDER2D\nvarying vec2 v_texcoord;varying vec4 v_color;uniform sampler2D u_baseRender2DTexture;uniform vec4 u_baseRenderColor;uniform vec4 u_tilingOffset;\n#ifdef LIGHT2D_ENABLE\nvarying vec2 v_lightUV;uniform vec3 u_LightDirection;uniform vec4 u_LightAndShadow2DParam;uniform vec4 u_LightAndShadow2DAmbient;uniform sampler2D u_LightAndShadow2D;\n#ifdef LIGHT2D_SCENEMODE_ADD\nuniform sampler2D u_LightAndShadow2D_AddMode;\n#endif\n#ifdef LIGHT2D_SCENEMODE_SUB\nuniform sampler2D u_LightAndShadow2D_SubMode;\n#endif\n#ifdef LIGHT2D_NORMAL_PARAM\nuniform sampler2D u_normal2DTexture;uniform float u_normal2DStrength;\n#endif\nvoid lightAndShadow(inout vec4 color){\n#ifdef LIGHT2D_EMPTY\ncolor.rgb*=u_LightAndShadow2DAmbient.rgb;\n#else\nvec2 uv=v_lightUV;vec2 tt=step(vec2(0.0),uv)*step(uv,vec2(1.0));float side=tt.x*tt.y;vec3 ambient=color.rgb*u_LightAndShadow2DAmbient.rgb;color.rgb=color.rgb*texture2D(u_LightAndShadow2D,uv).rgb*side;side*=color.a;\n#ifdef LIGHT2D_SCENEMODE_ADD\ncolor.rgb=min(vec3(1.0),color.rgb+texture2D(u_LightAndShadow2D_AddMode,uv).rgb*side);\n#endif\n#ifdef LIGHT2D_SCENEMODE_SUB\ncolor.rgb=max(vec3(0.0),color.rgb-texture2D(u_LightAndShadow2D_SubMode,uv).rgb*side);\n#endif\n#ifdef LIGHT2D_NORMAL_PARAM\nvec3 dr=normalize(u_LightDirection);vec3 normal=normalize(texture2D(u_normal2DTexture,v_texcoord).rgb*2.0-1.0);color.rgb=color.rgb*((1.0-u_normal2DStrength)+abs(dot(dr,normal.rgb))*u_normal2DStrength);\n#endif\ncolor.rgb=min(vec3(1.0),color.rgb+ambient);\n#endif\n}\n#endif\nvoid setglColor(in vec4 color){color.a*=v_color.w;vec4 transColor=v_color;\n#ifndef GAMMASPACE\ntransColor=gammaToLinear(v_color);\n#endif\ncolor.rgb*=transColor.rgb;gl_FragColor=color;}vec2 transformUV(in vec2 texcoord,in vec4 tilingOffset){vec2 uv=texcoord*tilingOffset.zw+tilingOffset.xy;return uv;}\n#endif\nvoid clip(){if(v_cliped.x<0.)discard;if(v_cliped.x>1.)discard;if(v_cliped.y<0.)discard;if(v_cliped.y>1.)discard;}";

    var Sprite2DVertex = "#ifdef CAMERA2D\nuniform mat3 u_view2D;\n#endif\n#ifdef SPRITE2DGLOBAL\n#endif\n#ifdef RENDERTEXTURE\nuniform vec3 u_InvertMat_0;uniform vec3 u_InvertMat_1;\n#endif\n#ifdef VERTEX_SIZE\nuniform vec4 u_vertexSize;\n#endif\nuniform vec3 u_NMatrix_0;uniform vec3 u_NMatrix_1;uniform vec2 u_size;\n#ifdef MATERIALCLIP\nuniform vec4 u_mClipMatDir;uniform vec4 u_mClipMatPos;\n#endif\nuniform vec4 u_clipMatDir;uniform vec4 u_clipMatPos;varying vec2 v_cliped;varying vec4 v_color;void transfrom(vec2 pos,vec3 xDir,vec3 yDir,out vec2 outPos){outPos.x=xDir.x*pos.x+xDir.y*pos.y+xDir.z;outPos.y=yDir.x*pos.x+yDir.y*pos.y+yDir.z;}void clip(inout vec2 globalPos){vec4 clipMatDir;vec4 clipMatPos;\n#ifdef MATERIALCLIP\nclipMatDir=u_mClipMatDir;clipMatPos=u_mClipMatPos;float tx=clipMatPos.z;float ty=clipMatPos.w;float cmaxx=tx+clipMatDir.x;float cmaxy=ty+clipMatDir.w;float parentMinX=u_clipMatPos.x;float parentMinY=u_clipMatPos.y;float offsetx=u_clipMatPos.z-parentMinX;float offsety=u_clipMatPos.w-parentMinY;float parentMaxX=parentMinX+u_clipMatDir.x;float parentMaxY=parentMinY+u_clipMatDir.w;if(tx<parentMinX){clipMatDir.x-=(parentMinX-tx);tx=clipMatPos.x=parentMinX;}if(cmaxx>parentMaxX){clipMatDir.x-=(cmaxx-parentMaxX);}if(ty<parentMinY){clipMatDir.w-=(parentMinY-ty);ty=clipMatPos.y=parentMinY;}if(cmaxy>parentMaxY){clipMatDir.w-=(cmaxy-parentMaxY);}clipMatPos.zw=vec2(tx+offsetx,ty+offsety);\n#else\nclipMatDir=u_clipMatDir;clipMatPos=u_clipMatPos;\n#endif\nvec2 cliped;float clipw=length(clipMatDir.xy);float cliph=length(clipMatDir.zw);vec2 clippos=globalPos-clipMatPos.xy;if(clipw>20000.&&cliph>20000.)cliped=vec2(0.5,0.5);else{cliped=vec2(dot(clippos,clipMatDir.xy)/clipw/clipw,dot(clippos,clipMatDir.zw)/cliph/cliph);}globalPos=clippos+clipMatPos.zw;v_cliped=cliped;}void getGlobalPos(in vec2 localPos,out vec2 globalPos){transfrom(localPos,u_NMatrix_0,u_NMatrix_1,globalPos);}void getProjectPos(in vec2 viewPos,out vec4 projectPos){projectPos=vec4((viewPos.x/u_size.x-0.5)*2.0,(0.5-viewPos.y/u_size.y)*2.0,0.,1.0);\n#ifdef INVERTY\nprojectPos.y=-projectPos.y;\n#endif\n}void getViewPos(in vec2 globalPos,out vec2 viewPos){\n#ifdef RENDERTEXTURE\nvec2 tempPos;transfrom(globalPos,u_InvertMat_0,u_InvertMat_1,tempPos);\n#ifdef CAMERA2D\nviewPos.xy=(u_view2D*vec3(tempPos,1.0)).xy+u_size/2.;\n#else\nviewPos.xy=tempPos;\n#endif\n#else\n#ifdef CAMERA2D\nviewPos.xy=(u_view2D*vec3(globalPos,1.0)).xy+u_size/2.;\n#else\nviewPos.xy=globalPos;\n#endif\n#endif\n}\n#ifdef TEXTUREVS\nstruct vertexInfo{vec2 pos;vec4 color;vec2 cliped;vec4 texcoordAlpha;float useTex;float useClip;vec4 customs;};uniform float u_VertAlpha;varying vec4 v_texcoordAlpha;varying float v_useTex;varying float v_useClip;varying vec4 v_customs;void getVertexInfo(inout vertexInfo info){info.texcoordAlpha.xy=a_posuv.zw;info.color=a_attribColor;info.color.a*=u_VertAlpha;info.color.xyz*=info.color.w;info.useTex=a_attribFlags.r;info.useClip=a_attribFlags.g;info.customs=a_customs;vec2 pos;\n#ifdef VERTEX_SIZE\npos=(a_posuv.xy*u_vertexSize.zw)+u_vertexSize.xy;\n#else\npos=a_posuv.xy;\n#endif\ninfo.pos=pos;}vec4 getPosition(in vec2 positionOS){vec2 globalPos;\n#ifdef VERTEX_SIZE\ngetGlobalPos(positionOS,globalPos);\n#else\nglobalPos=positionOS;\n#endif\nclip(globalPos);vec2 viewPos;getViewPos(globalPos,viewPos);vec4 pos;getProjectPos(viewPos,pos);return pos;}\n#endif\n#ifdef BASERENDER2D\nvarying vec2 v_texcoord;uniform vec4 u_baseRenderColor;struct vertexInfo{vec4 color;vec2 uv;vec2 pos;vec2 lightUV;};\n#ifdef LIGHT2D_ENABLE\nvarying vec2 v_lightUV;uniform vec4 u_LightAndShadow2DParam;void lightAndShadow(vertexInfo info){v_lightUV=info.lightUV;}void invertMat(inout vec3 v1,inout vec3 v2){float a1=v1.x;float b1=v2.x;float c1=v1.y;float d1=v2.y;float tx1=v1.z;float ty1=v2.z;float n=a1*d1-b1*c1;v1.x=d1/n;v2.x=-b1/n;v1.y=-c1/n;v2.y=a1/n;v1.z=(c1*ty1-d1*tx1)/n;v2.z=-(a1*ty1-b1*tx1)/n;}\n#endif\nvec4 linearToGamma(in vec4 value){return vec4(mix(pow(value.rgb,vec3(0.41666))*1.055-vec3(0.055),value.rgb*12.92,vec3(lessThanEqual(value.rgb,vec3(0.0031308)))),value.a);}void getVertexInfo(inout vertexInfo info){info.pos=a_position.xy;info.color=vec4(1.0,1.0,1.0,1.0);\n#ifdef COLOR\ninfo.color=a_color;info.color.rgb*=a_color.a;\n#endif\ninfo.color*=linearToGamma(u_baseRenderColor);\n#ifdef UV\ninfo.uv=a_uv;\n#endif\n#ifdef LIGHT2D_ENABLE\nvec2 global;getGlobalPos(info.pos,global);info.lightUV.x=(global.x-u_LightAndShadow2DParam.x)/u_LightAndShadow2DParam.z;info.lightUV.y=1.0-(global.y-u_LightAndShadow2DParam.y)/u_LightAndShadow2DParam.w;\n#endif\n}vec4 getPosition(in vec2 positionOS){vec2 globalPos;getGlobalPos(positionOS,globalPos);clip(globalPos);vec2 viewPos;getViewPos(globalPos,viewPos);vec4 pos;getProjectPos(viewPos,pos);return pos;}\n#endif\n";

    var OutputTransformGLSL = "#if !defined(OutputTransform_lib)\n#define OutputTransform_lib\nvec3 gammaCorrect(in vec3 color,float gammaValue){return pow(color,vec3(gammaValue));}vec4 gammaCorrect(in vec4 color){float gammaValue=1.0/2.2;return vec4(gammaCorrect(color.rgb,gammaValue),color.a);}vec4 outputTransform(in vec4 color){\n#ifdef GAMMACORRECT\nreturn gammaCorrect(color);\n#else\nreturn color;\n#endif\n}\n#endif\n";

    class Shader2D {
        destroy() {
        }
        static __init__() {
            Shader3D.addInclude("Sprite2DFrag.glsl", Sprite2DFrag);
            Shader3D.addInclude("Sprite2DVertex.glsl", Sprite2DVertex);
            Shader3D.addInclude("Color.glsl", ColorGLSL);
            Shader3D.addInclude("Math.glsl", MathGLSL);
            Shader3D.addInclude("OutputTransform.glsl", OutputTransformGLSL);
            Shader2D.graphicsShader = Shader3D.add("Sprite2DTexture", false, false);
            Shader2D.graphicsShader.shaderType = exports.ShaderFeatureType.D2_TextureSV;
            let subShader = new SubShader(Shader2D.graphicsAttribute, {}, {});
            Shader2D.graphicsShader.addSubShader(subShader);
            subShader.addShaderPass(texture_vs, texture_ps);
            Shader2D.render2DNodeShader = Shader3D.add("baseRender2D", false, false);
            Shader2D.render2DNodeShader.shaderType = exports.ShaderFeatureType.D2_BaseRenderNode2D;
            subShader = new SubShader(Shader2D.Render2DNodeAttribute, {}, {});
            Shader2D.render2DNodeShader.addSubShader(subShader);
            subShader.addShaderPass(baseRender2D_vs, baseRender2D_ps);
        }
    }
    Shader2D.graphicsAttribute = {
        'a_posuv': [0, exports.ShaderDataType.Vector4],
        'a_attribColor': [1, exports.ShaderDataType.Vector4],
        'a_attribFlags': [2, exports.ShaderDataType.Vector4],
        'a_customs': [3, exports.ShaderDataType.Vector4]
    };
    Shader2D.Render2DNodeAttribute = {
        'a_position': [0, exports.ShaderDataType.Vector4],
        'a_color': [1, exports.ShaderDataType.Vector4],
        'a_uv': [2, exports.ShaderDataType.Vector2]
    };

    class GraphicsRenderData {
        constructor(owner) {
            this._renderElements = [];
            this._submits = new FastSinglelist;
            this._bufferBlocks = [];
            this.texturesMap = new Map();
            this.owner = owner;
        }
        clear() {
            let len = this._submits.length;
            let i = 0;
            for (i = 0; i < len; i++) {
                this._submits.elements[i].clear();
            }
            this._bufferBlocks.length = 0;
            this._submits.length = 0;
        }
        destroy() {
            this.clear();
            let material = this.owner.material;
            let elements = this._renderElements;
            for (let i = 0; i < elements.length; i++) {
                if (material) {
                    material._removeOwnerElement(elements[i]);
                }
                GraphicsRenderData._pool.recover(elements[i]);
            }
            elements.length = 0;
            this.texturesMap.forEach(res => {
                res.off(Event.CHANGE, this, this._resourceRepaint);
            });
            this.texturesMap.clear();
            let submits = this._submits.elements;
            for (let i = 0; i < this._submits.length; i++) {
                submits[i].destroy();
            }
            this._submits.destroy();
            this._submits = null;
            this.owner = null;
        }
        _check() {
            let result = true;
            this.texturesMap.forEach(texture => {
                result = texture._getSource() && result;
            });
            return result;
        }
        updateRenderElement(graphics, struct, handle) {
            let originLen = this._renderElements.length;
            let submits = this._submits;
            let submitLength = submits.length;
            let needUpdate = originLen !== submitLength;
            let flength = Math.max(originLen, submitLength);
            let blocks = this._bufferBlocks;
            for (let i = 0; i < flength; i++) {
                let submit = submits.elements[i];
                let element = this._renderElements[i];
                if (i < submitLength) {
                    if (!element) {
                        element = GraphicsRenderData._pool.take();
                        element.value2DShaderData = struct.spriteShaderData;
                        element.owner = struct;
                        this._renderElements[i] = element;
                    }
                    element.primitiveShaderData = submit._internalInfo.shaderData;
                    element.renderStateIsBySprite = submit.renderStateIsBySprite && graphics._useSpriteState;
                    if (submit.material) {
                        element.subShader = submit.material.shader.getSubShaderAt(0);
                        element.materialShaderData = submit.material.shaderData;
                        submit.material._setOwner2DElement(element);
                    }
                    else {
                        element.subShader = Shader2D.graphicsShader.getSubShaderAt(0);
                    }
                    let geometry = element.geometry;
                    geometry.bufferState = submit.mesh.bufferState;
                    geometry.clearRenderParams();
                    let indexView = this._updateIndexViews(submit, geometry);
                    let vertexBuffer = submit.mesh._buffer.vertexBuffer;
                    {
                        let vertexBlock = LayaGL.render2DRenderPassFactory.createGraphic2DBufferBlock();
                        vertexBlock.vertexs = submit.vertexs;
                        vertexBlock.indexView = indexView;
                        vertexBlock.vertexBuffer = vertexBuffer;
                        blocks.push(vertexBlock);
                    }
                    this._updateGraphicsKeys(element, submit);
                }
                else {
                    graphics.material && (graphics.material._removeOwnerElement(element));
                    GraphicsRenderData._pool.recover(element);
                }
            }
            this._renderElements.length = submitLength;
            if (needUpdate) {
                struct.renderElements = this._renderElements;
            }
            handle.applyVertexBufferBlock(blocks);
        }
        _updateIndexViews(submit, geometry) {
            let indexView = submit.mesh.checkIndex(submit.indexCount);
            indexView.setGeometry(geometry);
            submit.indexView = indexView;
            indexView.setData(submit.indices);
            submit.indexCount = 0;
            submit.indices.length = 0;
            return indexView;
        }
        _updateGraphicsKeys(element, submit) {
            let useCustomMaterial = submit.material ? 1 : 0;
            let mc = (useCustomMaterial === 0 && submit._internalInfo.materialClip) ? 1 : 0;
            let texture;
            let textureHost = submit._internalInfo.textureHost;
            if (textureHost)
                texture = textureHost.bitmap || textureHost;
            element.type = submit._key.blendShader
                | (useCustomMaterial << 4)
                | (mc << 5)
                | ((texture ? texture.id : 0) << 6);
        }
        setRenderElement(struct, handle) {
            struct.renderElements = this._renderElements;
            handle.applyVertexBufferBlock(this._bufferBlocks);
        }
        createSubmit(runner, mesh, material) {
            let elements = this._submits.elements;
            let submit = null;
            if (elements.length > this._submits.length) {
                submit = elements[this._submits.length];
                submit.update(runner, mesh, material);
                this._submits.length++;
            }
            else {
                submit = SubmitBase.create(runner, mesh, material);
                this._submits.add(submit);
            }
            return submit;
        }
        addResRef(res) {
            if (res instanceof Texture) {
                let old = this.texturesMap.get(res.id);
                if (!old) {
                    res.on("dispose", this, this._resourceRepaint);
                    this.texturesMap.set(res.id, res);
                }
            }
        }
        _resourceRepaint() {
            if (this.owner._needGraphicsUpdate()) {
                this.owner._graphics.repaint();
            }
            else {
                this.owner._graphics._modified = true;
            }
        }
    }
    GraphicsRenderData._pool = Pool.createPool2(() => {
        let element = LayaGL.render2DRenderPassFactory.createPrimitiveRenderElement2D();
        element.renderStateIsBySprite = false;
        element.nodeCommonMap = ["Sprite2D"];
        return element;
    }, (element, needGeometry) => {
        if (needGeometry || needGeometry == null) {
            element.geometry = LayaGL.renderDeviceFactory.createRenderGeometryElement(exports.MeshTopology.Triangles, exports.DrawType.DrawElement);
            element.geometry.indexFormat = exports.IndexFormat.UInt16;
        }
        else {
            if (element.geometry) {
                element.geometry.destroy();
                element.geometry = null;
            }
        }
    }, (element) => {
        if (element.geometry) {
            element.geometry.clearRenderParams();
            element.geometry.bufferState = null;
        }
        element.materialShaderData = null;
        element.value2DShaderData = null;
        element.primitiveShaderData = null;
        element.globalShaderData = null;
        element.owner = null;
        element.subShader = null;
        element.renderStateIsBySprite = false;
        element.type = 0;
    });
    class SubStructRender {
        constructor() {
            this._renderElement = null;
            this._shaderData = null;
            this._handle = null;
            this._submit = null;
            this._internalInfo = null;
            this._rtRect = new Rectangle();
            this._oriRect = new Rectangle();
            this._needUpdateVertexSize = true;
            this._scaleX = 1;
            this._scaleY = 1;
            this._shaderData = LayaGL.renderDeviceFactory.createShaderData();
            this._handle = LayaGL.render2DRenderPassFactory.create2D2DPrimitiveDataHandle();
            this._submit = new SubmitBase;
            this._internalInfo = new GraphicsShaderInfo();
            this._submit._internalInfo = this._internalInfo;
            this._renderElement = GraphicsRenderData._pool.take();
            this._renderElement.value2DShaderData = this._shaderData;
            this._renderElement.subShader = Shader2D.graphicsShader.getSubShaderAt(0);
            this._renderElement.primitiveShaderData = this._submit._internalInfo.shaderData;
            this._renderElement.nodeCommonMap = ["Sprite2D"];
            this._renderElement.geometry = Render2DProcessor.runner.inv_geometry;
            BlendModeHandler.initBlendMode(this._shaderData);
            this._internalInfo.enableVertexSize = true;
        }
        bind(sprite, subRenderPass, subStruct) {
            this._sprite = sprite;
            this._subRenderPass = subRenderPass;
            this._subStruct = subStruct;
            this._subStruct.spriteShaderData = this._shaderData;
            this._subStruct.renderType = exports.BaseRender2DType.graphics;
            this._submit.material = sprite.material;
            subStruct.renderDataHandler = this._handle;
            subStruct.renderMatrix = sprite.globalTrans.getMatrix();
            subStruct.renderElements = [this._renderElement];
            this._renderElement.owner = this._subStruct;
            this._renderElement.type = this._subStruct.blendMode;
        }
        _updateRenderOffset(rect, oriRect, scaleX, scaleY) {
            rect.cloneTo(this._rtRect);
            if (!oriRect.equals(this._oriRect)) {
                this._needUpdateVertexSize = true;
            }
            oriRect.cloneTo(this._oriRect);
            this._scaleX = scaleX;
            this._scaleY = scaleY;
            let originPass = this._subRenderPass;
            let matrix = originPass.offsetMatrix;
            let sprite = this._sprite;
            if (sprite.mask) {
                this._updateLogicMatrix(sprite.mask, sprite.globalTrans.getMatrix(), rect.x, rect.y, matrix);
            }
            else if (sprite._maskParent && sprite.transform) {
                this._updateLogicMatrix(sprite, sprite.globalTrans.getMatrix(), rect.x, rect.y, matrix);
            }
            else {
                this._handle.logicMatrix = null;
                matrix.identity();
                matrix.tx = rect.x;
                matrix.ty = rect.y;
            }
            matrix.scale(1 / scaleX, 1 / scaleY);
            originPass.offsetMatrix = matrix;
        }
        _updateLogicMatrix(sprite, global, offsetX, offsetY, out) {
            if (!this._logicMatrix) {
                this._logicMatrix = new Matrix;
            }
            let logicMatrix = this._logicMatrix;
            let spriteGlobal = sprite.globalTrans.getMatrix();
            let parent = sprite.parent ? sprite.parent : sprite._maskParent;
            let parentGlobal = parent.globalTrans.getMatrix();
            parentGlobal.copyTo(logicMatrix);
            let x = sprite.x - sprite._pivotX;
            let y = sprite.y - sprite._pivotY;
            logicMatrix.tx = x * parentGlobal.a + y * parentGlobal.c + parentGlobal.tx;
            logicMatrix.ty = x * parentGlobal.b + y * parentGlobal.d + parentGlobal.ty;
            logicMatrix.copyTo(out);
            Matrix.mul(logicMatrix, global.copyTo(Matrix.TEMP).invert(), logicMatrix);
            this._handle.logicMatrix = this._logicMatrix;
            out.tx = offsetX * out.a + offsetY * out.c + out.tx;
            out.ty = offsetX * out.b + offsetY * out.d + out.ty;
            Matrix.mul(spriteGlobal, out.invert(), out);
            out.invert();
        }
        _updateRenderTexture(oriRT, destRT) {
            var _a;
            this._handle.mask = (_a = this._sprite.mask) === null || _a === void 0 ? void 0 : _a._struct;
            if (this._submit._key.blendShader !== this._subStruct.blendMode) {
                this._submit._key.blendShader = this._subStruct.blendMode;
                BlendModeHandler.setShaderData(this._subStruct.blendMode, this._internalInfo.shaderData);
            }
            if (this._internalInfo.textureHost == destRT && !this._needUpdateVertexSize)
                return;
            if (destRT) {
                this._renderElement.type = destRT._id << 6;
            }
            else {
                this._renderElement.type = 0;
            }
            this._internalInfo.textureHost = destRT;
            let oriRect = this._oriRect;
            let vSize = Vector4.TEMP;
            vSize.x = oriRect.x;
            vSize.y = oriRect.y;
            let width = destRT.sourceWidth;
            let height = destRT.sourceHeight;
            if (width > 0 && height > 0) {
                vSize.z = Math.round(width / this._scaleX);
                vSize.w = Math.round(height / this._scaleY);
                vSize.x -= (vSize.z - oriRect.width) / 2;
                vSize.y -= (vSize.w - oriRect.height) / 2;
            }
            else {
                vSize.z = oriRect.width;
                vSize.w = oriRect.height;
            }
            this._internalInfo.vertexSize = vSize;
            this._needUpdateVertexSize = false;
        }
        destroy() {
            this._renderElement.geometry = null;
            GraphicsRenderData._pool.recover(this._renderElement);
            this._submit.destroy();
            this._submit = null;
            this._internalInfo = null;
            this._handle = null;
            this._subRenderPass = null;
            this._subStruct = null;
            this._sprite = null;
        }
    }

    var BlurEffect2DVS = "\n#define SHADER_NAME blurEffect2D\nvarying vec2 v_Texcoord0;void main(){gl_Position=vec4((a_PositionTexcoord.x)*u_centerScale.x,(a_PositionTexcoord.y)*u_centerScale.y,0.0,1.0);v_Texcoord0=a_PositionTexcoord.zw;\n#ifdef INVERTY\ngl_Position.y=-gl_Position.y;\n#endif\n}";

    var BlurEffect2DFS = "\n#define SHADER_NAME blurEffect2D\n#include \"Color.glsl\"\n#include \"OutputTransform.glsl\";\nvec4 transspaceColor(vec4 color){\n#ifndef GAMMATEXTURE\n#ifdef GAMMASPACE\ncolor.xyz=linearToGamma(color.xyz);\n#endif\n#else\n#ifndef GAMMASPACE\ncolor.xyz=gammaToLinear(color.xyz);\n#endif\n#endif\nreturn color;}varying vec2 v_Texcoord0;float getGaussian(float x,float y){return u_strength_sig2_2sig2_gauss1.w*exp(-(x*x+y*y)/u_strength_sig2_2sig2_gauss1.z);}vec4 blur(){const float blurw=9.0;vec4 vec4Color=vec4(0.0,0.0,0.0,0.0);vec2 halfsz=vec2(blurw,blurw)/2.0/u_blurInfo;vec2 startpos=v_Texcoord0.xy-halfsz;vec2 ctexcoord=startpos;vec2 step=1.0/u_blurInfo;for(float y=0.0;y<=blurw;++y){ctexcoord.x=startpos.x;for(float x=0.0;x<=blurw;++x){vec4Color+=texture2D(u_MainTex,ctexcoord)*getGaussian(x-blurw/2.0,y-blurw/2.0);ctexcoord.x+=step.x;}ctexcoord.y+=step.y;}return vec4Color;}void main(){gl_FragColor=blur();}";

    var ColorEffect2DVS = "#define SHADER_NAME colorEffect2D\nvarying vec2 v_Texcoord0;void main(){gl_Position=vec4((a_PositionTexcoord.x)*u_centerScale.x,(a_PositionTexcoord.y)*u_centerScale.y,0.0,1.0);v_Texcoord0=a_PositionTexcoord.zw;\n#ifdef INVERTY\ngl_Position.y=-gl_Position.y;\n#endif\n}";

    var ColorEffect2DFS = "#define SHADER_NAME colorEffect2D\n#include \"Color.glsl\"\n#include \"OutputTransform.glsl\";\nvarying vec2 v_Texcoord0;void main(){vec4 mainColor=texture2D(u_MainTex,v_Texcoord0);gl_FragColor=mainColor;\n#ifdef COLORFILTER\nmat4 alphaMat=u_colorMat;alphaMat[0][3]*=gl_FragColor.a;alphaMat[1][3]*=gl_FragColor.a;alphaMat[2][3]*=gl_FragColor.a;gl_FragColor=gl_FragColor*alphaMat;gl_FragColor+=u_colorAlpha/255.0*gl_FragColor.a;\n#endif\ngl_FragColor=outputTransform(gl_FragColor);}";

    var GlowEffect2DVS = "#define SHADER_NAME glow2D\nvarying vec2 v_Texcoord0;void main(){gl_Position=vec4((a_PositionTexcoord.x)*u_centerScale.x,(a_PositionTexcoord.y)*u_centerScale.y,0.0,1.0);v_Texcoord0=a_PositionTexcoord.zw;\n#ifdef INVERTY\ngl_Position.y=-gl_Position.y;\n#endif\n}";

    var GlowEffect2DFS = "#define SHADER_NAME glow2D\n#include \"OutputTransform.glsl\";\nvarying vec2 v_Texcoord0;void main(){const float c_IterationTime=10.0;float floatIterationTotalTime=c_IterationTime*c_IterationTime;vec4 vec4Color=vec4(0.0,0.0,0.0,0.0);vec2 vec2FilterDir=vec2(-u_blurInfo1.z/u_blurInfo2.x,-u_blurInfo1.w/u_blurInfo2.y);vec2 vec2FilterOff=vec2(u_blurInfo1.x/u_blurInfo2.x/c_IterationTime*2.0,u_blurInfo1.y/u_blurInfo2.y/c_IterationTime*2.0);float maxNum=u_blurInfo1.x*u_blurInfo1.y;vec2 vec2Off=vec2(0.0,0.0);float floatOff=c_IterationTime/2.0;for(float i=0.0;i<=c_IterationTime;++i){for(float j=0.0;j<=c_IterationTime;++j){vec2Off=vec2(vec2FilterOff.x*(i-floatOff),vec2FilterOff.y*(j-floatOff));vec4Color+=texture2D(u_MainTex,v_Texcoord0.xy+vec2FilterDir+vec2Off);}}vec4Color/=floatIterationTotalTime;gl_FragColor=vec4(u_color.rgb,vec4Color.a*u_blurInfo2.z);gl_FragColor.rgb*=gl_FragColor.a;}";

    class Effect2DShaderInit {
        static colorEffect2DShaderInit() {
            let attributeMap = {
                "a_PositionTexcoord": [0, exports.ShaderDataType.Vector4]
            };
            let uniformMap = {
                "u_centerScale": exports.ShaderDataType.Vector2,
                "u_MainTex": exports.ShaderDataType.Texture2D,
                "u_colorMat": exports.ShaderDataType.Matrix4x4,
                "u_colorAlpha": exports.ShaderDataType.Vector4
            };
            let shader = Shader3D.add("ColorEffect2D");
            shader.shaderType = exports.ShaderFeatureType.PostProcess;
            let subShader = new SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            let blitPass = subShader.addShaderPass(ColorEffect2DVS, ColorEffect2DFS);
            blitPass.statefirst = true;
            blitPass.renderState.depthWrite = false;
            blitPass.renderState.depthTest = RenderState.DEPTHTEST_OFF;
            blitPass.renderState.blend = RenderState.BLEND_ENABLE_ALL;
            blitPass.renderState.blendEquation = RenderState.BLENDEQUATION_ADD;
            blitPass.renderState.srcBlend = RenderState.BLENDPARAM_ONE;
            blitPass.renderState.dstBlend = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
            blitPass.renderState.cull = RenderState.CULL_NONE;
        }
        static blurEffect2DShaderInit() {
            let attributeMap = {
                "a_PositionTexcoord": [0, exports.ShaderDataType.Vector4]
            };
            let uniformMap = {
                "u_centerScale": exports.ShaderDataType.Vector2,
                "u_MainTex": exports.ShaderDataType.Texture2D,
                "u_strength_sig2_2sig2_gauss1": exports.ShaderDataType.Vector4,
                "u_blurInfo": exports.ShaderDataType.Vector2
            };
            let shader = Shader3D.add("BlurEffect2D");
            shader.shaderType = exports.ShaderFeatureType.PostProcess;
            let subShader = new SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            let blitPass = subShader.addShaderPass(BlurEffect2DVS, BlurEffect2DFS);
            blitPass.statefirst = true;
            blitPass.renderState.depthWrite = false;
            blitPass.renderState.depthTest = RenderState.DEPTHTEST_OFF;
            blitPass.renderState.blend = RenderState.BLEND_ENABLE_ALL;
            blitPass.renderState.blendEquation = RenderState.BLENDEQUATION_ADD;
            blitPass.renderState.srcBlend = RenderState.BLENDPARAM_ONE;
            blitPass.renderState.dstBlend = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
            blitPass.renderState.cull = RenderState.CULL_NONE;
        }
        static glow2DShaderInit() {
            let attributeMap = {
                "a_PositionTexcoord": [0, exports.ShaderDataType.Vector4]
            };
            let uniformMap = {
                "u_centerScale": exports.ShaderDataType.Vector2,
                "u_MainTex": exports.ShaderDataType.Texture2D,
                "u_color": exports.ShaderDataType.Vector4,
                "u_blurInfo1": exports.ShaderDataType.Vector4,
                "u_blurInfo2": exports.ShaderDataType.Vector4
            };
            let shader = Shader3D.add("glow2D");
            shader.shaderType = exports.ShaderFeatureType.PostProcess;
            let subShader = new SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            let blitPass = subShader.addShaderPass(GlowEffect2DVS, GlowEffect2DFS);
            blitPass.statefirst = true;
            blitPass.renderState.depthWrite = false;
            blitPass.renderState.depthTest = RenderState.DEPTHTEST_OFF;
            blitPass.renderState.blend = RenderState.BLEND_ENABLE_ALL;
            blitPass.renderState.blendEquation = RenderState.BLENDEQUATION_ADD;
            blitPass.renderState.srcBlend = RenderState.BLENDPARAM_ONE;
            blitPass.renderState.dstBlend = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
            blitPass.renderState.cull = RenderState.CULL_NONE;
        }
    }

    const TEMPMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    class RenderState2D {
        static restoreTempArray() {
            TEMPMAT4_ARRAY[0] = 1;
            TEMPMAT4_ARRAY[1] = 0;
            TEMPMAT4_ARRAY[4] = 0;
            TEMPMAT4_ARRAY[5] = 1;
            TEMPMAT4_ARRAY[12] = 0;
            TEMPMAT4_ARRAY[13] = 0;
        }
        static clear() {
            RenderState2D.worldAlpha = 1;
        }
    }
    RenderState2D.worldMatrix4 = TEMPMAT4_ARRAY;
    RenderState2D.worldMatrix = new Matrix();
    RenderState2D.matWVP = null;
    RenderState2D.worldAlpha = 1.0;
    RenderState2D.worldScissorTest = false;
    RenderState2D.width = 0;
    RenderState2D.height = 0;
    RenderState2D.InvertY = false;

    exports.MaterialRenderMode = void 0;
    (function (MaterialRenderMode) {
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_OPAQUE"] = 0] = "RENDERMODE_OPAQUE";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_CUTOUT"] = 1] = "RENDERMODE_CUTOUT";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_TRANSPARENT"] = 2] = "RENDERMODE_TRANSPARENT";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_ADDTIVE"] = 3] = "RENDERMODE_ADDTIVE";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_ALPHABLENDED"] = 4] = "RENDERMODE_ALPHABLENDED";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_CUSTOME"] = 5] = "RENDERMODE_CUSTOME";
    })(exports.MaterialRenderMode || (exports.MaterialRenderMode = {}));
    class Material extends Resource {
        static load(url, complete) {
            ILaya.loader.load(url, complete, null, Loader.MATERIAL);
        }
        static __initDefine__() {
            Material.SHADERDEFINE_ALPHATEST = Shader3D.getDefineByName("ALPHATEST");
            Material.SHADERDEFINE_MAINTEXTURE = Shader3D.getDefineByName("MAINTEXTURE");
            Material.SHADERDEFINE_ADDTIVEFOG = Shader3D.getDefineByName("ADDTIVEFOG");
            Material.ALPHATESTVALUE = Shader3D.propertyNameToID("u_AlphaTestValue");
            Shader3D.CULL = Shader3D.propertyNameToID("s_Cull");
            Shader3D.BLEND = Shader3D.propertyNameToID("s_Blend");
            Shader3D.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc");
            Shader3D.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst");
            Shader3D.BLEND_SRC_RGB = Shader3D.propertyNameToID("s_BlendSrcRGB");
            Shader3D.BLEND_DST_RGB = Shader3D.propertyNameToID("s_BlendDstRGB");
            Shader3D.BLEND_SRC_ALPHA = Shader3D.propertyNameToID("s_BlendSrcAlpha");
            Shader3D.BLEND_DST_ALPHA = Shader3D.propertyNameToID("s_BlendDstAlpha");
            Shader3D.BLEND_EQUATION = Shader3D.propertyNameToID("s_BlendEquation");
            Shader3D.BLEND_EQUATION_RGB = Shader3D.propertyNameToID("s_BlendEquationRGB");
            Shader3D.BLEND_EQUATION_ALPHA = Shader3D.propertyNameToID("s_BlendEquationAlpha");
            Shader3D.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest");
            Shader3D.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite");
            Shader3D.STENCIL_WRITE_MASK = Shader3D.propertyNameToID("s_StencilWriteMask");
            Shader3D.STENCIL_READ_MASK = Shader3D.propertyNameToID("s_StencilReadMask");
            Shader3D.STENCIL_Ref = Shader3D.propertyNameToID("s_StencilRef");
            Shader3D.STENCIL_TEST = Shader3D.propertyNameToID("s_StencilTest");
            Shader3D.STENCIL_WRITE = Shader3D.propertyNameToID("s_StencilWrite");
            Shader3D.STENCIL_Op = Shader3D.propertyNameToID("s_StencilOp");
            Shader3D.DEPTH_BIAS = Shader3D.propertyNameToID("s_DepthBias");
            Shader3D.DEPTH_BIAS_CONSTANT = Shader3D.propertyNameToID("s_DepthBiasConstant");
            Shader3D.DEPTH_BIAS_SLOPESCALE = Shader3D.propertyNameToID("s_DepthBiasSlopeScale");
            Shader3D.DEPTH_BIAS_CLAMP = Shader3D.propertyNameToID("s_DepthBiasClamp");
        }
        get renderQueue() {
            return this._renderQueue;
        }
        set renderQueue(value) {
            this._renderQueue = value;
            this._notifyOwnerElements();
        }
        _setOwner3DElement(element) {
            this.ownerElements.add(element);
            element.materialShaderData = this._shaderValues;
            element.materialRenderQueue = this.renderQueue;
            element.subShader = this._shader.getSubShaderAt(0);
            element.materialId = this.id;
        }
        _setOwner2DElement(element) {
            this.ownerElements.add(element);
            element.materialShaderData = this._shaderValues;
            element.subShader = this._shader.getSubShaderAt(0);
        }
        _removeOwnerElement(element) {
            this.ownerElements.delete(element);
        }
        _notifyOwnerElements() {
            this.ownerElements.forEach(element => {
                element.materialId ? this._setOwner3DElement(element) : this._setOwner2DElement(element);
            });
        }
        get shaderData() {
            return this._shaderValues;
        }
        get alphaTestValue() {
            return this._shaderValues.getNumber(Material.ALPHATESTVALUE);
        }
        set alphaTestValue(value) {
            this._shaderValues.setNumber(Material.ALPHATESTVALUE, value);
        }
        get alphaTest() {
            return this.shaderData.hasDefine(Material.SHADERDEFINE_ALPHATEST);
        }
        set alphaTest(value) {
            if (value)
                this._shaderValues.addDefine(Material.SHADERDEFINE_ALPHATEST);
            else
                this._shaderValues.removeDefine(Material.SHADERDEFINE_ALPHATEST);
        }
        addDefine(define) {
            this._shaderValues.addDefine(define);
        }
        removeDefine(define) {
            this._shaderValues.removeDefine(define);
        }
        setDefine(define, value) {
            if (value) {
                this._shaderValues.addDefine(define);
            }
            else {
                this._shaderValues.removeDefine(define);
            }
        }
        hasDefine(define) {
            return this._shaderValues.hasDefine(define);
        }
        get depthWrite() {
            return this._shaderValues.getBool(Shader3D.DEPTH_WRITE);
        }
        set depthWrite(value) {
            this._shaderValues.setBool(Shader3D.DEPTH_WRITE, value);
        }
        get cull() {
            return this._shaderValues.getInt(Shader3D.CULL);
        }
        set cull(value) {
            this._shaderValues.setInt(Shader3D.CULL, value);
        }
        get blend() {
            return this._shaderValues.getInt(Shader3D.BLEND);
        }
        set blend(value) {
            this._shaderValues.setInt(Shader3D.BLEND, value);
        }
        get blendSrc() {
            return this._shaderValues.getInt(Shader3D.BLEND_SRC);
        }
        set blendSrc(value) {
            this._shaderValues.setInt(Shader3D.BLEND_SRC, value);
        }
        get blendDst() {
            return this._shaderValues.getInt(Shader3D.BLEND_DST);
        }
        set blendDst(value) {
            this._shaderValues.setInt(Shader3D.BLEND_DST, value);
        }
        get blendSrcAlpha() {
            return this._shaderValues.getInt(Shader3D.BLEND_SRC_ALPHA);
        }
        set blendSrcAlpha(value) {
            this._shaderValues.setInt(Shader3D.BLEND_SRC_ALPHA, value);
        }
        get blendSrcRGB() {
            return this._shaderValues.getInt(Shader3D.BLEND_SRC_RGB);
        }
        set blendSrcRGB(value) {
            this._shaderValues.setInt(Shader3D.BLEND_SRC_RGB, value);
        }
        get blendDstRGB() {
            return this._shaderValues.getInt(Shader3D.BLEND_DST_RGB);
        }
        set blendDstRGB(value) {
            this._shaderValues.setInt(Shader3D.BLEND_DST_RGB, value);
        }
        get blendDstAlpha() {
            return this._shaderValues.getInt(Shader3D.BLEND_DST_ALPHA);
        }
        set blendDstAlpha(value) {
            this._shaderValues.setInt(Shader3D.BLEND_DST_ALPHA, value);
        }
        get blendEquation() {
            return this._shaderValues.getInt(Shader3D.BLEND_EQUATION);
        }
        set blendEquation(value) {
            this._shaderValues.setInt(Shader3D.BLEND_EQUATION, value);
        }
        get blendEquationRGB() {
            return this._shaderValues.getInt(Shader3D.BLEND_EQUATION_RGB);
        }
        set blendEquationRGB(value) {
            this._shaderValues.setInt(Shader3D.BLEND_EQUATION_RGB, value);
        }
        get blendEquationAlpha() {
            return this._shaderValues.getInt(Shader3D.BLEND_EQUATION_ALPHA);
        }
        set blendEquationAlpha(value) {
            this._shaderValues.setInt(Shader3D.BLEND_EQUATION_ALPHA, value);
        }
        get depthTest() {
            return this._shaderValues.getInt(Shader3D.DEPTH_TEST);
        }
        set depthTest(value) {
            this._shaderValues.setInt(Shader3D.DEPTH_TEST, value);
        }
        get stencilTest() {
            return this._shaderValues.getInt(Shader3D.STENCIL_TEST);
        }
        set stencilTest(value) {
            this._shaderValues.setInt(Shader3D.STENCIL_TEST, value);
        }
        get stencilWrite() {
            return this._shaderValues.getBool(Shader3D.STENCIL_WRITE);
        }
        set stencilWrite(value) {
            this._shaderValues.setBool(Shader3D.STENCIL_WRITE, value);
        }
        get stencilWriteMask() {
            return this._shaderValues.getInt(Shader3D.STENCIL_WRITE_MASK);
        }
        set stencilWriteMask(value) {
            this._shaderValues.setInt(Shader3D.STENCIL_WRITE_MASK, value);
        }
        get stencilReadMask() {
            return this._shaderValues.getInt(Shader3D.STENCIL_READ_MASK);
        }
        set stencilReadMask(value) {
            this._shaderValues.setInt(Shader3D.STENCIL_READ_MASK, value);
        }
        get stencilRef() {
            return this._shaderValues.getInt(Shader3D.STENCIL_Ref);
        }
        set stencilRef(value) {
            this._shaderValues.setInt(Shader3D.STENCIL_Ref, value);
        }
        get stencilOp() {
            return this._shaderValues.getVector3(Shader3D.STENCIL_Op);
        }
        set stencilOp(value) {
            this._shaderValues.setVector3(Shader3D.STENCIL_Op, value);
        }
        get depthBias() {
            return this._shaderValues.getBool(Shader3D.DEPTH_BIAS);
        }
        set depthBias(value) {
            this._shaderValues.setBool(Shader3D.DEPTH_BIAS, value);
        }
        get depthBiasConstant() {
            return this._shaderValues.getNumber(Shader3D.DEPTH_BIAS_CONSTANT);
        }
        set depthBiasConstant(value) {
            this._shaderValues.setNumber(Shader3D.DEPTH_BIAS_CONSTANT, value);
        }
        get dephtBiasSlopeScale() {
            return this._shaderValues.getNumber(Shader3D.DEPTH_BIAS_SLOPESCALE);
        }
        set dephtBiasSlopeScale(value) {
            this._shaderValues.setNumber(Shader3D.DEPTH_BIAS_SLOPESCALE, value);
        }
        get depthBiasClamp() {
            return this._shaderValues.getNumber(Shader3D.DEPTH_BIAS_CLAMP);
        }
        set depthBiasClamp(value) {
            this._shaderValues.setNumber(Shader3D.DEPTH_BIAS_CLAMP, value);
        }
        get MaterialProperty() {
            let propertyMap = {};
            var shaderValues = this._shaderValues.getData();
            for (let key in shaderValues) {
                propertyMap[LayaGL.renderEngine.propertyIDToName(parseInt(key))] = shaderValues[key];
            }
            return propertyMap;
        }
        get MaterialDefine() {
            let shaderDefineArray = new Array();
            let defineData = this._shaderValues.getDefineData();
            Shader3D._getNamesByDefineData(defineData, shaderDefineArray);
            return shaderDefineArray;
        }
        get materialRenderMode() {
            return this._matRenderNode;
        }
        set materialRenderMode(value) {
            this._matRenderNode = value;
            switch (value) {
                case exports.MaterialRenderMode.RENDERMODE_OPAQUE:
                    this.alphaTest = false;
                    this.renderQueue = Material.RENDERQUEUE_OPAQUE;
                    this.depthWrite = true;
                    this.blend = RenderState.BLEND_DISABLE;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    break;
                case exports.MaterialRenderMode.RENDERMODE_CUTOUT:
                    this.renderQueue = Material.RENDERQUEUE_ALPHATEST;
                    this.alphaTest = true;
                    this.depthWrite = true;
                    this.blend = RenderState.BLEND_DISABLE;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    break;
                case exports.MaterialRenderMode.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.blend = RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    break;
                case exports.MaterialRenderMode.RENDERMODE_ADDTIVE:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.blend = RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = RenderState.BLENDPARAM_ONE;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    this._shaderValues.addDefine(Material.SHADERDEFINE_ADDTIVEFOG);
                    break;
                case exports.MaterialRenderMode.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.blend = RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    this._shaderValues.removeDefine(Material.SHADERDEFINE_ADDTIVEFOG);
                    break;
                case exports.MaterialRenderMode.RENDERMODE_CUSTOME:
                    break;
                default:
                    console.warn(`Material : renderMode value error - (${value}).`);
                    break;
            }
        }
        constructor() {
            super();
            this.ownerElements = new Set();
            this._shaderValues = LayaGL.renderDeviceFactory.createShaderData(this);
            this.renderQueue = Material.RENDERQUEUE_OPAQUE;
            this._matRenderNode = 0;
            this.alphaTest = false;
            this.cull = RenderState.CULL_BACK;
            this.blend = RenderState.BLEND_DISABLE;
            this.blendSrc = RenderState.BLENDPARAM_ONE;
            this.blendDst = RenderState.BLENDPARAM_ZERO;
            this.blendSrcRGB = RenderState.BLENDPARAM_ONE;
            this.blendDstRGB = RenderState.BLENDPARAM_ZERO;
            this.blendSrcAlpha = RenderState.BLENDPARAM_ONE;
            this.blendDstAlpha = RenderState.BLENDPARAM_ZERO;
            this.blendEquation = RenderState.BLENDEQUATION_ADD;
            this.blendEquationRGB = RenderState.BLENDEQUATION_ADD;
            this.blendEquationAlpha = RenderState.BLENDEQUATION_ADD;
            this.depthTest = RenderState.DEPTHTEST_LEQUAL;
            this.depthWrite = true;
            this.stencilWriteMask = 0xFF;
            this.stencilReadMask = 0xFF;
            this.stencilRef = 1;
            this.stencilTest = RenderState.STENCILTEST_OFF;
            this.stencilWrite = false;
            this.stencilOp = new Vector3(RenderState.STENCILOP_KEEP, RenderState.STENCILOP_KEEP, RenderState.STENCILOP_REPLACE);
            this.depthBias = false;
            this.depthBiasConstant = 0.0;
            this.dephtBiasSlopeScale = 0.0;
            this.depthBiasClamp = 0.0;
            this.destroyedImmediately = Config.destroyResourceImmediatelyDefault;
        }
        _disposeResource() {
            this._shaderValues.destroy();
            this._shaderValues = null;
            this.ownerElements.clear();
        }
        get shader() {
            return this._shader;
        }
        effectiveProperty() {
            return this._shader.getSubShaderAt(0)._uniformMap;
        }
        setShaderName(name) {
            this._shader = Shader3D.find(name);
            if (!this._shader) {
                console.warn(`Material: unknown shader name '${name}'`);
                this._shader = Shader3D.find("BLINNPHONG");
            }
            this.shaderData.clearDefine();
            this.shaderData.clearData();
            let subShader = this._shader.getSubShaderAt(0);
            let defaultValue = subShader._uniformDefaultValue;
            let typeMap = subShader._uniformMap;
            this.applyUniformDefaultValue(typeMap, defaultValue);
            this._notifyOwnerElements();
        }
        applyUniformDefaultValue(uniformMap, defaultValue) {
            uniformMap.forEach((uniform, id) => {
                if (uniform.arrayLength <= 0) {
                    let type = uniform.uniformtype;
                    let uniformName = uniform.propertyName;
                    if (defaultValue && defaultValue[uniformName] != undefined) {
                        let value = defaultValue[uniformName];
                        this.setShaderData(uniformName, type, value);
                    }
                    else {
                        let value = ShaderDataDefaultValue(type);
                        if (value) {
                            this.setShaderData(uniformName, type, value);
                        }
                    }
                }
            });
        }
        getBoolByIndex(uniformIndex) {
            return this.shaderData.getBool(uniformIndex);
        }
        setBoolByIndex(uniformIndex, value) {
            this.shaderData.setBool(uniformIndex, value);
        }
        getBool(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getBoolByIndex(uniformIndex);
        }
        setBool(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setBoolByIndex(uniformIndex, value);
        }
        getFloatByIndex(uniformIndex) {
            return this.shaderData.getNumber(uniformIndex);
        }
        setFloatByIndex(uniformIndex, value) {
            this.shaderData.setNumber(uniformIndex, value);
        }
        getFloat(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getFloatByIndex(uniformIndex);
        }
        setFloat(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setFloatByIndex(uniformIndex, value);
        }
        getIntByIndex(uniformIndex) {
            return this.shaderData.getInt(uniformIndex);
        }
        setIntByIndex(uniformIndex, value) {
            this.shaderData.setInt(uniformIndex, value);
        }
        getInt(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getIntByIndex(uniformIndex);
        }
        setInt(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setIntByIndex(uniformIndex, value);
        }
        getVector2ByIndex(uniformIndex) {
            return this.shaderData.getVector2(uniformIndex);
        }
        setVector2ByIndex(uniformIndex, value) {
            this.shaderData.setVector2(uniformIndex, value);
        }
        getVector2(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getVector2ByIndex(uniformIndex);
        }
        setVector2(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setVector2ByIndex(uniformIndex, value);
        }
        getVector3ByIndex(uniformIndex) {
            return this.shaderData.getVector3(uniformIndex);
        }
        setVector3ByIndex(uniformIndex, value) {
            this.shaderData.setVector3(uniformIndex, value);
        }
        getVector3(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getVector3ByIndex(uniformIndex);
        }
        setVector3(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setVector3ByIndex(uniformIndex, value);
        }
        setVector4ByIndex(uniformIndex, value) {
            this.shaderData.setVector(uniformIndex, value);
        }
        getVector4ByIndex(uniformIndex) {
            return this.shaderData.getVector(uniformIndex);
        }
        setVector4(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setVector4ByIndex(uniformIndex, value);
        }
        getVector4(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getVector4ByIndex(uniformIndex);
        }
        getColorByIndex(uniformIndex) {
            return this.shaderData.getColor(uniformIndex);
        }
        setColorByIndex(uniformIndex, value) {
            this.shaderData.setColor(uniformIndex, value);
        }
        getColor(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.shaderData.getColor(uniformIndex);
        }
        setColor(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setColorByIndex(uniformIndex, value);
        }
        getMatrix4x4ByIndex(uniformIndex) {
            return this.shaderData.getMatrix4x4(uniformIndex);
        }
        setMatrix4x4ByIndex(uniformIndex, value) {
            this.shaderData.setMatrix4x4(uniformIndex, value);
        }
        getMatrix4x4(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getMatrix4x4ByIndex(uniformIndex);
        }
        setMatrix4x4(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setMatrix4x4ByIndex(uniformIndex, value);
        }
        getMatrix3x3ByIndex(index) {
            return this.shaderData.getMatrix3x3(index);
        }
        setMatrix3x3ByIndex(index, value) {
            this.shaderData.setMatrix3x3(index, value);
        }
        getMatrix3x3(name) {
            let index = Shader3D.propertyNameToID(name);
            return this.getMatrix3x3ByIndex(index);
        }
        setMatrix3x3(name, value) {
            let index = Shader3D.propertyNameToID(name);
            this.setMatrix3x3ByIndex(index, value);
        }
        setTextureByIndex(uniformIndex, texture) {
            if (LayaEnv.isConch) {
                this.shaderData.setTexture(uniformIndex, texture);
                if (texture && !texture._texture) {
                    texture.once(Event.READY, this, this.reSetTexture, [uniformIndex, texture]);
                }
            }
            else {
                this.shaderData.setTexture(uniformIndex, texture);
            }
        }
        reSetTexture(uniformIndex, texture) {
            this.setTextureByIndex(uniformIndex, texture);
        }
        getTextureByIndex(uniformIndex) {
            return this.shaderData.getTexture(uniformIndex);
        }
        setTexture(name, texture) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setTextureByIndex(uniformIndex, texture);
        }
        getTexture(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getTextureByIndex(uniformIndex);
        }
        getBufferByIndex(uniformIndex) {
            return this.shaderData.getBuffer(uniformIndex);
        }
        setBufferByIndex(uniformIndex, value) {
            this.shaderData.setBuffer(uniformIndex, value);
        }
        getBuffer(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getBufferByIndex(uniformIndex);
        }
        setBuffer(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setBufferByIndex(uniformIndex, value);
        }
        setShaderDataByIndex(uniformIndex, type, value) {
            this.shaderData.setShaderData(uniformIndex, type, value);
        }
        setShaderData(name, type, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setShaderDataByIndex(uniformIndex, type, value);
        }
        getShaderData(name, type) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getShaderDataByIndex(uniformIndex, type);
        }
        getShaderDataByIndex(uniformIndex, type) {
            return this._shaderValues.getShaderData(uniformIndex, type);
        }
        cloneTo(destObject) {
            destObject.name = this.name;
            destObject.renderQueue = this.renderQueue;
            destObject.setShaderName(this._shader._name);
            this._shaderValues.cloneTo(destObject._shaderValues);
        }
        clone() {
            var dest = new Material();
            this.cloneTo(dest);
            return dest;
        }
        checkType(type) {
            if (this._shader && this._shader.shaderType === exports.ShaderFeatureType.None)
                return true;
            let isVaild = this._shader && this._shader.shaderType == type;
            if (!isVaild) {
                console.warn("This Renderer expect Material shader type is " + exports.ShaderFeatureType[type] + ", but the Material shader type is " + exports.ShaderFeatureType[this._shader.shaderType] + ".");
            }
            return isVaild;
        }
        get _defineDatas() {
            return this._shaderValues.getDefineData();
        }
        oldparseEndEvent() {
        }
    }
    Material.RENDERQUEUE_OPAQUE = 2000;
    Material.RENDERQUEUE_ALPHATEST = 2450;
    Material.RENDERQUEUE_TRANSPARENT = 3000;

    class VertexMesh2D {
        static getVertexDeclaration(vertexFlags, compatible = true) {
            let verDecs = [];
            for (let i = 0, len = vertexFlags.length; i < len; i++) {
                let vertexFlag = vertexFlags[i];
                let verDec = VertexMesh2D._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")];
                if (!verDec) {
                    var subFlags = vertexFlag.split(",");
                    var offset = 0;
                    var elements = [];
                    for (let j = 0, n = subFlags.length; j < n; j++) {
                        var element;
                        switch (subFlags[j]) {
                            case "POSITION":
                                element = new VertexElement(offset, VertexElementFormat.Vector3, VertexMesh.MESH_POSITION0);
                                offset += 12;
                                break;
                            case "COLOR":
                                element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_COLOR0);
                                offset += 16;
                                break;
                            case "UV":
                                element = new VertexElement(offset, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE0);
                                offset += 8;
                                break;
                            case "BLENDWEIGHT":
                                element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDWEIGHT0);
                                offset += 16;
                                break;
                            case "BLENDINDICES":
                                if (compatible) {
                                    element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDINDICES0);
                                    offset += 16;
                                }
                                else {
                                    element = new VertexElement(offset, VertexElementFormat.Byte4, VertexMesh.MESH_BLENDINDICES0);
                                    offset += 4;
                                }
                                break;
                            default:
                                throw "VertexMesh: unknown vertex flag.";
                        }
                        elements.push(element);
                    }
                    verDec = new VertexDeclaration(offset, elements);
                    VertexMesh2D._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")] = verDec;
                }
                verDecs.push(verDec);
            }
            return verDecs;
        }
        static getMeshDefine(mesh, out) {
            out.length = 0;
            let vertexs = mesh._vertexBuffers;
            for (var i = 0, n = vertexs.length; i < n; i++) {
                let elements = vertexs[i].vertexDeclaration._vertexElements;
                for (const element of elements) {
                    switch (element.elementUsage) {
                        case VertexMesh.MESH_COLOR0:
                            out.push(Shader3D.getDefineByName("COLOR"));
                            break;
                        case VertexMesh.MESH_TEXTURECOORDINATE0:
                            out.push(Shader3D.getDefineByName("UV"));
                            break;
                    }
                }
            }
        }
    }
    VertexMesh2D._vertexDeclarationMap = {};
    class Mesh2D extends Resource {
        static createMesh2DByPrimitive(vbs, vbDeclaration, ib, ibFormat, submeshInfo, canRead = false) {
            let mesh2d = new Mesh2D();
            mesh2d.canRead = canRead;
            let vbArray = [];
            let vertices = [];
            for (var i = 0, n = vbs.length; i < n; i++) {
                let vbdata = vbs[i];
                let vertex = LayaGL.renderDeviceFactory.createVertexBuffer(exports.BufferUsage.Dynamic);
                vertex.vertexDeclaration = vbDeclaration[i];
                vertex.setDataLength(vbdata.buffer.byteLength);
                vertex.setData(vbdata.buffer, 0, 0, vbdata.buffer.byteLength);
                vbArray.push(vertex);
                vertices[i] = vbdata.buffer;
            }
            let indexBuffer = LayaGL.renderDeviceFactory.createIndexBuffer(exports.BufferUsage.Dynamic);
            indexBuffer._setIndexDataLength(ib.buffer.byteLength);
            indexBuffer._setIndexData(ib, 0);
            indexBuffer.indexType = ibFormat;
            mesh2d._setBuffers(vbArray, indexBuffer);
            let geometryArray = [];
            for (var i = 0; i < submeshInfo.length; i++) {
                let geometry = LayaGL.renderDeviceFactory.createRenderGeometryElement(exports.MeshTopology.Triangles, exports.DrawType.DrawElement);
                geometry.bufferState = mesh2d._bufferState;
                geometry.setDrawElemenParams(submeshInfo[i].length, submeshInfo[i].start);
                geometry.indexFormat = ibFormat;
                geometryArray.push(geometry);
            }
            mesh2d._setSubMeshes(geometryArray);
            if (canRead) {
                mesh2d._vertices = vertices;
                mesh2d._indices = ib;
            }
            return mesh2d;
        }
        get vertexBuffers() {
            return this._vertexBuffers;
        }
        get indexBuffer() {
            return this._indexBuffer;
        }
        get vertexCount() {
            return this._vertexCount;
        }
        get indexCount() {
            return this._indexBuffer.indexCount;
        }
        get subMeshCount() {
            return this._subMeshes.length;
        }
        get indexFormat() {
            return this._indexFormat;
        }
        constructor() {
            super();
            this._instanceBufferStateType = 0;
            this._vertexBuffers = null;
            this._indexBuffer = null;
            this._vertexCount = 0;
            this._indexFormat = exports.IndexFormat.UInt16;
            this.canRead = false;
            this._vertices = null;
            this._indices = null;
            this._bufferState = LayaGL.renderDeviceFactory.createBufferState();
            this._subMeshes = [];
            this.destroyedImmediately = Config.destroyResourceImmediatelyDefault;
        }
        _disposeResource() {
            for (let i = 0, n = this._subMeshes.length; i < n; i++)
                this._subMeshes[i].destroy();
            for (let i = 0, n = this._vertexBuffers.length; i < n; i++)
                this._vertexBuffers[i].destroy();
            this._indexBuffer && this._indexBuffer.destroy();
            this._bufferState.destroy();
            this._instanceBufferState && this._instanceBufferState.destroy();
            this._instanceWorldVertexBuffer && this._instanceWorldVertexBuffer.destroy();
            this._instanceSimpleAniVertexBuffer && this._instanceSimpleAniVertexBuffer.destroy();
            this._setCPUMemory(0);
            this._setGPUMemory(0);
            this._bufferState = null;
            this._instanceBufferState = null;
            this._vertexBuffers = null;
            this._indexBuffer = null;
            this._subMeshes = null;
            this._indexBuffer = null;
        }
        _setSubMeshes(subMeshes) {
            this._subMeshes = subMeshes;
        }
        _setBuffers(vertexBuffers, indexBuffer) {
            var bufferState = this._bufferState;
            this._vertexBuffers = vertexBuffers;
            this._indexBuffer = indexBuffer;
            bufferState.applyState(vertexBuffers, indexBuffer);
        }
        getSubMesh(index) {
            return this._subMeshes[index];
        }
        setVertices(vertices) {
            for (let i = 0, len = vertices.length; i < len; i++) {
                if (vertices[i] && this._vertexBuffers[i]) {
                    this._vertexBuffers[i].setData(vertices[i], 0, 0, vertices[i].byteLength);
                }
            }
            if (this.canRead) {
                this._vertices = vertices;
            }
        }
        getVertices() {
            if (!this.canRead || !this._vertices) {
                throw new Error("Can't getVertices without the canRead flag, or if the canRead flag is false before setVertices!");
            }
            else {
                return this._vertices;
            }
        }
        setVertexByIndex(data, index, bufferOffset = 0) {
            this._vertexBuffers[index].setData(data, bufferOffset, 0, data.byteLength);
        }
        setIndices(indices) {
            var format;
            if (indices instanceof Uint32Array)
                format = exports.IndexFormat.UInt32;
            else if (indices instanceof Uint16Array)
                format = exports.IndexFormat.UInt16;
            else if (indices instanceof Uint8Array)
                format = exports.IndexFormat.UInt8;
            let indexBuffer = this._indexBuffer;
            if (indexBuffer.indexCount < indices.length) {
                console.error("Mesh2D:set indices buffer large than ori indices");
            }
            var iscreateBuffer = false;
            if (this._indexFormat !== format || indexBuffer.indexCount < indices.length) {
                indexBuffer.destroy();
                iscreateBuffer = true;
                this._indexBuffer = indexBuffer = LayaGL.renderDeviceFactory.createIndexBuffer(exports.BufferUsage.Static);
                this._indexBuffer._setIndexDataLength(indices.byteLength);
                indexBuffer.indexCount = indexBuffer.indexCount;
                indexBuffer.indexType = format;
            }
            indexBuffer._setIndexData(indices, 0);
            if (iscreateBuffer) {
                this._bufferState.applyState(this._bufferState._vertexBuffers, indexBuffer);
            }
            if (this.canRead) {
                this._indices = indices;
            }
        }
        getIndices() {
            if (!this.canRead || !this._indices) {
                throw new Error("Can't getIndices without the canRead flag, or if the canRead flag is false before setIndices!");
            }
            else {
                return this._indices;
            }
        }
    }

    class Mesh2DRender extends BaseRenderNode2D {
        static __init__() {
            if (Mesh2DRender.mesh2DDefaultMaterial)
                return;
            Mesh2DRender.mesh2DDefaultMaterial = new Material();
            Mesh2DRender.mesh2DDefaultMaterial.setShaderName("baseRender2D");
            Mesh2DRender.mesh2DDefaultMaterial.setBoolByIndex(Shader3D.DEPTH_WRITE, false);
            Mesh2DRender.mesh2DDefaultMaterial.setIntByIndex(Shader3D.DEPTH_TEST, RenderState.DEPTHTEST_OFF);
            Mesh2DRender.mesh2DDefaultMaterial.setIntByIndex(Shader3D.BLEND, RenderState.BLEND_ENABLE_ALL);
            Mesh2DRender.mesh2DDefaultMaterial.setIntByIndex(Shader3D.BLEND_EQUATION, RenderState.BLENDEQUATION_ADD);
            Mesh2DRender.mesh2DDefaultMaterial.setIntByIndex(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
            Mesh2DRender.mesh2DDefaultMaterial.setIntByIndex(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
            Mesh2DRender.mesh2DDefaultMaterial.setFloatByIndex(ShaderDefines2D.UNIFORM_VERTALPHA, 1.0);
            Mesh2DRender.mesh2DDefaultMaterial.setIntByIndex(Shader3D.CULL, RenderState.CULL_NONE);
            Mesh2DRender.mesh2DDefaultMaterial.lock = true;
        }
        _createRenderHandle() {
            return LayaGL.render2DRenderPassFactory.createMesh2DRenderDataHandle();
        }
        _initDefaultRenderData() {
            this.color = new Color();
            this.tilingOffset = new Vector4(0, 0, 1, 1);
            this.texture = null;
        }
        _isMaterialVaild(value) {
            return value.checkType(exports.ShaderFeatureType.D2_BaseRenderNode2D);
        }
        renderUpdate(context) {
            this._updateLight();
        }
        set sharedMesh(value) {
            if (this._sharedMesh == value)
                return;
            let meshArrayDefine = new Array();
            if (this._sharedMesh) {
                VertexMesh2D.getMeshDefine(this._sharedMesh, meshArrayDefine);
                for (var i = 0, n = meshArrayDefine.length; i < n; i++)
                    this._spriteShaderData.removeDefine(meshArrayDefine[i]);
                this._sharedMesh._removeReference();
            }
            meshArrayDefine.length = 0;
            if (value) {
                if (!value._vertexBuffers) {
                    value = null;
                    console.warn("not a 2D mesh");
                }
                else {
                    VertexMesh2D.getMeshDefine(value, meshArrayDefine);
                    for (var i = 0, n = meshArrayDefine.length; i < n; i++)
                        this._spriteShaderData.addDefine(meshArrayDefine[i]);
                    value._addReference();
                }
            }
            this._sharedMesh = value;
            this._changeMesh();
        }
        get sharedMesh() {
            return this._sharedMesh;
        }
        set color(value) {
            this._renderHandle.baseColor = value;
        }
        get color() {
            return this._renderHandle.baseColor;
        }
        set tilingOffset(value) {
            this._renderHandle.tilingOffset = value;
        }
        get tilingOffset() {
            return this._renderHandle.tilingOffset;
        }
        set texture(value) {
            this._renderHandle.baseTexture = value;
        }
        get texture() {
            return this._renderHandle.baseTexture;
        }
        set normalTexture(value) {
            this._renderHandle.normal2DTexture = value;
        }
        get normalTexture() {
            return this._renderHandle.normal2DTexture;
        }
        set normalStrength(value) {
            this._renderHandle.normal2DStrength = value;
        }
        get normalStrength() {
            return this._renderHandle.normal2DStrength;
        }
        set sharedMaterial(value) {
            super.sharedMaterial = value;
            this._changeMesh();
        }
        get sharedMaterial() {
            return this._materials[0];
        }
        _changeMesh() {
            let submeshNum = this._sharedMesh ? this._sharedMesh.subMeshCount : 0;
            if (submeshNum < this._renderElements.length) {
                for (var i = this._renderElements.length, n = submeshNum; n < i; i--) {
                    let element = this._renderElements[i - 1];
                    element.destroy();
                }
                this._renderElements.length = submeshNum;
            }
            for (var i = 0, n = submeshNum; i < n; i++) {
                let element = this._renderElements[i];
                if (!element)
                    element = this._renderElements[i] = LayaGL.render2DRenderPassFactory.createRenderElement2D();
                element.geometry = this._sharedMesh.getSubMesh(i);
                element.value2DShaderData = this._spriteShaderData;
                BaseRenderNode2D._setRenderElement2DMaterial(element, this._materials[i] ? this._materials[i] : Mesh2DRender.mesh2DDefaultMaterial);
                element.renderStateIsBySprite = false;
                element.nodeCommonMap = this._getcommonUniformMap();
                element.owner = this._struct;
            }
            this._struct.renderElements = this._renderElements;
        }
        constructor() {
            super();
            this._renderElements = [];
            this._materials = [];
        }
    }

    class Command2D {
        constructor() {
            this._commandBuffer = null;
        }
        recover() {
            this._commandBuffer = null;
            this._context = null;
        }
        destroy() {
            this._commandBuffer = null;
            this._context = null;
        }
    }

    class Blit2DCMD extends Command2D {
        static __initBlitShader__() {
            let blitvs = `
        #define SHADER_NAME Blit2DVS

        varying vec2 v_Texcoord0;

        void main()
        {
            gl_Position = vec4(u_OffsetScale.x * 2.0 - 1.0 + (a_PositionTexcoord.x + 1.0) * u_OffsetScale.z, (1.0 - ((u_OffsetScale.y * 2.0 - 1.0 + (-a_PositionTexcoord.y + 1.0) * u_OffsetScale.w) + 1.0) / 2.0) * 2.0 - 1.0, 0.0, 1.0);

            v_Texcoord0 = a_PositionTexcoord.zw;

            #ifdef INVERTY
            gl_Position.y = -gl_Position.y;
            #endif
        }
        `;
            let blitfs = `
        #define SHADER_NAME Blit2DFS

        #include "Color.glsl";

        varying vec2 v_Texcoord0;

        void main()
        {
            vec4 mainColor = texture2D(u_MainTex, v_Texcoord0);
            #ifdef Gamma_u_MainTex
            mainColor = gammaToLinear(mainColor);
            #endif // Gamma_u_AlbedoTexture
            gl_FragColor = mainColor;
            gl_FragColor = outputTransform(gl_FragColor);
        }
        `;
            let attributeMap = {
                "a_PositionTexcoord": [0, exports.ShaderDataType.Vector4]
            };
            let uniformMap = {
                "u_OffsetScale": exports.ShaderDataType.Vector4,
                "u_MainTex": exports.ShaderDataType.Texture2D,
                "u_MainTex_TexelSize": exports.ShaderDataType.Vector4,
            };
            let shader = Shader3D.add("Blit2DCMD");
            shader.shaderType = exports.ShaderFeatureType.PostProcess;
            let subShader = new SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            let blitPass = subShader.addShaderPass(blitvs, blitfs);
            blitPass.statefirst = true;
            blitPass.renderState.depthWrite = false;
            blitPass.renderState.depthTest = RenderState.DEPTHTEST_OFF;
            blitPass.renderState.blend = RenderState.BLEND_ENABLE_ALL;
            blitPass.renderState.blendEquation = RenderState.BLENDEQUATION_ADD;
            blitPass.renderState.srcBlend = RenderState.BLENDPARAM_ONE;
            blitPass.renderState.dstBlend = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
            blitPass.renderState.cull = RenderState.CULL_NONE;
        }
        static __initGeometryElement__() {
            let _vertices = new Float32Array([
                1, 1, 1, 1,
                1, -1, 1, 0,
                -1, 1, 0, 1,
                -1, -1, 0, 0
            ]);
            let vertexDec = new VertexDeclaration(16, [new VertexElement(0, VertexElementFormat.Vector4, 0)]);
            let vertex = LayaGL.renderDeviceFactory.createVertexBuffer(exports.BufferUsage.Dynamic);
            vertex.vertexDeclaration = vertexDec;
            vertex.setDataLength(_vertices.buffer.byteLength);
            vertex.setData(_vertices.buffer, 0, 0, _vertices.buffer.byteLength);
            let bufferState = LayaGL.renderDeviceFactory.createBufferState();
            bufferState.applyState([vertex], null);
            let geometry = Blit2DCMD.QuadGeometry = LayaGL.renderDeviceFactory.createRenderGeometryElement(exports.MeshTopology.TriangleStrip, exports.DrawType.DrawArray);
            geometry.setDrawArrayParams(0, 4);
            geometry.bufferState = bufferState;
            Blit2DCMD.__initInvertGeometryElement__();
        }
        static __initInvertGeometryElement__() {
            let _vertices = new Float32Array([
                1, 1, 1, 0,
                1, -1, 1, 1,
                -1, 1, 0, 0,
                -1, -1, 0, 1
            ]);
            let vertexDec = new VertexDeclaration(16, [new VertexElement(0, VertexElementFormat.Vector4, 0)]);
            let vertex = LayaGL.renderDeviceFactory.createVertexBuffer(exports.BufferUsage.Dynamic);
            vertex.vertexDeclaration = vertexDec;
            vertex.setDataLength(_vertices.buffer.byteLength);
            vertex.setData(_vertices.buffer, 0, 0, _vertices.buffer.byteLength);
            let bufferState = LayaGL.renderDeviceFactory.createBufferState();
            bufferState.applyState([vertex], null);
            let geometry = Blit2DCMD.InvertQuadGeometry = LayaGL.renderDeviceFactory.createRenderGeometryElement(exports.MeshTopology.TriangleStrip, exports.DrawType.DrawArray);
            geometry.setDrawArrayParams(0, 4);
            geometry.bufferState = bufferState;
        }
        static __init__() {
            Blit2DCMD.__initBlitShader__();
            Blit2DCMD.__initGeometryElement__();
            Blit2DCMD._blitShaderData = LayaGL.renderDeviceFactory.createShaderData();
            Blit2DCMD._defaultShader = Shader3D.find("Blit2DCMD");
        }
        static create(source, dest, offsetScale = null, shader = null, shaderData = null) {
            if (!Blit2DCMD._blitShaderData)
                Blit2DCMD.__init__();
            let cmd = Blit2DCMD._pool.take();
            cmd.source = source;
            cmd.dest = dest;
            cmd.offsetScale = offsetScale;
            cmd.setshader(shader, shaderData);
            return cmd;
        }
        constructor() {
            super();
            this._source = null;
            this._dest = null;
            this._offsetScale = new Vector4();
            this._shader = null;
            this._shaderData = null;
            this._renderElement = LayaGL.render2DRenderPassFactory.createRenderElement2D();
            this._blitQuadCMDData = LayaGL.render2DRenderPassFactory.createBlit2DQuadCMDData();
            this._blitQuadCMDData.element = this._renderElement;
            this._renderElement.geometry = Blit2DCMD.QuadGeometry;
            this._renderElement.nodeCommonMap = null;
            this._renderElement.renderStateIsBySprite = false;
        }
        get offsetScale() {
            return this._offsetScale;
        }
        set offsetScale(value) {
            value ? value.cloneTo(this._offsetScale) : Blit2DCMD._defaultOffsetScale.cloneTo(this._offsetScale);
            this._blitQuadCMDData.offsetScale = this._offsetScale;
        }
        get source() {
            return this._source;
        }
        set source(value) {
            this._source = value;
            this._blitQuadCMDData.source = value ? value._texture : Texture2D.blackTexture._texture;
        }
        get dest() {
            return this._dest;
        }
        set dest(value) {
            this._dest = value;
            this._blitQuadCMDData.dest = value ? value._renderTarget : null;
        }
        set shaderData(value) {
            this._shaderData = value || Blit2DCMD._blitShaderData;
            this._renderElement.materialShaderData = this._shaderData;
        }
        getRenderCMD() {
            return this._blitQuadCMDData;
        }
        setshader(shader, shaderData) {
            this._shader = shader || Blit2DCMD._defaultShader;
            this.shaderData = shaderData;
            this._renderElement.subShader = this._shader.getSubShaderAt(0);
        }
        destroy() {
            this._commandBuffer = null;
            this._context = null;
        }
        recover() {
            super.recover();
            Blit2DCMD._pool.recover(this);
        }
    }
    Blit2DCMD._defaultOffsetScale = new Vector4(0, 0, 1, 1);
    Blit2DCMD._pool = Pool.createPool(Blit2DCMD);

    class DrawMesh2DCMD extends Command2D {
        static create(mesh, mat, texture, color, material) {
            let cmd = DrawMesh2DCMD._pool.take();
            cmd.mesh = mesh;
            cmd.material = material || Mesh2DRender.mesh2DDefaultMaterial;
            cmd.texture = texture;
            cmd.color = color;
            cmd._setMatrix(mat);
            return cmd;
        }
        constructor() {
            super();
            this._renderElements = [];
            this._renderColor = new Color(1, 1, 1, 1);
            this._drawElementData = LayaGL.render2DRenderPassFactory.createDraw2DElementCMDData();
            this._shaderData = LayaGL.renderDeviceFactory.createShaderData();
            this._shaderData.addDefine(BaseRenderNode2D.SHADERDEFINE_BASERENDER2D);
            let temp = Vector4.TEMP.setValue(0, 0, 0, 0);
            this._shaderData.setVector(ShaderDefines2D.UNIFORM_CLIPMATPOS, temp);
            temp.x = temp.w = Const.MAX_CLIP_SIZE;
            this._shaderData.setVector(ShaderDefines2D.UNIFORM_CLIPMATDIR, temp);
            this._needUpdateElement = true;
            this._matrix = new Matrix();
        }
        _setMatrix(value) {
            value ? value.copyTo(this._matrix) : Matrix.EMPTY.copyTo(this._matrix);
            let mat = this._matrix;
            let vec3 = Vector3.TEMP;
            vec3.x = mat.a;
            vec3.y = mat.c;
            vec3.z = mat.tx;
            this._shaderData.setVector3(ShaderDefines2D.UNIFORM_NMATRIX_0, vec3);
            vec3.x = mat.b;
            vec3.y = mat.d;
            vec3.z = mat.ty;
            this._shaderData.setVector3(ShaderDefines2D.UNIFORM_NMATRIX_1, vec3);
        }
        set material(value) {
            if (value == this.material)
                return;
            if (!value)
                value = Mesh2DRender.mesh2DDefaultMaterial;
            this._material = value;
            this._needUpdateElement = true;
        }
        get material() {
            return this._material;
        }
        set mesh(value) {
            if (value == this.mesh)
                return;
            if (this._mesh) {
                let defines = [];
                VertexMesh2D.getMeshDefine(this._mesh, defines);
                for (var i = 0, n = defines.length; i < n; i++)
                    this._shaderData.removeDefine(defines[i]);
            }
            if (value) {
                let defines = [];
                VertexMesh2D.getMeshDefine(value, defines);
                for (var i = 0, n = defines.length; i < n; i++)
                    this._shaderData.addDefine(defines[i]);
            }
            this._mesh = value;
            this._needUpdateElement = true;
        }
        get mesh() {
            return this._mesh;
        }
        set texture(value) {
            value = value ? value : Texture2D.whiteTexture;
            if (value.gammaCorrection != 1) {
                this._shaderData.addDefine(ShaderDefines2D.GAMMATEXTURE);
            }
            else {
                this._shaderData.removeDefine(ShaderDefines2D.GAMMATEXTURE);
            }
            this._texture = value;
            this._shaderData.setTexture(BaseRenderNode2D.BASERENDER2DTEXTURE, value);
        }
        get texture() {
            return this._texture;
        }
        set color(value) {
            this._color = value;
            let a = value.a;
            let renderColor = this._renderColor;
            renderColor.setValue(value.r * a, value.g * a, value.b * a, a);
            this._shaderData.setColor(BaseRenderNode2D.BASERENDER2DCOLOR, renderColor);
        }
        get color() {
            return this._color;
        }
        getRenderCMD() {
            return this._drawElementData;
        }
        run() {
            if (this._needUpdateElement) {
                let elementLength = this._renderElements.length;
                let subMeshCount = this._mesh.subMeshCount;
                let length = Math.max(elementLength, subMeshCount);
                for (let i = 0; i < length; i++) {
                    let subMesh = this._mesh.getSubMesh(i);
                    let element = this._renderElements[i];
                    if (subMesh) {
                        if (!element) {
                            element = this._renderElements[i] = LayaGL.render2DRenderPassFactory.createRenderElement2D();
                        }
                        element.nodeCommonMap = ["BaseRender2D"];
                        element.geometry = subMesh;
                        element.renderStateIsBySprite = false;
                        element.value2DShaderData = this._shaderData;
                        element.materialShaderData = this._material.shaderData;
                        element.subShader = this._material._shader.getSubShaderAt(0);
                    }
                    else {
                        element.destroy();
                    }
                }
                this._renderElements.length = length;
                this._drawElementData.setRenderelements(this._renderElements);
                this._needUpdateElement = false;
            }
        }
        recover() {
            DrawMesh2DCMD._pool.recover(this);
            super.recover();
            this.material = null;
            this.texture = null;
            this.mesh = null;
        }
        destroy() {
            super.destroy();
            this._shaderData.destroy();
            this._shaderData = null;
            this._mesh = null;
            this._material = null;
        }
    }
    DrawMesh2DCMD._pool = Pool.createPool(DrawMesh2DCMD);

    class DrawRenderElement2DCMD extends Command2D {
        static create(element, mat = null) {
            let cmd = DrawRenderElement2DCMD._pool.take();
            cmd.renderElement = element;
            cmd._setMatrix(mat);
            return cmd;
        }
        get renderElement() {
            return this._renderElement;
        }
        set renderElement(value) {
            this._renderElement = value;
            this._drawElementCMDData.setRenderelements([this._renderElement]);
        }
        constructor() {
            super();
            this._drawElementCMDData = LayaGL.render2DRenderPassFactory.createDraw2DElementCMDData();
        }
        _setMatrix(value) {
            value ? (this._matreix = value.clone()) : (this._matreix = null);
            if (this._matreix && this.renderElement.nodeCommonMap && this.renderElement.nodeCommonMap.indexOf("BaseRender2D") != -1) {
                let vec3 = Vector3.TEMP;
                vec3.x = this._matreix.a;
                vec3.y = this._matreix.c;
                vec3.z = this._matreix.tx;
                this._renderElement.value2DShaderData.setVector3(ShaderDefines2D.UNIFORM_NMATRIX_0, vec3);
                vec3.x = this._matreix.b;
                vec3.y = this._matreix.d;
                vec3.z = this._matreix.ty;
                this._renderElement.value2DShaderData.setVector3(ShaderDefines2D.UNIFORM_NMATRIX_1, vec3);
            }
        }
        run() {
        }
        recover() {
            super.recover();
            DrawRenderElement2DCMD._pool.recover(this);
        }
        getRenderCMD() {
            return this._drawElementCMDData;
        }
        destroy() {
            this._renderElement = null;
            this._drawElementCMDData = null;
        }
    }
    DrawRenderElement2DCMD._pool = Pool.createPool(DrawRenderElement2DCMD);

    class Set2DRTCMD extends Command2D {
        static create(renderTexture, clearColor, colorValue, renderInvertY = true) {
            let cmd = Set2DRTCMD._pool.take();
            cmd.renderTexture = renderTexture;
            cmd._setRenderTargetCMD.clearColor = clearColor;
            cmd._setRenderTargetCMD.clearColorValue = colorValue;
            cmd._setRenderTargetCMD.invertY = renderInvertY;
            return cmd;
        }
        get renderTexture() {
            return this._renderTexture;
        }
        set renderTexture(value) {
            this._renderTexture = value;
            if (value) {
                this._setRenderTargetCMD.size.setValue(value.width, value.height);
                this._setRenderTargetCMD.rt = value._renderTarget;
            }
            else {
                this._setRenderTargetCMD.size.setValue(RenderState2D.width, RenderState2D.height);
                this._setRenderTargetCMD.rt = null;
            }
        }
        constructor() {
            super();
            this._renderTexture = null;
            this._setRenderTargetCMD = LayaGL.render2DRenderPassFactory.createSetRendertarget2DCMD();
        }
        run() {
        }
        getRenderCMD() {
            return this._setRenderTargetCMD;
        }
        recover() {
            Set2DRTCMD._pool.recover(this);
            this._renderTexture = null;
        }
    }
    Set2DRTCMD._pool = Pool.createPool(Set2DRTCMD);

    class Set2DShaderDataCMD extends Command2D {
        static create(shaderData, nameID, value, shaderDataType) {
            let cmd = Set2DShaderDataCMD._pool.take();
            cmd.setDest(shaderData);
            cmd._setRenderDataCMD.propertyID = nameID;
            cmd._setRenderDataCMD.dataType = shaderDataType;
            cmd._setRenderDataCMD.value = value;
            return cmd;
        }
        constructor() {
            super();
            this._globalMode = false;
            this._setRenderDataCMD = LayaGL.render2DRenderPassFactory.createSetRenderDataCMD();
        }
        getRenderCMD() {
            return this._setRenderDataCMD;
        }
        setDest(value) {
            this._setRenderDataCMD.dest = value;
        }
        recover() {
            Set2DShaderDataCMD._pool.recover(this);
            this._globalMode = false;
        }
    }
    Set2DShaderDataCMD._pool = Pool.createPool(Set2DShaderDataCMD);
    class Set2DDefineCMD extends Command2D {
        static create(shaderData, define, addDefine) {
            let cmd = Set2DDefineCMD._pool.take();
            cmd.setDest(shaderData);
            cmd._setRenderDefineCMD.add = addDefine;
            cmd._setRenderDefineCMD.define = define;
            return cmd;
        }
        constructor() {
            super();
            this._globalMode = false;
            this._setRenderDefineCMD = LayaGL.render2DRenderPassFactory.createSetShaderDefineCMD();
        }
        setDest(value) {
            this._setRenderDefineCMD.dest = value;
        }
        getRenderCMD() {
            return this._setRenderDefineCMD;
        }
        recover() {
            Set2DDefineCMD._pool.recover(this);
            this._globalMode = false;
        }
    }
    Set2DDefineCMD._pool = Pool.createPool(Set2DDefineCMD);

    class CommandBuffer2D {
        constructor(name) {
            this._scene = null;
            this._renderCMDs = [];
            this.cacheData = {};
            this._name = name;
            this.shaderData = LayaGL.renderDeviceFactory.createShaderData();
            this._context = Render2DProcessor.rendercontext2D;
            this._commands = [];
        }
        getName() {
            return this._name;
        }
        _cacheContextState() {
            this.cacheData.rt = this._context.getRenderTarget();
            this.cacheData.pipeline = this._context.pipelineMode;
            this.cacheData.invertY = this._context.invertY;
        }
        _recoverContextState() {
            this._context.setRenderTarget(this.cacheData.rt, false, Color.BLACK);
            this._context.pipelineMode = this.cacheData.pipeline;
            this._context.invertY = this.cacheData.invertY;
        }
        apply(render = true, recoverContextStat = true) {
            this.shaderData.clearData();
            let lastPass = this._context.passData;
            if (lastPass && lastPass.getDefineData()) {
                lastPass.cloneTo(this.shaderData);
            }
            else {
                this.shaderData.setVector2(ShaderDefines2D.UNIFORM_SIZE, Vector2.TEMP.setValue(RenderState2D.width, RenderState2D.height));
            }
            this._context.passData = this.shaderData;
            recoverContextStat && this._cacheContextState();
            for (var i = 0, n = this._commands.length; i < n; i++) {
                let cmd = this._commands[i];
                cmd.run && cmd.run();
            }
            render && this._context.runCMDList(this._renderCMDs);
            this._context.passData = lastPass;
            recoverContextStat && this._recoverContextState();
        }
        applyOne(recoverContextStat = true) {
            recoverContextStat && this._cacheContextState();
            if (this._commands.length) {
                var cmd = this._commands.shift();
                cmd.run && cmd.run();
                cmd.getRenderCMD && this._context.runOneCMD(this._renderCMDs.shift());
                cmd.recover();
            }
            recoverContextStat && this._recoverContextState();
            return this._commands.length > 0;
        }
        clear(recover = true) {
            if (recover)
                for (var i = 0, n = this._commands.length; i < n; i++)
                    this._commands[i].recover();
            this._commands.length = 0;
            this._renderCMDs.length = 0;
        }
        getCommandsSize() {
            return this._commands.length;
        }
        setShaderDataValue(shaderData, nameID, dataType, value) {
            if (!checkShaderDataValueLegal(value, dataType))
                return;
            let cmd = Set2DShaderDataCMD.create(shaderData, nameID, value, dataType);
            cmd._globalMode = false;
            this._commands.push(cmd);
            cmd._commandBuffer = this;
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setGlobalShaderDataValue(nameID, dataType, value) {
            if (!checkShaderDataValueLegal(value, dataType))
                return;
            if (!this._scene || (!this._scene._specialManager)) {
                return;
            }
            let cmd = Set2DShaderDataCMD.create(this._scene._specialManager._shaderData, nameID, value, dataType);
            cmd._globalMode = true;
            this._commands.push(cmd);
            cmd._commandBuffer = this;
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setShaderDefine(shaderData, define, value) {
            let cmd = Set2DDefineCMD.create(shaderData, define, value);
            cmd._globalMode = false;
            this._commands.push(cmd);
            cmd._commandBuffer = this;
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        blitTextureQuad(source, dest, offsetScale, shader, shaderData) {
            let cmd = Blit2DCMD.create(source, dest, offsetScale, shader, shaderData);
            this._commands.push(cmd);
            cmd._commandBuffer = this;
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        blitTextureBlur(source, dest, blurParams) {
        }
        setRenderTarget(renderTexture, clearColor, colorValue = Color.BLACK, invertY = true) {
            let cmd = Set2DRTCMD.create(renderTexture, clearColor, colorValue, invertY);
            this._commands.push(cmd);
            cmd._commandBuffer = this;
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        drawRenderElement(renderelement, mat) {
            let cmd = DrawRenderElement2DCMD.create(renderelement, mat);
            this._commands.push(cmd);
            cmd._commandBuffer = this;
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        drawMesh(mesh, mat, meshTexture, color, material) {
            let cmd = DrawMesh2DCMD.create(mesh, mat, meshTexture || Texture2D.whiteTexture, color || Color.WHITE, material || Mesh2DRender.mesh2DDefaultMaterial);
            this._commands.push(cmd);
            cmd._commandBuffer = this;
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        drawQuad() {
        }
        drawLine() {
        }
        addCacheCommand(cmd) {
            if (this._scene) {
                if (cmd instanceof Set2DShaderDataCMD) {
                    if (cmd._commandBuffer)
                        cmd.setDest(this._scene._specialManager._shaderData);
                }
                if (cmd instanceof Set2DDefineCMD) {
                    if (cmd._commandBuffer)
                        cmd.setDest(this._scene._specialManager._shaderData);
                }
            }
            this._commands.push(cmd);
            cmd._commandBuffer = this;
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
    }

    class PostProcess2D extends EventDispatcher {
        static init() {
            Effect2DShaderInit.colorEffect2DShaderInit();
            Effect2DShaderInit.blurEffect2DShaderInit();
            Effect2DShaderInit.glow2DShaderInit();
        }
        get enabled() {
            return this._enabled;
        }
        set enabled(value) {
            if (this._enabled != value) {
                this._enabled = value;
                this._context.command.clear(true);
                this._onChangeRender();
            }
        }
        constructor() {
            super();
            this._effects = [];
            this._enabled = true;
            this._hasCleanRT = false;
            this._context = new PostProcessRenderContext2D();
            this._context.compositeShaderData = LayaGL.renderDeviceFactory.createShaderData(null);
            this._context.command = new CommandBuffer2D();
        }
        get owner() {
            return this._owner;
        }
        set owner(value) {
            if (this._owner) {
                this._owner._renderType &= ~SpriteConst.POSTPROCESS;
            }
            this._owner = value;
            if (this._owner) {
                if (this._effects.length > 0 && this._enabled)
                    this._owner._renderType |= SpriteConst.POSTPROCESS;
            }
        }
        _checkEnabled() {
            if (this._effects.length === 0 || !this._enabled)
                return false;
            for (let i = 0; i < this._effects.length; i++) {
                if (this._effects[i].active)
                    return true;
            }
            return false;
        }
        _onChangeRender() {
            if (this._owner) {
                if (this._checkEnabled()) {
                    this._owner._renderType |= SpriteConst.POSTPROCESS;
                }
                else {
                    this._owner._renderType &= ~SpriteConst.POSTPROCESS;
                }
                this._owner.setSubpassFlag(exports.SubPassFlag.PostProcess);
                this._owner.repaint(exports.RepaintFlag.Graphics);
            }
        }
        getEffect(classReg) {
            return this._effects.find(effect => effect instanceof classReg) || null;
        }
        setResource(value) {
            this._context.source = value;
        }
        getDestRT() {
            return this._context.destination;
        }
        get effects() {
            return this._effects;
        }
        set effects(value) {
            this._effects.filter(e => !value.includes(e)).forEach(effect => effect.destroy());
            this._effects.length = 0;
            for (let i = 0, n = value.length; i < n; i++) {
                if (value[i])
                    this.addEffect(value[i]);
            }
            this._onChangeRender();
        }
        addEffect(effect) {
            if (effect.destroyed) {
                console.error("the target effect is destroyed", effect);
                return null;
            }
            if (effect.singleton && this.getEffect(effect.constructor)) {
                console.error("the target effect is a singleton", effect);
                return null;
            }
            this._effects.push(effect);
            effect.effectInit(this);
            this._onChangeRender();
            return effect;
        }
        removeEffect(effect) {
            let index = this._effects.indexOf(effect);
            if (index !== -1) {
                this._effects.splice(index, 1);
                effect.destroy();
                this._onChangeRender();
            }
        }
        _render() {
            this._context.command.clear(true);
            this._context.indirectTarget = this._context.source;
            this._context.destination = this._context.source;
            for (var i = 0, n = this._effects.length; i < n; i++) {
                let effect = this._effects[i];
                if (effect.active && !effect.destroyed) {
                    effect.render(this._context);
                    this._context.indirectTarget = this._context.destination;
                }
            }
            this._hasCleanRT = false;
        }
        clear() {
            this._effects.length = 0;
            this._onChangeRender();
        }
        clearCMD() {
            this._context.command.clear();
        }
        recoverAllRTS() {
            this._context.destination = null;
            for (let effect of this._effects) {
                effect.clearRT(this._context);
            }
            this._hasCleanRT = true;
        }
        apply() {
            if (this._hasCleanRT) {
                this.clearCMD();
                this._render();
                this._hasCleanRT = false;
            }
            this._context._apply();
            for (let i = 0, n = this._effects.length; i < n; i++) {
                let effect = this._effects[i];
                effect.clearRT(this._context);
            }
            this._hasCleanRT = true;
        }
        destroy() {
            this.owner = null;
            this._context.compositeShaderData.destroy();
            this._context.compositeShaderData = null;
            this._effects.forEach(effect => effect.destroy());
            this._effects.length = 0;
        }
    }
    class PostProcessRenderContext2D {
        constructor() {
            this.deferredReleaseTextures = [];
            this.oriOffset = new Vector2();
        }
        getRenderTexture(width, height, colorFormat, depthFormat) {
            let rt = RenderTexture2D.createFromPool(width, height, colorFormat, depthFormat);
            return rt;
        }
        _apply() {
            this.command.apply(true);
        }
    }

    const hiddenBits = NodeFlags.NOT_IN_PAGE;
    class Sprite extends Node {
        constructor() {
            super();
            this._x = 0;
            this._y = 0;
            this._width = 0;
            this._height = 0;
            this._scaleX = 1;
            this._scaleY = 1;
            this._skewX = 0;
            this._skewY = 0;
            this._pivotX = 0;
            this._pivotY = 0;
            this._anchorX = 0;
            this._anchorY = 0;
            this._rotation = 0;
            this._alpha = 1;
            this._blendMode = exports.BlendMode.invalid;
            this._visible = true;
            this._mouseState = 0;
            this._zOrder = 0;
            this._renderType = 0;
            this._subpassUpdateFlag = 0;
            this.mouseThrough = false;
            this.hitTestPrior = false;
            this._autosize = false;
            this._repaint = -1;
            this._repaintCount = -1;
            this._previousType = 0;
            this._sizeFlag = 0;
            this._cacheAsBmp = false;
            this._layer = 0;
            this._struct = LayaGL.render2DRenderPassFactory.createRenderStruct2D();
            this._struct.owner = this;
            this._globalTrans = new SpriteGlobalTransform(this);
        }
        _initShaderData() {
            if (this._shaderData)
                return;
            this._shaderData = LayaGL.renderDeviceFactory.createShaderData();
            BlendModeHandler.initBlendMode(this._shaderData);
            BlendModeHandler.setShaderData(this._struct.blendMode, this._shaderData);
            this._struct.spriteShaderData = this._shaderData;
            this._struct.isRenderStruct = true;
        }
        destroy(destroyChild = true) {
            super.destroy(destroyChild);
            if (this._texture) {
                this._texture._removeReference();
                this._texture = null;
            }
            if (this._oriRenderPass) {
                ILaya.stage.passManager.removePass(this._oriRenderPass);
                if (this._oriRenderPass.postProcess) {
                    this._oriRenderPass.postProcess.destroy();
                    this._oriRenderPass.postProcess = null;
                }
                this._oriRenderPass.destroy();
                this._oriRenderPass = null;
            }
            if (this._subStructRender) {
                this._subStructRender.destroy();
                this._subStructRender = null;
            }
            if (this._drawOriRT) {
                if (this._drawOriRT !== RenderTexture2D._empty) {
                    RenderTexture2D.recoverToPool(this._drawOriRT);
                }
                this._drawOriRT = null;
            }
            this.setGraphics(null);
            this._struct = null;
        }
        get parent() {
            return this._$parent;
        }
        get scene() {
            return this._scene;
        }
        get x() {
            return this._x;
        }
        set x(value) {
            this.pos(value, this._y);
        }
        get y() {
            return this._y;
        }
        set y(value) {
            this.pos(this._x, value);
        }
        get width() {
            if (this._autosize)
                return this.getSelfBounds(tmpRect).width;
            else if ((this._sizeFlag & 1) == 0)
                return this.measureWidth();
            else
                return this._width;
        }
        set width(value) {
            this.size(value, (this._sizeFlag & 2) == 0 ? null : this._height);
        }
        get height() {
            if (this._autosize)
                return this.getSelfBounds(tmpRect).height;
            else if ((this._sizeFlag & 2) == 0)
                return this.measureHeight();
            else
                return this._height;
        }
        set height(value) {
            this.size((this._sizeFlag & 1) == 0 ? null : this._width, value);
        }
        get _isWidthSet() {
            return (this._sizeFlag & 1) != 0;
        }
        get _isHeightSet() {
            return (this._sizeFlag & 2) != 0;
        }
        measureWidth() {
            return this._texture ? this._texture.width : 0;
        }
        measureHeight() {
            return this._texture ? this._texture.height : 0;
        }
        _isMaterialVaild(value) {
            return value.checkType(exports.ShaderFeatureType.D2_TextureSV);
        }
        get displayWidth() {
            return this.width * this.scaleX;
        }
        get displayHeight() {
            return this.height * this.scaleY;
        }
        get scaleX() {
            return this._scaleX;
        }
        set scaleX(value) {
            this.scale(value, this._scaleY);
        }
        get scaleY() {
            return this._scaleY;
        }
        set scaleY(value) {
            this.scale(this._scaleX, value);
        }
        get rotation() {
            return this._rotation;
        }
        set rotation(value) {
            if (this._rotation !== value) {
                this._rotation = value;
                this._transChanged(exports.TransformKind.Rotation);
            }
        }
        get skewX() {
            return this._skewX;
        }
        set skewX(value) {
            this.skew(value, this._skewY);
        }
        get skewY() {
            return this._skewY;
        }
        set skewY(value) {
            this.skew(this._skewX, value);
        }
        get transform() {
            if (!this._tfChanged)
                return this._transform;
            this._tfChanged = false;
            let m = this._transform || (this._transform = new Matrix());
            let sx = this._scaleX, sy = this._scaleY;
            let sskx = this._skewX;
            let ssky = this._skewY;
            let rot = this._rotation;
            if (rot || sx !== 1 || sy !== 1 || sskx !== 0 || ssky !== 0) {
                m._bTransform = true;
                let skx = (rot - sskx) * 0.0174532922222222;
                let sky = (rot + ssky) * 0.0174532922222222;
                let cx = Math.cos(sky);
                let ssx = Math.sin(sky);
                let cy = Math.sin(skx);
                let ssy = Math.cos(skx);
                m.a = sx * cx;
                m.b = sx * ssx;
                m.c = -sy * cy;
                m.d = sy * ssy;
                m.tx = m.ty = 0;
            }
            else {
                m.identity();
            }
            return m;
        }
        set transform(value) {
            this._tfChanged = false;
            let m = this._transform || (this._transform = new Matrix());
            if (value !== m)
                value.copyTo(m);
            if (value) {
                let out = Matrix.extractTransformInfo(value);
                this._x = out.x;
                this._y = out.y;
                this._scaleX = out.scaleX;
                this._scaleY = out.scaleY;
                this._skewX = out.skewX;
                this._skewY = out.skewY;
                this._rotation = out.rotation;
                m.tx = m.ty = 0;
                this._transChanged(exports.TransformKind.TRS);
            }
            this.parentRepaint();
        }
        get globalTrans() {
            return this._globalTrans;
        }
        get pivotX() {
            return this._pivotX;
        }
        set pivotX(value) {
            this.pivot(value, this._pivotY);
        }
        get pivotY() {
            return this._pivotY;
        }
        set pivotY(value) {
            this.pivot(this._pivotX, value);
        }
        get anchorX() {
            return this._anchorX;
        }
        set anchorX(value) {
            this.anchor(value, this._anchorY);
        }
        get anchorY() {
            return this._anchorY;
        }
        set anchorY(value) {
            this.anchor(this._anchorX, value);
        }
        get alpha() {
            return this._alpha;
        }
        set alpha(value) {
            value = value < 0 ? 0 : (value > 1 ? 1 : value);
            if (this._alpha !== value) {
                this._alpha = value;
                this._struct.alpha = value;
                this.repaint();
            }
        }
        get visible() {
            return this._visible;
        }
        set visible(value) {
            if (this._visible !== value) {
                this._visible = value;
                this._processVisible();
            }
        }
        get blendMode() {
            return this._blendMode === 0 ? null : exports.BlendMode[this._blendMode];
        }
        set blendMode(value) {
            let t = exports.BlendMode[value];
            if (typeof (t) !== "number")
                t = value === "destination-out" ? exports.BlendMode.destinationOut : 0;
            if (this._blendMode != t) {
                this._blendMode = t;
                this._initShaderData();
                this._struct.blendMode = this._blendMode;
                this.repaint(exports.RepaintFlag.Graphics);
            }
        }
        get layer() {
            return this._layer;
        }
        set layer(value) {
            if (this._layer !== value) {
                if (value >= 0 && value <= 30) {
                    this._layer = value;
                    this._struct.renderLayer = 1 << value;
                }
                else {
                    throw new Error("Layer value must be 0-30.");
                }
            }
        }
        get graphics() {
            if (!this._graphics) {
                this.graphics = new Graphics();
                this._ownGraphics = true;
            }
            return this._graphics;
        }
        set graphics(value) {
            this.setGraphics(value, false);
        }
        setGraphics(value, transferOwnership) {
            let g = this._graphics;
            this._graphics = null;
            if (g) {
                if (this._ownGraphics)
                    g.destroy();
                else {
                    g._data = null;
                    g.owner = null;
                    g._checkDisplay();
                }
            }
            this._ownGraphics = transferOwnership;
            this._graphics = value;
            if (value) {
                if (!this._graphicsData)
                    this._graphicsData = new GraphicsRenderData(this);
                else
                    this._graphicsData.clear();
                value._data = this._graphicsData;
                value.owner = this;
                value._checkDisplay();
            }
            else {
                if (this._graphicsData) {
                    this._graphicsData.destroy();
                    this._graphicsData = null;
                }
                this._renderType &= ~SpriteConst.GRAPHICS;
            }
            this.repaint(exports.RepaintFlag.Graphics);
        }
        get filters() {
            return this._filterArr;
        }
        set filters(value) {
            value && value.length === 0 && (value = null);
            this._filterArr = value;
            if (value) {
                let postProcess = this.getPostProcess(true);
                postProcess.clear();
                for (let f of this._filterArr) {
                    postProcess.addEffect(f.getEffect());
                }
            }
            else
                this.postProcess = null;
            this.repaint();
        }
        getPostProcess(create = true) {
            if (!this._oriRenderPass || !this._oriRenderPass.postProcess) {
                if (create) {
                    this.postProcess = new PostProcess2D();
                }
                else {
                    return null;
                }
            }
            return this._oriRenderPass.postProcess;
        }
        get postProcess() {
            return this.getPostProcess(false);
        }
        set postProcess(value) {
            var _a;
            if ((_a = this._oriRenderPass) === null || _a === void 0 ? void 0 : _a.postProcess) {
                if (this._oriRenderPass.postProcess === value)
                    return;
                this._oriRenderPass.postProcess.owner = null;
                this._oriRenderPass.postProcess = null;
                this.setSubpassFlag(exports.SubPassFlag.PostProcess);
            }
            if (value) {
                if (!this._oriRenderPass) {
                    this.createSubRenderPass();
                }
                value.owner = this;
                this._oriRenderPass.postProcess = value;
                this.setSubpassFlag(exports.SubPassFlag.PostProcess);
            }
        }
        get cacheAs() {
            return this._cacheAsBmp ? 'bitmap' : 'none';
        }
        set cacheAs(value) {
            let b = value === "bitmap";
            if (b === this._cacheAsBmp)
                return;
            this._cacheAsBmp = b;
            if (b) {
                this._renderType |= SpriteConst.CANVAS;
            }
            else {
                this._renderType &= ~SpriteConst.CANVAS;
            }
            this.setSubpassFlag(exports.SubPassFlag.CacheAsBitmap);
            this.repaint(exports.RepaintFlag.Graphics);
        }
        get mask() {
            return this._mask;
        }
        set mask(value) {
            if (value == this || (value && this._mask == value && value._maskParent == this))
                return;
            if (value && value.isAncestorOf(this))
                throw new Error("Mask cannot be ancestor of the masked object");
            if (this._mask) {
                this._mask.cacheAs = "none";
                this._mask._maskParent = null;
            }
            this._mask = value;
            if (value) {
                value._maskParent = this;
                value.cacheAs = "bitmap";
                this._renderType |= SpriteConst.MASK;
            }
            else {
                this._renderType &= ~SpriteConst.MASK;
            }
            this.setSubpassFlag(exports.SubPassFlag.Mask);
            this.repaint();
        }
        clearSubpassFlag(flag) {
            this._subpassUpdateFlag &= ~flag;
        }
        setSubpassFlag(flag) {
            this._subpassUpdateFlag |= flag;
            if (this._needUpdateSubpass()) {
                this.stage._subpassUpdateList.add(this);
                this._globalTrans._notifyRenderSpriteTransChange();
            }
        }
        _needUpdateSubpass() {
            let sprite = this._maskParent || this;
            return sprite.displayedInStage && sprite._struct.enabled;
        }
        get scrollRect() {
            return this._scrollRect;
        }
        set scrollRect(value) {
            if (this._scrollRect == null && value == null)
                return;
            this._scrollRect = value;
            if (value)
                this._renderType |= SpriteConst.CLIP;
            else
                this._renderType &= ~SpriteConst.CLIP;
            this._struct.setClipRect(value);
            if (this._oriRenderPass)
                this._oriRenderPass.repaint = true;
            this._globalTrans._spTransChanged(exports.TransformKind.Layout);
            this.repaint();
        }
        get viewport() {
            return null;
        }
        set viewport(value) {
        }
        set drawCallOptimize(value) {
            if (this._struct.dcOptimize === value)
                return;
            this._struct.dcOptimize = value;
            this._struct.setRepaint();
            this.parentRepaint();
            value && this._globalTrans._spTransChanged(exports.TransformKind.Layout);
        }
        get drawCallOptimize() {
            return this._struct.dcOptimize;
        }
        set enableCulling(value) {
            if (this._struct.enableCulling === value)
                return;
            this._struct.enableCulling = value;
            this._struct.setRepaint();
            this.parentRepaint();
            value && this._globalTrans._spTransChanged(exports.TransformKind.Layout);
        }
        get enableCulling() {
            return this._struct.enableCulling;
        }
        get hitArea() {
            return this._hitArea;
        }
        set hitArea(value) {
            this._hitArea = value;
        }
        get mouseEnabled() {
            return this._mouseState === 2;
        }
        set mouseEnabled(value) {
            let i = value ? 2 : 1;
            if (this._mouseState !== i) {
                this._mouseState = i;
                if (i === 2)
                    this.setMouseEnabledUp();
            }
        }
        setMouseEnabledUp() {
            let p = this._parent;
            while (p && p !== ILaya.stage) {
                if (p._mouseState !== 0 || !p._setBit(NodeFlags.CHECK_INPUT, true))
                    break;
                p = p._parent;
            }
        }
        getMousePoint() {
            return this.globalToLocal(tmpPoint.setTo(ILaya.stage.mouseX, ILaya.stage.mouseY));
        }
        get mouseX() {
            return this.getMousePoint().x;
        }
        get mouseY() {
            return this.getMousePoint().y;
        }
        get globalScaleX() {
            return this.globalTrans.scaleX;
        }
        get globalScaleY() {
            return this.globalTrans.scaleY;
        }
        get zOrder() {
            return this._zOrder;
        }
        set zOrder(value) {
            if (this._zOrder != value) {
                this._zOrder = value;
                if (this._parent) {
                    value && this._parent._setBit(NodeFlags.HAS_ZORDER, true);
                    ILaya.systemTimer.callLater(this._parent, this.updateZOrder);
                }
            }
        }
        get zIndex() {
            return this._struct.zIndex;
        }
        set zIndex(value) {
            if (this._struct.zIndex !== value) {
                this._struct.zIndex = value;
                this.parentRepaint();
            }
        }
        get stackingRoot() {
            return this._struct.stackingRoot;
        }
        set stackingRoot(value) {
            this._struct.stackingRoot = value;
        }
        updateZOrder() {
            let array = this._$children;
            if (!array || array.length < 2)
                return;
            let i = 1, j, len = array.length, key, c, d;
            let structArray = this._struct.children;
            while (i < len) {
                j = i;
                c = array[j];
                d = structArray[j];
                key = array[j]._zOrder;
                while (--j > -1) {
                    if (array[j]._zOrder > key) {
                        array[j + 1] = array[j];
                        structArray[j + 1] = structArray[j];
                    }
                    else
                        break;
                }
                array[j + 1] = c;
                structArray[j + 1] = d;
                i++;
            }
            this._struct.children = structArray;
            let flag = this._setBit(NodeFlags.HAS_ZORDER, false);
            this._childChanged();
            if (flag)
                this._setBit(NodeFlags.HAS_ZORDER, true);
        }
        get texture() {
            return this._texture;
        }
        set texture(value) {
            if (this._texture == value)
                return;
            this._texture && this._texture._removeReference();
            this._texture = value;
            if (value) {
                value._addReference();
                this.graphics.repaint();
            }
            else {
                if (this._graphics) {
                    this._graphics.repaint();
                }
                else {
                    this.repaint();
                }
            }
        }
        get material() {
            var _a;
            return (_a = this._graphics) === null || _a === void 0 ? void 0 : _a.material;
        }
        set material(value) {
            if (value && !this._isMaterialVaild(value))
                return;
            if (this._graphics == null && value == null)
                return;
            this.graphics.material = value;
        }
        get renderNode2D() {
            return this._renderNode;
        }
        set renderNode2D(value) {
            this._renderNode = value;
            if (value) {
                value.renderUpdate && this._struct.setRenderUpdateCallback(value.renderUpdate.bind(value));
                this._renderType |= SpriteConst.RENDERNODE2D;
            }
            else {
                this._struct.setRenderUpdateCallback(null);
                this._renderType &= ~SpriteConst.RENDERNODE2D;
            }
            if (this._graphics) {
                this._graphics.repaint();
            }
        }
        get autoSize() {
            return this._autosize;
        }
        set autoSize(value) {
            this._autosize = value;
        }
        pos(x, y) {
            if (this._x != x || this._y != y) {
                this._x = x;
                this._y = y;
                this._transChanged(exports.TransformKind.Pos);
            }
            return this;
        }
        pivot(x, y) {
            if (this._pivotX != x || this._pivotY != y) {
                this._pivotX = x;
                this._pivotY = y;
                let t = this.width;
                if (t != 0)
                    this._anchorX = x / t;
                t = this.height;
                if (t != 0)
                    this._anchorY = y / t;
                this._transChanged(exports.TransformKind.Anchor);
            }
            return this;
        }
        anchor(x, y) {
            if (this._anchorX != x || this._anchorY != y) {
                this._anchorX = x;
                this._anchorY = y;
                this._pivotX = x * this.width;
                this._pivotY = y * this.height;
                this._transChanged(exports.TransformKind.Anchor);
            }
            return this;
        }
        size(width, height) {
            let bw, bh;
            if (width == null) {
                bw = (this._sizeFlag & 1) != 0;
                this._sizeFlag &= ~1;
            }
            else {
                bw = this._width != width || (this._sizeFlag & 1) == 0;
                this._width = width;
                this._pivotX = this._anchorX * width;
                this._sizeFlag |= 1;
            }
            if (height == null) {
                bh = (this._sizeFlag & 2) != 0;
                this._sizeFlag &= ~2;
            }
            else {
                bh = this._height != height || (this._sizeFlag & 2) == 0;
                this._height = height;
                this._pivotY = this._anchorY * height;
                this._sizeFlag |= 2;
            }
            if (bw || bh)
                this._transChanged((bw ? exports.TransformKind.Width : 0) | (bh ? exports.TransformKind.Height : 0));
            return this;
        }
        scale(x, y) {
            if (this._scaleX !== x || this._scaleY !== y) {
                this._scaleX = x;
                this._scaleY = y;
                this._transChanged(exports.TransformKind.Scale);
            }
            return this;
        }
        skew(x, y) {
            if (this._skewX !== x || this._skewY !== y) {
                this._skewX = x;
                this._skewY = y;
                this._transChanged(exports.TransformKind.Skew);
            }
            return this;
        }
        _transChanged(kind) {
            var _a;
            if (this._destroyed)
                return;
            if (this._oriRenderPass)
                this._oriRenderPass.repaint = true;
            if (kind !== exports.TransformKind.Pos && kind !== exports.TransformKind.Anchor) {
                this._tfChanged = true;
                if ((kind & exports.TransformKind.Size) !== 0 && this._graphics)
                    this._graphics.repaint();
                else if ((this._renderType & SpriteConst.DRAW2RT) !== 0)
                    this.repaint();
                else {
                    this.parentRepaint();
                }
            }
            else {
                this.parentRepaint();
            }
            (_a = this._maskParent) === null || _a === void 0 ? void 0 : _a.repaint(exports.RepaintFlag.ChildChange);
            if ((kind & exports.TransformKind.TRS) !== 0
                || (kind & exports.TransformKind.Anchor) !== 0
                || ((kind & exports.TransformKind.Size) !== 0 && (this._anchorX !== 0 || this._anchorY !== 0 || this._struct.inheritedDcOptimize))) {
                this._globalTrans._spTransChanged(kind);
                if (this._getBit(NodeFlags.DEMAND_TRANS_EVENT))
                    notifyTransChanged(this);
            }
        }
        drawToCanvas(canvasWidth, canvasHeight, offsetX, offsetY) {
            return Sprite.drawToCanvas(this, canvasWidth, canvasHeight, offsetX, offsetY);
        }
        static drawToCanvas(sprite, canvasWidth, canvasHeight, offsetX, offsetY) {
            let rt = Sprite.drawToRenderTexture2D(sprite, canvasWidth, canvasHeight, offsetX, offsetY, null);
            var dt = rt.getData(0, 0, canvasWidth, canvasHeight);
            var imgdata = new ImageData(canvasWidth, canvasHeight);
            var lineLen = canvasWidth * 4;
            var dst = imgdata.data;
            var y = canvasHeight - 1;
            var off = y * lineLen;
            var srcoff = 0;
            for (; y >= 0; y--) {
                dst.set(dt.subarray(srcoff, srcoff + lineLen), off);
                off -= lineLen;
                srcoff += lineLen;
            }
            let canv = new HTMLCanvas();
            canv.size(canvasWidth, canvasHeight);
            canv.context.putImageData(imgdata, 0, 0);
            rt.destroy();
            return canv;
        }
        drawToTexture(canvasWidth, canvasHeight, offsetX, offsetY, rt = null, isDrawRenderRect = true) {
            let res = Sprite.drawToTexture(this, canvasWidth, canvasHeight, offsetX, offsetY, rt, isDrawRenderRect);
            return res;
        }
        static drawToTexture(sprite, canvasWidth, canvasHeight, offsetX, offsetY, rt = null, isDrawRenderRect = true) {
            return Sprite.drawToRenderTexture2D(sprite, canvasWidth, canvasHeight, offsetX, offsetY, rt, isDrawRenderRect);
        }
        drawToRenderTexture2D(canvasWidth, canvasHeight, offsetX, offsetY, rt, isDrawRenderRect, flipY, clearColor, renderScaleX = 1, renderScaleY = 1) {
            let res = Sprite.drawToRenderTexture2D(this, canvasWidth, canvasHeight, offsetX, offsetY, rt, isDrawRenderRect, flipY, clearColor, renderScaleX, renderScaleY);
            return res;
        }
        static drawToRenderTexture2D(sprite, canvasWidth, canvasHeight, offsetX, offsetY, rt, isDrawRenderRect, flipY, clearColor, renderScaleX = 1, renderScaleY = 1) {
            let renderout = rt || new RenderTexture2D(canvasWidth, canvasHeight, exports.RenderTargetFormat.R8G8B8A8);
            renderout._invertY = flipY;
            if (LayaGL.renderEngine._screenInvertY) {
                renderout._invertY = !renderout._invertY;
            }
            let runner = Render2DProcessor.runner;
            let passSet = new Set();
            let processor = new Render2DProcessor();
            const updateSprites = function (sprite) {
                if (!sprite._struct || !sprite._struct.enabled)
                    return;
                if (sprite._subpassUpdateFlag) {
                    sprite.updateSubRenderPassState();
                    if (sprite._oriRenderPass) {
                        let result = sprite.updateRenderTexture();
                        let destrt = sprite._drawOriRT;
                        if (destrt) {
                            sprite._oriRenderPass.renderTexture = destrt;
                            if (sprite.mask) {
                                sprite._oriRenderPass.mask = sprite.mask._struct;
                            }
                            else
                                sprite._oriRenderPass.mask = null;
                            if (result) {
                                sprite._oriRenderPass.renderTexture = destrt;
                            }
                            let process = sprite._renderType & SpriteConst.POSTPROCESS ? sprite.postProcess : null;
                            if (process
                                && destrt != RenderTexture2D._empty) {
                                if (result ||
                                    (sprite._subpassUpdateFlag & exports.SubPassFlag.UPDATE_POSTPROCESS)) {
                                    process.setResource(destrt);
                                    process.clearCMD();
                                    process._render();
                                }
                                if (process.enabled) {
                                    destrt = process._context.destination;
                                }
                            }
                            sprite._subStructRender._updateRenderTexture(sprite._drawOriRT, destrt);
                            sprite._subpassUpdateFlag = 0;
                        }
                        else {
                            sprite.setSubRenderPassState(false);
                        }
                    }
                }
                if (sprite._struct) {
                    sprite._updateStruct();
                    if (sprite._struct.pass)
                        passSet.add(sprite._struct.pass);
                }
                if (sprite._graphics) {
                    sprite._graphics._render(runner, 0, 0);
                }
                for (let i = 0, len = sprite._children.length; i < len; i++)
                    updateSprites(sprite._children[i]);
            };
            updateSprites(sprite);
            let pass = processor.basePass;
            if (clearColor) {
                pass.setClearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
                pass.doClearColor = true;
            }
            pass.renderTexture = renderout;
            let struct = sprite._oriRenderPass && sprite._oriRenderPass.enable ? sprite._subStruct : sprite._struct;
            pass.root = struct;
            let matrix = pass.offsetMatrix;
            matrix.identity();
            let local = sprite.transform;
            if (local)
                local.copyTo(matrix);
            matrix.scale(renderScaleX, renderScaleY);
            matrix.invert();
            matrix.tx = -offsetX;
            matrix.ty = -offsetY;
            pass.offsetMatrix = matrix;
            for (let pass of passSet) {
                if (pass.priority > 0) {
                    processor.addPass(pass);
                }
            }
            processor.apply(Render2DProcessor.rendercontext2D);
            processor.clear();
            pass.destroy();
            return renderout;
        }
        hitTestPoint(x, y) {
            let point = this.globalToLocal(tmpPoint.setTo(x, y));
            x = point.x;
            y = point.y;
            var rect = this._hitArea ? this._hitArea :
                (this._isWidthSet && this._isHeightSet) ? tmpRect.setTo(0, 0, this._width, this._height) : this.getGraphicBounds(false, tmpRect);
            return rect.contains(x, y, this);
        }
        setSelfBounds(bound) {
            this._userBounds = bound;
        }
        getBounds(out) {
            out = this.getSelfBounds(out, true);
            return SpriteUtils.transformRect(this, out, this._parent, out);
        }
        getSelfBounds(out, recursive) {
            var _a;
            if (recursive == null)
                recursive = true;
            if (this._userBounds != null)
                return this._userBounds.clone(out);
            else if (this._scrollRect != null && !this._getBit(NodeFlags.DISABLE_INNER_CLIPPING))
                return this._scrollRect.clone(out);
            else if (!recursive && ((_a = this._oriRenderPass) === null || _a === void 0 ? void 0 : _a.enable))
                return this._subStructRender._rtRect.clone(out);
            else {
                out = this.getGraphicBounds(false, out);
                if (recursive && this._children.length > 0) {
                    let rect = Rectangle.create();
                    for (let child of this._children) {
                        if (child._struct.enabled && child._maskParent != this) {
                            child.getBounds(rect);
                            out.union(rect, out);
                        }
                    }
                    rect.recover();
                }
                return out;
            }
        }
        getGraphicBounds(realSize, out) {
            if (out)
                out.setTo(0, 0, 0, 0);
            else
                out = new Rectangle();
            if (this._graphics != null)
                out.union(this._graphics.getBounds(), out);
            if (this._texture != null)
                out.union(tmpRect.setTo(0, 0, this._width || this._texture.width, this._height || this._texture.height), out);
            if (this._renderNode != null) {
                let rect = this._renderNode.rect;
                Rectangle.minMaxRect(rect.x, rect.y, rect.z, rect.w, tmpRect);
                out.union(tmpRect, out);
                tmpRect.setTo(0, 0, this._width, this._height);
                out.union(tmpRect, out);
            }
            return out;
        }
        localToGlobal(point, createNewPoint, globalNode) {
            if (createNewPoint) {
                point = new Point(point.x, point.y);
            }
            let ele = this;
            globalNode = globalNode || ILaya.stage;
            while (ele && !ele._destroyed) {
                if (ele == globalNode)
                    break;
                point = ele.toParentPoint(point);
                ele = ele._parent;
            }
            return point;
        }
        globalToLocal(point, createNewPoint, globalNode) {
            if (createNewPoint) {
                point = new Point(point.x, point.y);
            }
            let ele = this;
            tmpSpriteList.length = 0;
            globalNode = globalNode || ILaya.stage;
            while (ele && !ele._destroyed) {
                if (ele == globalNode)
                    break;
                tmpSpriteList.push(ele);
                ele = ele._parent;
            }
            let i = tmpSpriteList.length - 1;
            while (i >= 0) {
                ele = tmpSpriteList[i];
                point = ele.fromParentPoint(point);
                i--;
            }
            return point;
        }
        toParentPoint(point) {
            var _a;
            if (!point)
                return point;
            point.x -= this.pivotX;
            point.y -= this.pivotY;
            (_a = this.transform) === null || _a === void 0 ? void 0 : _a.transformPoint(point);
            point.x += this._x;
            point.y += this._y;
            let scroll = this._scrollRect;
            if (scroll) {
                point.x -= scroll.x * this._scaleX;
                point.y -= scroll.y * this._scaleY;
            }
            return point;
        }
        fromParentPoint(point) {
            var _a;
            if (!point)
                return point;
            point.x -= this._x;
            point.y -= this._y;
            var scroll = this._scrollRect;
            if (scroll) {
                point.x += scroll.x * this._scaleX;
                point.y += scroll.y * this._scaleY;
            }
            (_a = this.transform) === null || _a === void 0 ? void 0 : _a.invertTransformPoint(point);
            point.x += this.pivotX;
            point.y += this.pivotY;
            return point;
        }
        loadImage(url, complete) {
            if (!url) {
                this.texture = null;
                complete && complete.run();
            }
            else {
                let tex = ILaya.loader.getRes(url);
                if (tex) {
                    this.texture = tex;
                    complete && complete.run();
                }
                else {
                    if (this._skinBaseUrl)
                        url = URL.formatURL(url, this._skinBaseUrl);
                    ILaya.loader.load(url).then((tex) => {
                        this.texture = tex;
                        complete && complete.run();
                    });
                }
            }
            return this;
        }
        static fromImage(url) {
            return new Sprite().loadImage(url);
        }
        reCache() {
            if (this._cacheAsBmp || this._mask)
                this.repaint();
        }
        getRepaint() {
            return this._repaint;
        }
        repaint(flag) {
            if (this._destroyed)
                return;
            if (this._repaint < Stat.loopCount
                || (this._repaint === Stat.loopCount && this._repaintCount < Stat.render2DCount)
                || !this._previousType) {
                this._repaint = Stat.loopCount;
                this._repaintCount = Stat.render2DCount;
                this._previousType = this._renderType;
                this._struct.setRepaint();
                this.stage._graphicUpdateList.add(this);
                this.parentRepaint();
                if (this._renderType & SpriteConst.DRAW2RT) {
                    if (!this._drawOriRT
                        || this._subpassUpdateFlag
                        || flag & exports.RepaintFlag.UpdateRT
                        || (this.transform && this._maskParent)) {
                        this.setSubpassFlag(exports.SubPassFlag.RenderTexture);
                    }
                }
                if (this._renderType & SpriteConst.GRAPHICS) {
                    if (flag & exports.RepaintFlag.Graphics) {
                        if (this._graphics)
                            this._graphics._modified = true;
                    }
                    this._globalTrans._notifyRenderSpriteTransChange();
                }
            }
            if (this._maskParent) {
                this._maskParent.setSubpassFlag(exports.SubPassFlag.Mask);
                this._maskParent.repaint(flag);
            }
        }
        _needGraphicsUpdate() {
            return !this._destroyed && this._struct.enabled && this._graphics && this._graphics._display && !!(this.displayedInStage || this._maskParent);
        }
        clearRepaint() {
            this._repaint = -1;
            this._repaintCount = -1;
        }
        _needRepaint() {
            return !!(this._repaint >= Stat.loopCount && this._repaintCount >= LayaGL.renderEngine._framePassCount && this._previousType === 0);
        }
        parentRepaint() {
            let p = this._parent;
            if (!p)
                return;
            let pStruct = p._struct;
            let pass = pStruct ? pStruct.pass : null;
            if (pStruct && pass) {
                if (pass.renderTexture) {
                    p.parentRepaint();
                    if (p._renderType & SpriteConst.DRAW2RT && !p._needRepaint()) {
                        p.setSubpassFlag(exports.SubPassFlag.RenderTexture);
                        pStruct.setRepaint();
                    }
                }
                else
                    pStruct.setRepaint();
            }
        }
        get dragSupport() {
            return this._dragSupport || (this._dragSupport = new DragSupport(this));
        }
        startDrag(area, hasInertia, elasticDistance, elasticBackTime, data, ratio) {
            let d = this.dragSupport;
            if (area != null)
                d.area.copyFrom(area);
            else
                d.area.reset();
            d.hasInertia = !!hasInertia;
            elasticDistance != null && (d.elasticDistance = elasticDistance);
            elasticBackTime != null && (d.elasticBackTime = elasticBackTime);
            ratio != null && (d.ratio = ratio);
            d.start(data);
        }
        stopDrag() {
            this._dragSupport && this._dragSupport.stop();
        }
        onAfterDeserialize() {
            super.onAfterDeserialize();
            if (LayaEnv.isPlaying) {
                if (this._gcmds) {
                    this.graphics.cmds = this._gcmds;
                    delete this._gcmds;
                }
                if (this._filters) {
                    this.filters = this._filters;
                    delete this._filters;
                }
            }
            if (this._mouseState === 2)
                this.setMouseEnabledUp();
        }
        onStartListeningToType(type) {
            super.onStartListeningToType(type);
            if (Event.isMouseEvent(type)) {
                if (this._mouseState === 0) {
                    this._setBit(NodeFlags.CHECK_INPUT, true);
                    this.setMouseEnabledUp();
                }
            }
            else if (type === Event.TRANSFORM_CHANGED) {
                this._setBit(NodeFlags.DEMAND_TRANS_EVENT, true);
                this.setDemandTransEventUp();
            }
        }
        setDemandTransEventUp() {
            let p = this._parent;
            while (p && p !== ILaya.stage) {
                if (!p._setBit(NodeFlags.DEMAND_TRANS_EVENT, true))
                    break;
                p = p._parent;
            }
        }
        _processVisible() {
            let b = this._visible && !this._getBit(hiddenBits);
            if (this._struct && this._struct.enabled !== b) {
                this._struct.enabled = b;
                if (b) {
                    this.repaint();
                }
                else {
                    this._struct.setRepaint();
                }
                this.parentRepaint();
                this._checkSubRenderPass();
                this._refreshRenderPass();
                return true;
            }
            return false;
        }
        _setUnBelongScene() {
            if (this._ownerArea != null) {
                this._ownerArea = null;
            }
            super._setUnBelongScene();
        }
        _setBelongScene(scene) {
            super._setBelongScene(scene);
            this._findOwnerArea();
        }
        _findOwnerArea() {
            let ele = this;
            while (ele) {
                if (ele === this._scene || ele === ILaya.stage)
                    break;
                if (ele._globalRenderData) {
                    this._ownerArea = ele;
                    break;
                }
                ele = ele._parent;
            }
        }
        _setStructParent(value) {
            let struct = this._struct;
            if (struct && struct.parent) {
                struct.parent.removeChild(struct);
                struct.parent = null;
            }
            if (value && value._struct) {
                let index = value._children.indexOf(this);
                value._struct.addChild(struct, index);
            }
        }
        createSubRenderPass() {
            let subPass = LayaGL.render2DRenderPassFactory.createRender2DPass();
            subPass.root = this._struct;
            subPass.enable = false;
            subPass.setClearColor(0, 0, 0, 0);
            let subStruct = LayaGL.render2DRenderPassFactory.createRenderStruct2D();
            subStruct.owner = this;
            subStruct.pass = subPass;
            this._subStructRender = new SubStructRender();
            this._subStructRender.bind(this, subPass, subStruct);
            this._subStruct = subStruct;
            this._oriRenderPass = subPass;
            subStruct.renderMatrix = this.globalTrans.getMatrix();
        }
        updateRenderTexture() {
            let rect = Rectangle.create();
            let oriRect = Rectangle.create();
            if (this._mask) {
                SpriteUtils.getRect(this._mask, false, rect);
                if (this._mask.transform) {
                    rect.transform(this._mask.transform, rect);
                }
                rect.x += this._mask._pivotX;
                rect.y += this._mask._pivotY;
            }
            else {
                SpriteUtils.getRect(this, false, rect);
                if (this._maskParent && this.transform) {
                    rect.transform(this.transform, rect);
                }
                rect.x += this._pivotX;
                rect.y += this._pivotY;
            }
            let scaleX = 1, scaleY = 1;
            let oldRT = this._drawOriRT;
            let maskRect = this._subStructRender._rtRect;
            rect.width = MathUtil.roundTo(rect.width);
            rect.height = MathUtil.roundTo(rect.height);
            rect.cloneTo(oriRect);
            if (Config.useRetinalCanvas) {
                scaleX = ILaya.stage._scaleX;
                scaleY = ILaya.stage._scaleY;
                rect.width = Math.round(rect.width * scaleX);
                rect.height = Math.round(rect.height * scaleY);
                rect.x = rect.x * scaleX;
                rect.y = rect.y * scaleY;
            }
            if (oldRT) {
                if (maskRect.width === rect.width && maskRect.height === rect.height) {
                    this._subStructRender._updateRenderOffset(rect, oriRect, scaleX, scaleY);
                    rect.recover();
                    oriRect.recover();
                    return false;
                }
                if (oldRT !== RenderTexture2D._empty)
                    RenderTexture2D.recoverToPool(oldRT);
            }
            this._subStructRender._updateRenderOffset(rect, oriRect, scaleX, scaleY);
            if (rect.width === 0 || rect.height === 0) {
                this._drawOriRT = RenderTexture2D._empty;
            }
            else {
                let renderTexture = RenderTexture2D.createFromPool(rect.width, rect.height, exports.RenderTargetFormat.R8G8B8A8, exports.RenderTargetFormat.None);
                renderTexture._invertY = LayaGL.renderEngine._screenInvertY;
                this._drawOriRT = renderTexture;
            }
            rect.recover();
            oriRect.recover();
            return true;
        }
        updateSubRenderPassState() {
            this.setSubRenderPassState((this._renderType & SpriteConst.DRAW2RT) !== 0);
        }
        _updateStruct() {
            let trans = this.globalTrans;
            if (this._destroyed || !trans)
                return;
            let matrix = trans.getMatrix();
            let struct = this._struct;
            this._struct.renderMatrix = matrix;
            if (this._subStruct)
                this._subStruct.renderMatrix = matrix;
            let rect = struct.rect;
            if (this._struct.inheritedEnableCulling || this._struct.inheritedDcOptimize) {
                this.getSelfBounds(rect, false);
                rect.transform(matrix, rect);
                struct.rect = rect;
            }
            else {
                struct.rect.reset();
            }
            if (this._subStruct) {
                rect.cloneTo(this._subStruct.rect);
                this._subStruct.rect = this._subStruct.rect;
            }
        }
        setSubRenderPassState(enable) {
            if (!this._oriRenderPass) {
                if (!enable)
                    return;
                this.createSubRenderPass();
            }
            if (enable && !this._oriRenderPass.enable) {
                this._struct.pass = this._oriRenderPass;
                this._struct.subStruct = this._subStruct;
                this._subStruct.enabled = true;
                if (this._maskParent) {
                    this._subStruct.blendMode = exports.BlendMode.mask;
                }
            }
            else if (!enable && this._oriRenderPass && this._oriRenderPass.enable) {
                this._struct.pass = null;
                this._subStruct.enabled = false;
                this._subStruct.blendMode = this._blendMode;
                this._struct.subStruct = null;
                this._struct.setRepaint();
            }
            this._oriRenderPass.enable = enable;
            this._refreshRenderPass();
        }
        _setParent(value) {
            this._globalTrans._spTransChanged(exports.TransformKind.TRS);
            super._setParent(value);
            this._setStructParent(value);
            if (value && (this._mouseState === 2 || this._mouseState === 0 && this._getBit(NodeFlags.CHECK_INPUT))
                && !value._getBit(NodeFlags.CHECK_INPUT)) {
                this.setMouseEnabledUp();
            }
            if (value && this._getBit(NodeFlags.DEMAND_TRANS_EVENT) && !value._getBit(NodeFlags.DEMAND_TRANS_EVENT))
                this.setDemandTransEventUp();
        }
        _checkSubRenderPass() {
            if (this._needUpdateSubpass()) {
                if (this._subpassUpdateFlag || (this._renderType & SpriteConst.DRAW2RT && !this._drawOriRT)) {
                    this.setSubpassFlag(exports.SubPassFlag.RenderTexture);
                }
            }
            else if (this._subpassUpdateFlag) {
                ILaya.stage._subpassUpdateList.delete(this);
            }
            if (this._mask) {
                this._mask._checkSubRenderPass();
            }
        }
        _refreshRenderPass() {
            if (this._oriRenderPass) {
                let result = this._needUpdateSubpass() && this._oriRenderPass.enable && this._renderType & SpriteConst.DRAW2RT;
                if (result) {
                    ILaya.stage.passManager.addPass(this._oriRenderPass);
                }
                else {
                    if (this._drawOriRT && this._drawOriRT !== RenderTexture2D._empty) {
                        RenderTexture2D.recoverToPool(this._drawOriRT);
                    }
                    this._drawOriRT = null;
                    if (this._oriRenderPass.postProcess) {
                        this._oriRenderPass.postProcess.recoverAllRTS();
                    }
                    this._oriRenderPass.repaint = true;
                    ILaya.stage.passManager.removePass(this._oriRenderPass);
                }
            }
            if (this._mask) {
                this._mask._refreshRenderPass();
                if (!this._mask.displayedInStage) {
                    this._mask.repaint(exports.RepaintFlag.Graphics);
                }
            }
        }
        _setDisplay(value) {
            super._setDisplay(value);
            if (this._needGraphicsUpdate()) {
                if (this._graphics)
                    this._graphics._modified = true;
                this.stage._graphicUpdateList.add(this);
                this._globalTrans._notifyRenderSpriteTransChange();
            }
            this._checkSubRenderPass();
            this._refreshRenderPass();
        }
        _setChildIndex(node, oldIndex, index) {
            let out = super._setChildIndex(node, oldIndex, index);
            if (node._struct)
                node._parent._struct.updateChildIndex(node._struct, oldIndex, out);
            return out;
        }
        _childChanged(child) {
            super._childChanged(child);
            if (child) {
                if (child._zOrder)
                    this._setBit(NodeFlags.HAS_ZORDER, true);
            }
            if (this._getBit(NodeFlags.HAS_ZORDER))
                ILaya.systemTimer.callLater(this, this.updateZOrder);
            this.repaint(exports.RepaintFlag.ChildChange);
        }
        _addComponentInstance(comp) {
            var _a;
            if (comp instanceof BaseRenderNode2D &&
                ((_a = this._components) === null || _a === void 0 ? void 0 : _a.some((c) => c instanceof BaseRenderNode2D))) {
                console.warn(`${this.name} add RenderNode2D invalid, one sprite can only add one RenderNode`);
                return;
            }
            super._addComponentInstance(comp);
        }
    }
    const tmpRect = new Rectangle();
    const tmpPoint = new Point();
    const tmpSpriteList = [];
    function notifyTransChanged(sp) {
        sp.event(Event.TRANSFORM_CHANGED);
        for (let child of sp._children) {
            if (child._getBit(NodeFlags.DEMAND_TRANS_EVENT))
                notifyTransChanged(child);
        }
    }

    var _isFirstTouch = true;
    const _tempPoint = new Point();
    const _tempRect = new Rectangle();
    const _rollOverChain = [];
    const _rollOutChain = [];
    var _inst;
    class InputManager {
        constructor() {
            this._touches = [];
            this._touchPool = [];
            this._mouseTouch = new TouchInfo(this._touches);
            this._pressKeys = new Set();
            this._keyEvent = new Event();
            this._keyEvent._touches = this._touches;
        }
        static get inst() {
            return _inst;
        }
        static getTouchPos(touchId) {
            var _a;
            if (touchId == null)
                touchId = InputManager.lastTouchId;
            return ((_a = _inst.getTouch(touchId)) === null || _a === void 0 ? void 0 : _a.pos) || _inst._mouseTouch.pos;
        }
        static get touchTarget() {
            return _inst._touchTarget;
        }
        static get touches() {
            return _inst._touches;
        }
        static get touchCount() {
            return _inst._touches.length;
        }
        static cancelClick(touchId) {
            if (touchId == null)
                touchId = InputManager.lastTouchId;
            let touch = _inst.getTouch(touchId);
            if (touch)
                touch.clickCancelled = true;
        }
        static hasKeyDown(key) {
            return _inst._pressKeys.has(key);
        }
        static __init__() {
            let inst = _inst = new InputManager();
            inst._stage = ILaya.stage;
            let canvas = Browser.mainCanvas.source;
            let passiveOption = { passive: false };
            canvas.oncontextmenu = () => {
                return false;
            };
            canvas.addEventListener("mousedown", ev => {
                if (!Browser.onIE)
                    (ev.cancelable) && (ev.preventDefault());
                inst.handleMouse(ev, 0);
            }, passiveOption);
            canvas.addEventListener("mouseup", ev => {
                (ev.cancelable) && (ev.preventDefault());
                inst.handleMouse(ev, 1);
            }, passiveOption);
            canvas.addEventListener("mousemove", ev => {
                (ev.cancelable) && (ev.preventDefault());
                inst.handleMouse(ev, 2);
            }, passiveOption);
            canvas.addEventListener("mouseout", ev => {
                inst.handleMouse(ev, 3);
            }, passiveOption);
            canvas.addEventListener("touchstart", ev => {
                if (!_isFirstTouch && !PAL.textInput.target)
                    (ev.cancelable) && (ev.preventDefault());
                inst.handleTouch(ev, 0);
            }, passiveOption);
            canvas.addEventListener("touchend", ev => {
                if (!_isFirstTouch && !PAL.textInput.target)
                    (ev.cancelable) && (ev.preventDefault());
                _isFirstTouch = false;
                inst.handleTouch(ev, 1);
            }, passiveOption);
            canvas.addEventListener("touchmove", ev => {
                (ev.cancelable) && (ev.preventDefault());
                inst.handleTouch(ev, 2);
            }, passiveOption);
            canvas.addEventListener("touchcancel", ev => {
                (ev.cancelable) && (ev.preventDefault());
                inst.handleTouch(ev, 3);
            }, passiveOption);
            canvas.addEventListener("wheel", ev => {
                inst.handleMouse(ev, 4);
            }, passiveOption);
            if (typeof (canvas.setPointerCapture) === 'function') {
                canvas.addEventListener("pointerdown", ev => {
                    canvas.setPointerCapture(ev.pointerId);
                });
                canvas.addEventListener("pointerup", ev => {
                    canvas.releasePointerCapture(ev.pointerId);
                }, true);
            }
            let doc = Browser.document;
            doc.addEventListener("keydown", ev => {
                inst.handleKeys(ev);
            }, true);
            doc.addEventListener("keypress", ev => {
                inst.handleKeys(ev);
            }, true);
            doc.addEventListener("keyup", ev => {
                inst.handleKeys(ev);
            }, true);
        }
        handleMouse(ev, type) {
            this._eventType = type;
            this._nativeEvent = ev;
            InputManager.lastTouchId = 0;
            let now = performance.now();
            if (this._lastTouchTime != null && now - this._lastTouchTime < 100)
                return;
            let touch = this._mouseTouch;
            _tempPoint.setTo(ev.pageX || ev.clientX, ev.pageY || ev.clientY);
            this._stage._canvasTransform.invertTransformPoint(_tempPoint);
            InputManager.mouseX = _tempPoint.x;
            InputManager.mouseY = _tempPoint.y;
            let x = _tempPoint.x / this._stage.clientScaleX;
            let y = _tempPoint.y / this._stage.clientScaleY;
            touch.event.nativeEvent = ev;
            if (type == 3 || !InputManager.mouseEventsEnabled)
                touch.target = this._touchTarget = null;
            else {
                touch.target = this._touchTarget = this.getNodeUnderPoint(x, y);
                let ix = Math.round(x);
                let iy = Math.round(y);
                if (ix != touch.pos.x || iy != touch.pos.y) {
                    InputManager.lastMouseTime = now;
                    touch.pos.setTo(ix, iy);
                    touch.move();
                    if (InputManager.mouseEventsEnabled) {
                        touch.bubble(Event.MOUSE_MOVE);
                        for (let t of touch.downTargets) {
                            touch.event._stopped = false;
                            t.event(Event.MOUSE_DRAG, touch.event);
                            if (touch.event._stopped)
                                break;
                        }
                    }
                }
            }
            if (touch.lastRollOver != touch.target)
                this.handleRollOver(touch);
            if (type == 0) {
                if (!touch.began) {
                    touch.begin();
                    this._touches[0] = touch;
                    touch.event.button = ev.button;
                    touch.downButton = ev.button;
                    InputManager.onMouseDownCapture.invoke(touch.touchId);
                    if (InputManager.mouseEventsEnabled) {
                        if (ev.button == 0)
                            touch.bubble(Event.MOUSE_DOWN);
                        else
                            touch.bubble(Event.RIGHT_MOUSE_DOWN);
                    }
                }
            }
            else if (type == 1) {
                if (touch.began && ev.button == touch.downButton) {
                    touch.end();
                    this._touches.length = 0;
                    touch.event.button = ev.button;
                    if (InputManager.mouseEventsEnabled) {
                        if (ev.button == 0)
                            touch.bubble(Event.MOUSE_UP);
                        else
                            touch.bubble(Event.RIGHT_MOUSE_UP);
                        if (touch.moved) {
                            for (let t of touch.downTargets)
                                t.event(Event.MOUSE_DRAG_END, touch.event);
                        }
                        let clickTarget = touch.clickTest();
                        if (clickTarget) {
                            if (ev.button == 0) {
                                touch.event.isDblClick = touch.clickCount == 2;
                                touch.bubble(Event.CLICK, clickTarget);
                                if (touch.clickCount == 2)
                                    touch.bubble(Event.DOUBLE_CLICK, clickTarget);
                                touch.event.isDblClick = false;
                            }
                            else {
                                touch.event.isDblClick = touch.clickCount == 2;
                                touch.bubble(Event.RIGHT_CLICK, clickTarget);
                                touch.event.isDblClick = false;
                            }
                        }
                    }
                    touch.event.button = 0;
                }
            }
            else if (type == 4) {
                if (InputManager.mouseEventsEnabled) {
                    touch.event.delta = ev.deltaY * 0.025;
                    touch.bubble(Event.MOUSE_WHEEL);
                    touch.event.delta = 0;
                }
            }
        }
        handleTouch(ev, type) {
            this._eventType = type;
            this._nativeEvent = ev;
            this._lastTouchTime = performance.now();
            let touches = ev.changedTouches;
            for (let i = 0; i < touches.length; ++i) {
                let uTouch = touches[i];
                if (!InputManager.multiTouchEnabled
                    && this._touches.length > 0
                    && this._touches[0].touchId != uTouch.identifier)
                    continue;
                _tempPoint.setTo(uTouch.pageX, uTouch.pageY);
                this._stage._canvasTransform.invertTransformPoint(_tempPoint);
                InputManager.mouseX = _tempPoint.x;
                InputManager.mouseY = _tempPoint.y;
                let x = _tempPoint.x / this._stage.clientScaleX;
                let y = _tempPoint.y / this._stage.clientScaleY;
                let touch = this.getTouch(uTouch.identifier, type == 0);
                if (!touch)
                    continue;
                touch.event.nativeEvent = ev;
                touch.event.touchId = touch.touchId;
                InputManager.lastTouchId = touch.touchId;
                if (type == 3 || !InputManager.mouseEventsEnabled)
                    touch.target = this._touchTarget = null;
                else {
                    touch.target = this._touchTarget = this.getNodeUnderPoint(x, y);
                    InputManager.lastMouseTime = this._lastTouchTime;
                    let ix = Math.round(x);
                    let iy = Math.round(y);
                    if (Math.abs(ix - touch.pos.x) > 1.5 || Math.abs(iy - touch.pos.y) > 1.5) {
                        touch.pos.setTo(ix, iy);
                        if (type == 2) {
                            touch.move();
                            if (InputManager.mouseEventsEnabled) {
                                touch.bubble(Event.MOUSE_MOVE);
                                for (let t of touch.downTargets) {
                                    touch.event._stopped = false;
                                    t.event(Event.MOUSE_DRAG, touch.event);
                                    if (touch.event._stopped)
                                        break;
                                }
                            }
                        }
                    }
                }
                if (touch.lastRollOver != touch.target)
                    this.handleRollOver(touch);
                if (type == 0) {
                    if (!touch.began) {
                        touch.begin();
                        InputManager.onMouseDownCapture.invoke(touch.touchId);
                        if (InputManager.mouseEventsEnabled) {
                            touch.bubble(Event.MOUSE_DOWN);
                        }
                    }
                }
                else if (type == 1 || type == 3) {
                    if (touch.began) {
                        touch.end();
                        if (InputManager.mouseEventsEnabled) {
                            touch.bubble(Event.MOUSE_UP);
                            if (touch.moved) {
                                for (let t of touch.downTargets)
                                    t.event(Event.MOUSE_DRAG_END, touch.event);
                            }
                            if (type != 3) {
                                let clickTarget = touch.clickTest();
                                if (clickTarget != null) {
                                    touch.event.isDblClick = touch.clickCount == 2;
                                    touch.bubble(Event.CLICK, clickTarget);
                                    if (touch.clickCount == 2)
                                        touch.bubble(Event.DOUBLE_CLICK, clickTarget);
                                    touch.event.isDblClick = false;
                                }
                            }
                        }
                        touch.target = null;
                        this.handleRollOver(touch);
                    }
                    touch.reset();
                    this._touches.splice(this._touches.indexOf(touch), 1);
                    this._touchPool.push(touch);
                }
            }
        }
        getTouch(touchId, shouldCreate) {
            let touch = this._touches.find(e => e.touchId == touchId);
            if (touch || !shouldCreate)
                return touch;
            touch = this._touchPool.length > 0 ? this._touchPool.pop() : new TouchInfo(this._touches);
            touch.touchId = touchId;
            this._touches.push(touch);
            return touch;
        }
        handleKeys(ev) {
            let type = ev.type;
            let keyCode = ev.keyCode;
            if (type === "keydown") {
                if (keyCode != 0)
                    this._pressKeys.add(keyCode);
                this._pressKeys.add(ev.key);
            }
            else if (type === "keyup") {
                if (keyCode != 0)
                    this._pressKeys.delete(keyCode);
                this._pressKeys.delete(ev.key);
            }
            this._keyEvent.nativeEvent = ev;
            this._keyEvent._defaultPrevented = false;
            if (InputManager.keyEventsEnabled) {
                let target = (this._stage.focus && this._stage.focus.displayedInStage) ? this._stage.focus : this._stage;
                let ct = target;
                while (ct) {
                    ct.event(type, this._keyEvent.setTo(type, ct, target));
                    ct = ct._parent;
                }
            }
            if (this._keyEvent._defaultPrevented)
                ev.preventDefault();
            this._keyEvent.nativeEvent = null;
        }
        getNodeUnderPoint(x, y) {
            let target = this.getSpriteUnderPoint(this._stage, x, y);
            if (!target)
                target = this.getSprite3DUnderPoint(x, y);
            return target || this._stage;
        }
        getSpriteUnderPoint(sp, x, y) {
            if ((sp._renderType & SpriteConst.AREA2D) !== 0 && LayaEnv.isPlaying) {
                sp.localToView(x, y, Point.TEMP);
                x = Point.TEMP.x;
                y = Point.TEMP.y;
            }
            let scrollRect = sp._scrollRect;
            if (scrollRect && !sp._getBit(NodeFlags.DISABLE_INNER_CLIPPING)) {
                _tempRect.setTo(scrollRect.x, scrollRect.y, scrollRect.width, scrollRect.height);
                if (!_tempRect.contains(x, y))
                    return null;
            }
            let editing = sp._getBit(NodeFlags.EDITING_NODE);
            if (!editing && sp.hitTestPrior && !sp.mouseThrough && sp != this._stage && !this.hitTest(sp, x, y))
                return null;
            for (let i = sp._children.length - 1; i > -1; i--) {
                let child = sp._children[i];
                let childEditing = editing || child._getBit(NodeFlags.EDITING_NODE);
                if (!child._destroyed
                    && child._nodeType !== 1
                    && (childEditing ? ((!child.hasHideFlag(HideFlags.HideInHierarchy) || child.mouseThrough) && !child._getBit(NodeFlags.HIDE_BY_EDITOR))
                        : (child._mouseState === 2 || child._mouseState === 0 && child._getBit(NodeFlags.CHECK_INPUT)))
                    && child._struct.enabled) {
                    _tempPoint.setTo(x, y);
                    child.fromParentPoint(_tempPoint);
                    let ret = this.getSpriteUnderPoint(child, _tempPoint.x, _tempPoint.y);
                    if (ret)
                        return ret;
                }
            }
            if (editing) {
                if (!sp._getBit(NodeFlags.LOCK_BY_EDITOR)
                    && !sp.hasHideFlag(HideFlags.HideInHierarchy)
                    && this.hitTest(sp, x, y, editing))
                    return sp;
            }
            else if (sp != this._stage) {
                if (sp.hitTestPrior && !sp.mouseThrough || this.hitTest(sp, x, y))
                    return sp;
            }
            return null;
        }
        getSprite3DUnderPoint(x, y) {
            return null;
        }
        hitTest(sp, x, y, editing) {
            let isHit = false;
            if (sp._scrollRect) {
                x -= sp._scrollRect.x;
                y -= sp._scrollRect.y;
            }
            let hitArea = sp._hitArea;
            let mouseThrough = sp.mouseThrough;
            if (editing) {
                hitArea = null;
                mouseThrough = false;
            }
            if (hitArea) {
                return hitArea.contains(x, y, sp);
            }
            if (sp.width > 0 && sp.height > 0 || mouseThrough || hitArea) {
                if (!mouseThrough)
                    isHit = (hitArea ? hitArea : _tempRect.setTo(0, 0, sp.width, sp.height)).contains(x, y, sp);
                else
                    isHit = sp.getGraphicBounds(false, Rectangle.TEMP).contains(x, y);
            }
            return isHit;
        }
        handleRollOver(touch) {
            if (!InputManager.mouseEventsEnabled) {
                touch.lastRollOver = touch.target;
                return;
            }
            _rollOverChain.length = 0;
            _rollOutChain.length = 0;
            let ele = touch.lastRollOver;
            while (ele) {
                _rollOutChain.push(ele);
                ele = ele._parent;
            }
            touch.lastRollOver = touch.target;
            ele = touch.target;
            while (ele) {
                let i = _rollOutChain.indexOf(ele);
                if (i != -1) {
                    _rollOutChain.splice(i, _rollOutChain.length - i);
                    break;
                }
                _rollOverChain.push(ele);
                ele = ele._parent;
            }
            let cnt = _rollOutChain.length;
            if (cnt > 0) {
                for (let i = 0; i < cnt; i++) {
                    ele = _rollOutChain[i];
                    if (!ele._destroyed)
                        ele.event(Event.MOUSE_OUT, touch.event.setTo(Event.MOUSE_OUT, ele, ele));
                }
                _rollOutChain.length = 0;
            }
            cnt = _rollOverChain.length;
            if (cnt > 0) {
                for (let i = 0; i < cnt; i++) {
                    ele = _rollOverChain[i];
                    if (ele.activeInHierarchy)
                        ele.event(Event.MOUSE_OVER, touch.event.setTo(Event.MOUSE_OVER, ele, ele));
                }
                _rollOverChain.length = 0;
            }
        }
    }
    InputManager.multiTouchEnabled = true;
    InputManager.mouseEventsEnabled = true;
    InputManager.keyEventsEnabled = true;
    InputManager.clickTestThreshold = 10;
    InputManager.mouseX = 0;
    InputManager.mouseY = 0;
    InputManager.lastMouseTime = 0;
    InputManager.lastTouchId = 0;
    InputManager.onMouseDownCapture = new Delegate();
    const clickTrack = {};
    class TouchInfo {
        constructor(touches) {
            this.downPos = new Point();
            this.downTargets = [];
            this.bubbleChain = [];
            this.event = new Event();
            this.event._touches = touches;
            this.pos = this.event.touchPos;
            this.touchId = 0;
            this.reset();
        }
        begin() {
            this.began = true;
            this.clickCancelled = false;
            this.moved = false;
            this.downPos.copy(this.pos);
            this.downTargets.length = 0;
            if (this.target) {
                let ele = this.target;
                while (ele) {
                    this.downTargets.push(ele);
                    ele = ele._parent;
                }
            }
        }
        move() {
            this.moved = true;
            let ox = Math.abs(this.pos.x - this.downPos.x) * ILaya.stage._canvasTransform.getScaleX();
            let oy = Math.abs(this.pos.y - this.downPos.y) * ILaya.stage._canvasTransform.getScaleY();
            if (ox > InputManager.clickTestThreshold || oy > InputManager.clickTestThreshold)
                this.clickCancelled = true;
        }
        end() {
            this.began = false;
            let now = performance.now();
            let lastClick = clickTrack[this.touchId];
            if (!lastClick) {
                lastClick = { pos: new Point(), time: 0, button: 0 };
                clickTrack[this.touchId] = lastClick;
            }
            if (this.downTargets.length == 0
                || this.clickCancelled
                || Math.abs(this.pos.x - this.downPos.x) > InputManager.clickTestThreshold
                || Math.abs(this.pos.y - this.downPos.y) > InputManager.clickTestThreshold) {
                this.clickCancelled = true;
                lastClick.time = 0;
                this.clickCount = 1;
            }
            else {
                if (now - lastClick.time < 350
                    && Math.abs(this.pos.x - lastClick.pos.x) < InputManager.clickTestThreshold
                    && Math.abs(this.pos.y - lastClick.pos.y) < InputManager.clickTestThreshold
                    && lastClick.button == this.event.button) {
                    this.clickCount = 2;
                }
                else
                    this.clickCount = 1;
                lastClick.time = now;
                lastClick.pos.copy(this.pos);
                lastClick.button = this.event.button;
            }
        }
        clickTest() {
            if (this.clickCancelled) {
                this.downTargets.length = 0;
                return null;
            }
            let obj = this.downTargets[0];
            if (obj.activeInHierarchy) {
                this.downTargets.length = 0;
                return obj;
            }
            obj = this.target;
            while (obj) {
                let i = this.downTargets.indexOf(obj);
                if (i != -1 && obj.activeInHierarchy)
                    break;
                obj = obj._parent;
            }
            this.downTargets.length = 0;
            return obj;
        }
        reset() {
            this.pos.setTo(0, 0);
            this.touchId = 0;
            this.clickCount = 0;
            this.began = false;
            this.moved = false;
            this.target = null;
            this.downTargets.length = 0;
            this.lastRollOver = null;
            this.clickCancelled = false;
            this.downButton = 0;
        }
        bubble(type, target) {
            let arr = this.bubbleChain;
            arr.length = 0;
            target = target || this.target || ILaya.stage;
            let obj = target;
            while (obj) {
                if (obj.activeInHierarchy)
                    arr.push(obj);
                obj = obj._parent;
            }
            let evt = this.event;
            evt._stopped = false;
            for (let obj of arr) {
                evt.setTo(type, obj, target);
                obj.event(type, evt);
                if (evt._stopped) {
                    if (type === Event.MOUSE_DOWN || type === Event.RIGHT_MOUSE_DOWN) {
                        let i = this.downTargets.indexOf(obj);
                        if (i != -1)
                            this.downTargets.splice(i + 1, this.downTargets.length - i - 1);
                    }
                    break;
                }
            }
            if (type === Event.MOUSE_UP || type === Event.RIGHT_MOUSE_UP) {
                for (let obj of this.downTargets) {
                    if (obj && arr.indexOf(obj) == -1) {
                        evt.setTo(type, obj, target);
                        obj.event(type, evt);
                        if (evt && evt._stopped)
                            break;
                    }
                }
            }
        }
    }

    class ComponentDriver {
        constructor() {
            this._onUpdates = new Set();
            this._onLateUpdates = new Set();
            this._onPreRenders = new Set();
            this._onPostRenders = new Set();
            this._toStarts = new Set();
            this._toDestroys = new Set();
        }
        callStart() {
            for (let ele of this._toStarts) {
                if (ele._status == 2) {
                    ele._status = 3;
                    try {
                        ele.onStart();
                    }
                    catch (err) {
                        this.onError(err);
                    }
                }
            }
            this._toStarts.clear();
        }
        callUpdate() {
            let t = performance.now();
            for (let ele of this._onUpdates) {
                if (ele._status == 3) {
                    try {
                        ele.onUpdate();
                    }
                    catch (err) {
                        this.onError(err);
                    }
                }
            }
            LayaGL.statAgent.recordTimeData(exports.StatElement.T_ScriptUpdateTime, performance.now() - t);
        }
        callLateUpdate() {
            let t = performance.now();
            for (let ele of this._onLateUpdates) {
                if (ele._status == 3) {
                    try {
                        ele.onLateUpdate();
                    }
                    catch (err) {
                        this.onError(err);
                    }
                }
            }
            LayaGL.statAgent.recordTimeData(exports.StatElement.T_ScriptLateUpdateTime, performance.now() - t);
        }
        callPreRender() {
            for (let ele of this._onPreRenders) {
                if (ele._status == 3) {
                    try {
                        ele.onPreRender();
                    }
                    catch (err) {
                        this.onError(err);
                    }
                }
            }
        }
        callPostRender() {
            for (let ele of this._onPostRenders) {
                if (ele._status == 3) {
                    try {
                        ele.onPostRender();
                    }
                    catch (err) {
                        this.onError(err);
                    }
                }
            }
        }
        callDestroy() {
            for (let ele of this._toDestroys) {
                try {
                    ele._destroy(true);
                }
                catch (err) {
                    this.onError(err);
                }
            }
            this._toDestroys.clear();
        }
        add(comp) {
            if (comp._status == 1) {
                if (comp.onStart) {
                    comp._status = 2;
                    this._toStarts.add(comp);
                }
                else
                    comp._status = 3;
            }
            if (comp.onUpdate)
                this._onUpdates.add(comp);
            if (comp.onLateUpdate)
                this._onLateUpdates.add(comp);
            if (comp.onPreRender)
                this._onPreRenders.add(comp);
            if (comp.onPostRender)
                this._onPostRenders.add(comp);
        }
        remove(comp) {
            if (comp._status == 2)
                comp._status = 1;
            if (comp.onUpdate)
                this._onUpdates.delete(comp);
            if (comp.onLateUpdate)
                this._onLateUpdates.delete(comp);
            if (comp.onPreRender)
                this._onPreRenders.delete(comp);
            if (comp.onPostRender)
                this._onPostRenders.delete(comp);
        }
        destroy() {
        }
        onError(err) {
            console.error(err);
        }
    }

    class Timer {
        constructor(autoActive, greedyMode) {
            this.scale = 1;
            this.currFrame = 0;
            this.delta = 0;
            this.unscaledDelta = 0;
            this._map = {};
            this._handlers = [];
            (autoActive || autoActive == null) && Timer.gSysTimer && Timer.gSysTimer.frameLoop(1, this, this._update);
            this.currTimer = performance.now();
            this._lastTimer = performance.now();
            this._greedy = !!greedyMode;
        }
        get totalTime() {
            return this._lastTimer;
        }
        _update(timestamp) {
            if (timestamp == null)
                timestamp = performance.now();
            if (this.scale <= 0) {
                this._lastTimer = timestamp;
                this.delta = 0;
                return;
            }
            let frame = this.currFrame = this.currFrame + this.scale;
            this.unscaledDelta = timestamp - this._lastTimer;
            let awake = this.unscaledDelta > 30000;
            this.delta = this.unscaledDelta * this.scale;
            let timer = this.currTimer = this.currTimer + this.delta;
            this._lastTimer = timestamp;
            let handlers = this._handlers;
            let killed = 0;
            for (let i = 0, n = handlers.length - 1; i <= n; i++) {
                let handler = handlers[i];
                if (handler.method) {
                    let t = handler.userFrame ? frame : timer;
                    if (t >= handler.exeTime) {
                        if (handler.repeat) {
                            if (!handler.jumpFrame || awake) {
                                handler.exeTime += handler.delay;
                                handler.run(false);
                                if (t > handler.exeTime) {
                                    handler.exeTime += Math.ceil((t - handler.exeTime) / handler.delay) * handler.delay;
                                }
                            }
                            else {
                                while (t >= handler.exeTime) {
                                    handler.exeTime += handler.delay;
                                    handler.run(false);
                                }
                            }
                        }
                        else {
                            handler.run(true);
                        }
                    }
                }
                else
                    killed++;
                i === n && this._greedy && (n = handlers.length - 1);
            }
            if (killed > 30 || frame % 200 === 0)
                this._clearHandlers();
        }
        _clearHandlers() {
            let handlers = this._handlers;
            let j = 0;
            for (let i = 0, n = handlers.length; i < n; i++) {
                let handler = handlers[i];
                if (handler.method !== null) {
                    if (j !== i)
                        handlers[j++] = handler;
                    else
                        j++;
                }
                else {
                    if (this._map[handler.key] == handler)
                        delete this._map[handler.key];
                    handler.clear();
                    Timer._pool.push(handler);
                }
            }
            handlers.length = j;
        }
        _create(useFrame, repeat, delay, caller, method, args, coverBefore) {
            let key = Utils.getGID(caller, method);
            if (coverBefore == null || coverBefore) {
                let handler = this._map[key];
                if (handler) {
                    handler.repeat = repeat;
                    handler.userFrame = useFrame;
                    handler.delay = delay;
                    handler.caller = caller;
                    handler.method = method;
                    handler.args = args;
                    handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + performance.now() - this._lastTimer);
                    return handler;
                }
            }
            let handler = Timer._pool.length > 0 ? Timer._pool.pop() : new TimerHandler();
            handler.key = key;
            handler.repeat = repeat;
            handler.userFrame = useFrame;
            handler.delay = delay;
            handler.caller = caller;
            handler.method = method;
            handler.args = args;
            handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + performance.now() - this._lastTimer);
            this._map[key] = handler;
            this._handlers.push(handler);
            return handler;
        }
        once(delay, caller, method, args, coverBefore) {
            this._create(false, false, delay, caller, method, args, coverBefore);
        }
        loop(delay, caller, method, args, coverBefore, jumpFrame) {
            let handler = this._create(false, true, delay, caller, method, args, coverBefore);
            if (handler)
                handler.jumpFrame = jumpFrame;
        }
        frameOnce(delay, caller, method, args, coverBefore) {
            this._create(true, false, delay, caller, method, args, coverBefore);
        }
        frameLoop(delay, caller, method, args, coverBefore) {
            this._create(true, true, delay, caller, method, args, coverBefore);
        }
        toString() {
            return " handlers:" + this._handlers.length + " pool:" + Timer._pool.length;
        }
        clear(caller, method) {
            let handler = this._map[Utils.getGID(caller, method)];
            if (handler) {
                handler.clear();
            }
        }
        clearAll(caller) {
            if (!caller)
                return;
            for (let i = 0, n = this._handlers.length; i < n; i++) {
                let handler = this._handlers[i];
                if (handler.caller === caller) {
                    handler.clear();
                }
            }
        }
        callLater(caller, method, args) {
            Timer.callLaters._create(false, false, 0, caller, method, args, true).exeTime = 0;
        }
        runCallLater(caller, method, forceRun) {
            if (!Timer.callLaters.runTimer(caller, method) && forceRun)
                method.apply(caller);
        }
        clearCallLater(caller, method) {
            Timer.callLaters.clear(caller, method);
        }
        runTimer(caller, method) {
            let handler = this._map[Utils.getGID(caller, method)];
            if (handler && handler.method != null) {
                this._map[handler.key] = null;
                handler.run(true);
                return true;
            }
            else
                return false;
        }
        pause() {
            this.scale = 0;
        }
        resume() {
            this.scale = 1;
        }
        destroy() {
            for (let i = 0, n = this._handlers.length; i < n; i++) {
                let handler = this._handlers[i];
                handler.clear();
            }
            this._handlers.length = 0;
        }
    }
    Timer.gSysTimer = null;
    Timer.callLaters = new Timer(false, true);
    Timer._pool = [];
    class TimerHandler {
        clear() {
            this.caller = null;
            this.method = null;
            this.args = null;
        }
        run(withClear) {
            let caller = this.caller;
            if (caller && caller.destroyed)
                return this.clear();
            let method = this.method;
            let args = this.args;
            withClear && this.clear();
            if (method == null)
                return;
            args ? method.apply(caller, args) : method.call(caller);
        }
    }

    class Stage extends Sprite {
        constructor() {
            super();
            this.offset = new Point();
            this.designWidth = 0;
            this.designHeight = 0;
            this.canvasRotation = false;
            this.canvasDegree = 0;
            this.renderingEnabled = true;
            this.screenAdaptationEnabled = true;
            this._canvasTransform = new Matrix();
            this._scene3Ds = [];
            this._scene2Ds = [];
            this._frameRate = "fast";
            this._screenMode = "none";
            this._scaleMode = "noscale";
            this._alignV = "top";
            this._alignH = "left";
            this._bgColor = "gray";
            this._renderCount = 0;
            this._frameStartTime = 0;
            this._wgColor = new Color(0, 0, 0, 0);
            this._needUpdateCanvasSize = false;
            this._graphicUpdateList = new Set();
            this._subpassUpdateList = new Set();
            this._tranMatrixUpdateList = new Set();
            this.mouseEnabled = true;
            this.hitTestPrior = true;
            this._setBit(NodeFlags.DISPLAYED_INSTAGE, true);
            this._setBit(NodeFlags.ACTIVE_INHIERARCHY, true);
            this._isFocused = true;
            this._transform = new Matrix();
            this._componentDriver = new ComponentDriver();
            this.passManager = new Render2DProcessor();
            PAL.browser.on(Event.FOCUS, () => {
                if (!this._isFocused) {
                    this._isFocused = true;
                    this.event(Event.FOCUS);
                    this.event(Event.FOCUS_CHANGE);
                }
            });
            PAL.browser.on(Event.BLUR, () => {
                if (this._isFocused) {
                    this._isFocused = false;
                    this.event(Event.BLUR);
                    this.event(Event.FOCUS_CHANGE);
                }
            });
            PAL.browser.on(Event.VISIBILITY_CHANGE, (visible) => {
                this.renderingEnabled = visible;
                this.event(Event.VISIBILITY_CHANGE, visible);
            });
            PAL.browser.on(Event.RESIZE, () => {
                if (PAL.textInput.target)
                    return;
                if (this.screenAdaptationEnabled) {
                    this.event(Event.WILL_RESIZE);
                    this.updateCanvasSize(true);
                }
            });
            PAL.browser.on(Event.ORIENTATION_CHANGE, (e) => {
                if (this.screenAdaptationEnabled) {
                    this.event(Event.WILL_RESIZE);
                    this.updateCanvasSize(true);
                }
            });
            this.passManager.basePass.root = this._struct;
            this._struct.pass = this.passManager.basePass;
        }
        _transChanged(kind) {
            super._transChanged(kind);
            if ((kind & exports.TransformKind.Size) != 0) {
                this.designWidth = this._width;
                this.designHeight = this._height;
                this.updateCanvasSize(true);
            }
        }
        measureWidth() {
            this.needUpdateCanvasSize();
            return this._width;
        }
        measureHeight() {
            this.needUpdateCanvasSize();
            return this._height;
        }
        get isFocused() {
            return this._isFocused;
        }
        get isVisibility() {
            return PAL.browser.getVisibility();
        }
        updateCanvasSize(delay) {
            if (delay) {
                if (!this._needUpdateCanvasSize) {
                    this._needUpdateCanvasSize = true;
                    ILaya.systemTimer.callLater(this, this.updateCanvasSize);
                }
            }
            else {
                this.setScreenSize(Browser.clientWidth * Browser.pixelRatio, Browser.clientHeight * Browser.pixelRatio);
            }
        }
        needUpdateCanvasSize() {
            if (this._needUpdateCanvasSize)
                this.updateCanvasSize();
        }
        setScreenSize(screenWidth, screenHeight) {
            var _a;
            this._needUpdateCanvasSize = false;
            let pixelRatio = Browser.pixelRatio;
            screenWidth /= pixelRatio;
            screenHeight /= pixelRatio;
            if (this._screenMode !== Stage.SCREEN_NONE) {
                let screenType = screenWidth / screenHeight < 1 ? Stage.SCREEN_VERTICAL : Stage.SCREEN_HORIZONTAL;
                this.canvasRotation = screenType !== this._screenMode;
                if (this.canvasRotation) {
                    let temp = screenHeight;
                    screenHeight = screenWidth;
                    screenWidth = temp;
                }
            }
            else
                this.canvasRotation = false;
            let canvas = Browser.mainCanvas;
            let mat = this._canvasTransform.identity();
            let scaleMode = this._scaleMode;
            let canvasWidth = this.designWidth;
            let canvasHeight = this.designHeight;
            let canvasScale = 1;
            if (!Browser.isDomSupported
                && (scaleMode === Stage.SCALE_NOSCALE || scaleMode == Stage.SCALE_SHOWALL || scaleMode === Stage.SCALE_NOBORDER)) {
                scaleMode = Stage.SCALE_FIXED_AUTO;
            }
            switch (scaleMode) {
                case Stage.SCALE_NOSCALE:
                    break;
                case Stage.SCALE_FULL:
                    canvasWidth = screenWidth;
                    canvasHeight = screenHeight;
                    break;
                case Stage.SCALE_SHOWALL:
                    canvasScale = Math.min(screenWidth / canvasWidth, screenHeight / canvasHeight);
                    break;
                case Stage.SCALE_NOBORDER:
                    canvasScale = Math.max(screenWidth / canvasWidth, screenHeight / canvasHeight);
                    break;
                case Stage.SCALE_FIXED_WIDTH:
                case Stage.SCALE_FIXED_HEIGHT:
                case Stage.SCALE_FIXED_AUTO:
                    if (scaleMode === Stage.SCALE_FIXED_WIDTH
                        || scaleMode === Stage.SCALE_FIXED_AUTO && (screenWidth / screenHeight) < (canvasWidth / canvasHeight)) {
                        canvasScale = screenWidth / canvasWidth;
                        canvasHeight = screenHeight / canvasScale;
                    }
                    else {
                        canvasScale = screenHeight / canvasHeight;
                        canvasWidth = screenWidth / canvasScale;
                    }
                    break;
            }
            this._width = canvasWidth;
            this._height = canvasHeight;
            if (Config.useRetinalCanvas || !Browser.isDomSupported) {
                canvasWidth *= canvasScale;
                canvasHeight *= canvasScale;
                canvasScale = 1;
                if (pixelRatio > 4 && Browser.isDomSupported)
                    pixelRatio = 4;
                canvasWidth *= pixelRatio;
                canvasHeight *= pixelRatio;
                canvasScale /= pixelRatio;
            }
            mat.scale(canvasScale, canvasScale);
            if (Browser.isDomSupported) {
                let offsetX = 0;
                let offsetY = 0;
                if (this._alignH === Stage.ALIGN_LEFT)
                    offsetX = 0;
                else if (this._alignH === Stage.ALIGN_RIGHT)
                    offsetX = screenWidth - canvasWidth * canvasScale;
                else
                    offsetX = (screenWidth - canvasWidth * canvasScale) * 0.5;
                if (this._alignV === Stage.ALIGN_TOP)
                    offsetY = 0;
                else if (this._alignV === Stage.ALIGN_BOTTOM)
                    offsetY = screenHeight - canvasHeight * canvasScale;
                else
                    offsetY = (screenHeight - canvasHeight * canvasScale) * 0.5;
                offsetX += this.offset.x;
                offsetY += this.offset.y;
                mat.translate(Math.round(offsetX), Math.round(offsetY));
            }
            if (this.canvasRotation) {
                if (this._screenMode === Stage.SCREEN_HORIZONTAL) {
                    mat.rotate(Math.PI / 2);
                    mat.translate(screenHeight, 0);
                    this.canvasDegree = 90;
                }
                else {
                    mat.rotate(-Math.PI / 2);
                    mat.translate(0, screenWidth);
                    this.canvasDegree = -90;
                }
            }
            else
                this.canvasDegree = 0;
            mat.a = formatData(mat.a);
            mat.d = formatData(mat.d);
            mat.tx = formatData(mat.tx);
            mat.ty = formatData(mat.ty);
            canvasWidth = Math.round(canvasWidth);
            canvasHeight = Math.round(canvasHeight);
            canvas.size(canvasWidth, canvasHeight);
            if (Browser.isDomSupported) {
                let canvasStyle = Browser.mainCanvas.source.style;
                PAL.browser.setStyleTransformOrigin(canvasStyle, "0px 0px 0px");
                PAL.browser.setStyleTransform(canvasStyle, "matrix(" + mat.toString() + ")");
                canvasStyle.width = canvasWidth + "px";
                canvasStyle.height = canvasHeight + "px";
                mat.translate(parseInt(canvasStyle.left) || 0, parseInt(canvasStyle.top) || 0);
            }
            this.scale(formatData(canvasWidth / this._width), formatData(canvasHeight / this._height));
            RenderState2D.width = canvasWidth;
            RenderState2D.height = canvasHeight;
            (_a = window['Laya3D']) === null || _a === void 0 ? void 0 : _a._changeWebGLSize(canvasWidth, canvasHeight);
            LayaGL.renderEngine.resizeOffScreen(canvasWidth, canvasHeight);
            if (TextRenderConfig.scaleFontWithCtx) {
                let fontScale = Math.min(Math.max(1, ILaya.stage.scaleX, ILaya.stage.scaleY), TextRenderConfig.maxFontScale);
                fontScale = 0.2 * Math.ceil(fontScale / 0.2);
                if (TextRenderConfig.fontScale !== fontScale) {
                    TextRenderConfig.fontScale = fontScale;
                    Render2DProcessor.runner._textRender.onFontScaleChanged();
                    const repaintTexts = (p) => {
                        for (let child of p._children) {
                            if ((child._renderType & SpriteConst.TEXT) !== 0)
                                child.repaint();
                        }
                    };
                    repaintTexts(this);
                }
            }
            this.visible = true;
            this.repaint();
            this.event(Event.RESIZE);
        }
        get scaleMode() {
            return this._scaleMode;
        }
        set scaleMode(value) {
            this._scaleMode = value;
            this.updateCanvasSize(true);
        }
        get alignH() {
            this.needUpdateCanvasSize();
            return this._alignH;
        }
        set alignH(value) {
            this._alignH = value;
            this.updateCanvasSize(true);
        }
        get alignV() {
            this.needUpdateCanvasSize();
            return this._alignV;
        }
        set alignV(value) {
            this._alignV = value;
            this.updateCanvasSize(true);
        }
        get bgColor() {
            return this._bgColor;
        }
        set bgColor(value) {
            this._bgColor = value;
            if (value) {
                let colorArr = ColorUtils.create(value).arrColor;
                this._wgColor.setValue(colorArr[0], colorArr[1], colorArr[2], colorArr[3]);
            }
            else
                this._wgColor.setValue(0, 0, 0, 0);
            if (Browser.isDomSupported)
                Browser.mainCanvas.source.style.background = value !== null && value !== void 0 ? value : "none";
        }
        get mouseX() {
            return Math.round(InputManager.mouseX / this.clientScaleX);
        }
        get mouseY() {
            return Math.round(InputManager.mouseY / this.clientScaleY);
        }
        getMousePoint() {
            return Point.TEMP.setTo(this.mouseX, this.mouseY);
        }
        get clientScaleX() {
            this.needUpdateCanvasSize();
            return this._scaleX;
        }
        get clientScaleY() {
            this.needUpdateCanvasSize();
            return this._scaleY;
        }
        get screenMode() {
            return this._screenMode;
        }
        set screenMode(value) {
            this._screenMode = value;
        }
        getTimeFromFrameStart() {
            return performance.now() - this._frameStartTime;
        }
        get visible() {
            return super.visible;
        }
        set visible(value) {
            super.visible = value;
            if (Browser.isDomSupported)
                Browser.mainCanvas.source.style.visibility = value ? "visible" : "hidden";
        }
        render(timestamp) {
            if (this._frameRate === Stage.FRAME_SLEEP) {
                if (timestamp - this._frameStartTime < 1000)
                    return;
                this._frameStartTime = timestamp;
            }
            else {
                if (!this._visible) {
                    this._renderCount++;
                    if (this._renderCount % 5 === 0) {
                        Timer.callLaters._update(timestamp);
                        Stat.loopCount++;
                        this._runComponents();
                        this._updateTimers(timestamp);
                    }
                    return;
                }
                this._frameStartTime = timestamp;
            }
            this._renderCount++;
            let frameMode = this._frameRate === Stage.FRAME_MOUSE ? (((timestamp - InputManager.lastMouseTime) < 2000) ? Stage.FRAME_FAST : Stage.FRAME_SLOW) : this._frameRate;
            let isFastMode = (frameMode !== Stage.FRAME_SLOW);
            let isDoubleLoop = (this._renderCount % 2 === 0);
            if (!isFastMode && !isDoubleLoop)
                return;
            Timer.callLaters._update(timestamp);
            Stat.loopCount++;
            LayaGL.renderEngine.startFrame();
            if (this.renderingEnabled) {
                this._runComponents();
                for (let i = 0, n = this._scene2Ds.length; i < n; i++) {
                    this._scene2Ds[i]._update();
                }
                for (let i = 0, n = this._scene3Ds.length; i < n; i++) {
                    this._scene3Ds[i]._update();
                }
                this._componentDriver.callPreRender();
                Render2DProcessor.rendercontext2D.setRenderTarget(null, true, this._wgColor);
                let t = performance.now();
                for (let i = 0, n = this._scene3Ds.length; i < n; i++)
                    this._scene3Ds[i].renderSubmit();
                LayaGL.statAgent.recordTimeData(exports.StatElement.T_AllRender3D, performance.now() - t);
                t = performance.now();
                this._render2d();
                LayaGL.statAgent.recordTimeData(exports.StatElement.T_AllRender2D, performance.now() - t);
                this._componentDriver.callPostRender();
            }
            else
                this._runComponents();
            this._updateTimers(timestamp);
            Stat.render();
            LayaGL.renderEngine.endFrame();
        }
        _render2d() {
            for (let i = 0, n = this._scene2Ds.length; i < n; i++) {
                this._scene2Ds[i].render(0, 0);
            }
            for (let sprite of this._subpassUpdateList) {
                if (sprite._destroyed || !sprite._subpassUpdateFlag)
                    continue;
                sprite.updateSubRenderPassState();
                if (!sprite._oriRenderPass
                    || !sprite._oriRenderPass.enable) {
                    sprite._subpassUpdateFlag = 0;
                    continue;
                }
                let result = sprite.updateRenderTexture();
                let destrt = sprite._drawOriRT;
                if (!destrt) {
                    sprite.setSubRenderPassState(false);
                    continue;
                }
                if (sprite.mask) {
                    sprite._oriRenderPass.mask = sprite.mask._struct;
                }
                else {
                    sprite._oriRenderPass.mask = null;
                }
                if (result) {
                    sprite._oriRenderPass.renderTexture = destrt;
                }
                let process = sprite._renderType & SpriteConst.POSTPROCESS ? sprite._oriRenderPass.postProcess : null;
                if (process && destrt != RenderTexture2D._empty) {
                    if (result ||
                        (sprite._subpassUpdateFlag & exports.SubPassFlag.UPDATE_POSTPROCESS)) {
                        process.setResource(destrt);
                        process.clearCMD();
                        process._render();
                    }
                    if (process.enabled) {
                        destrt = process._context.destination;
                    }
                }
                sprite._subStructRender._updateRenderTexture(sprite._drawOriRT, destrt);
                sprite._subpassUpdateFlag = 0;
            }
            this._updateMatrixList(this._tranMatrixUpdateList, Stat.loopCount);
            for (let sprite of this._graphicUpdateList) {
                if (sprite._needGraphicsUpdate()) {
                    sprite._graphics._render(Render2DProcessor.runner);
                }
            }
            this.passManager.apply(Render2DProcessor.rendercontext2D);
            this._graphicUpdateList.clear();
            this._subpassUpdateList.clear();
            this._tranMatrixUpdateList.clear();
            RenderTexture2D.cleanupExpired();
            Stat.render2DCount++;
        }
        _updateMatrixList(changeMatrixList, frame) {
            for (let sprite of changeMatrixList) {
                sprite._updateStruct();
            }
        }
        _runComponents() {
            this._componentDriver.callStart();
            this._componentDriver.callUpdate();
            this._componentDriver.callLateUpdate();
            this._componentDriver.callDestroy();
        }
        _updateTimers(timestamp) {
            ILaya.systemTimer._update(timestamp);
            ILaya.physicsTimer._update(timestamp);
            ILaya.timer._update(timestamp);
            Tweener._runAll();
        }
        set fullScreenEnabled(value) {
            let canvas = Browser.mainCanvas.source;
            if (value) {
                canvas.addEventListener('mousedown', requestFullscreen);
                canvas.addEventListener('touchstart', requestFullscreen);
                PAL.browser.on("fullscreenchange", this, this.fullScreenChanged);
            }
            else {
                canvas.removeEventListener('mousedown', requestFullscreen);
                canvas.removeEventListener('touchstart', requestFullscreen);
                PAL.browser.off("fullscreenchange", this, this.fullScreenChanged);
            }
        }
        fullScreenChanged() {
            this.event(Event.FULL_SCREEN_CHANGE);
        }
        exitFullscreen() {
            PAL.browser.exitFullscreen();
        }
        get frameRate() {
            return this._frameRate;
        }
        set frameRate(value) {
            this._frameRate = value;
        }
    }
    Stage.SCALE_NOSCALE = "noscale";
    Stage.SCALE_SHOWALL = "showall";
    Stage.SCALE_NOBORDER = "noborder";
    Stage.SCALE_FULL = "full";
    Stage.SCALE_FIXED_WIDTH = "fixedwidth";
    Stage.SCALE_FIXED_HEIGHT = "fixedheight";
    Stage.SCALE_FIXED_AUTO = "fixedauto";
    Stage.ALIGN_LEFT = "left";
    Stage.ALIGN_RIGHT = "right";
    Stage.ALIGN_CENTER = "center";
    Stage.ALIGN_TOP = "top";
    Stage.ALIGN_MIDDLE = "middle";
    Stage.ALIGN_BOTTOM = "bottom";
    Stage.SCREEN_NONE = "none";
    Stage.SCREEN_HORIZONTAL = "horizontal";
    Stage.SCREEN_VERTICAL = "vertical";
    Stage.FRAME_FAST = "fast";
    Stage.FRAME_SLOW = "slow";
    Stage.FRAME_MOUSE = "mouse";
    Stage.FRAME_SLEEP = "sleep";
    function requestFullscreen() {
        PAL.browser.requestFullscreen();
        let canvas = Browser.mainCanvas.source;
        canvas.removeEventListener('mousedown', requestFullscreen);
        canvas.removeEventListener('touchstart', requestFullscreen);
    }
    function formatData(value) {
        if (Math.abs(value) < 0.000001)
            return 0;
        if (Math.abs(1 - value) < 0.001)
            return value > 0 ? 1 : -1;
        return value;
    }

    class Render {
        static __init__() {
            Render.frameInterval = 1000 / Config.FPS;
            let timeId = 0;
            PAL.browser.on("visibilitychange", (visible) => {
                if (!visible)
                    timeId = window.setInterval(Render.loop, 1000);
                else if (timeId != 0)
                    window.clearInterval(timeId);
            });
            Render.startLoop();
        }
        static startLoop() {
            let requestFrame = PAL.browser.requestFrame;
            let lastTime = null;
            let first = true;
            let startTm = 0;
            let leftTime = 0;
            function loop(timestamp) {
                if (timestamp == null || PAL.g !== null)
                    timestamp = performance.now();
                let interval = Render.frameInterval;
                if (first) {
                    startTm = Math.floor(timestamp / interval) * interval;
                    first = false;
                }
                let delta = leftTime + timestamp - lastTime;
                if (delta + 1 >= interval || !Config.fixedFrames) {
                    leftTime = Math.min(delta - interval, interval);
                    lastTime = timestamp;
                    Render.lastFrame = Math.floor((timestamp - startTm) / interval);
                    Render.loop(timestamp);
                }
                requestFrame(loop);
            }
            requestFrame(loop);
        }
        static loop(timestamp) {
            LayaGL.statAgent.startFrameLogic(timestamp);
            ILaya.stage.render(timestamp);
            LayaGL.statAgent.endFrameLogic(timestamp);
        }
        static vsyncTime() {
            return Render.lastFrame * Render.frameInterval;
        }
        static get canvas() {
            return Browser.mainCanvas.source;
        }
    }
    Render.frameInterval = 1000 / 60;
    Render.lastFrame = 0;

    class Texture2DArray extends BaseTexture {
        static get defaultTexture() {
            return this._defaultTexture;
        }
        static __init__() {
            if (LayaGL.renderEngine.getCapable(exports.RenderCapable.Texture3D)) {
                this._defaultTexture = new Texture2DArray(1, 1, 1, exports.TextureFormat.R8G8B8A8, false, false, false);
                this._defaultTexture.lock = true;
                this._defaultTexture.setPixelsData(new Uint8Array([255, 255, 255, 255]), false, false);
            }
        }
        constructor(width, height, depth, format, mipmap = true, canRead, sRGB = false) {
            super(width, height, format);
            this._dimension = exports.TextureDimension.Texture2DArray;
            this._gammaSpace = sRGB;
            this.depth = depth;
            let context = LayaGL.textureContext;
            this._texture = context.createTexture3DInternal(this._dimension, width, height, depth, format, mipmap, sRGB, false);
            return;
        }
        setImageData(sources, premultiplyAlpha, invertY) {
            let texture = this._texture;
            let context = LayaGL.textureContext;
            context.setTexture3DImageData(texture, sources, this.depth, premultiplyAlpha, invertY);
        }
        setPixelsData(source, premultiplyAlpha, invertY) {
            let texture = this._texture;
            let context = LayaGL.textureContext;
            context.setTexture3DPixelsData(texture, source, this.depth, premultiplyAlpha, invertY);
        }
        setSubPixelsData(xOffset, yOffset, zOffset, width, height, depth, pixels, mipmapLevel, generateMipmap, premultiplyAlpha, invertY) {
            let texture = this._texture;
            let context = LayaGL.textureContext;
            context.setTexture3DSubPixelsData(texture, pixels, mipmapLevel, generateMipmap, xOffset, yOffset, zOffset, width, height, depth, premultiplyAlpha, invertY);
        }
    }

    exports.TextureCubeFace = void 0;
    (function (TextureCubeFace) {
        TextureCubeFace[TextureCubeFace["PositiveX"] = 0] = "PositiveX";
        TextureCubeFace[TextureCubeFace["NegativeX"] = 1] = "NegativeX";
        TextureCubeFace[TextureCubeFace["PositiveY"] = 2] = "PositiveY";
        TextureCubeFace[TextureCubeFace["NegativeY"] = 3] = "NegativeY";
        TextureCubeFace[TextureCubeFace["PositiveZ"] = 4] = "PositiveZ";
        TextureCubeFace[TextureCubeFace["NegativeZ"] = 5] = "NegativeZ";
    })(exports.TextureCubeFace || (exports.TextureCubeFace = {}));
    const DEFAULT_PIXELS = new Uint8Array(4);
    class TextureCube extends BaseTexture {
        static get blackTexture() {
            return TextureCube._blackTexture;
        }
        static get grayTexture() {
            return TextureCube._grayTexture;
        }
        static get whiteTexture() {
            return TextureCube._whiteTexture;
        }
        static get errorTexture() {
            return TextureCube._errorTexture;
        }
        static __init__() {
            var blackTexture = new TextureCube(1, exports.TextureFormat.R8G8B8A8, false);
            var grayTexture = new TextureCube(1, exports.TextureFormat.R8G8B8A8, false);
            var writeTexture = new TextureCube(1, exports.TextureFormat.R8G8B8A8, false);
            var pixels = DEFAULT_PIXELS;
            pixels[0] = 0, pixels[1] = 0, pixels[2] = 0;
            pixels[3] = 255;
            blackTexture.setPixelsData([pixels, pixels, pixels, pixels, pixels, pixels], false, false);
            blackTexture.lock = true;
            pixels[0] = 128, pixels[1] = 128, pixels[2] = 128;
            pixels[3] = 255;
            grayTexture.setPixelsData([pixels, pixels, pixels, pixels, pixels, pixels], false, false);
            grayTexture.lock = true;
            pixels[0] = 255, pixels[1] = 255, pixels[2] = 255;
            pixels[3] = 255;
            writeTexture.setPixelsData([pixels, pixels, pixels, pixels, pixels, pixels], false, false);
            writeTexture.lock = true;
            TextureCube._grayTexture = grayTexture;
            TextureCube._blackTexture = blackTexture;
            TextureCube._whiteTexture = writeTexture;
            TextureCube._errorTexture = writeTexture;
        }
        constructor(size, format, mipmap = true, sRGB = false, premultiplyAlpha = false) {
            super(size, size, format);
            this._dimension = exports.TextureDimension.Cube;
            this._texture = LayaGL.textureContext.createTextureInternal(this._dimension, size, size, format, mipmap, sRGB, premultiplyAlpha);
            return;
        }
        setImageData(source, premultiplyAlpha, invertY) {
            let error = false;
            let k = source.findIndex(s => s != null);
            if (k != -1) {
                let img = source[k];
                if (!source.every(s => s != null && s.width == img.width && s.height == img.height))
                    error = true;
            }
            else
                error = true;
            let texture = this._texture;
            if (!error)
                LayaGL.textureContext.setCubeImageData(texture, source, premultiplyAlpha, invertY);
            else {
                let pixels = DEFAULT_PIXELS;
                LayaGL.textureContext.setCubePixelsData(texture, [pixels, pixels, pixels, pixels, pixels, pixels], premultiplyAlpha, invertY);
            }
        }
        setPixelsData(source, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setCubePixelsData(texture, source, premultiplyAlpha, invertY);
        }
        updateSubPixelsData(source, xOffset, yOffset, width, height, mipmapLevel, generateMipmap, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setCubeSubPixelData(texture, source, mipmapLevel, generateMipmap, xOffset, yOffset, width, height, premultiplyAlpha, invertY);
        }
        setDDSData(ddsInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setCubeDDSData(texture, ddsInfo);
        }
        setKTXData(ktxInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setCubeKTXData(texture, ktxInfo);
        }
        get defaultTexture() {
            return TextureCube.grayTexture;
        }
    }

    class SoundManager {
        static __init__() {
            ILaya.stage.on(Event.BLUR, () => {
                if (mgr.autoStopMusic && mgr._musicChannel && !mgr._musicChannel.paused)
                    PAL.media.resumeUntilGotFocus(mgr._musicChannel);
            });
        }
        static get musicVolume() {
            return mgr._musicVolume;
        }
        static set musicVolume(value) {
            value = MathUtil.clamp(value, 0, 1);
            if (value !== mgr._musicVolume)
                mgr._musicVolume = value;
            if (mgr._musicChannel)
                mgr._musicChannel.volume = value;
        }
        static get soundVolume() {
            return mgr._soundVolume;
        }
        static set soundVolume(value) {
            value = MathUtil.clamp(value, 0, 1);
            if (value !== mgr._soundVolume) {
                mgr._soundVolume = value;
                for (let channel of mgr._channels) {
                    if (channel !== mgr._musicChannel) {
                        channel.volume = channel.volume;
                    }
                }
            }
        }
        static get muted() {
            return mgr._muted;
        }
        static set muted(value) {
            value = !!value;
            if (value !== mgr._muted) {
                mgr._muted = value;
                this.updateMutedStatus();
            }
        }
        static get soundMuted() {
            return mgr._soundMuted;
        }
        static set soundMuted(value) {
            value = !!value;
            if (value !== mgr._soundMuted) {
                mgr._soundMuted = value;
                this.updateMutedStatus();
            }
        }
        static get musicMuted() {
            return mgr._musicMuted;
        }
        static set musicMuted(value) {
            value = !!value;
            if (value !== mgr._musicMuted) {
                mgr._musicMuted = value;
                this.updateMutedStatus();
            }
        }
        static playSound(url, loops, complete, soundClass, startTime) {
            if (!url)
                return null;
            if (typeof (soundClass) === 'number')
                startTime = soundClass;
            let channel = PAL.media.createSoundChannel(url, false);
            channel.loops = loops !== null && loops !== void 0 ? loops : 1;
            channel.startTime = startTime !== null && startTime !== void 0 ? startTime : 0;
            channel.playbackRate = this.playbackRate;
            channel.volume = mgr._soundVolume;
            channel.muted = mgr._soundMuted || mgr._muted;
            channel.completeHandler = complete;
            channel._isMusic = false;
            channel.play();
            return channel;
        }
        static playMusic(url, loops, complete, startTime) {
            if (mgr._musicChannel) {
                mgr._musicChannel.stop();
                mgr._musicChannel = null;
            }
            if (!url)
                return null;
            let channel = PAL.media.createSoundChannel(url, mgr.useAudioMusic);
            channel.loops = loops !== null && loops !== void 0 ? loops : 1;
            channel.startTime = startTime !== null && startTime !== void 0 ? startTime : 0;
            channel.playbackRate = this.playbackRate;
            channel.volume = mgr._musicVolume;
            channel.muted = mgr._musicMuted || mgr._muted;
            channel.completeHandler = complete;
            channel._isMusic = true;
            channel.play();
            return channel;
        }
        static stopSound(url) {
            for (let channel of mgr._channels) {
                if (channel.url == url) {
                    channel.stop();
                    if (channel === mgr._musicChannel) {
                        mgr._musicChannel = null;
                    }
                }
            }
        }
        static stopAll() {
            mgr._musicChannel = null;
            for (let channel of mgr._channels)
                channel.stop();
        }
        static stopAllSound() {
            for (let channel of mgr._channels) {
                if (channel !== mgr._musicChannel) {
                    channel.stop();
                }
            }
        }
        static stopMusic() {
            if (mgr._musicChannel)
                mgr._musicChannel.stop();
            mgr._musicChannel = null;
        }
        static setSoundVolume(volume, url) {
            if (url) {
                let channel = this.findChannel(url);
                if (channel)
                    channel.volume = volume;
            }
            else {
                this.soundVolume = volume;
            }
        }
        static setMusicVolume(volume) {
            this.musicVolume = volume;
        }
        static findChannel(url) {
            for (let channel of mgr._channels) {
                if (channel.url == url) {
                    return channel;
                }
            }
            return null;
        }
        static updateMutedStatus() {
            let s = mgr._muted || mgr._soundMuted;
            let m = mgr._muted || mgr._musicMuted;
            for (let channel of mgr._channels) {
                if (channel === mgr._musicChannel)
                    channel.muted = m;
                else
                    channel.muted = s;
            }
        }
        static addChannel(channel) {
            mgr._channels.add(channel);
            if (channel._isMusic)
                mgr._musicChannel = channel;
        }
        static removeChannel(channel) {
            mgr._channels.delete(channel);
            if (channel === mgr._musicChannel)
                mgr._musicChannel = null;
        }
    }
    SoundManager.playbackRate = 1;
    SoundManager.useAudioMusic = true;
    SoundManager.autoStopMusic = true;
    SoundManager._muted = false;
    SoundManager._soundMuted = false;
    SoundManager._musicMuted = false;
    SoundManager._musicVolume = 1;
    SoundManager._soundVolume = 1;
    SoundManager._musicChannel = null;
    SoundManager._channels = new Set();
    const mgr = SoundManager;

    class Widget extends Component {
        constructor() {
            super();
            this._top = null;
            this._bottom = null;
            this._left = null;
            this._right = null;
            this._centerX = null;
            this._centerY = null;
            this.runInEditor = true;
            this.hideFlags |= HideFlags.HideAndDontSave;
        }
        onReset() {
            this._top = this._bottom = this._left = this._right = this._centerX = this._centerY = null;
        }
        _onEnable() {
            if (this.owner.parent)
                this._onAdded();
            else
                this.owner.once(Event.ADDED, this, this._onAdded);
        }
        _onDisable() {
            this.owner.off(Event.ADDED, this, this._onAdded);
            if (this.owner.parent)
                this.owner.parent.off(Event.RESIZE, this, this._onParentResize);
        }
        _onAdded() {
            if (this.owner.parent)
                this.owner.parent.on(Event.RESIZE, this, this._onParentResize);
            this.resetLayoutX();
            this.resetLayoutY();
        }
        _onParentResize() {
            var flagX = this.resetLayoutX();
            var flagY = this.resetLayoutY();
            if (flagX || flagY)
                this.owner.event(Event.RESIZE);
        }
        resetLayoutX() {
            var owner = this.owner;
            if (!owner)
                return false;
            var parent = owner.parent;
            if (parent) {
                if (this._centerX != null) {
                    owner.x = Math.round((parent.width - owner.displayWidth) * 0.5 + this._centerX + owner.pivotX * owner.scaleX);
                }
                else if (this._left != null) {
                    owner.x = Math.round(this._left + owner.pivotX * owner.scaleX);
                    if (this._right != null) {
                        if (!parent._width)
                            return false;
                        var temp = (parent._width - this._left - this._right) / (owner.scaleX || 0.01);
                        if (temp != owner._width) {
                            owner.width = temp;
                            return true;
                        }
                    }
                }
                else if (this._right != null) {
                    owner.x = Math.round(parent.width - owner.displayWidth - this._right + owner.pivotX * owner.scaleX);
                }
            }
            return false;
        }
        resetLayoutY() {
            var owner = this.owner;
            if (!owner)
                return false;
            var parent = owner.parent;
            if (parent) {
                if (this._centerY != null) {
                    owner.y = Math.round((parent.height - owner.displayHeight) * 0.5 + this._centerY + owner.pivotY * owner.scaleY);
                }
                else if (this._top != null) {
                    owner.y = Math.round(this._top + owner.pivotY * owner.scaleY);
                    if (this._bottom != null) {
                        if (!parent._height)
                            return false;
                        var temp = (parent._height - this._top - this._bottom) / (owner.scaleY || 0.01);
                        if (temp != owner._height) {
                            owner.height = temp;
                            return true;
                        }
                    }
                }
                else if (this._bottom != null) {
                    owner.y = Math.round(parent.height - owner.displayHeight - this._bottom + owner.pivotY * owner.scaleY);
                }
            }
            return false;
        }
        resetLayout() {
            if (this.owner) {
                this.resetLayoutX();
                this.resetLayoutY();
            }
        }
        get top() {
            return this._top;
        }
        set top(value) {
            if (isNaN(value))
                value = null;
            if (this._top != value) {
                this._top = value;
                this.resetLayoutY();
            }
        }
        get bottom() {
            return this._bottom;
        }
        set bottom(value) {
            if (isNaN(value))
                value = null;
            if (this._bottom != value) {
                this._bottom = value;
                this.resetLayoutY();
            }
        }
        get left() {
            return this._left;
        }
        set left(value) {
            if (isNaN(value))
                value = null;
            if (this._left != value) {
                this._left = value;
                this.resetLayoutX();
            }
        }
        get right() {
            return this._right;
        }
        set right(value) {
            if (isNaN(value))
                value = null;
            if (this._right != value) {
                this._right = value;
                this.resetLayoutX();
            }
        }
        get centerX() {
            return this._centerX;
        }
        set centerX(value) {
            if (isNaN(value))
                value = null;
            if (this._centerX != value) {
                this._centerX = value;
                this.resetLayoutX();
            }
        }
        get centerY() {
            return this._centerY;
        }
        set centerY(value) {
            if (isNaN(value))
                value = null;
            if (this._centerY != value) {
                this._centerY = value;
                this.resetLayoutY();
            }
        }
    }
    Widget.EMPTY = null;
    Widget.EMPTY = new Widget();

    class Scene2DSpecialManager {
        constructor() {
            this.componentElementMap = new Map();
            this._shaderData = LayaGL.renderDeviceFactory.createShaderData(null);
            if (!Scene2DSpecialManager.SPRITE2DGLOBAL) {
                Scene2DSpecialManager.SPRITE2DGLOBAL = Shader3D.getDefineByName("SPRITE2DGLOBAL");
            }
            this._shaderData.addDefine(Scene2DSpecialManager.SPRITE2DGLOBAL);
        }
    }

    class Camera2D extends Sprite {
        static shaderValueInit() {
            Camera2D.VIEW2D = Shader3D.propertyNameToID("u_view2D");
            Camera2D.SHADERDEFINE_CAMERA2D = Shader3D.getDefineByName("CAMERA2D");
        }
        get ignoreRotation() {
            return this._ignoreRotation;
        }
        set ignoreRotation(value) {
            this._ignoreRotation = value;
        }
        get isMain() {
            return this._isMain;
        }
        set isMain(value) {
            if (this._ownerArea) {
                if (value) {
                    this._ownerArea._setMainCamera(this);
                    this._isMain = true;
                }
                else {
                    if (this._ownerArea.mainCamera == this) {
                        this._ownerArea._setMainCamera(null);
                        this._isMain = false;
                    }
                }
            }
            this._isMain = value;
        }
        _setUnBelongScene() {
            if (this._ownerArea != null) {
                if (this._ownerArea.mainCamera == this)
                    this._ownerArea._setMainCamera(null);
                this._ownerArea = null;
            }
            super._setUnBelongScene();
        }
        _findOwnerArea() {
            let ele = this;
            while (ele) {
                if (ele === this._scene || ele === ILaya.stage)
                    break;
                if ((ele._renderType & SpriteConst.AREA2D) !== 0) {
                    this._ownerArea = ele;
                    if (this._isMain && !this._ownerArea.mainCamera)
                        this._ownerArea._setMainCamera(this);
                    break;
                }
                ele = ele._parent;
            }
            if (this._ownerArea == null) {
                console.warn("Camera2D must be a descendant of Area2D");
            }
        }
        get zoom() {
            return this._zoom;
        }
        set zoom(value) {
            if (value) {
                value.cloneTo(this._zoom);
                this._struct.setRepaint();
                this.parentRepaint();
            }
        }
        get limit_Left() {
            return this._limit_Left;
        }
        set limit_Left(value) {
            this._limit_Left = value;
        }
        get limit_Right() {
            return this._limit_Right;
        }
        set limit_Right(value) {
            this._limit_Right = value;
        }
        get limit_Bottom() {
            return this._limit_Bottom;
        }
        set limit_Bottom(value) {
            this._limit_Bottom = value;
        }
        get limit_Top() {
            return this._limit_Top;
        }
        set limit_Top(value) {
            this._limit_Top = value;
        }
        get positionSmooth() {
            return this._positionSmooth;
        }
        set positionSmooth(value) {
            this._positionSmooth = value;
        }
        get positionSpeed() {
            return this._positionSpeed;
        }
        set positionSpeed(value) {
            this._positionSpeed = value;
        }
        get dragHorizontalEnable() {
            return this._dragHorizontalEnable;
        }
        set dragHorizontalEnable(value) {
            this._dragHorizontalEnable = value;
        }
        get dragVerticalEnable() {
            return this._dragVerticalEnable;
        }
        set dragVerticalEnable(value) {
            this._dragVerticalEnable = value;
        }
        get drag_Left() {
            return this._drag_Left;
        }
        set drag_Left(value) {
            this._drag_Left = value;
        }
        get drag_Right() {
            return this._drag_Right;
        }
        set drag_Right(value) {
            this._drag_Right = value;
        }
        get drag_Top() {
            return this._drag_Top;
        }
        set drag_Top(value) {
            this._drag_Top = value;
        }
        get drag_Bottom() {
            return this._drag_Bottom;
        }
        set drag_Bottom(value) {
            this._drag_Bottom = value;
        }
        get cameraMatrix() {
            return this._cameraMatrix;
        }
        getCameraPos() {
            return this._cameraPos;
        }
        constructor() {
            super();
            this._cameraPos = new Vector2();
            this._cameraSmoothPos = new Vector2();
            this._firstUpdate = true;
            this._cameraMatrix = new Matrix3x3();
            this._cameraInvertMatrix = new Matrix3x3();
            this._ignoreRotation = true;
            this.visiableLayer = -1;
            this._viewRect = new Vector2();
            this.limit_Left = -10000000;
            this.limit_Right = 10000000;
            this.limit_Top = -10000000;
            this.limit_Bottom = 10000000;
            this.drag_Left = 0.2;
            this.drag_Right = 0.2;
            this.drag_Top = 0.2;
            this.drag_Bottom = 0.2;
            this.positionSmooth = false;
            this._rect = new Vector4();
            this._zoom = new Vector2(1, 1);
        }
        _getScreenSize() {
            this._viewRect.setValue(RenderState2D.width, RenderState2D.height);
            return this._viewRect;
        }
        onEnable() {
            this.on(Event.TRANSFORM_CHANGED, this, this._onTransChanged);
        }
        onDisable() {
            this.off(Event.TRANSFORM_CHANGED, this, this._onTransChanged);
        }
        _onTransChanged(e) {
            this._struct.setRepaint();
            this.parentRepaint();
        }
        _getCameraTransform() {
            let viewport = this._getScreenSize();
            let curPosPoint = Point.TEMP;
            this.globalTrans.getPos(curPosPoint);
            let extendHorizental = viewport.x * 0.5 * this._zoom.x;
            let extendVertical = viewport.y * 0.5 * this._zoom.y;
            if (!this._firstUpdate) {
                if (this.dragHorizontalEnable) {
                    this._cameraPos.x = Math.min(this._cameraPos.x, curPosPoint.x + extendHorizental * this.drag_Left);
                    this._cameraPos.x = Math.max(this._cameraPos.x, curPosPoint.x - extendHorizental * this.drag_Right);
                }
                else {
                    this._cameraPos.x = curPosPoint.x;
                }
                if (this.dragVerticalEnable) {
                    this._cameraPos.y = Math.min(this._cameraPos.y, curPosPoint.y + extendVertical * this.drag_Top);
                    this._cameraPos.y = Math.max(this._cameraPos.y, curPosPoint.y - extendVertical * this.drag_Bottom);
                }
                else {
                    this._cameraPos.y = curPosPoint.y;
                }
                let sceneRect_left = this._cameraPos.x - extendHorizental;
                let sceneRect_right = sceneRect_left + viewport.x;
                let sceneRect_top = this._cameraPos.y - extendVertical;
                let sceneRect_bottom = sceneRect_top + viewport.y;
                if (sceneRect_left < this.limit_Left) {
                    this._cameraPos.x -= sceneRect_left - this.limit_Left;
                }
                if (sceneRect_right > this.limit_Right) {
                    this._cameraPos.x -= sceneRect_right - this.limit_Right;
                }
                if (sceneRect_bottom > this.limit_Bottom) {
                    this._cameraPos.y -= sceneRect_bottom - this.limit_Bottom;
                }
                if (sceneRect_top < this.limit_Top) {
                    this._cameraPos.y -= sceneRect_top - this.limit_Top;
                }
                if (this.positionSmooth) {
                    let epsilon = 0.01;
                    let speed = Math.max(epsilon, Math.min(1.0, this.positionSpeed * 0.16));
                    let deltaX = this._cameraPos.x - this._cameraSmoothPos.x;
                    let deltaY = this._cameraPos.y - this._cameraSmoothPos.y;
                    let transX = deltaX * speed;
                    let transY = deltaY * speed;
                    if (Math.abs(transX) < epsilon && Math.abs(transY) < epsilon) {
                        this._cameraSmoothPos.x = this._cameraPos.x;
                        this._cameraSmoothPos.y = this._cameraPos.y;
                    }
                    else {
                        this._cameraSmoothPos.x += transX;
                        this._cameraSmoothPos.y += transY;
                    }
                }
                else {
                    this._cameraSmoothPos.x = this._cameraPos.x;
                    this._cameraSmoothPos.y = this._cameraPos.y;
                }
            }
            else {
                this._cameraSmoothPos.x = this._cameraPos.x = curPosPoint.x;
                this._cameraSmoothPos.y = this._cameraPos.y = curPosPoint.y;
                this._firstUpdate = false;
            }
            if (!this.ignoreRotation) {
                if (this.rotationSmooth) ;
                else {
                    this._cameraRotation = this.globalTrans.rotation;
                }
            }
            else {
                this._cameraRotation = 0;
            }
            this._rect.setValue(this._cameraSmoothPos.x - extendHorizental, this._cameraSmoothPos.x + extendHorizental, this._cameraSmoothPos.y - extendVertical, this._cameraSmoothPos.y + extendVertical);
            Matrix3x3.createMatrixFromValue(this._cameraSmoothPos, this._cameraRotation * Math.PI / 180, this._zoom, this._cameraMatrix);
            this._cameraMatrix.invert(this._cameraInvertMatrix);
            return this._cameraInvertMatrix;
        }
    }

    class Scene extends Sprite {
        static regManager(type, cla) {
            Scene.componentManagerMap.set(type, cla);
        }
        static __init__() {
            Camera2D.shaderValueInit();
            let scene2DUniformMap = Scene.scene2DUniformMap = LayaGL.renderDeviceFactory.createGlobalUniformMap("Sprite2DGlobal");
            scene2DUniformMap.addShaderUniform(Camera2D.VIEW2D, "u_view2D", exports.ShaderDataType.Matrix3x3);
        }
        constructor() {
            super();
            this.autoDestroyAtClosed = false;
            this._componentElementDatasMap = {};
            this._specialManager = new Scene2DSpecialManager();
            this._timer = ILaya.timer;
            this._widget = Widget.EMPTY;
            this._area2Ds = new Set();
            this._scene = this;
            Scene.componentManagerMap.forEach((val, key) => {
                this._specialManager.componentElementMap.set(key, new val(this));
            });
            this._globalRenderData = LayaGL.render2DRenderPassFactory.create2DGlobalRenderDataHandle();
            this._globalRenderData.globalShaderData = this._shaderData = this._specialManager._shaderData;
            this._globalRenderData.renderLayerMask = -1;
            this._struct.globalRenderData = this._globalRenderData;
            this._struct.spriteShaderData = this._shaderData;
            BlendModeHandler.initBlendMode(this._shaderData);
        }
        set componentElementDatasMap(value) {
            this._componentElementDatasMap = value;
            this._specialManager.componentElementMap.forEach((value, key) => {
                this._componentElementDatasMap[key] && value.Init(this._componentElementDatasMap[key]);
            });
        }
        get componentElementDatasMap() {
            return this._componentElementDatasMap;
        }
        _update() {
            var delta = ILaya.timer.delta * 0.001;
            this._specialManager.componentElementMap.forEach((value) => {
                value.update(delta);
            });
        }
        getComponentElementManager(type) {
            return this._specialManager.componentElementMap.get(type);
        }
        getNodeByID(id) {
            if (this._idMap)
                return this._idMap[id];
            return null;
        }
        open(closeOther, param) {
            if (closeOther == null || closeOther)
                Scene.closeAll();
            Scene.root.addChild(this);
            if (this._scene3D)
                ILaya.stage.addChildAt(this._scene3D, 0);
            this.onOpened(param);
        }
        onOpened(param) {
        }
        close(type = null) {
            this.onClosed(type);
            if (this.autoDestroyAtClosed) {
                this.destroy();
                if (this._scene3D)
                    this._scene3D.destroy();
            }
            else {
                this.removeSelf();
                if (this._scene3D)
                    this._scene3D.removeSelf();
            }
        }
        onClosed(type) {
        }
        destroy(destroyChild = true) {
            super.destroy(destroyChild);
            if (this._scene3D) {
                this._scene3D.destroy();
                this._scene3D = null;
            }
            this._idMap = null;
            Scene.unDestroyedScenes.delete(this);
            this._specialManager.componentElementMap.forEach(element => {
                element.destroy();
            });
        }
        get timer() {
            return this._timer;
        }
        set timer(value) {
            this._timer = value;
        }
        get scene3D() {
            return this._scene3D;
        }
        get top() {
            return this._widget.top;
        }
        set top(value) {
            if (value != this._widget.top) {
                this._getWidget().top = value;
            }
        }
        get bottom() {
            return this._widget.bottom;
        }
        set bottom(value) {
            if (value != this._widget.bottom) {
                this._getWidget().bottom = value;
            }
        }
        get left() {
            return this._widget.left;
        }
        set left(value) {
            if (value != this._widget.left) {
                this._getWidget().left = value;
            }
        }
        get right() {
            return this._widget.right;
        }
        set right(value) {
            if (value != this._widget.right) {
                this._getWidget().right = value;
            }
        }
        get centerX() {
            return this._widget.centerX;
        }
        set centerX(value) {
            if (value != this._widget.centerX) {
                this._getWidget().centerX = value;
            }
        }
        get centerY() {
            return this._widget.centerY;
        }
        set centerY(value) {
            if (value != this._widget.centerY) {
                this._getWidget().centerY = value;
            }
        }
        render(x, y) {
            this._preRenderUpdate(x, y);
            for (let area of this._area2Ds) {
                area.render();
            }
        }
        setglobalRenderData(uniformIndex, type, value) {
            this._shaderData && this._shaderData.setShaderData(uniformIndex, type, value);
            for (let area2D of this._area2Ds) {
                area2D._globalShaderData.setShaderData(uniformIndex, type, value);
            }
        }
        _preRenderUpdate(x, y) {
            this._specialManager._shaderData;
            if (this._light2DManager)
                this._light2DManager.preRenderUpdate();
        }
        _transChanged(kind) {
            super._transChanged(kind);
            if ((kind & exports.TransformKind.Layout) != 0)
                this.callLater(this._sizeChanged);
        }
        _sizeChanged() {
            this.event(Event.RESIZE);
            if (this._widget !== Widget.EMPTY)
                this._widget.resetLayout();
        }
        _onAdded() {
            super._onAdded();
            ILaya.stage._scene2Ds.push(this);
        }
        _onRemoved() {
            super._onRemoved();
            let index = ILaya.stage._scene2Ds.indexOf(this);
            ILaya.stage._scene2Ds.splice(index, 1);
        }
        freshLayout() {
            this.refreshLayout();
        }
        refreshLayout() {
            if (this._widget != Widget.EMPTY) {
                this._widget.resetLayout();
            }
        }
        _getWidget() {
            this._widget === Widget.EMPTY && (this._widget = this.addComponent(Widget));
            return this._widget;
        }
        static get root() {
            let root = Scene._root;
            if (!root) {
                root = Scene._root = ILaya.stage.addChild(new Sprite());
                root.name = "root";
                root.mouseThrough = true;
                ILaya.stage.on("resize", null, () => {
                    root.size(ILaya.stage.width, ILaya.stage.height);
                    root.event(Event.RESIZE);
                });
                root.size(ILaya.stage.width, ILaya.stage.height);
                root.event(Event.RESIZE);
            }
            return root;
        }
        static load(url, complete, progress) {
            return Scene._load(url, progress ? value => progress.runWith(value) : null).then(scene => {
                if (complete)
                    complete.runWith(scene);
                return scene;
            });
        }
        static open(url, closeOther, param, complete, progress) {
            if (typeof (complete) === "function") {
                progress = complete;
                complete = null;
            }
            if (typeof (param) === "function") {
                complete = param;
                param = null;
            }
            if (progress instanceof Handler) {
                let h = progress;
                progress = (value) => h.runWith(value);
            }
            return Scene._load(url, progress).then(scene => {
                scene.open(closeOther, param);
                if (complete instanceof Handler)
                    complete.runWith(scene);
                else if (complete)
                    complete(scene);
                return scene;
            });
        }
        static _load(url, progress) {
            Scene.showLoadingPage();
            return ILaya.loader.load(url, null, value => {
                if (Scene._loadPage)
                    Scene._loadPage.event("progress", value);
                if (progress)
                    progress(value);
            }).then((content) => {
                Scene.hideLoadingPage();
                if (!content)
                    throw new Error("Can not find scene:" + url);
                let scene;
                let errors = [];
                let ret = content.create(null, errors);
                if (errors.length > 0)
                    console.warn(`Error loading ${url}: \n${errors.join("\n")}`);
                if (ret instanceof Scene)
                    scene = ret;
                else if (ret._nodeType === 1) {
                    scene = new Scene();
                    scene.left = scene.right = scene.top = scene.bottom = 0;
                    scene._scene3D = ret;
                }
                else
                    throw new Error("Not a scene:" + url);
                if (scene._scene3D)
                    scene._scene3D._scene2D = scene;
                Scene.unDestroyedScenes.add(scene);
                return scene;
            });
        }
        static close(url, name) {
            let flag = false;
            for (let scene of Scene.unDestroyedScenes) {
                if (scene && scene.parent && scene.url === url && (name == null || scene.name == name)) {
                    scene.close();
                    flag = true;
                    break;
                }
            }
            return flag;
        }
        static closeAll() {
            let root = Scene.root;
            for (let i = 0, n = root.numChildren; i < n; i++) {
                var scene = root.getChildAt(0);
                if (scene instanceof Scene)
                    scene.close();
                else
                    scene.removeSelf();
            }
        }
        static destroy(url, name) {
            let flag = false;
            for (let scene of Scene.unDestroyedScenes) {
                if (scene.url === url && (name == null || scene.name == name) && !scene._destroyed) {
                    scene.destroy();
                    flag = true;
                    break;
                }
            }
            return flag;
        }
        static gc() {
            Resource.destroyUnusedResources();
        }
        static setLoadingPage(loadPage) {
            Scene._loadPage = loadPage;
        }
        static showLoadingPage(param = null, delay = 500) {
            if (Scene._loadPage) {
                ILaya.systemTimer.clear(null, Scene._showLoading);
                ILaya.systemTimer.clear(null, Scene._hideLoading);
                ILaya.systemTimer.once(delay, null, Scene._showLoading, [param], false);
            }
        }
        static _showLoading(param) {
            ILaya.stage.addChild(Scene._loadPage);
            if (Scene._loadPage instanceof Scene)
                Scene._loadPage.onOpened(param);
        }
        static _hideLoading() {
            if (Scene._loadPage instanceof Scene)
                Scene._loadPage.close();
            else
                Scene._loadPage.removeSelf();
        }
        static hideLoadingPage(delay = 500) {
            if (Scene._loadPage) {
                ILaya.systemTimer.clear(null, Scene._showLoading);
                ILaya.systemTimer.clear(null, Scene._hideLoading);
                ILaya.systemTimer.once(delay, null, Scene._hideLoading);
            }
        }
    }
    Scene.unDestroyedScenes = new Set();
    Scene.componentManagerMap = new Map();

    class Laya {
        static init(...args) {
            if (Laya._inited)
                return Promise.resolve();
            Laya._inited = true;
            let stageConfig;
            if (typeof (args[0]) === "number") {
                stageConfig = {
                    designWidth: args[0],
                    designHeight: args[1]
                };
            }
            else
                stageConfig = args[0];
            ILaya.systemTimer = Laya.systemTimer = Timer.gSysTimer = exports.systemTimer = new Timer(false);
            ILaya.timer = Laya.timer = exports.timer = new Timer(false);
            ILaya.physicsTimer = Laya.physicsTimer = exports.physicsTimer = new Timer(false);
            ILaya.loader = Laya.loader = exports.loader = new Loader();
            PAL.__init__();
            let steps = [];
            steps.push(() => {
                let mainCanvas = Browser.mainCanvas = new HTMLCanvas(false);
                mainCanvas.source = PAL.browser.createMainCanvas();
                Browser.canvas = new HTMLCanvas(true);
                Browser.context = Browser.canvas.context;
                return PAL.browser.start();
            });
            if (LayaEnv.beforeInit)
                steps.push(() => LayaEnv.beforeInit(stageConfig));
            Laya._beforeInitCallbacks.forEach(func => steps.push(() => func(stageConfig)));
            steps.push(() => LayaGL.renderDeviceFactory.createEngine(null, Browser.mainCanvas));
            steps.push(() => Laya.initRender2D(stageConfig));
            let laya3D = window["Laya3D"];
            if (laya3D)
                steps.push(() => laya3D.__init__());
            steps.push(() => Promise.all(Laya._initCallbacks.map(func => func())));
            steps.push(() => {
                let p = Promise.resolve();
                for (let func of Laya._afterInitCallbacks)
                    p = p.then(func);
                return p;
            });
            if (LayaEnv.afterInit)
                steps.push(() => LayaEnv.afterInit());
            let p = Promise.resolve();
            for (let step of steps)
                p = p.then(step);
            return p;
        }
        static initRender2D(stageConfig) {
            PAL.browser.onInitRender();
            exports.stage = window.stage = ILaya.stage = Laya.stage = new Stage();
            exports.stage.size(stageConfig.designWidth, stageConfig.designHeight);
            if (stageConfig.scaleMode)
                exports.stage.scaleMode = stageConfig.scaleMode;
            if (stageConfig.screenMode)
                exports.stage.screenMode = stageConfig.screenMode;
            if (stageConfig.alignV)
                exports.stage.alignV = stageConfig.alignV;
            if (stageConfig.alignH)
                exports.stage.alignH = stageConfig.alignH;
            if (Config.isAlpha)
                exports.stage.bgColor = "#00000000";
            else if (stageConfig.backgroundColor)
                exports.stage.bgColor = stageConfig.backgroundColor;
            VertexElementFormat.__init__();
            VertexMesh.__init__();
            Shader3D.init();
            GraphicsMesh.__init__();
            ShaderDefines2D.__init__();
            Render.__init__();
            Shader2D.__init__();
            BlendModeHandler._init_();
            Texture2D.__init__();
            RenderTexture2D.__init__();
            TextureCube.__init__();
            Texture2DArray.__init__();
            HalfFloatUtils.__init__();
            Scene.__init__();
            Render2DProcessor.__init__();
            BaseRenderNode2D.initBaseRender2DCommandEncoder();
            Blit2DCMD.__init__();
            PostProcess2D.init();
            Material.__initDefine__();
            Mesh2DRender.__init__();
            InputManager.__init__();
            SoundManager.__init__();
        }
        static alertGlobalError(value) {
            if (value)
                PAL.browser.captureGlobalError(Laya._onGlobalError);
            else
                PAL.browser.captureGlobalError(null);
        }
        static _onGlobalError(ev) {
            var _a;
            let msg = "Something went wrong\n"
                + (ev.message || ev.reason)
                + "\n"
                + (ev.stack || ((_a = ev.error) === null || _a === void 0 ? void 0 : _a.stack));
            if (_erralert++ < 5)
                PAL.browser.alert(msg);
            else
                console.error(msg);
        }
        static addInitCallback(callback) {
            Laya._initCallbacks.push(callback);
        }
        static addBeforeInitCallback(callback) {
            Laya._beforeInitCallbacks.push(callback);
        }
        static addAfterInitCallback(callback) {
            Laya._afterInitCallbacks.push(callback);
        }
        static importNative(name) {
            if (!LayaEnv.isConch)
                return null;
            let path = window.$DLL_PATHS[name];
            let obj = window.importNative(path || name);
            if (!obj)
                throw new Error(`failed to load ${name}`);
            return obj;
        }
    }
    Laya.stage = null;
    Laya.systemTimer = null;
    Laya.physicsTimer = null;
    Laya.timer = null;
    Laya.loader = null;
    Laya._inited = false;
    Laya._initCallbacks = [];
    Laya._beforeInitCallbacks = [];
    Laya._afterInitCallbacks = [];
    var _erralert = 0;
    ILaya.Laya = Laya;
    ILaya.Loader = Loader;
    ILaya.InputManager = InputManager;
    var init = Laya.init;
    exports.stage = void 0;
    exports.systemTimer = void 0;
    exports.physicsTimer = void 0;
    exports.timer = void 0;
    exports.loader = void 0;
    var alertGlobalError = Laya.alertGlobalError;
    var addInitCallback = Laya.addInitCallback;
    var addBeforeInitCallback = Laya.addBeforeInitCallback;
    var addAfterInitCallback = Laya.addAfterInitCallback;
    var importNative = Laya.importNative;

    exports.AnimationWrapMode = void 0;
    (function (AnimationWrapMode) {
        AnimationWrapMode[AnimationWrapMode["Positive"] = 0] = "Positive";
        AnimationWrapMode[AnimationWrapMode["Reverse"] = 1] = "Reverse";
        AnimationWrapMode[AnimationWrapMode["PingPong"] = 2] = "PingPong";
    })(exports.AnimationWrapMode || (exports.AnimationWrapMode = {}));
    exports.AnimationStretchMode = void 0;
    (function (AnimationStretchMode) {
        AnimationStretchMode[AnimationStretchMode["None"] = 0] = "None";
        AnimationStretchMode[AnimationStretchMode["Fill"] = 1] = "Fill";
        AnimationStretchMode[AnimationStretchMode["ResizeToFit"] = 2] = "ResizeToFit";
    })(exports.AnimationStretchMode || (exports.AnimationStretchMode = {}));
    class FrameAnimation extends Component {
        constructor() {
            super();
            this.repeatDelay = 0;
            this.timeScale = 1;
            this._wrapMode = 0;
            this._loop = true;
            this._frame = 0;
            this._autoPlay = true;
            this._stretchMode = 0;
            this._source = "";
            this._playing = false;
            this._count = 0;
            this._index = 0;
            this._elapsed = 0;
            this._loadId = 0;
            this.interval = Config.animationInterval;
            this._frames = [];
            this._drawCmds = [];
            this._delays = [];
            this._offset = new Point();
            this._color = new Color(1, 1, 1, 1);
            this._singleton = false;
            this.runInEditor = true;
        }
        get frame() {
            return LayaEnv.isPlaying ? this._frame : this._index;
        }
        set frame(value) {
            var _a;
            this._index = this._frame = value;
            this.drawFrame();
            if ((_a = this._labels) === null || _a === void 0 ? void 0 : _a[value])
                this.owner.event(Event.LABEL, this._labels[value]);
        }
        get frames() {
            return this._frames;
        }
        set frames(value) {
            var _a;
            if (this._drawCmd) {
                (_a = this.owner._graphics) === null || _a === void 0 ? void 0 : _a.removeCmd(this._drawCmd);
                this._drawCmd = null;
            }
            for (let cmd of this._drawCmds) {
                cmd.lock = false;
                cmd.recover();
            }
            this._drawCmds.length = 0;
            this._frames.length = 0;
            if (value != null && value.length > 0) {
                this._frames.push(...value);
                let dx = 0, dy = 0;
                if (this._stretchMode === exports.AnimationStretchMode.None) {
                    dx = this._offset.x;
                    dy = this._offset.y;
                }
                let stretch = this._stretchMode === exports.AnimationStretchMode.Fill;
                for (let tex of value) {
                    let cmd = stretch ? DrawTextureCmd.create(tex, 0, 0, 1, 1, null, 1, null, null, null, true)
                        : DrawTextureCmd.create(tex, dx, dy);
                    cmd.lock = true;
                    this._drawCmds.push(cmd);
                }
                this._count = this._frames.length;
                this._elapsed = 0;
                if (this._wrapMode === exports.AnimationWrapMode.Reverse)
                    this._frame = this._count - 1;
                else {
                    this._reversed = false;
                    this._frame = 0;
                }
                if (this._stretchMode === exports.AnimationStretchMode.ResizeToFit) {
                    let w = this.width, h = this.height;
                    if (w > 0 && h > 0 || LayaEnv.isPlaying) {
                        this._changingSize = true;
                        this.owner.size(w, h);
                        this._changingSize = false;
                    }
                }
                this.drawFrame();
            }
            else {
                this._count = 0;
            }
        }
        get frameDelays() {
            return this._delays;
        }
        get isPlaying() {
            return this._playing;
        }
        get autoPlay() {
            return this._autoPlay;
        }
        set autoPlay(value) {
            this._autoPlay = value;
            if (this.enabled) {
                if (value)
                    this.play();
                else
                    this.stop();
            }
        }
        get wrapMode() {
            return this._wrapMode;
        }
        set wrapMode(value) {
            if (this._wrapMode != value) {
                this._wrapMode = value;
                if (this._playing) {
                    if (value === exports.AnimationWrapMode.Reverse)
                        this._reversed = true;
                    else if (value === exports.AnimationWrapMode.Positive)
                        this._reversed = false;
                }
            }
        }
        get loop() {
            return this._loop;
        }
        set loop(value) {
            if (this._loop != value) {
                this._loop = value;
                if (value && !this._playing && this._autoPlay)
                    this.play();
            }
        }
        get stretchMode() {
            return this._stretchMode;
        }
        set stretchMode(value) {
            if (this._changingSize)
                return;
            if (this._stretchMode != value) {
                this._stretchMode = value;
                if (this._count > 0) {
                    if (this._stretchMode === exports.AnimationStretchMode.ResizeToFit) {
                        let w = this.width, h = this.height;
                        if (w > 0 && h > 0 || LayaEnv.isPlaying) {
                            this._changingSize = true;
                            this.owner.size(w, h);
                            this._changingSize = false;
                        }
                    }
                    this.applyStretchMode();
                    this.drawFrame();
                }
            }
        }
        get offset() {
            return this._offset;
        }
        set offset(value) {
            this._offset.copy(value);
            this.applyStretchMode();
            this.drawFrame();
        }
        get color() {
            return this._color;
        }
        set color(value) {
            this._color = value;
            this.drawFrame();
        }
        get width() {
            return this._count > 0 ? this._frames[0].sourceWidth : 0;
        }
        get height() {
            return this._count > 0 ? this._frames[0].sourceHeight : 0;
        }
        applyStretchMode() {
            if (this._stretchMode === exports.AnimationStretchMode.Fill) {
                for (let cmd of this._drawCmds) {
                    cmd.x = cmd.y = 0;
                    cmd.width = cmd.height = 1;
                    cmd.percent = true;
                }
            }
            else {
                let dx = 0, dy = 0;
                if (this._stretchMode === exports.AnimationStretchMode.None) {
                    dx = this._offset.x;
                    dy = this._offset.y;
                }
                for (let cmd of this._drawCmds) {
                    cmd.x = dx;
                    cmd.y = dy;
                    if (cmd.texture) {
                        cmd.width = cmd.texture.sourceWidth;
                        cmd.height = cmd.texture.sourceHeight;
                    }
                    cmd.percent = false;
                }
            }
        }
        play() {
            if (this._playing)
                return;
            this._playing = true;
            this._elapsed = 0;
            this._reversed = this._wrapMode === exports.AnimationWrapMode.Reverse;
        }
        stop() {
            this._playing = false;
            if (!LayaEnv.isPlaying) {
                this._frame = this._index;
                this.drawFrame();
            }
        }
        _onEnable() {
            if (this._autoPlay)
                this.play();
        }
        _onDestroy() {
            super._onDestroy();
            this.frames = null;
            if (this._atlas) {
                if (this.owner._getBit(NodeFlags.EDITING_NODE))
                    this._atlas.off("reload", this, this.onAtlasReload);
                this._atlas = null;
            }
        }
        onUpdate() {
            var _a;
            if (!this._playing || this._count == 0)
                return;
            let dt = ILaya.timer.delta;
            if (dt > 100)
                dt = 100;
            if (this.timeScale != 1)
                dt *= this.timeScale;
            let frame = this._frame;
            this._elapsed += dt;
            let tt = this.interval;
            if (this._reversed) {
                if (frame > 0)
                    tt += this._delays[frame - 1] || 0;
                else
                    tt += this.repeatDelay;
            }
            else {
                tt += this._delays[frame] || 0;
                if (frame === this._count - 1)
                    tt += this.repeatDelay;
            }
            if (this._elapsed < tt)
                return;
            this._elapsed -= tt;
            if (this._elapsed > this.interval)
                this._elapsed = this.interval;
            let emit = false;
            if (this._reversed) {
                frame--;
                if (frame < 0) {
                    if (this._loop) {
                        if (this._wrapMode === exports.AnimationWrapMode.PingPong) {
                            this._reversed = false;
                            frame = 1;
                        }
                        else
                            frame = this._count - 1;
                        emit = true;
                    }
                    else {
                        frame = 0;
                        this._playing = false;
                        emit = true;
                    }
                }
            }
            else {
                frame++;
                if (frame > this._count - 1) {
                    if (this._loop) {
                        if (this._wrapMode === exports.AnimationWrapMode.PingPong) {
                            this._reversed = true;
                            frame = Math.max(0, this._count - 2);
                        }
                        else
                            frame = 0;
                        emit = true;
                    }
                    else {
                        frame = this._count - 1;
                        this._playing = false;
                        emit = true;
                    }
                }
            }
            this._frame = frame;
            if (this._playing) {
                this.drawFrame();
                if ((_a = this._labels) === null || _a === void 0 ? void 0 : _a[frame])
                    this.owner.event(Event.LABEL, this._labels[frame]);
            }
            if (emit)
                this.owner.event(Event.COMPLETE);
        }
        drawFrame() {
            let cmd = this._drawCmds[this._frame];
            if (cmd != this._drawCmd)
                this._drawCmd = this.owner.graphics.replaceCmd(this._drawCmd, cmd);
            if (this._drawCmd)
                this._drawCmd.color = this._color.getABGR();
        }
        get source() {
            return this._source;
        }
        set source(value) {
            if (value == null)
                value = "";
            this._source = value;
            this.load();
        }
        get images() {
            return this._images;
        }
        set images(value) {
            this._images = value;
            this.load();
        }
        load() {
            if (this._atlas) {
                if (this.owner._getBit(NodeFlags.EDITING_NODE))
                    this._atlas.off("reload", this, this.onAtlasReload);
                this._atlas = null;
            }
            if (this._source)
                this.loadAtlas(this._source);
            else if (this._images && this._images.length > 0)
                this.loadImages(this._images);
            else
                this.onLoaded(null, ++this._loadId);
        }
        loadImages(urls) {
            let loadId = ++this._loadId;
            let textures = urls.map(url => Loader.getRes(url));
            if (textures.indexOf(null) === -1) {
                this.frames = textures;
                this.owner.event(Event.LOADED);
            }
            else {
                ILaya.loader.load(urls).then((textures) => {
                    if (loadId != this._loadId || this.destroyed)
                        return;
                    this.frames = textures;
                    this.owner.event(Event.LOADED);
                });
            }
            return this;
        }
        loadAtlas(url) {
            let loadId = ++this._loadId;
            let atlas = Loader.getRes(url, Loader.ATLAS);
            if (atlas)
                this.onLoaded(atlas, loadId);
            else
                ILaya.loader.load(url, Loader.ATLAS).then(atlas => this.onLoaded(atlas, loadId));
            return this;
        }
        setAtlas(res) {
            this.onLoaded(res, ++this._loadId);
        }
        onLoaded(atlas, loadId) {
            var _a, _b;
            if (loadId != this._loadId || this.destroyed)
                return;
            this._atlas = atlas;
            if (atlas) {
                if (this.owner._getBit(NodeFlags.EDITING_NODE))
                    this._atlas.on("reload", this, this.onAtlasReload);
                let ani = atlas.animation;
                if (ani) {
                    this.interval = ani.interval;
                    this.repeatDelay = (_a = ani.repeatDelay) !== null && _a !== void 0 ? _a : 0;
                    this.wrapMode = (_b = ani.wrapMode) !== null && _b !== void 0 ? _b : 0;
                    this._delays.length = 0;
                    if (ani.frameDelays)
                        this._delays.push(...ani.frameDelays);
                }
                this.frames = atlas.frames;
            }
            else
                this.frames = null;
            this.owner.event(Event.LOADED);
        }
        onAtlasReload() {
            this.onLoaded(this._atlas, this._loadId);
        }
    }

    class Animation extends Sprite {
        constructor() {
            super();
            this._comp = this.addComponent(FrameAnimation);
            this._comp.hideFlags |= HideFlags.HideAndDontSave;
            this._comp.autoPlay = false;
        }
        get loop() {
            return this._comp.loop;
        }
        set loop(value) {
            this._comp.loop = value;
        }
        get wrapMode() {
            return this._comp.wrapMode;
        }
        set wrapMode(value) {
            this._comp.wrapMode = value;
        }
        get interval() {
            return this._comp.interval;
        }
        set interval(value) {
            this._comp.interval = value;
        }
        get index() {
            return this._comp.frame;
        }
        set index(value) {
            this._comp.frame = value;
        }
        get count() {
            return this._comp.frames.length;
        }
        get source() {
            return this._comp.source;
        }
        set source(value) {
            this._comp.source = value;
        }
        get images() {
            return this._comp.images;
        }
        set images(value) {
            this._comp.images = value;
        }
        get isPlaying() {
            return this._comp.isPlaying;
        }
        set autoPlay(value) {
            this._comp.autoPlay = value;
        }
        get autoPlay() {
            return this._comp.autoPlay;
        }
        play(start, loop, name = "") {
            if (name)
                this._setFramesFromCache(name, true);
            if (start != null)
                this._comp.frame = (typeof (start) == 'string') ? this.getFrameByLabel(start) : start;
            if (loop != null)
                this._comp.loop = loop;
            this._comp.play();
        }
        clear() {
            this._comp.stop();
            this._comp.frames = null;
            this._labels = null;
            return this;
        }
        stop() {
            this._comp.stop();
        }
        gotoAndStop(position) {
            this.index = (typeof (position) == 'string') ? this.getFrameByLabel(position) : position;
            this.stop();
        }
        addLabel(label, index) {
            if (!this._labels) {
                this._labels = [];
                this._comp._labels = this._labels;
            }
            this._labels[index] = label;
        }
        removeLabel(label) {
            if (!this._labels)
                return;
            for (let i = 0, n = this._labels.length; i < n; i++) {
                if (this._labels[i] == label) {
                    delete this._labels[i];
                }
            }
        }
        loadImages(urls) {
            this._comp.images = urls;
            return this;
        }
        loadAtlas(url) {
            this._comp.source = url;
            return this;
        }
        getFrameByLabel(label) {
            if (!this._labels)
                return 0;
            let i = this._labels.indexOf(label);
            return i != -1 ? i : 0;
        }
        static createFrames(urls, key) {
            Animation.framesMap[key] = urls;
            ILaya.loader.load(urls);
        }
        static clearCache(key) {
            delete Animation.framesMap[key];
        }
        _setFramesFromCache(name, showWarn = false) {
            let urls = Animation.framesMap[name];
            if (urls) {
                this.images = urls;
                return true;
            }
            else {
                if (showWarn)
                    console.log("ani not found:", name);
            }
            return false;
        }
    }
    Animation.framesMap = {};

    class BitmapFont extends Resource {
        static loadFont(path, complete) {
            ILaya.loader.load(path, Loader.FONT).then(font => {
                complete && complete.runWith(font);
            });
        }
        constructor() {
            super(false);
            this.dict = {};
            this.fontSize = 12;
            this.autoScaleSize = false;
            this.tint = true;
            this.maxWidth = 0;
            this.lineHeight = 12;
            this.letterSpacing = 0;
        }
        parseFont(xml, texture) {
            var _a;
            if (xml == null || texture == null)
                return;
            this.texture = texture;
            texture._addReference();
            let scale = 1;
            let info = xml.getNode("info");
            this.fontSize = info.getAttrInt("size", 12);
            this.autoScaleSize = info.getAttrBool("autoScaleSize");
            this.lineHeight = info.getAttrInt("lineHeight", this.fontSize);
            if (this.lineHeight == 0)
                this.lineHeight = this.fontSize;
            let padding = info.getAttrString("padding", "");
            let paddingArray = padding.split(",");
            this.padding = [parseInt(paddingArray[0]), parseInt(paddingArray[1]), parseInt(paddingArray[2]), parseInt(paddingArray[3])];
            let chars = ((_a = xml.getNode("chars")) === null || _a === void 0 ? void 0 : _a.elements("char")) || [];
            let maxWidth = 0;
            let dict = this.dict;
            for (let i = 0, n = chars.length; i < n; i++) {
                let ct = chars[i];
                let id = ct.getAttrInt("id");
                let xOffset = ct.getAttrInt("xoffset") / scale;
                let yOffset = ct.getAttrInt("yoffset") / scale;
                let advance = ct.getAttrInt("xadvance") / scale;
                let x = ct.getAttrInt("x");
                let y = ct.getAttrInt("y");
                let width = ct.getAttrInt("width");
                let height = ct.getAttrInt("height");
                let tex = Texture.create(texture, x, y, width, height, xOffset, yOffset);
                if (advance == 0)
                    advance = width;
                advance += this.letterSpacing;
                maxWidth = Math.max(maxWidth, advance);
                dict[id] = { x: 0, y: 0, width, height, advance, texture: tex };
            }
            if (maxWidth > 0)
                this.maxWidth = maxWidth;
            else
                this.maxWidth = this.fontSize;
            if (!dict[32])
                dict[32] = { x: 0, y: 0, advance: Math.floor(this.fontSize * 0.5) + this.letterSpacing };
        }
        _disposeResource() {
            var _a;
            if (this.texture) {
                for (let k in this.dict) {
                    (_a = this.dict[k].texture) === null || _a === void 0 ? void 0 : _a.destroy();
                }
                this.texture._removeReference();
                this.dict = null;
                this.texture = null;
                this.padding = null;
            }
        }
        getTextWidth(text, fontSize) {
            let w = 0;
            for (let i = 0, n = text.length; i < n; i++) {
                let g = this.dict[text.charCodeAt(i)];
                if (g) {
                    let scale = this.autoScaleSize ? (fontSize / this.fontSize) : 1;
                    w += Math.round(g.advance * scale);
                }
            }
            return w;
        }
        getMaxWidth(fontSize) {
            if (fontSize != null && this.autoScaleSize)
                return Math.round(this.maxWidth * (fontSize / this.fontSize));
            else
                return this.maxWidth;
        }
        getMaxHeight(fontSize) {
            if (fontSize != null && this.autoScaleSize)
                return Math.round(this.lineHeight * (fontSize / this.fontSize));
            else
                return this.lineHeight;
        }
    }

    class TextStyle {
        constructor() {
            this.font = "";
            this.fontSize = 12;
            this.color = "#000000";
            this.bold = false;
            this.italic = false;
            this.underline = false;
            this.strikethrough = false;
            this.align = 'left';
            this.valign = 'top';
            this.alignItems = "middle";
            this.leading = 2;
            this.stroke = 0;
            this.strokeColor = '#000000';
        }
    }

    exports.HtmlElementType = void 0;
    (function (HtmlElementType) {
        HtmlElementType[HtmlElementType["Text"] = 0] = "Text";
        HtmlElementType[HtmlElementType["Link"] = 1] = "Link";
        HtmlElementType[HtmlElementType["Image"] = 2] = "Image";
        HtmlElementType[HtmlElementType["Input"] = 3] = "Input";
        HtmlElementType[HtmlElementType["Select"] = 4] = "Select";
        HtmlElementType[HtmlElementType["Object"] = 5] = "Object";
        HtmlElementType[HtmlElementType["LinkEnd"] = 6] = "LinkEnd";
    })(exports.HtmlElementType || (exports.HtmlElementType = {}));
    class HtmlElement {
        constructor() {
            this.style = new TextStyle();
        }
        getAttr(attrName) {
            if (this._attrs == null)
                return null;
            return this._attrs[attrName];
        }
        setAttr(attrName, attrValue) {
            if (this._attrs == null)
                this._attrs = {};
            this._attrs[attrName] = attrValue;
        }
        getAttrString(attrName, defValue) {
            return XMLUtils.getString(this._attrs, attrName, defValue);
        }
        getAttrInt(attrName, defValue) {
            return XMLUtils.getInt(this._attrs, attrName, defValue);
        }
        getAttrFloat(attrName, defValue) {
            return XMLUtils.getFloat(this._attrs, attrName, defValue);
        }
        getAttrBool(attrName, defValue) {
            return XMLUtils.getBool(this._attrs, attrName, defValue);
        }
        fetchAttributes() {
            this._attrs = Object.assign({}, XMLIterator.attributes);
        }
        reset() {
            this.name = null;
            this.text = null;
            if (this.obj) {
                this.obj.release();
                Pool.recoverByClass(this.obj);
                this.obj = null;
            }
            this._attrs = null;
        }
        static getFromPool(type) {
            let ele;
            if (this.pool.length > 0)
                ele = this.pool.pop();
            else
                ele = new HtmlElement();
            ele.type = type;
            if (ele.type != exports.HtmlElementType.Text && !ele._attrs)
                ele._attrs = {};
            return ele;
        }
        static returnToPool(ele) {
            if (Array.isArray(ele)) {
                for (let e of ele)
                    e.reset();
                this.pool.push(...ele);
                ele.length = 0;
            }
            else {
                ele.reset();
                this.pool.push(ele);
            }
        }
    }
    HtmlElement.pool = [];

    class HtmlImage {
        constructor() {
            this._v = 0;
            this.obj = new Sprite();
        }
        get element() {
            return this._element;
        }
        get width() {
            return this.obj.width;
        }
        get height() {
            return this.obj.height;
        }
        create(owner, element) {
            this._owner = owner;
            this._element = element;
            this._owner.objContainer.addChild(this.obj);
            let src = this._element.getAttrString("src");
            if (src)
                this.loadTexture(src);
        }
        loadTexture(src) {
            let width = this._element.getAttrInt("width", -1);
            let height = this._element.getAttrInt("height", -1);
            if (width != -1)
                this.obj.width = width;
            if (height != -1)
                this.obj.height = height;
            this._w = width;
            this._h = height;
            let res = Loader.getRes(src);
            if (res) {
                this.onLoaded(res, ++this._v);
            }
            else {
                let ver = ++this._v;
                ILaya.loader.load(src, { silent: true }).then(res => this.onLoaded(res, ver, true));
            }
        }
        onLoaded(res, ver, delayed) {
            if (!this._owner || this.obj.destroyed)
                return;
            if (ver != this._v)
                return;
            let obj = this.obj;
            let ani = this._ani;
            if (res instanceof Texture) {
                obj.texture = res;
                if (ani)
                    ani.setAtlas(null);
                if (this._w == -1)
                    obj.width = res.sourceWidth;
                if (this._h == -1)
                    obj.height = res.sourceHeight;
            }
            else if (res instanceof AtlasResource) {
                obj.texture = null;
                if (!ani) {
                    ani = this._ani = obj.addComponent(FrameAnimation);
                    ani.stretchMode = exports.AnimationStretchMode.Fill;
                    ani.autoPlay = true;
                    ani.loop = true;
                }
                ani.setAtlas(res);
                if (this._w == -1)
                    obj.width = ani.width;
                if (this._h == -1)
                    obj.height = ani.height;
            }
            else {
                obj.texture = null;
                if (ani)
                    ani.setAtlas(null);
                if (this._w == -1)
                    obj.width = 0;
                if (this._h == -1)
                    obj.height = 0;
            }
            if (delayed)
                this._owner.refreshLayout();
        }
        pos(x, y) {
            this.obj.pos(x, y);
        }
        release() {
            this.obj.removeSelf();
            this.obj.offAll();
            this.obj.texture = null;
            if (this._ani)
                this._ani.setAtlas(null);
            this._owner = null;
            this._element = null;
            this._v++;
        }
        destroy() {
            this.obj.destroy();
        }
    }

    class HtmlLink {
        constructor() {
            this._shape = new Sprite();
            this._shape.hitArea = this;
            this._shape.on(Event.CLICK, () => {
                this._owner.bubbleEvent(Event.LINK, this._element.getAttrString("href"));
            });
            this._rects = [];
            this._rectCnt = 0;
        }
        get element() {
            return this._element;
        }
        get width() {
            return 0;
        }
        get height() {
            return 0;
        }
        create(owner, element) {
            this._owner = owner;
            this._element = element;
            this._owner.objContainer.addChild(this._shape);
        }
        resetArea() {
            this._rectCnt = 0;
        }
        addRect(x, y, width, height) {
            let rect = this._rects[this._rectCnt];
            if (!rect)
                rect = this._rects[this._rectCnt] = new Rectangle();
            this._rectCnt++;
            rect.setTo(x, y, width, height);
        }
        contains(x, y) {
            for (let i = 0; i < this._rectCnt; i++) {
                if (this._rects[i].contains(x, y))
                    return true;
            }
            return false;
        }
        pos(x, y) {
        }
        release() {
            this._shape.removeSelf();
            this._owner = null;
            this._element = null;
        }
        destroy() {
            this._shape.destroy();
        }
    }

    class HtmlParseOptions {
        constructor() {
            this.linkUnderline = HtmlParseOptions.defaultLinkUnderline;
            this.linkColor = HtmlParseOptions.defaultLinkColor;
        }
    }
    HtmlParseOptions.defaultLinkUnderline = true;
    HtmlParseOptions.defaultLinkColor = null;
    ClassUtils.regClass("HtmlParseOptions", HtmlParseOptions);

    const s_list1 = new Array();
    const s_list2 = new Array();
    class HtmlParser {
        constructor() {
            this._styleStack = new Array();
            this._style = new TextStyle();
            this._options = new HtmlParseOptions();
        }
        parse(aSource, style, out, options) {
            if (options == null)
                options = this._options;
            this._elements = out;
            this._styleStackTop = 0;
            Object.assign(this._style, style);
            this._style.colorChanged = false;
            let skipText = 0;
            let ignoreWhiteSpace = options.ignoreWhiteSpace;
            let skipNextCR = false;
            let text;
            XMLIterator.begin(aSource, true);
            while (XMLIterator.nextTag()) {
                if (skipText == 0) {
                    text = XMLIterator.getText(ignoreWhiteSpace);
                    if (text.length > 0) {
                        if (skipNextCR && text[0] == '\n')
                            text = text.substring(1);
                        this.appendText(text);
                    }
                }
                skipNextCR = false;
                switch (XMLIterator.tagName) {
                    case "b":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.bold = true;
                        }
                        else
                            this.popStyle();
                        break;
                    case "i":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.italic = true;
                        }
                        else
                            this.popStyle();
                        break;
                    case "u":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.underline = true;
                        }
                        else
                            this.popStyle();
                        break;
                    case "strike":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.strikethrough = true;
                        }
                        else
                            this.popStyle();
                        break;
                    case "font":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.fontSize = XMLUtils.getInt(XMLIterator.attributes, "size", this._style.fontSize);
                            let color = XMLIterator.getAttribute("color");
                            if (color != null) {
                                this._style.color = color;
                                this._style.colorChanged = true;
                            }
                        }
                        else if (XMLIterator.tagType == exports.XMLTagType.End)
                            this.popStyle();
                        break;
                    case "br":
                        this.appendText("\n");
                        break;
                    case "img":
                        if (XMLIterator.tagType == exports.XMLTagType.Start || XMLIterator.tagType == exports.XMLTagType.Void) {
                            let element = HtmlElement.getFromPool(exports.HtmlElementType.Image);
                            element.fetchAttributes();
                            element.name = element.getAttrString("name");
                            element.style.align = this._style.align;
                            element.style.underline = this._style.underline;
                            element.style.underlineColor = this._style.underlineColor;
                            this._elements.push(element);
                        }
                        break;
                    case "a":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.underline = this._style.underline || options.linkUnderline;
                            if (!this._style.colorChanged && options.linkColor != null)
                                this._style.color = options.linkColor;
                            let element = HtmlElement.getFromPool(exports.HtmlElementType.Link);
                            element.fetchAttributes();
                            element.name = element.getAttrString("name");
                            element.style.align = this._style.align;
                            this._elements.push(element);
                        }
                        else if (XMLIterator.tagType == exports.XMLTagType.End) {
                            this.popStyle();
                            let element = HtmlElement.getFromPool(exports.HtmlElementType.LinkEnd);
                            this._elements.push(element);
                        }
                        break;
                    case "input":
                        {
                            let element = HtmlElement.getFromPool(exports.HtmlElementType.Input);
                            element.fetchAttributes();
                            element.name = element.getAttrString("name");
                            Object.assign(element.style, this._style);
                            this._elements.push(element);
                        }
                        break;
                    case "select":
                        {
                            if (XMLIterator.tagType == exports.XMLTagType.Start || XMLIterator.tagType == exports.XMLTagType.Void) {
                                let element = HtmlElement.getFromPool(exports.HtmlElementType.Select);
                                element.fetchAttributes();
                                if (XMLIterator.tagType == exports.XMLTagType.Start) {
                                    s_list1.length = 0;
                                    s_list2.length = 0;
                                    while (XMLIterator.nextTag()) {
                                        if (XMLIterator.tagName == "select")
                                            break;
                                        if (XMLIterator.tagName == "option") {
                                            if (XMLIterator.tagType == exports.XMLTagType.Start || XMLIterator.tagType == exports.XMLTagType.Void)
                                                s_list2.push(XMLUtils.getString(XMLIterator.attributes, "value", ""));
                                            else
                                                s_list1.push(XMLIterator.getText());
                                        }
                                    }
                                    element.setAttr("items", s_list1.slice());
                                    element.setAttr("values", s_list2.slice());
                                }
                                element.name = element.getAttrString("name");
                                Object.assign(element.style, this._style);
                                this._elements.push(element);
                            }
                        }
                        break;
                    case "p":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.align = XMLIterator.getAttribute("align");
                            if (!this.isNewLine())
                                this.appendText("\n");
                        }
                        else if (XMLIterator.tagType == exports.XMLTagType.End) {
                            this.appendText("\n");
                            skipNextCR = true;
                            this.popStyle();
                        }
                        break;
                    case "ui":
                    case "div":
                    case "li":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            if (!this.isNewLine())
                                this.appendText("\n");
                        }
                        else {
                            this.appendText("\n");
                            skipNextCR = true;
                        }
                        break;
                    case "html":
                    case "body":
                        ignoreWhiteSpace = true;
                        break;
                    case "head":
                    case "style":
                    case "script":
                    case "form":
                        if (XMLIterator.tagType == exports.XMLTagType.Start)
                            skipText++;
                        else if (XMLIterator.tagType == exports.XMLTagType.End)
                            skipText--;
                        break;
                }
            }
            if (skipText == 0) {
                text = XMLIterator.getText(ignoreWhiteSpace);
                if (text.length > 0) {
                    if (skipNextCR && text[0] == '\n')
                        text = text.substring(1);
                    this.appendText(text);
                }
            }
            this._elements = null;
        }
        pushStyle() {
            let tf;
            if (this._styleStack.length <= this._styleStackTop) {
                tf = new TextStyle();
                this._styleStack.push(tf);
            }
            else
                tf = this._styleStack[this._styleStackTop];
            Object.assign(tf, this._style);
            this._styleStackTop++;
        }
        popStyle() {
            if (this._styleStackTop > 0) {
                let tf = this._styleStack[this._styleStackTop - 1];
                Object.assign(this._style, tf);
                this._styleStackTop--;
            }
        }
        isNewLine() {
            if (this._elements.length > 0) {
                let element = this._elements[this._elements.length - 1];
                if (element && element.type == exports.HtmlElementType.Text)
                    return element.text.endsWith("\n");
                else
                    return false;
            }
            return true;
        }
        appendText(text) {
            let element;
            if (this._elements.length > 0) {
                element = this._elements[this._elements.length - 1];
                if (element.type == exports.HtmlElementType.Text && equalStyle(element.style, this._style)) {
                    element.text += text;
                    return;
                }
            }
            element = HtmlElement.getFromPool(exports.HtmlElementType.Text);
            element.text = text;
            Object.assign(element.style, this._style);
            this._elements.push(element);
        }
    }
    HtmlParser.defaultParser = new HtmlParser();
    HtmlParser.classMap = {
        [exports.HtmlElementType.Image]: HtmlImage,
        [exports.HtmlElementType.Link]: HtmlLink
    };
    function equalStyle(s1, s2) {
        for (let k in s1) {
            if (!k.startsWith("_") && s1[k] != s2[k])
                return false;
        }
        return true;
    }

    class UBBParser {
        constructor() {
            this._readPos = 0;
            this.defaultImgWidth = 0;
            this.defaultImgHeight = 0;
            this._handlers = {};
            this._handlers["url"] = this.onTag_URL;
            this._handlers["img"] = this.onTag_IMG;
            this._handlers["b"] = this.onTag_B;
            this._handlers["i"] = this.onTag_I;
            this._handlers["u"] = this.onTag_U;
            this._handlers["sup"] = this.onTag_Simple;
            this._handlers["sub"] = this.onTag_Simple;
            this._handlers["color"] = this.onTag_COLOR;
            this._handlers["font"] = this.onTag_FONT;
            this._handlers["size"] = this.onTag_SIZE;
        }
        onTag_URL(tagName, end, attr) {
            if (!end) {
                if (attr != null)
                    return "<a href=\"" + attr + "\">";
                else {
                    var href = this.getTagText();
                    return "<a href=\"" + href + "\">";
                }
            }
            else
                return "</a>";
        }
        onTag_IMG(tagName, end, attr) {
            if (!end) {
                var src = this.getTagText(true);
                if (!src)
                    return null;
                if (this.defaultImgWidth)
                    return "<img src=\"" + src + "\" width=\"" + this.defaultImgWidth + "\" height=\"" + this.defaultImgHeight + "\"/>";
                else
                    return "<img src=\"" + src + "\"/>";
            }
            else
                return null;
        }
        onTag_B(tagName, end, attr) {
            return end ? ("</b>") : ("<b>");
        }
        onTag_I(tagName, end, attr) {
            return end ? ("</i>") : ("<i>");
        }
        onTag_U(tagName, end, attr) {
            return end ? ("</u>") : ("<u>");
        }
        onTag_Simple(tagName, end, attr) {
            return end ? ("</" + tagName + ">") : ("<" + tagName + ">");
        }
        onTag_COLOR(tagName, end, attr) {
            if (!end) {
                this.lastColor = attr;
                return "<font color=\"" + attr + "\">";
            }
            else
                return "</font>";
        }
        onTag_FONT(tagName, end, attr) {
            if (!end)
                return "<font face=\"" + attr + "\">";
            else
                return "</font>";
        }
        onTag_SIZE(tagName, end, attr) {
            if (!end) {
                this.lastSize = attr;
                return "<font size=\"" + attr + "\">";
            }
            else
                return "</font>";
        }
        getTagText(remove) {
            var pos1 = this._readPos;
            var pos2;
            var result = "";
            while ((pos2 = this._text.indexOf("[", pos1)) != -1) {
                if (this._text.charCodeAt(pos2 - 1) == 92) {
                    result += this._text.substring(pos1, pos2 - 1);
                    result += "[";
                    pos1 = pos2 + 1;
                }
                else {
                    result += this._text.substring(pos1, pos2);
                    break;
                }
            }
            if (pos2 == -1)
                return null;
            if (remove)
                this._readPos = pos2;
            return result;
        }
        parse(text, remove) {
            this._text = text;
            this.lastColor = null;
            this.lastSize = null;
            var pos1 = 0, pos2, pos3;
            var end;
            var tag, attr;
            var repl;
            var func;
            var result = "";
            while ((pos2 = text.indexOf("[", pos1)) != -1) {
                if (pos2 > 0 && text.charCodeAt(pos2 - 1) == 92) {
                    result += text.substring(pos1, pos2 - 1);
                    result += "[";
                    pos1 = pos2 + 1;
                    continue;
                }
                result += text.substring(pos1, pos2);
                pos1 = pos2;
                pos2 = text.indexOf("]", pos1);
                if (pos2 == -1)
                    break;
                end = text.charAt(pos1 + 1) == '/';
                tag = text.substring(end ? pos1 + 2 : pos1 + 1, pos2);
                this._readPos = pos2 + 1;
                attr = null;
                repl = null;
                pos3 = tag.indexOf("=");
                if (pos3 != -1) {
                    attr = tag.substring(pos3 + 1);
                    tag = tag.substring(0, pos3);
                }
                tag = tag.toLowerCase();
                func = this._handlers[tag];
                if (func != null) {
                    if (!remove) {
                        repl = func.call(this, tag, end, attr);
                        if (repl != null)
                            result += repl;
                    }
                }
                else
                    result += text.substring(pos1, this._readPos);
                pos1 = this._readPos;
            }
            if (pos1 < text.length)
                result += text.substring(pos1);
            this._text = null;
            return result;
        }
    }
    UBBParser.defaultParser = new UBBParser();

    class Text extends Sprite {
        constructor() {
            super();
            this._overflow = Text.VISIBLE;
            this._singleCharRender = false;
            this._prompt = '';
            this._wordWrap = false;
            this._asPassword = false;
            this._textWidth = 0;
            this._textHeight = 0;
            this._html = false;
            this._ubb = false;
            this._maxWidth = 0;
            this._hideText = false;
            this._renderType |= SpriteConst.TEXT;
            this._textStyle = new TextStyle();
            this._textStyle.fontSize = Config.defaultFontSize;
            this._text = "";
            this.font = "";
            this._elements = [];
            this._lines = [];
            this._padding = [0, 0, 0, 0];
            this._fontSizeScale = 1;
            this.graphics._useSpriteRect = true;
        }
        static registerBitmapFont(name, bitmapFont) {
            bitmapFont._addReference();
            Text._bitmapFonts[name] = bitmapFont;
        }
        static unregisterBitmapFont(name, destroy = true) {
            let font = Text._bitmapFonts[name];
            if (font) {
                font._removeReference();
                if (destroy)
                    font.destroy();
                delete Text._bitmapFonts[name];
            }
        }
        destroy(destroyChild = true) {
            recoverLines(this._lines);
            HtmlElement.returnToPool(this._elements);
            if (this._bgDrawCmd)
                this._bgDrawCmd.lock = false;
            super.destroy(destroyChild);
        }
        measureWidth() {
            this.typeset();
            return this._textWidth;
        }
        measureHeight() {
            this.typeset();
            return this._textHeight;
        }
        _transChanged(kind) {
            super._transChanged(kind);
            if ((kind & exports.TransformKind.Size) != 0) {
                if (this._scrollRect != null) {
                    this._updateScrollRect();
                }
                if (!this._updatingLayout)
                    this.markChanged();
                else
                    this.drawBg();
            }
        }
        _updateScrollRect() {
            let rect = this._scrollRect || new Rectangle();
            let rectWidth = this._isWidthSet ? this._width : this._textWidth;
            let rectHeight = this._isHeightSet ? this._height : this._textHeight;
            rect.setTo(0, 0, rectWidth, rectHeight);
            this.scrollRect = rect;
        }
        get textWidth() {
            this.typeset();
            return this._textWidth;
        }
        get textHeight() {
            this.typeset();
            return this._textHeight;
        }
        get text() {
            return this._text;
        }
        set text(value) {
            if (value == null)
                value = "";
            else if (typeof (value) !== "string")
                value = '' + value;
            if (!this.ignoreLang && Text.langPacks)
                value = Text.langPacks[value] || value;
            if (this._text != value) {
                this._text = value;
                this.markChanged();
                this.event(Event.CHANGE);
            }
        }
        changeText(text) {
            this.text = text;
        }
        get font() {
            return this._textStyle.font;
        }
        set font(value) {
            this._textStyle.font = value;
            if (!value) {
                value = Config.defaultFont;
                if (!value)
                    value = "Arial";
            }
            this._realFont = value;
            this._bitmapFont = Text._bitmapFonts[value];
            if (this._bitmapFont) {
                if (this._text)
                    this.markChanged();
            }
            else if (value && (Utils.getFileExtension(value) || value.startsWith("res://"))) {
                let fontObj = ILaya.loader.getRes(value);
                if (!fontObj || fontObj.obsolute) {
                    this._realFont = "Arial";
                    let t = this._textStyle.font;
                    ILaya.loader.load(value).then(fontObj => {
                        if (this._textStyle.font != t || !fontObj)
                            return;
                        if (fontObj instanceof BitmapFont)
                            this._bitmapFont = fontObj;
                        else
                            this._realFont = fontObj.family;
                        if (this._text)
                            this.markChanged();
                    });
                }
                else {
                    if (fontObj instanceof BitmapFont)
                        this._bitmapFont = fontObj;
                    else
                        this._realFont = fontObj.family;
                    if (this._text)
                        this.markChanged();
                }
            }
            else {
                this._realFont = (Browser.onIPhone ? (Config.fontFamilyMap[value] || value) : value);
                if (this._text)
                    this.markChanged();
            }
        }
        get realFont() {
            return this._realFont;
        }
        get fontSize() {
            return this._textStyle.fontSize;
        }
        set fontSize(value) {
            if (this._textStyle.fontSize != value) {
                this._textStyle.fontSize = value;
                this.markChanged();
            }
        }
        get color() {
            return this._textStyle.color;
        }
        set color(value) {
            if (this._textStyle.color != value) {
                this._textStyle.color = value;
                if (!this._isChanged && !this._html && !this._ubb)
                    this._graphics.replaceTextColor(this._textStyle.color);
                else
                    this.markChanged();
            }
        }
        get bold() {
            return this._textStyle.bold;
        }
        set bold(value) {
            if (this._textStyle.bold != value) {
                this._textStyle.bold = value;
                this.markChanged();
            }
        }
        get italic() {
            return this._textStyle.italic;
        }
        set italic(value) {
            if (this._textStyle.italic != value) {
                this._textStyle.italic = value;
                this.markChanged();
            }
        }
        get align() {
            return this._textStyle.align;
        }
        set align(value) {
            if (this._textStyle.align != value) {
                this._textStyle.align = value;
                this.markChanged();
            }
        }
        get valign() {
            return this._textStyle.valign;
        }
        set valign(value) {
            if (this._textStyle.valign != value) {
                this._textStyle.valign = value;
                this.markChanged();
            }
        }
        get alignItems() {
            return this._textStyle.alignItems;
        }
        set alignItems(value) {
            if (this._textStyle.alignItems != value) {
                this._textStyle.alignItems = value;
                this.markChanged();
            }
        }
        get wordWrap() {
            return this._wordWrap;
        }
        set wordWrap(value) {
            if (this._wordWrap != value) {
                this._wordWrap = value;
                this.markChanged();
            }
        }
        get leading() {
            return this._textStyle.leading;
        }
        set leading(value) {
            if (this._textStyle.leading != value) {
                this._textStyle.leading = value;
                this.markChanged();
            }
        }
        get padding() {
            return this._padding;
        }
        set padding(value) {
            if (typeof (value) == 'string') {
                let arr = value.split(",");
                this._padding.length = 0;
                for (let i = 0; i < 4; i++) {
                    let v = parseFloat(arr[i]);
                    if (isNaN(v))
                        v = 0;
                    this._padding.push(v);
                }
            }
            else
                this._padding = value;
            this.markChanged();
        }
        get bgColor() {
            return this._bgColor;
        }
        set bgColor(value) {
            this._bgColor = value;
            this.drawBg();
        }
        get borderColor() {
            return this._borderColor;
        }
        set borderColor(value) {
            this._borderColor = value;
            this.drawBg();
        }
        get stroke() {
            return this._textStyle.stroke;
        }
        set stroke(value) {
            if (this._textStyle.stroke != value) {
                this._textStyle.stroke = value;
                this.markChanged();
            }
        }
        get strokeColor() {
            return this._textStyle.strokeColor;
        }
        set strokeColor(value) {
            if (this._textStyle.strokeColor != value) {
                this._textStyle.strokeColor = value;
                this.markChanged();
            }
        }
        get overflow() {
            return this._overflow;
        }
        set overflow(value) {
            if (this._overflow != value) {
                this._overflow = value;
                if (value !== Text.VISIBLE) {
                    this._updateScrollRect();
                }
                else
                    this.scrollRect = null;
            }
        }
        get underline() {
            return this._textStyle.underline;
        }
        set underline(value) {
            if (this._textStyle.underline != value) {
                this._textStyle.underline = value;
                this.markChanged();
            }
        }
        get underlineColor() {
            return this._textStyle.underlineColor;
        }
        set underlineColor(value) {
            if (this._textStyle.underlineColor != value) {
                this._textStyle.underlineColor = value;
                this.markChanged();
            }
        }
        get strikethrough() {
            return this._textStyle.strikethrough;
        }
        set strikethrough(value) {
            if (this._textStyle.strikethrough != value) {
                this._textStyle.strikethrough = value;
                this.markChanged();
            }
        }
        get strikethroughColor() {
            return this._textStyle.strikethroughColor;
        }
        set strikethroughColor(value) {
            if (this._textStyle.strikethroughColor != value) {
                this._textStyle.strikethroughColor = value;
                this.markChanged();
            }
        }
        get singleCharRender() {
            return this._singleCharRender;
        }
        set singleCharRender(value) {
            if (this._singleCharRender !== value) {
                this._singleCharRender = value;
                this.markChanged();
            }
        }
        get html() {
            return this._html;
        }
        set html(value) {
            if (this._html != value) {
                this._html = value;
                this.markChanged();
            }
        }
        get ubb() {
            return this._ubb;
        }
        set ubb(value) {
            if (this._ubb != value) {
                this._ubb = value;
                this.markChanged();
            }
        }
        get maxWidth() {
            return this._maxWidth;
        }
        set maxWidth(value) {
            if (this._maxWidth != value) {
                this._maxWidth = value;
                this.markChanged();
            }
        }
        get htmlParseOptions() {
            return this._htmlParseOptions;
        }
        set htmlParseOptions(value) {
            this._htmlParseOptions = value;
        }
        get templateVars() {
            return this._templateVars;
        }
        set templateVars(value) {
            if (!this._templateVars && !value)
                return;
            if (value === true)
                this._templateVars = {};
            else if (value === false)
                this._templateVars = null;
            else
                this._templateVars = value;
            this.markChanged();
        }
        setVar(name, value) {
            if (!this._templateVars)
                this._templateVars = {};
            this._templateVars[name] = value;
            this.markChanged();
            return this;
        }
        get scrollX() {
            if (!this._scrollPos)
                return 0;
            return this._scrollPos.x;
        }
        set scrollX(value) {
            this.typeset();
            if (!this._scrollPos)
                return;
            let maxScrollX = this.maxScrollX;
            value = value < 0 ? 0 : value;
            value = value > maxScrollX ? maxScrollX : value;
            this._scrollPos.x = value;
            this.renderText();
        }
        get scrollY() {
            if (!this._scrollPos)
                return 0;
            return this._scrollPos.y;
        }
        set scrollY(value) {
            this.typeset();
            if (!this._scrollPos)
                return;
            let maxScrollY = this.maxScrollY;
            value = value < 0 ? 0 : value;
            value = value > maxScrollY ? maxScrollY : value;
            this._scrollPos.y = value;
            this.renderText();
        }
        get maxScrollX() {
            let r = this.textWidth - this._width;
            return r < 0 ? 0 : r;
        }
        get maxScrollY() {
            let r = this.textHeight - this._height;
            return r < 0 ? 0 : r;
        }
        get lines() {
            this.typeset();
            return this._lines;
        }
        markChanged() {
            if (!this._isChanged) {
                this._isChanged = true;
                ILaya.systemTimer.callLater(this, this._typeset);
            }
        }
        typeset(force) {
            (this._isChanged || force) && ILaya.systemTimer.runCallLater(this, this._typeset, true);
        }
        refreshLayout() {
            ILaya.systemTimer.callLater(this, this.doLayout);
        }
        get objContainer() {
            if (!this._objContainer) {
                this._objContainer = new Sprite();
                this._objContainer.hideFlags |= HideFlags.HideAndDontSave;
                this.addChild(this._objContainer);
            }
            return this._objContainer;
        }
        hideText(value) {
            this._hideText = value;
            if (value) {
                this.graphics.clear(true, this._bgDrawCmd);
            }
            else {
                this.markChanged();
                this.typeset();
            }
        }
        _typeset() {
            this._isChanged = false;
            if (this._hideText || this._destroyed)
                return;
            HtmlElement.returnToPool(this._elements);
            if (this._objContainer)
                this._objContainer.removeChildren();
            let text = this._text;
            if (this._onTranslate)
                text = this._onTranslate(text, this._templateVars);
            let isPrompt;
            if (!text && this._prompt) {
                text = this._prompt;
                isPrompt = true;
            }
            if (!text) {
                this.graphics.clear(true, this._bgDrawCmd);
                this._textWidth = this._textHeight = 0;
                this._scrollPos = null;
                if (this._onPostLayout) {
                    this._updatingLayout = true;
                    this._onPostLayout();
                    this._updatingLayout = false;
                }
                return;
            }
            let html = this._html;
            text = text.replace(normalizeCR, "\n");
            if (this._parseEscapeChars)
                text = text.replace(escapeCharsPattern, getReplaceStr);
            if (!isPrompt && this._templateVars)
                text = Utils.parseTemplate(text, this._templateVars);
            if (this._ubb) {
                text = UBBParser.defaultParser.parse(text);
                html = true;
            }
            if (!isPrompt && this._asPassword)
                text = Text._passwordChar.repeat(text.length);
            let saveColor;
            if (isPrompt) {
                saveColor = this._textStyle.color;
                this._textStyle.color = this._promptColor;
            }
            if (html)
                HtmlParser.defaultParser.parse(text, this._textStyle, this._elements, this._htmlParseOptions);
            else {
                let ele = HtmlElement.getFromPool(exports.HtmlElementType.Text);
                Object.assign(ele.style, this._textStyle);
                ele.text = text;
                this._elements.push(ele);
            }
            if (isPrompt)
                this._textStyle.color = saveColor;
            this.doLayout();
        }
        doLayout() {
            if (this._destroyed)
                return;
            this._updatingLayout = true;
            this._fontSizeScale = 1;
            let wordWrap = this._wordWrap || this._overflow == Text.ELLIPSIS;
            let noBreakWord = this._wordWrap;
            let padding = this._padding;
            let rectWidth;
            if (this._isWidthSet)
                rectWidth = this._width - padding[3] - padding[1];
            else
                rectWidth = Number.MAX_VALUE;
            if (this._maxWidth > 0) {
                let m = this._maxWidth - padding[3] - padding[1];
                if (!wordWrap || m < rectWidth)
                    rectWidth = m;
                wordWrap = true;
            }
            let rectHeight = this._isHeightSet ? (this._height - padding[0] - padding[2]) : Number.MAX_VALUE;
            let alignItems = this._textStyle.alignItems == "middle" ? 1 : (this._textStyle.alignItems == "bottom" ? 2 : 0);
            let lineX, lineY;
            let curLine;
            let lastCmd;
            let charWidth, charHeight;
            let fontSize;
            let bfont = this._bitmapFont;
            let ctxFont;
            let textRender = Render2DProcessor.runner._textRender;
            let getTextWidth = (text) => {
                if (bfont)
                    return bfont.getTextWidth(text, fontSize);
                else {
                    let ret = Browser.context.measureText(text);
                    return ret ? ret.width : 100;
                }
            };
            let getTextWidth2 = (text, font, fontSize) => {
                if (bfont) {
                    return bfont.getTextWidth(text, fontSize);
                }
                else {
                    let t = Browser.context.font;
                    Browser.context.font = font;
                    let ret = Browser.context.measureText(text);
                    Browser.context.font = t;
                    return ret ? ret.width : 100;
                }
            };
            let buildLines = (text, style) => {
                fontSize = Math.floor(style.fontSize * this._fontSizeScale);
                if (fontSize == 0)
                    fontSize = 1;
                if (bfont) {
                    charWidth = bfont.getMaxWidth(fontSize);
                    charHeight = bfont.getMaxHeight(fontSize);
                }
                else {
                    Browser.context.font = ctxFont = (style.bold ? "bold " : "") + fontSize + "px " + this._realFont;
                    charWidth = fontSize;
                    charHeight = textRender.getFontHeight(this._realFont, fontSize, style.bold);
                }
                let lines = text.split("\n");
                if (wordWrap) {
                    for (let i = 0, n = lines.length; i < n; i++) {
                        let line = lines[i];
                        if (line.length > 0)
                            wrapText(line, style);
                        if (i != n - 1) {
                            addLine();
                        }
                    }
                }
                else {
                    for (let i = 0, n = lines.length; i < n; i++) {
                        let line = lines[i];
                        if (line.length > 0)
                            addCmd(line, style, null);
                        if (i != n - 1) {
                            addLine();
                        }
                    }
                }
            };
            let addCmd = (target, style, width) => {
                let cmd = cmdPool.length > 0 ? cmdPool.pop() : {};
                cmd.x = lineX;
                cmd.y = lineY;
                if (typeof (target) === "string") {
                    if (!width)
                        width = getTextWidth(target);
                    cmd.text = target;
                    cmd.ctxFont = ctxFont;
                    cmd.fontSize = fontSize;
                    cmd.width = width;
                    cmd.height = charHeight;
                }
                else {
                    cmd.obj = target;
                    cmd.width = target.width;
                    cmd.height = target.height;
                    if (target.width > 0) {
                        cmd.x++;
                        cmd.width += 2;
                    }
                }
                cmd.style = style;
                cmd.linkEnd = false;
                cmd.next = null;
                cmd.prev = lastCmd;
                lineX += Math.round(cmd.width);
                if (lastCmd)
                    lastCmd.next = cmd;
                else
                    curLine.cmd = cmd;
                lastCmd = cmd;
            };
            let moveCmds = (cmd) => {
                while (cmd.linkEnd && cmd.next) {
                    cmd = cmd.next;
                }
                if (!cmd)
                    return;
                cmd.prev.next = null;
                while (cmd) {
                    let next = cmd.next;
                    cmd.x = lineX;
                    cmd.y = lineY;
                    cmd.next = null;
                    cmd.prev = lastCmd;
                    lineX += Math.round(cmd.width);
                    if (lastCmd)
                        lastCmd.next = cmd;
                    else
                        curLine.cmd = cmd;
                    lastCmd = cmd;
                    cmd = next;
                }
            };
            let splitCmd = (cmd, pos) => {
                let ccode = cmd.text.charCodeAt(pos);
                if (isLowSurrogate(ccode))
                    pos--;
                if (pos == 0)
                    return false;
                let str = cmd.text.substring(pos);
                cmd.text = cmd.text.substring(0, pos);
                cmd.width = getTextWidth2(cmd.text, cmd.ctxFont, cmd.fontSize);
                let cmd2 = cmdPool.length > 0 ? cmdPool.pop() : {};
                cmd2.text = str;
                cmd2.style = cmd.style;
                cmd2.ctxFont = cmd.ctxFont;
                cmd2.fontSize = cmd.fontSize;
                cmd2.width = getTextWidth2(str, cmd.ctxFont, cmd.fontSize);
                cmd2.height = cmd.height;
                cmd2.next = cmd.next;
                cmd2.prev = cmd;
                cmd.next = cmd2;
                return true;
            };
            let addLine = (last) => {
                lineX = 0;
                if (curLine) {
                    let lineHeight = 0;
                    let lineWidth = 0;
                    let cmd = curLine.cmd;
                    while (cmd) {
                        if (cmd.height > lineHeight)
                            lineHeight = cmd.height;
                        lineWidth += cmd.width;
                        cmd = cmd.next;
                    }
                    cmd = curLine.cmd;
                    while (cmd) {
                        if (alignItems == 1)
                            cmd.y = Math.floor((lineHeight - cmd.height) * 0.5);
                        else if (alignItems == 2)
                            cmd.y = Math.floor((lineHeight - cmd.height));
                        else
                            cmd.y = 0;
                        cmd = cmd.next;
                    }
                    if (lineHeight == 0)
                        lineHeight = charHeight;
                    lineHeight++;
                    curLine.height = lineHeight;
                    curLine.width = Math.round(lineWidth);
                    lineY += curLine.height + Math.floor(this._textStyle.leading * this._fontSizeScale);
                }
                if (last)
                    return null;
                curLine = linePool.length > 0 ? linePool.pop() : {};
                curLine.x = 0;
                curLine.y = lineY;
                this._lines.push(curLine);
                lastCmd = null;
                return curLine;
            };
            let wrapText = (text, style) => {
                let remainWidth = Math.max(0, rectWidth - lineX);
                let tw = getTextWidth(text);
                if (tw <= remainWidth) {
                    addCmd(text, style, tw);
                    return;
                }
                let maybeIndex = 0;
                let wordWidth = 0;
                let startIndex = 0;
                let isPunc;
                let testResult;
                let isEmoji = emojiTest.test(text);
                if (!bfont && !isEmoji) {
                    maybeIndex = Math.floor(remainWidth / charWidth);
                    if (maybeIndex != 0)
                        wordWidth = getTextWidth(text.substring(0, maybeIndex));
                }
                let len = text.length;
                for (let j = maybeIndex; j < len; j++) {
                    let cc = text.charAt(j);
                    let ccode = cc.charCodeAt(0);
                    if (isEmoji && isHighSurrogate(ccode) && j + 1 < len)
                        cc += text.charAt(j + 1);
                    tw = getTextWidth(cc);
                    wordWidth += tw;
                    if (wordWidth <= remainWidth || j === startIndex && lineX === 0) {
                        if (cc.length > 1)
                            j++;
                        continue;
                    }
                    let part = text.substring(startIndex, j);
                    wordWidth -= tw;
                    if (noBreakWord && ((ccode >= 65 && ccode <= 90) || (ccode >= 97 && ccode <= 122)
                        || (ccode >= 48 && ccode <= 57)
                        || (isPunc = punctuationChars.includes(ccode)))) {
                        let wb = part.length > 0 ? ((testResult = wordBoundaryTest.exec(part)) ? testResult.index : null) : 0;
                        if (wb > 0) {
                            if (wb > part.length - maxWordLength) {
                                j = startIndex + wb;
                                part = text.substring(startIndex, j);
                                wordWidth = null;
                                tw = null;
                            }
                        }
                        else if (wb != null && lastCmd != null) {
                            let cmd = lastCmd;
                            let totalLen = part.length;
                            let newLine = false;
                            while (cmd) {
                                if (cmd.width > 0) {
                                    if (cmd.obj != null)
                                        break;
                                    testResult = wordBoundaryTest.exec(cmd.text);
                                    let textLen = cmd.text.length;
                                    if (testResult == null) {
                                        addLine();
                                        if (isPunc && totalLen == 0) {
                                            if (splitCmd(cmd, textLen - 1))
                                                moveCmds(cmd.next);
                                            else if (cmd.x > 0)
                                                moveCmds(cmd);
                                        }
                                        else if (cmd.next != null)
                                            moveCmds(cmd.next);
                                        newLine = true;
                                        break;
                                    }
                                    else if (testResult.index > 0) {
                                        if (testResult.index > textLen - (maxWordLength - totalLen)) {
                                            addLine();
                                            splitCmd(cmd, testResult.index);
                                            moveCmds(cmd.next);
                                            newLine = true;
                                        }
                                        break;
                                    }
                                    else {
                                        totalLen += textLen;
                                        if (totalLen >= maxWordLength)
                                            break;
                                    }
                                }
                                cmd = cmd.prev;
                            }
                            if (newLine) {
                                remainWidth = rectWidth - lineX;
                                if (wordWidth + tw < remainWidth) {
                                    wordWidth += tw;
                                    continue;
                                }
                            }
                        }
                        else {
                            if (isPunc) {
                                let b = (isEmoji && j >= 1 && isLowSurrogate(text.charCodeAt(j - 1))) ? 2 : 1;
                                if (j - b > startIndex || lineX > 0) {
                                    j -= b;
                                    part = text.substring(startIndex, j);
                                    wordWidth = null;
                                    tw = null;
                                }
                            }
                        }
                    }
                    if (part.length > 0)
                        addCmd(part, style, wordWidth);
                    addLine();
                    startIndex = j;
                    remainWidth = rectWidth;
                    wordWidth = null;
                    if (maybeIndex > 1)
                        j += maybeIndex - 1;
                    else if (tw != null) {
                        wordWidth = tw;
                        if (cc.length > 1)
                            j++;
                    }
                    else if (isEmoji && isHighSurrogate(text.charCodeAt(j)))
                        j++;
                    if (wordWidth == null && j < len - 1)
                        wordWidth = getTextWidth(text.substring(startIndex, j + 1));
                }
                addCmd(text.substring(startIndex, len), style);
            };
            let calcTextSize = () => {
                let nw = 0, nh = 0;
                for (let line of this._lines) {
                    if (line.width > nw)
                        nw = line.width;
                }
                if (nw > 0)
                    nw += padding[1] + padding[3];
                this._textWidth = nw;
                let lastLine = this._lines[this._lines.length - 1];
                if (lastLine)
                    nh = lastLine.y + lastLine.height;
                if (nh > 0)
                    nh += padding[0] + padding[2];
                this._textHeight = nh;
            };
            let run = () => {
                lineX = lineY = charWidth = charHeight = 0;
                curLine = null;
                lastCmd = null;
                recoverLines(this._lines);
                addLine();
                let elements = this._elements;
                for (let i = 0, n = elements.length; i < n; i++) {
                    let ele = elements[i];
                    if (ele.type == exports.HtmlElementType.Text) {
                        buildLines(ele.text, ele.style);
                    }
                    else if (ele.type == exports.HtmlElementType.LinkEnd) {
                        if (lastCmd)
                            lastCmd.linkEnd = true;
                    }
                    else {
                        let htmlObj = ele.obj;
                        if (!htmlObj) {
                            let cls = HtmlParser.classMap[ele.type];
                            if (cls) {
                                htmlObj = Pool.createByClass(cls);
                                htmlObj.create(this, ele);
                                ele.obj = htmlObj;
                            }
                        }
                        if (htmlObj) {
                            if (wordWrap) {
                                let remainWidth = rectWidth - lineX;
                                if (htmlObj.width > 0 && remainWidth < htmlObj.width + 1) {
                                    if (lineX > 0) {
                                        addLine();
                                    }
                                }
                            }
                            addCmd(htmlObj, ele.style);
                        }
                    }
                }
                addLine(true);
                calcTextSize();
            };
            run();
            if (this._overflow == Text.SHRINK) {
                if (this._lines.length > 1 && this._textHeight > rectHeight) {
                    let low = 0;
                    let high = this._textStyle.fontSize;
                    this._fontSizeScale = Math.sqrt(rectHeight / this._textHeight);
                    let cur = Math.floor(this._fontSizeScale * this._textStyle.fontSize);
                    while (true) {
                        run();
                        if (this._textWidth > rectWidth || this._textHeight > rectHeight)
                            high = cur;
                        else
                            low = cur;
                        if (high - low > 1 || high != low && cur == high) {
                            cur = low + (high - low) / 2;
                            this._fontSizeScale = cur / this._textStyle.fontSize;
                        }
                        else
                            break;
                    }
                }
                else if (this._textWidth > rectWidth) {
                    this._fontSizeScale = rectWidth / this._textWidth;
                    run();
                    if (this._textWidth > rectWidth) {
                        let size = Math.floor(this._textStyle.fontSize * this._fontSizeScale);
                        size--;
                        this._fontSizeScale = size / this._textStyle.fontSize;
                        run();
                    }
                }
            }
            else if (this._overflow == Text.ELLIPSIS
                && (this._textWidth > rectWidth || this._textHeight > rectHeight || !this._wordWrap && this._lines.length > 1)) {
                let i;
                if (!this._wordWrap && this._lines.length > 1)
                    i = 1;
                else {
                    i = this._lines.findIndex(line => line.y + line.height > rectHeight);
                    if (i === 0)
                        i = 1;
                }
                let linesDeleted = false;
                if (i != -1 && this._lines.length > i) {
                    recoverLines(this._lines.splice(i, this._lines.length - i), true);
                    linesDeleted = true;
                }
                curLine = this._lines[this._lines.length - 1];
                let cmd = curLine.cmd;
                let next;
                let textCmd;
                let done = false;
                while (cmd) {
                    next = cmd.next;
                    if (!cmd.obj)
                        textCmd = cmd;
                    if (done) {
                        cleanCmd(cmd, true);
                        cmdPool.push(cmd);
                    }
                    else if ((!next && linesDeleted) || cmd.x + cmd.width > rectWidth - 10) {
                        if (cmd.obj) {
                            cleanCmd(cmd, true);
                            cmd.text = ellipsisStr;
                            if (textCmd) {
                                cmd.ctxFont = textCmd.ctxFont;
                                cmd.fontSize = textCmd.fontSize;
                                cmd.height = textCmd.height;
                                cmd.style = textCmd.style;
                            }
                            else {
                                cmd.ctxFont = ctxFont;
                                cmd.fontSize = fontSize;
                                cmd.height = charHeight;
                                cmd.style = this._textStyle;
                            }
                        }
                        else {
                            let space = cmd.x + cmd.width - rectWidth;
                            let remove = space < 5 ? 2 : space < 10 ? 1 : 0;
                            let min = cmd === curLine.cmd ? 1 : 0;
                            let i = cmd.text.length;
                            while (i > min && remove > 0) {
                                if (isLowSurrogate(cmd.text.charCodeAt(i - 1)))
                                    i--;
                                i--;
                                remove--;
                            }
                            cmd.text = cmd.text.substring(0, i) + ellipsisStr;
                        }
                        cmd.width = getTextWidth2(cmd.text, cmd.ctxFont, cmd.fontSize);
                        cmd.next = null;
                        done = true;
                        addLine(true);
                    }
                    cmd = next;
                }
                if (done || linesDeleted)
                    calcTextSize();
            }
            if (this._onPostLayout)
                this._onPostLayout();
            let align = this._textStyle.align == "center" ? 1 : (this._textStyle.align == "right" ? 2 : 0);
            if (align != 0 && this._isWidthSet) {
                let rectWidth = this._width - padding[3] - padding[1];
                for (let line of this._lines) {
                    let offsetX = 0;
                    if (align == 1)
                        offsetX = Math.floor((rectWidth - line.width) * 0.5);
                    else if (align == 2)
                        offsetX = rectWidth - line.width;
                    if (offsetX > 0)
                        line.x = offsetX;
                }
            }
            if (this._isHeightSet && this._textHeight < this._height) {
                let offsetY = 0;
                if (this._textStyle.valign === "middle")
                    offsetY = Math.floor((this._height - this._textHeight) * 0.5);
                else if (this._textStyle.valign === "bottom")
                    offsetY = this._height - this._textHeight;
                if (offsetY > 0) {
                    for (let line of this._lines) {
                        line.y += offsetY;
                    }
                }
            }
            if (this._overflow == Text.SCROLL
                && (this._isWidthSet && this._textWidth > this._width || this._isHeightSet && this._textHeight > this._height)) {
                if (!this._scrollPos)
                    this._scrollPos = new Point(0, 0);
                else {
                    let maxScrollX = this.maxScrollX;
                    let maxScrollY = this.maxScrollY;
                    if (this._scrollPos.x > maxScrollX)
                        this._scrollPos.x = maxScrollX;
                    if (this._scrollPos.y > maxScrollY)
                        this._scrollPos.y = maxScrollY;
                }
            }
            else
                this._scrollPos = null;
            if (this._objContainer) {
                this._objContainer.size(this._width, this._height);
                if (this._scrollPos || this._overflow == Text.HIDDEN && this._objContainer.numChildren > 0) {
                    let rect = this._objContainer.scrollRect || new Rectangle();
                    let rectWidth = this._isWidthSet ? this._width : this._textWidth;
                    let rectHeight = this._isHeightSet ? this._height : this._textHeight;
                    this._objContainer.scrollRect = rect.setTo(0, 0, rectWidth, rectHeight);
                }
                else
                    this._objContainer.scrollRect = null;
            }
            this._updatingLayout = false;
            this.renderText();
        }
        renderText() {
            let graphics = this.graphics;
            graphics.clear(true, this._bgDrawCmd);
            this._fontGlobalScale = TextRenderConfig.fontScale;
            let padding = this._padding;
            let paddingLeft = padding[3];
            let paddingTop = padding[0];
            let bfont = this._bitmapFont;
            let scrollPos = this._scrollPos;
            let rectWidth = this._isWidthSet ? this._width : this._textWidth;
            let rectHeight = this._isHeightSet ? this._height : this._textHeight;
            let bottom = rectHeight - padding[2];
            let clipped = this._overflow == Text.HIDDEN || this._overflow == Text.SCROLL;
            rectWidth -= (padding[3] + padding[1]);
            rectHeight -= (padding[0] + padding[2]);
            let x = 0, y = 0;
            let lines = this._lines;
            let lineCnt = lines.length;
            let curLink;
            let linkStartX;
            for (let i = 0; i < lineCnt; i++) {
                let line = lines[i];
                x = paddingLeft + line.x;
                y = paddingTop + line.y;
                if (scrollPos) {
                    x -= scrollPos.x;
                    y -= scrollPos.y;
                }
                let lineClipped = clipped && ((y + line.height) <= paddingTop || y >= bottom);
                let cmd = line.cmd;
                while (cmd) {
                    if (cmd.linkEnd) {
                        if (curLink) {
                            curLink.addRect(linkStartX, y, x + cmd.x + cmd.width - linkStartX, line.height);
                            curLink = null;
                        }
                    }
                    if (cmd.obj) {
                        cmd.obj.pos(x + cmd.x, y + cmd.y);
                        if (cmd.obj.element.type == exports.HtmlElementType.Link) {
                            curLink = cmd.obj;
                            curLink.resetArea();
                            linkStartX = x + cmd.x;
                        }
                    }
                    else if (!lineClipped) {
                        if (bfont) {
                            let tx = 0;
                            let str = cmd.text;
                            let color = bfont.tint ? cmd.style.color : "#FFFFFF";
                            let scale = Math.floor((bfont.autoScaleSize ? cmd.style.fontSize : bfont.fontSize) * this._fontSizeScale) / bfont.fontSize;
                            for (let i = 0, n = str.length; i < n; i++) {
                                let c = str.charCodeAt(i);
                                let g = bfont.dict[c];
                                if (g) {
                                    if (g.texture)
                                        graphics.drawImage(g.texture, x + cmd.x + tx + g.x * scale, y + cmd.y + g.y * scale, g.width * scale, g.height * scale, color);
                                    tx += Math.round(g.advance * scale);
                                }
                            }
                        }
                        else {
                            let gcmd = FillTextCmd.create(cmd.text, x + cmd.x, y + cmd.y, null, cmd.style.color, null, cmd.style.stroke, cmd.style.strokeColor);
                            gcmd.fontFamily = this._realFont;
                            gcmd.fontSize = cmd.fontSize;
                            gcmd.bold = cmd.style.bold;
                            gcmd.italic = cmd.style.italic;
                            gcmd.singleCharRender = this._singleCharRender;
                            gcmd._preMeasuredWidth = cmd.width;
                            graphics.addCmd(gcmd);
                        }
                    }
                    if (!lineClipped && cmd.width > 0) {
                        if (cmd.style.underline) {
                            let thickness = Math.max(1, cmd.fontSize / 16);
                            graphics.drawLine(x + cmd.x, y + line.height - thickness, x + cmd.x + cmd.width, y + line.height - thickness, cmd.style.underlineColor || cmd.style.color, thickness);
                        }
                        if (cmd.style.strikethrough) {
                            let thickness = Math.max(1, cmd.fontSize / 16);
                            let stx = x + cmd.x;
                            let sty = (y + line.height / 2 - thickness) | 0;
                            let ext = 4;
                            graphics.drawLine(stx - ext, sty, stx + cmd.width + ext, sty, cmd.style.strikethroughColor || cmd.style.color, thickness);
                        }
                    }
                    cmd = cmd.next;
                }
                if (curLink) {
                    curLink.addRect(linkStartX, y, rectWidth - linkStartX + paddingLeft, line.height);
                    linkStartX = paddingLeft;
                }
            }
            if (clipped) {
                this._updateScrollRect();
            }
        }
        drawBg() {
            let cmd = this._bgDrawCmd;
            if (this._bgColor || this._borderColor) {
                if (!cmd) {
                    cmd = new DrawRectCmd();
                    cmd.x = cmd.y = 0;
                    cmd.width = cmd.height = 1;
                    cmd.percent = true;
                    cmd.lock = true;
                    this._bgDrawCmd = cmd;
                }
                cmd.fillColor = this._bgColor;
                cmd.lineColor = this._borderColor;
                cmd.lineWidth = this._borderColor ? 1 : 0;
                let cmds = this.graphics.cmds;
                let i = cmds.indexOf(cmd);
                if (i !== 0) {
                    if (i !== -1)
                        cmds.splice(i, 1);
                    cmds.unshift(cmd);
                    this.graphics.cmds = cmds;
                }
                else
                    this.graphics.repaint();
            }
            else if (cmd) {
                this.graphics.removeCmd(cmd, true);
                this._bgDrawCmd = null;
            }
        }
        _setParent(value) {
            super._setParent(value);
            if (value && this._fontGlobalScale != null && this._fontGlobalScale !== TextRenderConfig.fontScale) {
                this.repaint();
            }
        }
    }
    Text.VISIBLE = "visible";
    Text.SCROLL = "scroll";
    Text.HIDDEN = "hidden";
    Text.SHRINK = "shrink";
    Text.ELLIPSIS = "ellipsis";
    Text.RightToLeft = false;
    Text._passwordChar = "●";
    Text._bitmapFonts = {};
    const cmdPool = [];
    const linePool = [];
    function recoverLines(lines, releaseObjs) {
        for (let line of lines) {
            let cmd = line.cmd;
            while (cmd) {
                cleanCmd(cmd, releaseObjs);
                cmdPool.push(cmd);
                cmd = cmd.next;
            }
            line.cmd = null;
        }
        linePool.push(...lines);
        lines.length = 0;
    }
    function cleanCmd(cmd, releaseObj) {
        if (cmd.obj) {
            if (releaseObj) {
                cmd.obj.element.obj = null;
                cmd.obj.release();
                Pool.recoverByClass(cmd.obj);
            }
            cmd.obj = null;
        }
    }
    const emojiTest = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
    const wordBoundaryTest = /[a-zA-Z0-9\!-\+\/_]+$/;
    const punctuationChars = Array.from(".,，。、!！；;”’)）]】}》").map(char => char.charCodeAt(0));
    const normalizeCR = /\r\n/g;
    const escapeCharsPattern = /\\(\w)/g;
    const escapeSequence = { "\\n": "\n", "\\t": "\t" };
    const ellipsisStr = "…";
    const maxWordLength = 20;
    function getReplaceStr(word) {
        return escapeSequence[word];
    }
    function isHighSurrogate(c) {
        return c >= 0xD800 && c <= 0xDBFF;
    }
    function isLowSurrogate(c) {
        return c >= 0xDC00 && c <= 0xDFFF;
    }

    class Input extends Text {
        constructor() {
            super();
            this.confirmType = 'done';
            this.maxChars = 0;
            this._multiline = false;
            this._editable = true;
            this._width = 100;
            this._height = 20;
            this._type = "text";
            this._promptColor = "#a9a9a9";
            this.overflow = Text.SCROLL;
            this.valign = "middle";
            this.mouseEnabled = true;
        }
        get multiline() {
            return this._multiline;
        }
        set multiline(value) {
            if (this._multiline != value) {
                this._multiline = value;
                this.wordWrap = value;
                this.valign = value ? "top" : "middle";
            }
        }
        get focus() {
            return PAL.textInput.target === this;
        }
        set focus(value) {
            if (value)
                PAL.textInput.begin(this);
            else if (this === PAL.textInput.target)
                PAL.textInput.end();
        }
        get text() {
            if (PAL.textInput.target === this)
                PAL.textInput.syncText();
            return super.text;
        }
        set text(value) {
            if (value == null)
                value = "";
            else if (typeof (value) !== "string")
                value = '' + value;
            if (PAL.textInput.target === this) {
                PAL.textInput.setText(value);
                this.event(Event.CHANGE);
            }
            else {
                if (!this._multiline)
                    value = value.replace(/\r?\n/g, '');
                super.text = value;
            }
        }
        get editable() {
            return this._editable;
        }
        set editable(value) {
            this._editable = value;
        }
        get prompt() {
            return this._prompt;
        }
        set prompt(value) {
            var _a;
            if (value == null)
                value = "";
            value = ((_a = Text.langPacks) === null || _a === void 0 ? void 0 : _a[value]) || value;
            if (this._prompt != value) {
                this._prompt = value;
                this.markChanged();
            }
        }
        get promptColor() {
            return this._promptColor;
        }
        set promptColor(value) {
            if (this._promptColor != value) {
                this._promptColor = value;
                this.markChanged();
            }
        }
        get type() {
            return this._type;
        }
        set type(value) {
            this._asPassword = value === "password";
            this._type = value;
            this.markChanged();
        }
        setSelection(startIndex, endIndex) {
            this.focus = true;
            PAL.textInput.setSelection(startIndex, endIndex);
        }
        select() {
            this.focus = true;
            PAL.textInput.setSelection(0, -1);
        }
    }
    Input.TYPE_TEXT = "text";
    Input.TYPE_PASSWORD = "password";
    Input.TYPE_EMAIL = "email";
    Input.TYPE_URL = "url";
    Input.TYPE_NUMBER = "number";
    Input.TYPE_RANGE = "range";
    Input.TYPE_DATE = "date";
    Input.TYPE_MONTH = "month";
    Input.TYPE_WEEK = "week";
    Input.TYPE_TIME = "time";
    Input.TYPE_DATE_TIME = "datetime";
    Input.TYPE_DATE_TIME_LOCAL = "datetime-local";
    Input.TYPE_SEARCH = "search";

    class SoundNode extends Sprite {
        constructor() {
            super();
            this._loop = 1;
            if (LayaEnv.isPlaying) {
                this.on(Event.ADDED, () => { this.target = this.parent; });
                this.on(Event.REMOVED, () => { this.target = null; });
                this.on(Event.DISPLAY, this, this.onDisplay);
                this.on(Event.UNDISPLAY, this, this.onUndisplay);
            }
        }
        get source() {
            return this._source;
        }
        set source(value) {
            this._source = value;
            if (value) {
                if (this.activeInHierarchy && (this._autoPlay || this._channel) && LayaEnv.isPlaying)
                    this.play(this._loop);
            }
            else
                this.stop();
        }
        get isMusic() {
            return this._isMusic;
        }
        set isMusic(value) {
            this._isMusic = value;
        }
        get loop() {
            return this._loop;
        }
        set loop(value) {
            this._loop = value;
        }
        get autoPlay() {
            return this._autoPlay;
        }
        set autoPlay(value) {
            this._autoPlay = value;
            if (this.activeInHierarchy && value && !this._channel && LayaEnv.isPlaying)
                this.play(this._loop);
        }
        play(loops, complete, startTime) {
            if (!this._source)
                return;
            if (loops == null || isNaN(loops))
                loops = this._loop;
            this.stop();
            if (this._isMusic)
                this._channel = SoundManager.playMusic(this._source, loops, complete, startTime);
            else
                this._channel = SoundManager.playSound(this._source, loops, complete, startTime);
        }
        stop() {
            if (this._channel)
                this._channel.stop();
            this._channel = null;
        }
        _setPlayAction(tar, event, action, add = true) {
            if (!this[action])
                return;
            if (!tar)
                return;
            if (add) {
                tar.on(event, this, this[action]);
            }
            else {
                tar.off(event, this, this[action]);
            }
        }
        _setPlayActions(tar, events, action, add = true) {
            if (!tar)
                return;
            if (!events)
                return;
            let eventArr = events.split(",");
            let len = eventArr.length;
            for (let i = 0; i < len; i++) {
                this._setPlayAction(tar, eventArr[i], action, add);
            }
        }
        set playEvent(events) {
            this._playEvents = events;
            if (!events)
                return;
            if (this._tar) {
                this._setPlayActions(this._tar, events, "play");
            }
        }
        set target(tar) {
            if (this._tar) {
                this._setPlayActions(this._tar, this._playEvents, "play", false);
                this._setPlayActions(this._tar, this._stopEvents, "stop", false);
            }
            this._tar = tar;
            if (this._tar) {
                this._setPlayActions(this._tar, this._playEvents, "play", true);
                this._setPlayActions(this._tar, this._stopEvents, "stop", true);
            }
        }
        set stopEvent(events) {
            this._stopEvents = events;
            if (!events)
                return;
            if (this._tar) {
                this._setPlayActions(this._tar, events, "stop");
            }
        }
        onDisplay() {
            if (this._autoPlay && !this._channel)
                this.play(this._loop);
        }
        onUndisplay() {
            this.stop();
        }
    }

    class VideoNode extends Sprite {
        constructor() {
            super();
            this.options = { controls: false, objectFit: "contain" };
            this.mode = "decoder";
            this._autoPlay = false;
            this._loop = false;
            this._volume = 1;
            this._muted = false;
            this._playbackRate = 1;
            this._allowBackground = false;
            this._paused = false;
            this.on(Event.DISPLAY, this, this.onDisplay);
            this.on(Event.UNDISPLAY, this, this.onUndisplay);
        }
        get player() {
            return this._api;
        }
        get source() {
            return this._source;
        }
        set source(value) {
            this._source = value;
            if (value) {
                if (this.activeInHierarchy)
                    this._load();
            }
            else
                this._unload();
        }
        get autoPlay() {
            return this._autoPlay;
        }
        set autoPlay(value) {
            this._autoPlay = value;
            if (this._api && LayaEnv.isPlaying)
                value ? this._api.play() : this._api.pause();
        }
        get allowBackground() {
            return this._allowBackground;
        }
        set allowBackground(value) {
            this._allowBackground = value;
            if (this._api)
                this._api.allowBackground = value;
        }
        get currentTime() {
            var _a;
            return (_a = this._api) === null || _a === void 0 ? void 0 : _a.currentTime;
        }
        set currentTime(value) {
            if (!this._api)
                return;
            this._api.currentTime = value;
        }
        get readyState() {
            var _a, _b;
            return (_b = (_a = this._vtex) === null || _a === void 0 ? void 0 : _a.readyState) !== null && _b !== void 0 ? _b : 0;
        }
        get videoWidth() {
            var _a;
            return (_a = this._vtex) === null || _a === void 0 ? void 0 : _a.videoWidth;
        }
        get videoHeight() {
            var _a;
            return (_a = this._vtex) === null || _a === void 0 ? void 0 : _a.videoHeight;
        }
        get duration() {
            var _a;
            return (_a = this._api) === null || _a === void 0 ? void 0 : _a.duration;
        }
        get ended() {
            var _a;
            return (_a = this._api) === null || _a === void 0 ? void 0 : _a.ended;
        }
        get loop() {
            return this._loop;
        }
        set loop(value) {
            this._loop = value;
            if (this._api)
                this._api.loop = value;
        }
        get playbackRate() {
            return this._playbackRate;
        }
        set playbackRate(value) {
            this._playbackRate = value;
            if (this._api)
                this._api.playbackRate = value;
        }
        get volume() {
            return this._volume;
        }
        set volume(value) {
            this._volume = value;
            if (this._api)
                this._api.volume = value;
        }
        get muted() {
            return this._muted;
        }
        set muted(value) {
            this._muted = value;
            if (this._api)
                this._api.muted = value;
        }
        get paused() {
            return this._paused;
        }
        load(url) {
            this.source = url;
        }
        play() {
            if (!this._api)
                return;
            this._api.play();
        }
        pause() {
            this._paused = true;
            if (this._api)
                this._api.pause();
        }
        reload() {
            this.source = this._source;
        }
        canPlayType(type) {
            return PAL.media.canPlayType(type);
        }
        _load() {
            let player;
            let vt;
            let backendType = LayaEnv.isPlaying ? this.mode : "decoder";
            if (backendType === "player") {
                player = (this._player || PAL.media.createVideoPlayer());
                if (!player)
                    vt = PAL.media.createVideoTexture();
            }
            else {
                vt = (this._vtex || PAL.media.createVideoTexture());
                if (!vt)
                    player = PAL.media.createVideoPlayer();
            }
            if (player) {
                if (this._player !== player) {
                    this._player = player;
                    this._player.attachTo(this);
                    this._player.options = this.options;
                }
                if (this._vtex) {
                    this._vtex.destroy();
                    this._vtex = null;
                    this.texture = null;
                }
            }
            else {
                if (this._vtex !== vt) {
                    this._vtex = vt;
                    this._vtex.on(Event.READY, this, this._vtReady);
                    this._vtex.on("videoUpdate", this, this.reCache);
                    if (!this._tex)
                        this.texture = this._tex = new Texture();
                }
                if (this._player) {
                    this._player.destroy();
                    this._player = null;
                }
            }
            this._api = player || vt;
            this._api.loop = this._loop;
            this._api.volume = this._volume;
            this._api.muted = this._muted;
            this._api.playbackRate = this._playbackRate;
            this._api.allowBackground = this._allowBackground;
            if (this._autoPlay && !this._paused && LayaEnv.isPlaying)
                this._api.play();
            else
                this._api.pause();
            this._api.load(this._source);
        }
        _vtReady() {
            this._tex.setTo(this._vtex);
            this.graphics.repaint();
        }
        _unload() {
            var _a;
            if (this._vtex) {
                this._vtex.off(Event.READY, this, this._vtReady);
                this._vtex.off("videoUpdate", this, this.reCache);
                this._vtex.destroy();
                this._vtex = null;
            }
            (_a = this._player) === null || _a === void 0 ? void 0 : _a.destroy();
            this._player = null;
            this._api = null;
        }
        onDisplay() {
            if (!this._api && this._source)
                this._load();
        }
        onUndisplay() {
            this._unload();
        }
        destroy(detroyChildren = true) {
            this._unload();
            super.destroy(detroyChildren);
        }
        get currentSrc() {
            return this._source;
        }
        get videoTexture() {
            return this._vtex;
        }
        set videoTexture(value) {
            if (value)
                this.source = value.source;
            else
                this.source = null;
        }
    }

    class AnimatorPlayState2D {
        get duration() {
            return this._duration;
        }
        get animatorState() {
            return this._currentState;
        }
        constructor() {
            this._currentState = null;
            this._frontPlay = true;
        }
        _resetPlayState(startTime, clipDuration) {
            this._finish = false;
            this._startPlayTime = startTime;
            this._elapsedTime = startTime;
            this._lastIsFront = true;
            this._parentPlayTime = null;
            this._playNum = 0;
            this._playAllTime = 0;
            var playTime = (this._elapsedTime / clipDuration) % 1.0;
            this._normalizedPlayTime = playTime < 0 ? playTime + 1.0 : playTime;
            this._frontPlay = true;
        }
        _cloneTo(dest) {
            dest._finish = this._finish;
            dest._startPlayTime = this._startPlayTime;
            dest._elapsedTime = this._elapsedTime;
            dest._playNum = this._playNum;
            dest._parentPlayTime = this._parentPlayTime;
            dest._normalizedPlayTime = this._normalizedPlayTime;
            dest._lastIsFront = this._lastIsFront;
            dest._frontPlay = this._frontPlay;
            dest._playAllTime = this._playAllTime;
        }
    }

    class AnimatorControllerLayer2D {
        constructor(name) {
            this._referenceCount = 0;
            this._playStateInfo = new AnimatorPlayState2D();
            this._crossPlayStateInfo = new AnimatorPlayState2D();
            this._crossMark = 0;
            this._crossNodesOwnersCount = 0;
            this._crossNodesOwnersIndicesMap = {};
            this._srcCrossClipNodeIndices = [];
            this._destCrossClipNodeIndices = [];
            this.playOnWake = true;
            this.defaultWeight = 1.0;
            this.blendingMode = AnimatorControllerLayer2D.BLENDINGMODE_OVERRIDE;
            this.enable = true;
            this._states = [];
            this._playType = -1;
            this.name = name;
        }
        get states() {
            return this._states;
        }
        set states(states) {
            if (this._states === states)
                return;
            for (let i = this.states.length - 1; i >= 0; i--) {
                this.removeState(this.states[i]);
            }
            for (let i = states.length - 1; i >= 0; i--) {
                this.addState(states[i]);
            }
        }
        get defaultStateName() {
            if (!this._defaultState) {
                return null;
            }
            return this._defaultState.name;
        }
        set defaultStateName(str) {
            this._defaultState = this.getStateByName(str);
            if (null == this._defaultState) {
                if (0 == this._states.length) {
                    this._defaultStateNameCatch = str;
                }
                else {
                    for (var i = this._states.length - 1; i >= 0; i--) {
                        if (this._states[i].name == str) {
                            this._defaultState = this._states[i];
                            break;
                        }
                    }
                }
            }
        }
        get defaultState() {
            return this._defaultState;
        }
        set defaultState(value) {
            this._defaultState = value;
        }
        _removeClip(clipStateInfos, index, state) {
            clipStateInfos.splice(index, 1);
        }
        _getReferenceCount() {
            return this._referenceCount;
        }
        _addReference(count) {
            for (var i = 0, n = this._states.length; i < n; i++)
                this._states[i]._addReference(count);
            this._referenceCount += count;
        }
        _removeReference(count = 1) {
            for (var i = 0, n = this._states.length; i < n; i++)
                this._states[i]._removeReference(count);
            this._referenceCount -= count;
        }
        _clearReference() {
            this._removeReference(-this._referenceCount);
        }
        getCurrentPlayState() {
            return this._playStateInfo;
        }
        getStateByName(str) {
            for (let i = this._states.length - 1; i >= 0; i--) {
                if (this._states[i].name == str) {
                    return this._states[i];
                }
            }
            return null;
        }
        addState(state) {
            var stateName = state.name;
            if (this.getStateByName(stateName)) {
                throw new Error("AnimatorControllerLayer:this stat's name has exist.");
            }
            else {
                this._states.push(state);
                if (stateName == this._defaultStateNameCatch) {
                    this._defaultState = state;
                    this._defaultStateNameCatch = null;
                }
            }
        }
        removeState(state) {
            var states = this._states;
            var index = -1;
            for (var i = 0, n = states.length; i < n; i++) {
                if (states[i] === state) {
                    index = i;
                    break;
                }
            }
            if (-1 != index)
                this._removeClip(states, index, state);
        }
        clone() {
            var dest = new AnimatorControllerLayer2D(this.name);
            this.cloneTo(dest);
            return dest;
        }
        cloneTo(destObject) {
            destObject.name = this.name;
        }
        destroy() {
            this._removeReference();
            for (var i = 0, n = this._states.length; i < n; i++) {
                this._states[i].destroy();
            }
            this._states.length = 0;
        }
    }
    AnimatorControllerLayer2D.BLENDINGMODE_OVERRIDE = 0;
    AnimatorControllerLayer2D.BLENDINGMODE_ADDTIVE = 1;

    exports.AniParmType = void 0;
    (function (AniParmType) {
        AniParmType[AniParmType["Float"] = 0] = "Float";
        AniParmType[AniParmType["Bool"] = 1] = "Bool";
        AniParmType[AniParmType["Trigger"] = 2] = "Trigger";
    })(exports.AniParmType || (exports.AniParmType = {}));
    exports.AniStateConditionType = void 0;
    (function (AniStateConditionType) {
        AniStateConditionType[AniStateConditionType["Number"] = 0] = "Number";
        AniStateConditionType[AniStateConditionType["Bool"] = 1] = "Bool";
        AniStateConditionType[AniStateConditionType["Trigger"] = 2] = "Trigger";
    })(exports.AniStateConditionType || (exports.AniStateConditionType = {}));
    exports.AniStateConditionNumberCompressType = void 0;
    (function (AniStateConditionNumberCompressType) {
        AniStateConditionNumberCompressType[AniStateConditionNumberCompressType["Less"] = 0] = "Less";
        AniStateConditionNumberCompressType[AniStateConditionNumberCompressType["Greater"] = 1] = "Greater";
    })(exports.AniStateConditionNumberCompressType || (exports.AniStateConditionNumberCompressType = {}));
    class AnimatorControllerParse {
        static parse(data) {
            let ret = data;
            let layers = ret.controllerLayers;
            if (null == layers) {
                layers = [];
            }
            let clipsID = [];
            for (let i = layers.length - 1; i >= 0; i--) {
                let l = layers[i];
                let states = l.states;
                if (!states) {
                    states = [];
                    l.states = states;
                }
                l.defaultStateName = null;
                let retobj = this.checkStates(states, clipsID, ret);
                if (retobj) {
                    l.defaultStateName = retobj.enterName;
                }
                else {
                    layers.splice(i, 1);
                }
            }
            return { ret: ret, clipsID: clipsID };
        }
        static checkStates(states, clipsID, data) {
            let clipState = null;
            let enterState = null;
            for (let j = states.length - 1; j >= 0; j--) {
                let state = states[j];
                if (state.states) {
                    if (null == this.checkStates(state.states, clipsID, data)) {
                        states.splice(j, 1);
                    }
                    else {
                        if (null == clipState) {
                            clipState = [];
                        }
                        clipState.push(state);
                    }
                }
                else if ("-1" == state.id) {
                    enterState = state;
                }
                else if ("-2" == state.id) ;
                else if ("-3" == state.id) ;
                else if (null == state.clip || null == state.clip._$uuid || "" == state.clip._$uuid) {
                    states.splice(j, 1);
                }
                else {
                    if (0 > clipsID.indexOf(state.clip._$uuid)) {
                        clipsID.push(state.clip._$uuid);
                    }
                    this.checkNext(state, states, data);
                    if (null == clipState) {
                        clipState = [];
                    }
                    clipState.push(state);
                }
            }
            let ret = null;
            if (clipState && enterState) {
                let defName = this.checkDefault(enterState, clipState);
                if (null != defName) {
                    ret = { states: clipState, enterName: defName };
                }
            }
            return ret;
        }
        static checkNext(state, states, data) {
            let nexts = state.soloTransitions;
            if (nexts) {
                for (let i = nexts.length - 1; i >= 0; i--) {
                    let next = nexts[i];
                    let nState = this.getStateByID(states, next.id);
                    if (!nState || (null == nState.clip && "-3" != nState.id && null == nState.states)) {
                        nexts.splice(i, 1);
                    }
                    else {
                        next.name = nState.name;
                        next.conditions = this.checkConditions(next.conditions, data);
                    }
                }
            }
        }
        static checkConditions(conditions, data) {
            if (!conditions || 0 == conditions.length || null == data.animatorParams || 0 == data.animatorParams.length) {
                return [];
            }
            let parms = data.animatorParams;
            for (let i = conditions.length - 1; i >= 0; i--) {
                let o = conditions[i];
                let parm = null;
                for (let j = parms.length - 1; j >= 0; j--) {
                    if (parms[j].id == o.id) {
                        parm = parms[j];
                        break;
                    }
                }
                if (null == parm) {
                    conditions.splice(i, 1);
                }
                else {
                    o.name = parm.name;
                    if (parm.type == exports.AniParmType.Float) {
                        let num = Number(o.checkValue);
                        if (isNaN(num)) {
                            o.checkValue = 0;
                        }
                        num = Number(o.type);
                        if (isNaN(num)) {
                            o.type = 0;
                        }
                    }
                }
            }
            return conditions;
        }
        static checkDefault(state, states) {
            let nexts = state.soloTransitions;
            let id = null;
            if (nexts && 0 < nexts.length) {
                id = nexts[0].id;
            }
            let defState = null;
            if (null != id) {
                defState = this.getStateByID(states, id);
            }
            if (null != defState && (null != defState.clip || null != defState.states)) {
                return defState.name;
            }
            for (let i = states.length - 1; i >= 0; i--) {
                if (states[i].clip) {
                    return states[i].name;
                }
            }
            return null;
        }
        static getStateByID(states, id) {
            if (states) {
                for (let i = states.length - 1; i >= 0; i--) {
                    if (states[i].id == id) {
                        return states[i];
                    }
                }
            }
            return null;
        }
    }

    exports.AnimatorUpdateMode = void 0;
    (function (AnimatorUpdateMode) {
        AnimatorUpdateMode[AnimatorUpdateMode["Normal"] = 0] = "Normal";
        AnimatorUpdateMode[AnimatorUpdateMode["LowFrame"] = 1] = "LowFrame";
        AnimatorUpdateMode[AnimatorUpdateMode["UnScaleTime"] = 2] = "UnScaleTime";
    })(exports.AnimatorUpdateMode || (exports.AnimatorUpdateMode = {}));

    class Animator2D extends Component {
        constructor() {
            super();
            this._speed = 1;
            this._updateMode = exports.AnimatorUpdateMode.Normal;
            this._lowUpdateDelty = 20;
            this._isPlaying = true;
            this._isPlayBack = false;
            this._controllerLayers = [];
            this._parameters = {};
        }
        get controller() {
            return this._controller;
        }
        set controller(val) {
            if (this._controller)
                this._controller._removeReference();
            this._controller = val;
            if (val) {
                val._addReference();
                val.updateTo(this);
            }
        }
        get parameters() {
            return this._parameters;
        }
        set parameters(val) {
            this._parameters = val;
        }
        get speed() {
            return this._speed;
        }
        set speed(num) {
            this._speed = num;
        }
        get isPlaying() {
            return this._isPlaying;
        }
        _updateStateFinish(animatorState, playState) {
            if (playState._finish) {
                if (this.owner._renderType & SpriteConst.GRAPHICS) {
                    this.owner.graphics.repaint();
                }
                animatorState._eventExit();
            }
        }
        _switchState(parentState, currentState) {
            if (parentState) {
                parentState._eventSwitch(currentState);
            }
        }
        _setClipDatasToNode(stateInfo, additive, weight, controllerLayer = null) {
            var realtimeDatas = stateInfo._realtimeDatas;
            var nodes = stateInfo._clip._nodes;
            for (var i = 0, n = nodes.count; i < n; i++) {
                if (null == realtimeDatas[i])
                    continue;
                var node = nodes.getNodeByIndex(i);
                var o = this.getOwner(node);
                o && this._applyFloat(o, additive, weight, realtimeDatas[i]);
            }
        }
        _applyFloat(o, additive, weight, data) {
            var pro = o.pro;
            if (pro && pro.ower) {
                if (additive && "number" === typeof data) {
                    pro.ower[pro.key] = pro.defVal + weight * data;
                }
                else if ("number" === typeof data) {
                    pro.ower[pro.key] = weight * data;
                }
                else {
                    if ("string" === typeof data) {
                        if (data.startsWith("tres://")) {
                            let url = data.replace("tres://", "");
                            let source = Loader.getRes(url, Loader.IMAGE);
                            if (source) {
                                data = source;
                            }
                            else {
                                ILaya.loader.load(url, { type: Loader.IMAGE }).then(tex => {
                                    if (!this.destroyed) {
                                        pro.ower[pro.key] = tex;
                                    }
                                });
                                return;
                            }
                        }
                    }
                    pro.ower[pro.key] = data;
                }
            }
        }
        getOwner(node) {
            var ret;
            if (this._ownerMap) {
                ret = this._ownerMap.get(node);
                if (ret) {
                    return ret;
                }
            }
            var property = this.owner;
            for (var j = 0, m = node.ownerPathCount; j < m; j++) {
                var ownPat = node.getOwnerPathByIndex(j);
                if ("" == ownPat) {
                    continue;
                }
                else {
                    property = property.getChild(ownPat);
                    if (!property)
                        break;
                }
            }
            ret = { ower: property };
            if (property) {
                var pobj = property;
                var propertyCount = node.propertyCount;
                if (1 == propertyCount) {
                    var pname = node.getPropertyByIndex(0);
                    ret.pro = { ower: property, key: pname, defVal: property[pname] };
                }
                else {
                    for (var i = 0; i < propertyCount; i++) {
                        var pname = node.getPropertyByIndex(i);
                        if (i == propertyCount - 1 || null == pobj) {
                            ret.pro = { ower: pobj, key: pname, defVal: pobj ? pobj[pname] : null };
                            break;
                        }
                        if ('_gcmds' === pname && null == pobj[pname] && pobj.graphics) {
                            pobj = pobj.graphics;
                            pname = "cmds";
                        }
                        if (null == pobj[pname] && property == pobj) {
                            pobj = null;
                            var classObj = ClassUtils.getClass(pname);
                            if (classObj) {
                                pobj = property.getComponent(classObj);
                            }
                        }
                        else {
                            pobj = pobj[pname];
                        }
                    }
                }
            }
            if (null == this._ownerMap) {
                this._ownerMap = new Map();
            }
            this._ownerMap.set(node, ret);
            return ret;
        }
        _updateClipDatas(animatorState, addtive, playStateInfo) {
            var clip = animatorState._clip;
            var clipDuration = clip._duration;
            var curPlayTime = animatorState.clipStart * clipDuration + playStateInfo._normalizedPlayTime * playStateInfo._duration;
            var currentFrameIndices = animatorState._currentFrameIndices;
            let frontPlay = playStateInfo._frontPlay;
            clip._evaluateClipDatasRealTime(curPlayTime, currentFrameIndices, addtive, frontPlay, animatorState._realtimeDatas);
        }
        _updatePlayer(animatorState, playState, elapsedTime, loop, layerIndex) {
            playState._playAllTime += Math.abs(elapsedTime);
            const clipDuration = animatorState.clipEnd - animatorState.clipStart;
            var clipDurationTime = animatorState._clip._duration * clipDuration;
            var lastElapsedTime = playState._elapsedTime;
            var elapsedPlaybackTime = lastElapsedTime + elapsedTime;
            playState._lastElapsedTime = lastElapsedTime;
            playState._elapsedTime = elapsedPlaybackTime;
            var normalizedTime = elapsedPlaybackTime / clipDurationTime;
            var playTime = normalizedTime % 1.0;
            const normalizedPlayTime = playTime < 0 ? playTime + 1.0 : playTime;
            playState._normalizedPlayTime = normalizedPlayTime;
            playState._duration = clipDurationTime;
            let parentPlayNum = Math.floor(Math.abs(lastElapsedTime) / clipDurationTime);
            let playNum = Math.floor(Math.abs(elapsedPlaybackTime) / clipDurationTime);
            if (animatorState.yoyo) {
                this._isPlayBack = 0 != Math.floor(playNum) % 2;
                if (this._isPlayBack) {
                    playState._normalizedPlayTime = 1 - playState._normalizedPlayTime;
                }
                parentPlayNum = Math.floor(parentPlayNum / 2);
                playNum = Math.floor(playNum / 2);
            }
            if (0 < loop && loop <= playNum) {
                playState._finish = true;
                if (animatorState.yoyo) {
                    playState._normalizedPlayTime = 0;
                }
                else {
                    playState._normalizedPlayTime = 1;
                }
            }
            const isReplay = parentPlayNum != playNum;
            if (isReplay) {
                animatorState._eventLoop();
            }
            animatorState._eventStateUpdate(playState._normalizedPlayTime);
            this._applyTransition(layerIndex, animatorState._eventtransition(normalizedPlayTime, this.parameters, isReplay));
        }
        _updateEventScript(stateInfo, playStateInfo) {
            let clip = stateInfo._clip;
            let events = clip._animationEvents;
            if (!events || 0 == events.length)
                return;
            let clipDuration = clip._duration;
            var curPlayTime = playStateInfo.animatorState.clipStart * clipDuration + playStateInfo._normalizedPlayTime * playStateInfo._duration;
            let frontPlay = playStateInfo._frontPlay;
            const speed = playStateInfo._currentState.speed;
            if (0 > speed)
                frontPlay = !frontPlay;
            if (this._isPlayBack) {
                frontPlay = !frontPlay;
            }
            let pTime = playStateInfo._parentPlayTime;
            let parentPlayTime = playStateInfo._parentPlayTime;
            if (null == parentPlayTime) {
                if (frontPlay) {
                    parentPlayTime = clipDuration * playStateInfo.animatorState.clipStart;
                }
                else {
                    parentPlayTime = clipDuration * playStateInfo.animatorState.clipEnd;
                }
            }
            if (frontPlay) {
                if (curPlayTime < parentPlayTime) {
                    const cpt = playStateInfo.animatorState.clipStart * clipDuration + playStateInfo._duration;
                    this._eventScript(events, parentPlayTime, cpt, true);
                    parentPlayTime = playStateInfo.animatorState.clipStart * clipDuration;
                }
            }
            else {
                if (curPlayTime > parentPlayTime) {
                    const cpt = playStateInfo.animatorState.clipStart * clipDuration;
                    this._eventScript(events, parentPlayTime, cpt, false);
                    parentPlayTime = playStateInfo.animatorState.clipStart * clipDuration + playStateInfo._duration;
                }
            }
            this._eventScript(events, parentPlayTime, curPlayTime, frontPlay);
            if (pTime == playStateInfo._parentPlayTime) {
                playStateInfo._parentPlayTime = curPlayTime;
            }
        }
        _eventScript(events, parentPlayTime, currPlayTime, frontPlay) {
            let scripts = this.owner.components;
            if (frontPlay) {
                for (let i = 0, len = events.length; i < len; i++) {
                    let e = events[i];
                    if (e.time > parentPlayTime && e.time <= currPlayTime) {
                        for (let j = 0, m = scripts.length; j < m; j++) {
                            let script = scripts[j];
                            if (script._isScript()) {
                                let fun = script[e.eventName];
                                (fun) && (fun.apply(script, e.params));
                            }
                        }
                    }
                    else if (e.time > currPlayTime) {
                        break;
                    }
                }
            }
            else {
                for (let i = events.length - 1; i >= 0; i--) {
                    let e = events[i];
                    if (e.time < parentPlayTime && e.time >= currPlayTime) {
                        for (let j = 0, m = scripts.length; j < m; j++) {
                            let script = scripts[j];
                            if (script._isScript()) {
                                let fun = script[e.eventName];
                                (fun) && (fun.apply(script, e.params));
                            }
                        }
                    }
                    else if (e.time < currPlayTime) {
                        break;
                    }
                }
            }
        }
        _applyTransition(layerindex, transition) {
            if (!transition)
                return false;
            return this.crossFade(transition.destState.name, layerindex, transition.transstartoffset, transition.transduration);
        }
        _applyUpdateMode(delta) {
            let ret;
            switch (this._updateMode) {
                case exports.AnimatorUpdateMode.Normal:
                    ret = delta;
                    break;
                case exports.AnimatorUpdateMode.LowFrame:
                    ret = (Stat.loopCount % this._lowUpdateDelty == 0) ? delta * this._lowUpdateDelty : 0;
                    break;
                case exports.AnimatorUpdateMode.UnScaleTime:
                    ret = 0;
                    break;
            }
            return ret;
        }
        gotoAndStopByFrame(name, layerIndex, frame) {
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var animatorState = controllerLayer.getStateByName(name);
                if (!animatorState || !animatorState._clip)
                    return;
                var allFrame = animatorState._clip._duration * animatorState._clip._frameRate;
                let normalizedTime = frame / allFrame;
                if (1 < normalizedTime)
                    normalizedTime = 1;
                this.gotoAndStop(name, layerIndex, normalizedTime);
            }
        }
        getControllerLayer(layerIndex = 0) {
            return this._controllerLayers[layerIndex];
        }
        gotoAndStop(name, layerIndex, normalizedTime) {
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var animatorState = controllerLayer.getStateByName(name);
                if (!animatorState || !animatorState._clip)
                    return;
                var playStateInfo = controllerLayer._playStateInfo;
                var curPlayState = playStateInfo._currentState;
                var clipDuration = animatorState._clip._duration;
                var calclipduration = animatorState._clip._duration * (animatorState.clipEnd - animatorState.clipStart);
                playStateInfo._resetPlayState(clipDuration * normalizedTime, calclipduration);
                playStateInfo._normalizedPlayTime = normalizedTime;
                controllerLayer._playType = 0;
                if (curPlayState !== animatorState) {
                    playStateInfo._currentState = animatorState;
                    this._switchState(curPlayState, animatorState);
                }
                animatorState._eventStart(this, layerIndex);
                let addtive = controllerLayer.blendingMode != AnimatorControllerLayer2D.BLENDINGMODE_OVERRIDE;
                this._updateClipDatas(animatorState, addtive, playStateInfo);
                this._setClipDatasToNode(animatorState, addtive, controllerLayer.defaultWeight, controllerLayer);
                this.stop();
            }
        }
        play(name, layerIndex = 0, normalizedTime = Number.NEGATIVE_INFINITY) {
            if (this._checkEnterIndex) {
                let i = this._checkEnterIndex.indexOf(layerIndex);
                if (0 <= i) {
                    this._checkEnterIndex.splice(i, 1);
                }
            }
            this._isPlaying = true;
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var defaultState = controllerLayer.defaultState;
                if (!name && !defaultState)
                    throw new Error("Animator:must have default clip value,please set clip property.");
                var playStateInfo = controllerLayer._playStateInfo;
                var curPlayState = playStateInfo._currentState;
                var animatorState = name ? controllerLayer.getStateByName(name) : defaultState;
                if (!animatorState._clip)
                    return;
                var clipDuration = animatorState._clip._duration;
                var calclipduration = animatorState._clip._duration * (animatorState.clipEnd - animatorState.clipStart);
                if (curPlayState !== animatorState) {
                    if (normalizedTime !== Number.NEGATIVE_INFINITY)
                        playStateInfo._resetPlayState(clipDuration * normalizedTime, calclipduration);
                    else
                        playStateInfo._resetPlayState(0.0, calclipduration);
                    controllerLayer._playType = 0;
                    playStateInfo._currentState = animatorState;
                }
                else {
                    if (normalizedTime !== Number.NEGATIVE_INFINITY) {
                        playStateInfo._resetPlayState(clipDuration * normalizedTime, calclipduration);
                        controllerLayer._playType = 0;
                    }
                    else {
                        playStateInfo._resetPlayState(clipDuration * animatorState.clipStart, calclipduration);
                    }
                }
                this._switchState(curPlayState, animatorState);
                animatorState._eventStart(this, layerIndex);
            }
        }
        stop() {
            this._isPlaying = false;
        }
        onUpdate() {
            if (!this._isPlaying)
                return;
            if (this._checkEnterIndex) {
                for (let i = this._checkEnterIndex.length - 1; i >= 0; i--) {
                    let index = this._checkEnterIndex[i];
                    let enterTransition = this._controllerLayers[index]._enterTransition;
                    if (enterTransition.check(0, this.parameters, true)) {
                        var defaultClip = this.getDefaultState(index);
                        this.play(null, index, defaultClip.cycleOffset);
                    }
                }
            }
            var delta = this.owner.timer.delta / 1000.0;
            delta = this._applyUpdateMode(delta);
            if (0 == this.speed || 0 == delta)
                return;
            for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                var controllerLayer = this._controllerLayers[i];
                if (!controllerLayer.enable)
                    continue;
                var playStateInfo = controllerLayer._playStateInfo;
                var addtive = controllerLayer.blendingMode != AnimatorControllerLayer2D.BLENDINGMODE_OVERRIDE;
                switch (controllerLayer._playType) {
                    case 0:
                        var animatorState = playStateInfo._currentState;
                        var speed = this._speed * animatorState.speed;
                        var finish = playStateInfo._finish;
                        var loop = animatorState.loop;
                        if (-1 >= loop) {
                            var clip = animatorState._clip;
                            if (clip.islooping) {
                                loop = 0;
                            }
                            else {
                                loop = 1;
                            }
                        }
                        let dir = 1;
                        if (!playStateInfo._frontPlay) {
                            dir = -1;
                        }
                        finish || this._updatePlayer(animatorState, playStateInfo, delta * speed * dir, loop, i);
                        playStateInfo = controllerLayer._playStateInfo;
                        animatorState = playStateInfo._currentState;
                        {
                            this._updateClipDatas(animatorState, addtive, playStateInfo);
                            if (!finish) {
                                this._setClipDatasToNode(animatorState, addtive, controllerLayer.defaultWeight, controllerLayer);
                                this._updateEventScript(animatorState, playStateInfo);
                            }
                        }
                        finish || this._updateStateFinish(animatorState, playStateInfo);
                        break;
                }
            }
        }
        addControllerLayer(controllerLayer) {
            this._controllerLayers.push(controllerLayer);
        }
        crossFade(name, layerIndex = 0, normalizedTime = Number.NEGATIVE_INFINITY, transitionDuration) {
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var destAnimatorState = controllerLayer.getStateByName(name);
                if (destAnimatorState) {
                    this.play(name, layerIndex, normalizedTime);
                    return true;
                }
                else {
                    console.warn("Invalid layerIndex " + layerIndex + ".");
                }
            }
            return false;
        }
        onAfterDeserialize() {
            let arr = this.controllerLayers;
            if (!arr || null != this.controller)
                return;
            delete this.controllerLayers;
            this._controllerLayers.length = 0;
            for (let layer of arr) {
                this.addControllerLayer(layer);
            }
        }
        onEnable() {
            if (this._checkEnterIndex)
                this._checkEnterIndex.length = 0;
            else
                this._checkEnterIndex = [];
            if (this._isPlaying) {
                for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                    if (this._controllerLayers[i].playOnWake) {
                        var defaultClip = this.getDefaultState(i);
                        if (defaultClip) {
                            let enterTransition = this._controllerLayers[i]._enterTransition;
                            if (enterTransition) {
                                this._isPlaying = true;
                                if (enterTransition.check(0, this.parameters, true)) {
                                    this.play(null, i, defaultClip.cycleOffset);
                                }
                                else {
                                    this._checkEnterIndex.push(i);
                                }
                            }
                            else {
                                this.play(null, i, defaultClip.cycleOffset);
                            }
                        }
                    }
                }
            }
        }
        getDefaultState(layerIndex = 0) {
            var controllerLayer = this._controllerLayers[layerIndex];
            return controllerLayer.defaultState;
        }
        setParamsTrigger(name) {
            const data = this._parameters[name];
            if (data && data.type === exports.AniParmType.Trigger) {
                data.value = true;
            }
            else {
                this._parameters[name] = { name: name, type: exports.AniParmType.Trigger, value: true };
            }
        }
        setParamsNumber(name, value) {
            const data = this._parameters[name];
            if (data && data.type === exports.AniParmType.Float) {
                data.value = value;
            }
            else {
                this._parameters[name] = { name: name, type: exports.AniParmType.Float, value: value };
            }
        }
        setParamsBool(name, value) {
            const data = this._parameters[name];
            if (data && data.type === exports.AniParmType.Bool) {
                data.value = value;
            }
            else {
                this._parameters[name] = { name: name, type: exports.AniParmType.Bool, value: value };
            }
        }
        getParamsvalue(name) {
            let parm = this._parameters[name];
            if (parm) {
                return parm.value;
            }
            return null;
        }
        onDestroy() {
            if (this._controller) {
                this._controller._removeReference();
                this._controller = null;
            }
            for (var i = 0, n = this._controllerLayers.length; i < n; i++)
                this._controllerLayers[i].destroy();
            this._controllerLayers.length = 0;
            this._isPlaying = false;
            this._parameters = null;
        }
    }

    class AnimatorState2D extends EventDispatcher {
        constructor() {
            super(...arguments);
            this._referenceCount = 0;
            this._clip = null;
            this._currentFrameIndices = null;
            this.cycleOffset = 0;
            this.speed = 1.0;
            this.clipStart = 0.0;
            this.clipEnd = 1.0;
            this.loop = -1;
            this.yoyo = false;
            this.transitions = [];
            this.soloTransitions = [];
            this._scripts = null;
            this._realtimeDatas = [];
        }
        get clip() {
            return this._clip;
        }
        set clip(value) {
            if (this._clip != value) {
                if (this._clip)
                    (this._referenceCount > 0) && (this._clip._removeReference(this._referenceCount));
                if (value) {
                    var clipNodes = value._nodes;
                    var count = clipNodes.count;
                    this._currentFrameIndices = new Int16Array(count);
                    this._resetFrameIndices();
                    (this._referenceCount > 0) && (value._addReference(this._referenceCount));
                    this._realtimeDatas.length = count;
                }
                this._clip = value;
            }
        }
        _eventStateUpdate(value) {
            this.event(AnimatorState2D.EVENT_OnStateUpdate, value);
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++)
                    this._scripts[i].onStateUpdate(value);
            }
        }
        _eventStart(animator, layerIndex) {
            this.event(AnimatorState2D.EVENT_OnStateEnter);
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++) {
                    this._scripts[i].setPlayScriptInfo(animator, layerIndex, this);
                    this._scripts[i].onStateEnter();
                }
            }
        }
        _eventExit() {
            this.event(AnimatorState2D.EVENT_OnStateExit);
            if (this._scripts) {
                for (let i = 0, n = this._scripts.length; i < n; i++) {
                    this._scripts[i].onStateExit();
                }
            }
        }
        _eventSwitch(currentState) {
            this.event(AnimatorState2D.EVENT_OnStateSwitch, currentState);
            if (this._scripts) {
                for (let i = 0, n = this._scripts.length; i < n; i++) {
                    this._scripts[i].onStateSwitch && this._scripts[i].onStateSwitch(currentState);
                }
            }
        }
        _eventLoop() {
            this.event(AnimatorState2D.EVENT_OnStateLoop);
            if (this._scripts) {
                for (let i = 0, n = this._scripts.length; i < n; i++) {
                    if (this._scripts[i].onStateLoop)
                        this._scripts[i].onStateLoop();
                }
            }
        }
        _eventtransition(normalizeTime, paramsMap, isReplay) {
            let soloNums = this.soloTransitions.length;
            if (soloNums > 0) {
                for (var i = 0; i < soloNums; i++) {
                    if (this.soloTransitions[i].check(normalizeTime, paramsMap, isReplay))
                        return this.soloTransitions[i];
                }
                return null;
            }
            let transNums = this.transitions.length;
            for (var i = 0; i < transNums; i++) {
                if (this.transitions[i].check(normalizeTime, paramsMap, isReplay))
                    return this.transitions[i];
            }
            return null;
        }
        _resetFrameIndices() {
            for (var i = 0, n = this._currentFrameIndices.length; i < n; i++)
                this._currentFrameIndices[i] = -1;
        }
        _getReferenceCount() {
            return this._referenceCount;
        }
        _addReference(count) {
            (this._clip) && (this._clip._addReference(count));
            this._referenceCount += count;
        }
        _removeReference(count) {
            (this._clip) && (this._clip._removeReference(count));
            this._referenceCount -= count;
        }
        _clearReference() {
            this._removeReference(-this._referenceCount);
        }
        addScript(type) {
            var script = new type();
            this._scripts = this._scripts || [];
            this._scripts.push(script);
            return script;
        }
        getScript(type) {
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++) {
                    var script = this._scripts[i];
                    if (script instanceof type)
                        return script;
                }
            }
            return null;
        }
        getScripts(type) {
            var coms = null;
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++) {
                    var script = this._scripts[i];
                    if (script instanceof type) {
                        coms = coms || [];
                        coms.push(script);
                    }
                }
            }
            return coms;
        }
        clone() {
            var dest = new AnimatorState2D();
            this.cloneTo(dest);
            return dest;
        }
        cloneTo(destObject) {
            destObject.name = this.name;
            destObject.speed = this.speed;
            destObject.clip = this._clip;
        }
        destroy() {
            this._clip = null;
            this._currentFrameIndices = null;
            this._scripts = null;
            this._realtimeDatas.length = 0;
        }
    }
    AnimatorState2D.EVENT_OnStateEnter = "OnStartEnter";
    AnimatorState2D.EVENT_OnStateUpdate = "OnStateUpdate";
    AnimatorState2D.EVENT_OnStateExit = "OnStateExit";
    AnimatorState2D.EVENT_OnStateSwitch = "OnStateSwitch";
    AnimatorState2D.EVENT_OnStateLoop = 'OnStateLoop';

    class KeyframeNode2D {
        constructor() {
            this._ownerPath = [];
            this._propertys = [];
            this._keyFrames = [];
        }
        get keyFramesCount() {
            return this._keyFrames.length;
        }
        _setOwnerPathCount(value) {
            this._ownerPath.length = value;
        }
        _setOwnerPathByIndex(index, value) {
            this._ownerPath[index] = value;
        }
        _setPropertyCount(value) {
            this._propertys.length = value;
        }
        _setPropertyByIndex(index, value) {
            this._propertys[index] = value;
        }
        _setKeyframeCount(value) {
            this._keyFrames.length = value;
        }
        _joinOwnerPath(sep) {
            return this._ownerPath.join(sep);
        }
        _joinProperty(sep) {
            return this._propertys.join(sep);
        }
        getKeyframeByIndex(index) {
            return this._keyFrames[index];
        }
        get ownerPathCount() {
            return this._ownerPath.length;
        }
        get propertyCount() {
            return this._propertys.length;
        }
        getOwnerPathByIndex(index) {
            return this._ownerPath[index];
        }
        getPropertyByIndex(index) {
            return this._propertys[index];
        }
    }

    class Keyframe2D {
        clone() {
            var dest = new Keyframe2D();
            this.cloneTo(dest);
            return dest;
        }
        cloneTo(destObject) {
            destObject.time = this.time;
        }
    }
    Keyframe2D.defaultWeight = 0.33333;

    class Animation2DEvent {
        constructor() {
        }
    }

    exports.CurveType = void 0;
    (function (CurveType) {
        CurveType[CurveType["CRSpline"] = 0] = "CRSpline";
        CurveType[CurveType["Bezier"] = 1] = "Bezier";
        CurveType[CurveType["CubicBezier"] = 2] = "CubicBezier";
        CurveType[CurveType["Straight"] = 3] = "Straight";
    })(exports.CurveType || (exports.CurveType = {}));
    class PathPoint {
        constructor() {
            this.pos = new Vector3();
            this.c1 = new Vector3();
            this.c2 = new Vector3();
            this.curve = 0;
        }
        static create(x, y, z, curve) {
            let pt = pool$1.take();
            pt.pos.set(x, y, z);
            pt.curve = curve || 0;
            return pt;
        }
        recover() {
            pool$1.recover(this);
        }
        clone() {
            let pt = pool$1.take();
            this.pos.cloneTo(pt.pos);
            this.c1.cloneTo(pt.c1);
            this.c2.cloneTo(pt.c2);
            pt.curve = this.curve;
            return pt;
        }
        _reset() {
            this.pos.set(0, 0, 0);
            this.c1.set(0, 0, 0);
            this.c2.set(0, 0, 0);
            this.curve = 0;
        }
    }
    const pool$1 = Pool.createPool(PathPoint, null, e => e._reset());

    class CurvePath {
        constructor() {
            this._segments = [];
            this._points = [];
            this._curPt = new Vector3();
        }
        get length() {
            return this._fullLength;
        }
        create(...points) {
            this._segments.length = 0;
            let pts = this._points;
            pool.recover(this._points);
            this._fullLength = 0;
            this._cacheT = null;
            let cnt = points.length;
            if (cnt == 0)
                return;
            let splinePoints = [];
            let prev = points[0];
            if (prev.curve == exports.CurveType.CRSpline)
                splinePoints.push(prev.pos.cloneTo(pool.take()));
            for (let i = 1; i < cnt; i++) {
                let current = points[i];
                if (prev.curve != exports.CurveType.CRSpline) {
                    let seg = {};
                    seg.type = prev.curve;
                    seg.ptStart = pts.length;
                    if (prev.curve == exports.CurveType.Straight) {
                        seg.ptCount = 2;
                        pts.push(prev.pos.cloneTo(pool.take()));
                        pts.push(current.pos.cloneTo(pool.take()));
                    }
                    else if (prev.curve == exports.CurveType.Bezier) {
                        seg.ptCount = 3;
                        pts.push(prev.pos.cloneTo(pool.take()));
                        pts.push(current.pos.cloneTo(pool.take()));
                        pts.push(prev.c1.cloneTo(pool.take()));
                    }
                    else if (prev.curve == exports.CurveType.CubicBezier) {
                        seg.ptCount = 4;
                        pts.push(prev.pos.cloneTo(pool.take()));
                        pts.push(current.pos.cloneTo(pool.take()));
                        pts.push(prev.c1.cloneTo(pool.take()));
                        pts.push(prev.c2.cloneTo(pool.take()));
                    }
                    seg.length = Vector3.distance(prev.pos, current.pos);
                    this._fullLength += seg.length;
                    this._segments.push(seg);
                }
                if (current.curve != exports.CurveType.CRSpline) {
                    if (splinePoints.length > 0) {
                        splinePoints.push(current.pos.cloneTo(pool.take()));
                        this.createSplineSegment(splinePoints);
                    }
                }
                else
                    splinePoints.push(current.pos.cloneTo(pool.take()));
                prev = current;
            }
            if (splinePoints.length > 1)
                this.createSplineSegment(splinePoints);
        }
        createSplineSegment(splinePoints) {
            let cnt = splinePoints.length;
            splinePoints.splice(0, 0, splinePoints[0].cloneTo(pool.take()));
            splinePoints.push(splinePoints[cnt].cloneTo(pool.take()));
            splinePoints.push(splinePoints[cnt].cloneTo(pool.take()));
            cnt += 3;
            let seg = {};
            seg.type = exports.CurveType.CRSpline;
            seg.ptStart = this._points.length;
            seg.ptCount = cnt;
            this._points.push(...splinePoints);
            seg.length = 0;
            for (let i = 1; i < cnt; i++) {
                seg.length += Vector3.distance(splinePoints[i - 1], splinePoints[i]);
            }
            this._fullLength += seg.length;
            this._segments.push(seg);
            splinePoints.length = 0;
        }
        clear() {
            this._segments.length = 0;
            this._points.length = 0;
        }
        getPointAt(t) {
            let out = this._curPt;
            t = MathUtil.clamp01(t);
            if (t === this._cacheT)
                return out;
            out.set(0, 0, 0);
            this._cacheT = t;
            let cnt = this._segments.length;
            if (cnt == 0) {
                return out;
            }
            let pts = this._points;
            if (t == 1) {
                let seg = this._segments[cnt - 1];
                if (seg.type == exports.CurveType.Straight)
                    Vector3.lerp(pts[seg.ptStart], pts[seg.ptStart + 1], t, out);
                else if (seg.type == exports.CurveType.Bezier || seg.type == exports.CurveType.CubicBezier)
                    this.onBezierCurve(seg.ptStart, seg.ptCount, t, out);
                else
                    this.onCRSplineCurve(seg.ptStart, seg.ptCount, t, out);
                return out;
            }
            for (let i = 0, len = t * this._fullLength; i < cnt; i++) {
                let seg = this._segments[i];
                len -= seg.length;
                if (len < 0) {
                    t = 1 + len / seg.length;
                    if (seg.type == exports.CurveType.Straight)
                        Vector3.lerp(pts[seg.ptStart], pts[seg.ptStart + 1], t, out);
                    else if (seg.type == exports.CurveType.Bezier || seg.type == exports.CurveType.CubicBezier)
                        this.onBezierCurve(seg.ptStart, seg.ptCount, t, out);
                    else
                        this.onCRSplineCurve(seg.ptStart, seg.ptCount, t, out);
                    break;
                }
            }
            return out;
        }
        get segmentCount() {
            return this._segments.length;
        }
        getAnchorsInSegment(segmentIndex, out) {
            if (out == null)
                out = [];
            let pts = this._points;
            let seg = this._segments[segmentIndex];
            for (let i = 0; i < seg.ptCount; i++)
                out.push(pts[seg.ptStart + i]);
            return out;
        }
        getPointsInSegment(segmentIndex, t0, t1, outPoints, outTs, pointDensity) {
            if (outPoints == null)
                outPoints = [];
            if (!pointDensity || isNaN(pointDensity))
                pointDensity = 0.1;
            let pts = this._points;
            if (outTs)
                outTs.push(t0);
            let seg = this._segments[segmentIndex];
            if (seg.type == exports.CurveType.Straight) {
                let v = new Vector3();
                Vector3.lerp(pts[seg.ptStart], pts[seg.ptStart + 1], t0, v);
                outPoints.push(v);
                v = new Vector3();
                Vector3.lerp(pts[seg.ptStart], pts[seg.ptStart + 1], t1, v);
                outPoints.push(v);
            }
            else {
                let func;
                if (seg.type == exports.CurveType.Bezier || seg.type == exports.CurveType.CubicBezier)
                    func = this.onBezierCurve;
                else
                    func = this.onCRSplineCurve;
                outPoints.push(func.call(this, seg.ptStart, seg.ptCount, t0, new Vector3()));
                let SmoothAmount = Math.min(seg.length * pointDensity, 50);
                for (let j = 0; j <= SmoothAmount; j++) {
                    let t = j / SmoothAmount;
                    if (t > t0 && t < t1) {
                        outPoints.push(func.call(this, seg.ptStart, seg.ptCount, t, new Vector3()));
                        if (outTs)
                            outTs.push(t);
                    }
                }
                outPoints.push(func.call(this, seg.ptStart, seg.ptCount, t1, new Vector3()));
            }
            if (outTs)
                outTs.push(t1);
            return outPoints;
        }
        getAllPoints(out, outTs, pointDensity) {
            if (out == null)
                out = [];
            if (!pointDensity || isNaN(pointDensity))
                pointDensity = 0.1;
            for (let i = 0, cnt = this._segments.length; i < cnt; i++)
                this.getPointsInSegment(i, 0, 1, out, outTs, pointDensity);
            return out;
        }
        onCRSplineCurve(ptStart, ptCount, t, out) {
            let adjustedIndex = Math.floor(t * (ptCount - 4)) + ptStart;
            let pts = this._points;
            let p0 = pts[adjustedIndex];
            let p1 = pts[adjustedIndex + 1];
            let p2 = pts[adjustedIndex + 2];
            let p3 = pts[adjustedIndex + 3];
            let adjustedT = (t == 1) ? 1 : MathUtil.repeat(t * (ptCount - 4), 1);
            let t0 = ((-adjustedT + 2) * adjustedT - 1) * adjustedT * 0.5;
            let t1 = (((3 * adjustedT - 5) * adjustedT) * adjustedT + 2) * 0.5;
            let t2 = ((-3 * adjustedT + 4) * adjustedT + 1) * adjustedT * 0.5;
            let t3 = ((adjustedT - 1) * adjustedT * adjustedT) * 0.5;
            out.x = p0.x * t0 + p1.x * t1 + p2.x * t2 + p3.x * t3;
            out.y = p0.y * t0 + p1.y * t1 + p2.y * t2 + p3.y * t3;
            out.z = p0.z * t0 + p1.z * t1 + p2.z * t2 + p3.z * t3;
            return out;
        }
        onBezierCurve(ptStart, ptCount, t, out) {
            let t2 = 1 - t;
            let pts = this._points;
            let p0 = pts[ptStart];
            let p1 = pts[ptStart + 1];
            let cp0 = pts[ptStart + 2];
            if (ptCount == 4) {
                let cp1 = pts[ptStart + 3];
                Vector3.add(p0.scale(t2 * t2 * t2, tmpVec3), cp0.scale(3 * t2 * t2 * t, tmpVec31), tmpVec31);
                Vector3.add(cp1.scale(3 * t2 * t * t, tmpVec3), p1.scale(t * t * t, tmpVec32), tmpVec32);
                Vector3.add(tmpVec31, tmpVec32, out);
            }
            else {
                Vector3.add(p0.scale(t2 * t2, tmpVec3), cp0.scale(2 * t2 * t, tmpVec31), tmpVec3);
                Vector3.add(tmpVec3, p1.scale(t * t, tmpVec31), out);
            }
            return out;
        }
    }
    const tmpVec3 = new Vector3();
    const tmpVec31 = new Vector3();
    const tmpVec32 = new Vector3();
    const pool = Pool.createPool(Vector3, null, e => e.set(0, 0, 0));

    class AnimationClip2DParse01 {
        static READ_DATA() {
            this._DATA.offset = this._reader.readUint32();
            this._DATA.size = this._reader.readUint32();
        }
        static READ_BLOCK() {
            var count = this._BLOCK.count = this._reader.readUint16();
            var blockStarts = this._BLOCK.blockStarts = [];
            var blockLengths = this._BLOCK.blockLengths = [];
            for (var i = 0; i < count; i++) {
                blockStarts.push(this._reader.readUint32());
                blockLengths.push(this._reader.readUint32());
            }
        }
        static READ_STRINGS() {
            var offset = this._reader.readUint32();
            var count = this._reader.readUint16();
            var prePos = this._reader.pos;
            this._reader.pos = offset + this._DATA.offset;
            for (var i = 0; i < count; i++)
                this._strings[i] = this._reader.readUTFString();
            this._reader.pos = prePos;
        }
        static parse(clip, reader, version) {
            this._clip = clip;
            this._reader = reader;
            this._version = version;
            this.READ_DATA();
            this.READ_BLOCK();
            this.READ_STRINGS();
            for (var i = 0, n = this._BLOCK.count; i < n; i++) {
                var index = reader.readUint16();
                var blockName = this._strings[index];
                var fn = this["READ_" + blockName];
                if (!fn) {
                    throw new Error("model file err,no this function:" + index + " " + blockName);
                }
                else
                    fn.call(this);
            }
            this._version = null;
            this._reader = null;
            this._clip = null;
            this._strings.length = 0;
        }
        static timeToFrame(second, fps) {
            return Math.round(second * fps);
        }
        static createPathPoints(arr) {
            const result = [];
            for (var i = 0, len = arr.length; i < len; i++) {
                const data = arr[i];
                const point = new PathPoint();
                point.pos.x = data.pos.x;
                point.pos.y = data.pos.y;
                point.pos.z = data.pos.z;
                point.c1.x = data.c1.x;
                point.c1.y = data.c1.y;
                point.c1.z = data.c1.z;
                point.c2.x = data.c2.x;
                point.c2.y = data.c2.y;
                point.c2.z = data.c2.z;
                point.curve = data.curve;
                result.push(point);
            }
            return result;
        }
        static READ_ANIMATIONS2D() {
            var i, j;
            var reader = this._reader;
            var clip = this._clip;
            var node;
            var numList = [];
            var numCount = reader.readUint16();
            numList.length = numCount;
            for (i = 0; i < numCount; i++) {
                numList[i] = reader.readFloat32();
            }
            clip._duration = numList[reader.readInt16()];
            clip.islooping = !!reader.readByte();
            clip._frameRate = reader.readInt16();
            var nodeCount = reader.readInt16();
            var nodes = clip._nodes;
            nodes.count = nodeCount;
            var nodesMap = clip._nodesMap = {};
            var nodesDic = clip._nodesDic = {};
            for (i = 0; i < nodeCount; i++) {
                node = new KeyframeNode2D();
                nodes.setNodeByIndex(i, node);
                node._indexInList = i;
                var pathLength = reader.readUint16();
                node._setOwnerPathCount(pathLength);
                for (j = 0; j < pathLength; j++) {
                    node._setOwnerPathByIndex(j, this._strings[reader.readUint16()]);
                }
                var nodePath = node._joinOwnerPath("/");
                var mapArray = nodesMap[nodePath];
                (mapArray) || (nodesMap[nodePath] = mapArray = []);
                mapArray.push(node);
                var propertyLength = reader.readUint16();
                node._setPropertyCount(propertyLength);
                for (j = 0; j < propertyLength; j++) {
                    node._setPropertyByIndex(j, this._strings[reader.readUint16()]);
                }
                var fullPath = nodePath + "." + node._joinProperty(".");
                nodesDic[fullPath] = node;
                node.fullPath = fullPath;
                node.nodePath = nodePath;
                var keyframeCount = reader.readUint16();
                for (j = 0; j < keyframeCount; j++) {
                    var k = new Keyframe2D();
                    k.time = numList[reader.readUint16()];
                    k.data = { f: this.timeToFrame(k.time, clip._frameRate), val: 0 };
                    if (1 == reader.readByte()) {
                        k.data.tweenType = this._strings[reader.readUint16()];
                    }
                    if (1 == reader.readByte()) {
                        k.data.tweenInfo = {};
                        k.data.tweenInfo.inTangent = numList[reader.readUint16()];
                        k.data.tweenInfo.outTangent = numList[reader.readUint16()];
                        if (1 == reader.readByte()) {
                            k.data.tweenInfo.inWeight = numList[reader.readUint16()];
                        }
                        if (1 == reader.readByte()) {
                            k.data.tweenInfo.outWeight = numList[reader.readUint16()];
                        }
                    }
                    var num = reader.readByte();
                    if (0 == num) {
                        k.data.val = numList[reader.readUint16()];
                    }
                    else if (1 == num) {
                        k.data.val = this._strings[reader.readUint16()];
                    }
                    else if (2 == num) {
                        k.data.val = !!reader.readByte();
                    }
                    else if (3 == num) {
                        const jsonData = JSON.parse(reader.readUTFString());
                        if (Array.isArray(jsonData)) {
                            const curvePath = new CurvePath();
                            k.data.val = curvePath;
                            curvePath._$data = jsonData;
                            curvePath.create(...this.createPathPoints(jsonData));
                        }
                        else {
                            k.data.val = jsonData;
                        }
                    }
                    if (1 == reader.readByte()) {
                        try {
                            k.data.extend = JSON.parse(this._strings[reader.readUint16()]);
                        }
                        catch (err) { }
                    }
                    node._keyFrames.push(k);
                }
            }
            var eventCount = reader.readUint16();
            for (i = 0; i < eventCount; i++) {
                var event = new Animation2DEvent();
                event.time = numList[reader.readUint16()];
                event.eventName = this._strings[reader.readUint16()];
                var params = [];
                var paramCount = reader.readUint16();
                (paramCount > 0) && (event.params = params = []);
                for (j = 0; j < paramCount; j++) {
                    var eventType = reader.readByte();
                    switch (eventType) {
                        case 0:
                            params.push(!!reader.readByte());
                            break;
                        case 1:
                            params.push(reader.readInt32());
                            break;
                        case 2:
                            params.push(numList[reader.readUint16()]);
                            break;
                        case 3:
                            params.push(this._strings[reader.readUint16()]);
                            break;
                        default:
                            throw new Error("unknown type.");
                    }
                }
                clip.addEvent(event);
            }
        }
    }
    AnimationClip2DParse01._strings = [];
    AnimationClip2DParse01._DATA = { offset: 0, size: 0 };
    AnimationClip2DParse01._BLOCK = { count: 0 };

    class KeyframeNodeList2D {
        constructor() {
            this._nodes = [];
        }
        get count() {
            return this._nodes.length;
        }
        set count(value) {
            this._nodes.length = value;
        }
        getNodeByIndex(index) {
            return this._nodes[index];
        }
        setNodeByIndex(index, node) {
            this._nodes[index] = node;
        }
    }

    class AnimationClip2D extends Resource {
        static _parse(data) {
            var clip = new AnimationClip2D();
            var reader = new Byte(data);
            var version = reader.readUTFString();
            switch (version) {
                case "LAYAANIMATION2D:01":
                    AnimationClip2DParse01.parse(clip, reader, version);
                    break;
                default:
                    throw "unknown animationClip version.";
            }
            return clip;
        }
        constructor() {
            super();
            this._nodes = new KeyframeNodeList2D();
            this._animationEvents = [];
        }
        duration() {
            return this._duration;
        }
        _evaluateClipDatasRealTime(playCurTime, realTimeCurrentFrameIndexes, addtive, frontPlay, outDatas) {
            var nodes = this._nodes;
            for (var i = 0, n = nodes.count; i < n; i++) {
                var node = nodes.getNodeByIndex(i);
                var nextFrameIndex;
                var keyFrames = node._keyFrames;
                var keyFramesCount = keyFrames.length;
                if (0 == keyFramesCount)
                    continue;
                var frameIndex = realTimeCurrentFrameIndexes[i];
                if (frontPlay) {
                    if ((-1 != frameIndex) && (playCurTime < keyFrames[frameIndex].time)) {
                        frameIndex = -1;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                    nextFrameIndex = frameIndex + 1;
                    while (nextFrameIndex < keyFramesCount) {
                        if (keyFrames[nextFrameIndex].time > playCurTime)
                            break;
                        frameIndex++;
                        nextFrameIndex++;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                }
                else {
                    nextFrameIndex = frameIndex + 1;
                    if ((nextFrameIndex != keyFramesCount) && (playCurTime > keyFrames[nextFrameIndex].time)) {
                        frameIndex = keyFramesCount - 1;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                    nextFrameIndex = frameIndex + 1;
                    while (frameIndex > -1) {
                        if (keyFrames[frameIndex].time < playCurTime)
                            break;
                        frameIndex--;
                        nextFrameIndex--;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                }
                var isEnd = nextFrameIndex == keyFramesCount;
                if (-1 != frameIndex) {
                    var frame = keyFrames[frameIndex];
                    if (isEnd) {
                        if (frame.data.val instanceof CurvePath) {
                            outDatas[i] = frame.data.val.getPointAt(0);
                        }
                        else {
                            outDatas[i] = frame.data.val;
                        }
                    }
                    else {
                        var nextFarme = keyFrames[nextFrameIndex];
                        var d = nextFarme.time - frame.time;
                        var t;
                        if (d !== 0)
                            t = (playCurTime - frame.time) / d;
                        else
                            t = 0;
                        outDatas[i] = this._getTweenVal(frame, nextFarme, t, d);
                    }
                }
                else {
                    if (keyFrames[0].data.val instanceof CurvePath) {
                        outDatas[i] = keyFrames[0].data.val.getPointAt(0);
                    }
                    else {
                        outDatas[i] = keyFrames[0].data.val;
                    }
                }
                if (addtive && "number" == typeof keyFrames[0].data.val) {
                    outDatas[i] = outDatas[i] - keyFrames[0].data.val;
                }
            }
        }
        _getTweenVal(frame, nextFrame, t, dur) {
            var start = frame.data;
            var end = nextFrame.data;
            if (start.val instanceof CurvePath) {
                return start.val.getPointAt(t);
            }
            if ("number" != typeof start.val || "number" != typeof end.val) {
                return start.val;
            }
            var tweenFun = getEase(start.tweenType);
            var poval = start.val;
            var oval = end.val;
            if (null != tweenFun) {
                return tweenFun(t, poval, oval - poval, 1);
            }
            var outTangent = 0;
            var inTangent = 0;
            var outWeight = NaN;
            var inWeight = NaN;
            if (null != start.tweenInfo) {
                outTangent = start.tweenInfo.outTangent;
                outWeight = start.tweenInfo.outWeight;
            }
            if (null != end.tweenInfo) {
                inTangent = end.tweenInfo.inTangent;
                inWeight = end.tweenInfo.inWeight;
            }
            if (isNaN(outWeight) || 0 >= outWeight)
                outWeight = Keyframe2D.defaultWeight;
            if (isNaN(inWeight) || 0 >= inWeight)
                inWeight = Keyframe2D.defaultWeight;
            if (isNaN(outTangent))
                outTangent = 0;
            if (isNaN(inTangent))
                inTangent = 0;
            if (Math.abs(outTangent) == Number.MAX_VALUE) {
                if (0 > outTangent) {
                    outTangent = -Infinity;
                }
                else {
                    outTangent = Infinity;
                }
            }
            if (Math.abs(inTangent) == Number.MAX_VALUE) {
                if (0 > inTangent) {
                    inTangent = -Infinity;
                }
                else {
                    inTangent = Infinity;
                }
            }
            var tnum;
            if ((!start.tweenInfo && !end.tweenInfo) || (Keyframe2D.defaultWeight == inWeight && Keyframe2D.defaultWeight == outWeight)) {
                tnum = hermiteInterpolate(outTangent, inTangent, poval, oval, t, dur);
            }
            else {
                tnum = this.hermiteCurveSplineWeight(poval, frame.time, outWeight, outTangent, oval, nextFrame.time, inWeight, inTangent, t);
            }
            return tnum;
        }
        _binarySearchEventIndex(time) {
            var start = 0;
            var end = this._animationEvents.length - 1;
            var mid;
            while (start <= end) {
                mid = (start + end) >> 1;
                var midValue = this._animationEvents[mid].time;
                if (midValue == time)
                    return mid;
                else if (midValue > time)
                    end = mid - 1;
                else
                    start = mid + 1;
            }
            return start;
        }
        hermiteCurveSplineWeight(frameValue, frametime, frameOutWeight, frameOutTangent, nextframeValue, nextframetime, nextframeInweight, nextframeIntangent, time) {
            let Eps = 2.22e-16;
            let x = time;
            let x1 = frametime;
            let y1 = frameValue;
            let wt1 = frameOutWeight;
            let x2 = nextframetime;
            let y2 = nextframeValue;
            let wt2 = nextframeInweight;
            let dx = x2 - x1;
            let dy = y2 - y1;
            dy = Math.max(Math.abs(dy), Eps) * (dy < 0 ? -1 : 1);
            let yp1 = frameOutTangent;
            let yp2 = nextframeIntangent;
            if (!Number.isFinite(yp1) || !Number.isFinite(yp2)) {
                return frameValue;
            }
            yp1 = yp1 * dx / dy;
            yp2 = yp2 * dx / dy;
            let wt2s = 1 - wt2;
            let t = 0.5;
            let t2 = 0;
            if (Math.abs(wt1 - 0.33333334) < 0.0001 && Math.abs(wt2 - 0.33333334) < 0.0001) {
                t = x;
                t2 = 1 - t;
            }
            else {
                while (true) {
                    t2 = (1 - t);
                    let fg = 3 * t2 * t2 * t * wt1 + 3 * t2 * t * t * wt2s + t * t * t - x;
                    if (Math.abs(fg) <= 2.5 * Eps)
                        break;
                    let fpg = 3 * t2 * t2 * wt1 + 6 * t2 * t * (wt2s - wt1) + 3 * t * t * (1 - wt2s);
                    let fppg = 6 * t2 * (wt2s - 2 * wt1) + 6 * t * (1 - 2 * wt2s + wt1);
                    let fpppg = 18 * wt1 - 18 * wt2s + 6;
                    t -= (6 * fg * fpg * fpg - 3 * fg * fg * fppg) / (6 * fpg * fpg * fpg - 6 * fg * fpg * fppg + fg * fg * fpppg);
                }
            }
            let y = 3 * t2 * t2 * t * wt1 * yp1 + 3 * t2 * t * t * (1 - wt2 * yp2) + t * t * t;
            return y * dy + y1;
        }
        addEvent(event) {
            var index = this._binarySearchEventIndex(event.time);
            this._animationEvents.splice(index, 0, event);
        }
    }
    const _map = {};
    function getEase(name) {
        if (!name)
            return null;
        let func = _map[name];
        if (!func) {
            name = name.replace("_Ease", "");
            name = name.charAt(0).toLowerCase() + name.substring(1);
            func = Ease[name];
            if (func != null)
                _map[name] = func;
        }
        return func;
    }
    function hermiteInterpolate(outTangent, inTangent, startValue, endValue, t, dur) {
        if (Math.abs(outTangent) == Infinity || Math.abs(inTangent) == Infinity) {
            if (0 > outTangent || 0 < inTangent)
                return startValue;
            return startValue;
        }
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2.0 * t3 - 3.0 * t2 + 1.0;
        var b = t3 - 2.0 * t2 + t;
        var c = t3 - t2;
        var d = -2.0 * t3 + 3.0 * t2;
        return a * startValue + b * outTangent * dur + c * inTangent * dur + d * endValue;
    }

    class Animation2DParm {
    }

    exports.AniConditionType = void 0;
    (function (AniConditionType) {
        AniConditionType[AniConditionType["Greater"] = 0] = "Greater";
        AniConditionType[AniConditionType["Less"] = 1] = "Less";
        AniConditionType[AniConditionType["Equals"] = 2] = "Equals";
        AniConditionType[AniConditionType["NotEqual"] = 3] = "NotEqual";
    })(exports.AniConditionType || (exports.AniConditionType = {}));
    class Animation2DCondition {
    }

    class Prefab extends Resource {
        constructor() {
            super(false);
            this.fromDCC = false;
            this._traceDeps = true;
        }
        onLoad() {
            Resource._idResourcesMap[this._id] = this;
            return this;
        }
        create(options, errors) {
            return null;
        }
        static instantiate(url, classType) {
            return ILaya.loader.load(url, Loader.HIERARCHY).then((res) => {
                return res.create();
            });
        }
    }
    var HierarchyResource = Prefab;

    class AnimatorStateCondition {
        static conditionNameToID(name) {
            if (AnimatorStateCondition._conditionNameMap[name] != null) {
                return AnimatorStateCondition._conditionNameMap[name];
            }
            else {
                var id = this._propertyNameCounter++;
                this._conditionNameMap[name] = id;
                this._conditionNameMap[id] = name;
                return id;
            }
        }
        static conditionIDToName(id) {
            return this._conditionNameMap[id];
        }
        constructor(name = null) {
            if (!name)
                return;
            this._id = AnimatorStateCondition.conditionNameToID(name);
            this._name = name;
        }
        get id() {
            return this._id;
        }
        get name() {
            return this._name;
        }
        set name(value) {
            this._id = AnimatorStateCondition.conditionNameToID(value);
            this._name = value;
        }
        get type() {
            return this._type;
        }
        checkState(value) {
            return false;
        }
    }
    AnimatorStateCondition._conditionNameMap = {};
    AnimatorStateCondition._propertyNameCounter = 0;
    class AnimatorStateNumberCondition extends AnimatorStateCondition {
        constructor(name) {
            super(name);
            this._numberValue = 0;
            this._numberCompareFlag = exports.AniStateConditionNumberCompressType.Greater;
            this._type = exports.AniStateConditionType.Number;
        }
        get numberValue() {
            return this._numberValue;
        }
        set numberValue(value) {
            this._numberValue = value;
        }
        get compareFlag() {
            return this._numberCompareFlag;
        }
        set compareFlag(value) {
            this._numberCompareFlag = value;
        }
        checkState(value) {
            if (exports.AniStateConditionNumberCompressType.Greater == this._numberCompareFlag)
                return value > this._numberValue;
            else
                return value < this._numberValue;
        }
    }
    class AnimatorStateBoolCondition extends AnimatorStateCondition {
        constructor(name) {
            super(name);
            this._compareFlag = true;
            this._type = exports.AniStateConditionType.Bool;
        }
        get compareFlag() {
            return this._compareFlag;
        }
        set compareFlag(value) {
            this._compareFlag = value;
        }
        checkState(value) {
            return this._compareFlag == value;
        }
    }
    class AnimatorStateTriggerCondition extends AnimatorStateCondition {
        constructor(name) {
            super(name);
            this._type = exports.AniStateConditionType.Trigger;
        }
        checkState(value) {
            return value;
        }
    }

    class AnimatorTransition2D {
        constructor() {
            this.conditions = [];
            this.exitByTime = true;
            this.exitTime = 1;
            this.transduration = 0;
            this.transstartoffset = 0;
            this.mute = false;
        }
        addCondition(condition) {
            if (this.conditions.indexOf(condition) == -1) {
                this.conditions.push(condition);
            }
        }
        removeCondition(condition) {
            let index = this.conditions.indexOf(condition);
            if (index != -1) {
                this.conditions.splice(index, 0);
            }
        }
        check(normalizeTime, paramsMap, isReplay) {
            if (this.mute)
                return false;
            if (this.exitByTime && (normalizeTime < this.exitTime && !isReplay))
                return false;
            if (!this.conditions || this.conditions.length === 0)
                return true;
            if (this.isAndOperEnabled) {
                for (let i = 0; i < this.conditions.length; i++) {
                    const con = this.conditions[i];
                    const out = con.checkState(paramsMap[con.name].value);
                    if (!out)
                        return false;
                    if (con.type === exports.AniStateConditionType.Trigger) {
                        paramsMap[con.name].value = false;
                    }
                }
                return true;
            }
            else {
                for (let i = 0; i < this.conditions.length; i++) {
                    const con = this.conditions[i];
                    const out = con.checkState(paramsMap[con.name].value);
                    if (out) {
                        if (con.type === exports.AniStateConditionType.Trigger) {
                            paramsMap[con.name].value = false;
                        }
                        return true;
                    }
                }
            }
            return false;
        }
    }

    class AnimatorController2D extends Resource {
        constructor(data) {
            super();
            let obj = AnimatorControllerParse.parse(data);
            this.data = obj.ret;
            this.clipsID = obj.clipsID;
        }
        getLayers() {
            let layers = this.data.controllerLayers;
            let lArr = [];
            for (let i = layers.length - 1; i >= 0; i--) {
                let l = layers[i];
                let acl = new AnimatorControllerLayer2D(l.name);
                lArr.unshift(acl);
                for (let k in l) {
                    if ("name" == k || "states" == k || null == l[k]) {
                        continue;
                    }
                    try {
                        acl[k] = l[k];
                    }
                    catch (err) {
                        console.error(err);
                    }
                }
                this.getState(l.states, acl, this.data);
            }
            return lArr;
        }
        createState(states, idCatch, acl) {
            if (!states)
                return null;
            let ret = {};
            let defID = null;
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                let childStates = obj.states;
                if (childStates) {
                    let groupRet = this.createState(childStates, idCatch, acl);
                    if (groupRet) {
                        idCatch[obj.id] = groupRet.states[groupRet.id];
                    }
                    continue;
                }
                if (0 > Number(obj.id)) {
                    if ("-1" == obj.id) {
                        let transitions = obj.soloTransitions;
                        if (transitions && 0 < transitions.length) {
                            defID = transitions[0].id;
                        }
                    }
                    continue;
                }
                let state = new AnimatorState2D();
                idCatch[obj.id] = state;
                ret[obj.id] = state;
                for (let k in obj) {
                    try {
                        if ("scripts" == k) {
                            let scripts = obj[k];
                            if (scripts && Array.isArray(scripts)) {
                                for (let k = scripts.length - 1; k >= 0; k--) {
                                    let uuid = scripts[k];
                                    if (uuid && 0 == uuid.indexOf("res://")) {
                                        uuid = uuid.substring(6);
                                    }
                                    let c = ClassUtils.getClass(uuid);
                                    if (c) {
                                        state.addScript(c);
                                    }
                                }
                            }
                            continue;
                        }
                        else if ("soloTransitions" == k) {
                            continue;
                        }
                        else if (null != obj[k]) {
                            state[k] = obj[k];
                        }
                    }
                    catch (err) { }
                }
                acl.addState(state);
            }
            return { id: defID, states: ret };
        }
        getState(states, acl, data) {
            if (states) {
                let idCatch = {};
                this.createState(states, idCatch, acl);
                this.setTransitions(states, idCatch, acl, data);
            }
        }
        setExitTransition(exitRet, transitions, idCatch, data, pExitRet) {
            for (let id in exitRet) {
                let state = idCatch[id];
                if (state) {
                    let ats = state.transitions;
                    let sts = state.soloTransitions;
                    let linArr = exitRet[id];
                    for (let i = transitions.length - 1; i >= 0; i--) {
                        let t = transitions[i];
                        if ("-3" == t.id) {
                            if (null == pExitRet[id]) {
                                pExitRet[id] = [];
                            }
                            pExitRet[id].push(t);
                            continue;
                        }
                        for (let j = linArr.length - 1; j >= 0; j--) {
                            let t2 = linArr[j];
                            let ato = new AnimatorTransition2D();
                            ato.destState = idCatch[t.id];
                            if (t.conditions) {
                                this.addConditions(t.conditions, ato, data);
                            }
                            if (t2.conditions) {
                                this.addConditions(t2.conditions, ato, data);
                            }
                            for (let k in t) {
                                if ("solo" == k || "id" == k || "conditions" == k) {
                                    continue;
                                }
                                else {
                                    ato[k] = t[k];
                                }
                            }
                            if (t.solo) {
                                sts.unshift(ato);
                            }
                            else {
                                ats.unshift(ato);
                            }
                        }
                    }
                }
            }
        }
        _getAnimatorTransition2D(o, idCatch, data) {
            let ato = new AnimatorTransition2D();
            if (idCatch[o.id]) {
                ato.destState = idCatch[o.id];
            }
            if (o.conditions) {
                this.addConditions(o.conditions, ato, data);
            }
            for (let k in o) {
                if ("solo" == k || "id" == k || "conditions" == k) {
                    continue;
                }
                else {
                    ato[k] = o[k];
                }
            }
            return ato;
        }
        setTransitions(states, idCatch, acl, data, pState) {
            if (!states)
                return null;
            let exitRet = {};
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                if (obj.states) {
                    let exitTransition = this.setTransitions(obj.states, idCatch, acl, data, obj);
                    if (exitTransition) {
                        let transitions = obj.soloTransitions;
                        if (transitions) {
                            this.setExitTransition(exitTransition, transitions, idCatch, data, exitRet);
                        }
                    }
                }
            }
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                if (obj.states) {
                    continue;
                }
                if ("-1" == obj.id) {
                    if (obj.soloTransitions && 0 < obj.soloTransitions.length) {
                        if (null == pState) {
                            acl.defaultState = idCatch[obj.soloTransitions[0].id];
                            acl._enterTransition = this._getAnimatorTransition2D(obj.soloTransitions[0], idCatch, data);
                        }
                        else {
                            idCatch[pState.id] = idCatch[obj.soloTransitions[0].id];
                        }
                        continue;
                    }
                }
                else if ("-2" == obj.id) {
                    let transitions = obj.soloTransitions;
                    if (transitions) {
                        for (let j = transitions.length - 1; j >= 0; j--) {
                            let o = transitions[j];
                            let destState = idCatch[o.id];
                            if (destState) {
                                for (let idk in idCatch) {
                                    let state = idCatch[idk];
                                    let ato = this._getAnimatorTransition2D(o, idCatch, data);
                                    if (o.solo) {
                                        state.soloTransitions.unshift(ato);
                                    }
                                    else {
                                        state.transitions.unshift(ato);
                                    }
                                }
                            }
                        }
                    }
                    continue;
                }
                else if ("-3" == obj.id) {
                    continue;
                }
                let soloTransitions = obj.soloTransitions;
                if (soloTransitions && idCatch[obj.id]) {
                    let ats = idCatch[obj.id].transitions;
                    let sts = idCatch[obj.id].soloTransitions;
                    for (let j = soloTransitions.length - 1; j >= 0; j--) {
                        let o = soloTransitions[j];
                        if ("-3" == o.id) {
                            if (null == exitRet[obj.id]) {
                                exitRet[obj.id] = [];
                            }
                            exitRet[obj.id].push(o);
                            continue;
                        }
                        let ato = this._getAnimatorTransition2D(o, idCatch, data);
                        if (o.solo) {
                            sts.unshift(ato);
                        }
                        else {
                            ats.unshift(ato);
                        }
                    }
                }
            }
            return exitRet;
        }
        addConditions(arr, ato, data) {
            let parms = data.animatorParams;
            if (null == parms || 0 == parms.length)
                return;
            for (let i = 0, len = arr.length; i < len; i++) {
                let o = arr[i];
                let parm = null;
                for (let j = parms.length - 1; j >= 0; j--) {
                    if (parms[j].id == o.id) {
                        parm = parms[j];
                        break;
                    }
                }
                if (null == parm) {
                    return;
                }
                let c;
                if (parm.type == exports.AniParmType.Bool) {
                    let b = new AnimatorStateBoolCondition(parm.name);
                    b.compareFlag = Boolean(o.checkValue);
                    c = b;
                }
                else if (parm.type == exports.AniParmType.Float) {
                    let n = new AnimatorStateNumberCondition(parm.name);
                    n.numberValue = Number(o.checkValue);
                    n.compareFlag = o.type;
                    c = n;
                }
                else if (parm.type == exports.AniParmType.Trigger) {
                    let t = new AnimatorStateTriggerCondition(parm.name);
                    c = t;
                }
                ato.addCondition(c);
            }
        }
        updateTo(a) {
            let currLayer = a._controllerLayers;
            for (let i = 0, len = currLayer.length; i < len; i++) {
                currLayer[i].destroy();
            }
            currLayer.length = 0;
            let layers = this.getLayers();
            for (let i = 0, len = layers.length; i < len; i++) {
                a.addControllerLayer(layers[i]);
            }
            let parms = this.data.animatorParams;
            if (parms) {
                let setParm = {};
                for (let i = parms.length - 1; i >= 0; i--) {
                    let p = parms[i];
                    let sp = new Animation2DParm();
                    sp.name = p.name;
                    sp.type = p.type;
                    sp.value = p.val;
                    setParm[p.name] = sp;
                }
                a.parameters = setParm;
            }
        }
    }

    class Script extends Component {
        _isScript() {
            return true;
        }
        setupScript() {
            let owner = this.owner;
            let func;
            if (func = this.onTriggerEnter)
                owner.on(Event.TRIGGER_ENTER, this, func);
            if (func = this.onTriggerStay)
                owner.on(Event.TRIGGER_STAY, this, func);
            if (func = this.onTriggerExit)
                owner.on(Event.TRIGGER_EXIT, this, func);
            if (func = this.onCollisionEnter)
                owner.on(Event.COLLISION_ENTER, this, func);
            if (func = this.onCollisionStay)
                owner.on(Event.COLLISION_STAY, this, func);
            if (func = this.onCollisionExit)
                owner.on(Event.COLLISION_EXIT, this, func);
            if (func = this.onJointBreak)
                owner.on(Event.JOINT_BREAK, this, func);
            if (func = this.onMouseDown)
                owner.on(Event.MOUSE_DOWN, this, func);
            if (func = this.onMouseUp)
                owner.on(Event.MOUSE_UP, this, func);
            if (func = this.onRightMouseDown)
                owner.on(Event.RIGHT_MOUSE_DOWN, this, func);
            if (func = this.onRightMouseUp)
                owner.on(Event.RIGHT_MOUSE_UP, this, func);
            if (func = this.onMouseMove)
                owner.on(Event.MOUSE_MOVE, this, func);
            if (func = this.onMouseDrag)
                owner.on(Event.MOUSE_DRAG, this, func);
            if (func = this.onMouseDragEnd)
                owner.on(Event.MOUSE_DRAG_END, this, func);
            if (func = this.onMouseOver)
                owner.on(Event.MOUSE_OVER, this, func);
            if (func = this.onMouseOut)
                owner.on(Event.MOUSE_OUT, this, func);
            if (func = this.onMouseClick)
                owner.on(Event.CLICK, this, func);
            if (func = this.onMouseDoubleClick)
                owner.on(Event.DOUBLE_CLICK, this, func);
            if (func = this.onMouseRightClick)
                owner.on(Event.RIGHT_CLICK, this, func);
            if (func = this.onKeyDown)
                ILaya.stage.on(Event.KEY_DOWN, this, func);
            if (func = this.onKeyPress)
                ILaya.stage.on(Event.KEY_PRESS, this, func);
            if (func = this.onKeyUp)
                ILaya.stage.on(Event.KEY_UP, this, func);
        }
    }

    class LoadModel2DV01 {
        static parse(readData, version, mesh, subMeshes) {
            LoadModel2DV01._mesh = mesh;
            LoadModel2DV01._subMeshes = subMeshes;
            LoadModel2DV01._version = version;
            LoadModel2DV01._readData = readData;
            LoadModel2DV01.READ_DATA();
            LoadModel2DV01.READ_BLOCK();
            LoadModel2DV01.READ_STRINGS();
            for (var i = 0, n = LoadModel2DV01._BLOCK.count; i < n; i++) {
                LoadModel2DV01._readData.pos = LoadModel2DV01._BLOCK.blockStarts[i];
                var index = LoadModel2DV01._readData.readUint16();
                var blockName = LoadModel2DV01._strings[index];
                var fn = LoadModel2DV01["READ_" + blockName];
                if (fn == null)
                    console.warn("model file err,no this function:" + index + " " + blockName);
                else
                    fn.call(null);
            }
            LoadModel2DV01._strings.length = 0;
            LoadModel2DV01._readData = null;
            LoadModel2DV01._version = null;
            LoadModel2DV01._mesh = null;
            LoadModel2DV01._subMeshes = null;
        }
        static _readString() {
            return LoadModel2DV01._strings[LoadModel2DV01._readData.readUint16()];
        }
        static READ_DATA() {
            LoadModel2DV01._DATA.offset = LoadModel2DV01._readData.readUint32();
            LoadModel2DV01._DATA.size = LoadModel2DV01._readData.readUint32();
        }
        static READ_BLOCK() {
            var count = LoadModel2DV01._BLOCK.count = LoadModel2DV01._readData.readUint16();
            var blockStarts = LoadModel2DV01._BLOCK.blockStarts = [];
            var blockLengths = LoadModel2DV01._BLOCK.blockLengths = [];
            for (var i = 0; i < count; i++) {
                blockStarts.push(LoadModel2DV01._readData.readUint32());
                blockLengths.push(LoadModel2DV01._readData.readUint32());
            }
        }
        static READ_STRINGS() {
            var offset = LoadModel2DV01._readData.readUint32();
            var count = LoadModel2DV01._readData.readUint16();
            var prePos = LoadModel2DV01._readData.pos;
            LoadModel2DV01._readData.pos = offset + LoadModel2DV01._DATA.offset;
            for (var i = 0; i < count; i++)
                LoadModel2DV01._strings[i] = LoadModel2DV01._readData.readUTFString();
            LoadModel2DV01._readData.pos = prePos;
        }
        static READ_MESH() {
            var i;
            var memorySize = 0;
            var name = LoadModel2DV01._readString();
            var reader = LoadModel2DV01._readData;
            var arrayBuffer = reader.rawBuffer;
            var vertexBufferCount = reader.readInt16();
            var offset = LoadModel2DV01._DATA.offset;
            var mesh = LoadModel2DV01._mesh;
            let vertexBuffers = [];
            var vertexCount = 0;
            let vertices = [];
            for (i = 0; i < vertexBufferCount; i++) {
                var vbStart = offset + reader.readUint32();
                var byteLength = reader.readUint32();
                var vertexFlag = LoadModel2DV01._readString();
                var vertexDeclaration = VertexMesh.getVertexDeclaration(vertexFlag, false);
                var vertexData = arrayBuffer.slice(vbStart, vbStart + byteLength);
                vertices[i] = vertexData;
                var vertexBuffer = LayaGL.renderDeviceFactory.createVertexBuffer(exports.BufferUsage.Static);
                vertexBuffer.vertexDeclaration = vertexDeclaration;
                vertexBuffer.setDataLength(byteLength);
                vertexBuffer.setData(vertexData, 0, 0, byteLength);
                vertexCount = byteLength / vertexDeclaration.vertexStride;
                memorySize += byteLength;
                vertexBuffers[i] = vertexBuffer;
            }
            if (vertexCount > 65535)
                mesh._indexFormat = exports.IndexFormat.UInt32;
            else
                mesh._indexFormat = exports.IndexFormat.UInt16;
            var ibStart = offset + reader.readUint32();
            var ibLength = reader.readUint32();
            var ibDatas, byteCount;
            if (mesh.indexFormat == exports.IndexFormat.UInt32) {
                ibDatas = new Uint32Array(arrayBuffer.slice(ibStart, ibStart + ibLength));
                byteCount = 4;
            }
            else {
                ibDatas = new Uint16Array(arrayBuffer.slice(ibStart, ibStart + ibLength));
                byteCount = 2;
            }
            var indexBuffer = LayaGL.renderDeviceFactory.createIndexBuffer(exports.BufferUsage.Static);
            indexBuffer.indexType = mesh.indexFormat;
            indexBuffer.indexCount = ibLength / byteCount;
            indexBuffer._setIndexDataLength(ibLength);
            indexBuffer._setIndexData(ibDatas, 0);
            mesh._setBuffers(vertexBuffers, indexBuffer);
            mesh.canRead = true;
            mesh._vertices = vertices;
            mesh._indices = ibDatas;
            memorySize += ibDatas.byteLength;
            mesh._setCPUMemory(memorySize);
            mesh._setGPUMemory(memorySize);
            mesh.name = name;
            return true;
        }
        static READ_SUBMESH() {
            var reader = LoadModel2DV01._readData;
            var subMesh = LayaGL.renderDeviceFactory.createRenderGeometryElement(exports.MeshTopology.Triangles, exports.DrawType.DrawElement);
            reader.readInt16();
            let mesh = LoadModel2DV01._mesh;
            subMesh.bufferState = mesh._bufferState;
            subMesh.indexFormat = mesh.indexFormat;
            var drawCount = reader.readUint16();
            for (var i = 0; i < drawCount; i++) {
                let ibOffset = reader.readUint32();
                let ibCount = reader.readUint32();
                subMesh.setDrawElemenParams(ibCount, ibOffset);
            }
            LoadModel2DV01._subMeshes.push(subMesh);
            return true;
        }
    }
    LoadModel2DV01._BLOCK = { count: 0 };
    LoadModel2DV01._DATA = { offset: 0, size: 0 };
    LoadModel2DV01._strings = [];

    class MeshLoader {
        load(task) {
            let url = AssetDb.inst.getSubAssetURL(task.url, task.uuid, null, "lm");
            return task.loader.fetch(url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return this._parse(task, data);
            });
        }
        _parse(task, data) {
            var readData = new Byte(data);
            readData.pos = 0;
            var version = readData.readUTFString();
            if (!version || !version.startsWith("LAYAMODEL")) {
                console.warn(`Unknow version:${version} ! Model : ${task.url}`);
                return null;
            }
            let is2D = version.startsWith("LAYAMODEL2D");
            if (!is2D) {
                if (!MeshLoader.v3d) {
                    console.warn(`Loading ${task.url} , you need load the laya.d3 lib!`);
                    return null;
                }
                return MeshLoader.v3d.parse(readData, version);
            }
            else {
                return MeshLoader.v2d.parse(readData, version);
            }
        }
    }
    class Mesh2DReader {
        static parse(readData, version) {
            var mesh = new Mesh2D();
            let subMeshes = mesh._subMeshes;
            switch (version) {
                case "LAYAMODEL2D:01":
                    LoadModel2DV01.parse(readData, version, mesh, subMeshes);
                    break;
                default:
                    throw new Error("unknown mesh version: " + version);
            }
            mesh._setSubMeshes(subMeshes);
            return mesh;
        }
    }
    MeshLoader.v2d = Mesh2DReader;
    Loader.registerLoader(["lm"], MeshLoader, Loader.MESH);

    exports.TextResourceFormat = void 0;
    (function (TextResourceFormat) {
        TextResourceFormat[TextResourceFormat["Buffer"] = 0] = "Buffer";
        TextResourceFormat[TextResourceFormat["Plain"] = 1] = "Plain";
        TextResourceFormat[TextResourceFormat["JSON"] = 2] = "JSON";
        TextResourceFormat[TextResourceFormat["XML"] = 3] = "XML";
    })(exports.TextResourceFormat || (exports.TextResourceFormat = {}));
    class TextResource extends Resource {
        constructor(data, format) {
            super();
            this.data = data;
            this.format = format;
        }
    }

    class TextAssetLoader {
        load(task) {
            return task.loader.fetch(task.url, "text", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new TextResource(data, exports.TextResourceFormat.Plain);
            });
        }
    }
    class BytesAssetLoader {
        load(task) {
            return task.loader.fetch(task.url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new TextResource(data, exports.TextResourceFormat.Buffer);
            });
        }
    }
    class JsonAssetLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new TextResource(data, exports.TextResourceFormat.JSON);
            });
        }
    }
    class XMLAssetLoader {
        load(task) {
            return task.loader.fetch(task.url, "xml", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new TextResource(data, exports.TextResourceFormat.XML);
            });
        }
    }
    Loader.registerLoader(["txt", "csv"], TextAssetLoader, Loader.TEXT);
    Loader.registerLoader(["bin", "bytes", "fui"], BytesAssetLoader, Loader.BUFFER);
    Loader.registerLoader(["json"], JsonAssetLoader, Loader.JSON);
    Loader.registerLoader(["xml"], XMLAssetLoader, Loader.XML);

    class AtlasLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(0.2), task.options).then(data => {
                if (!data)
                    return null;
                let toloadPics = [];
                if (data.meta && data.meta.image) {
                    let folderPath = "";
                    let i = task.url.lastIndexOf("/");
                    if (i != -1)
                        folderPath = task.url.substring(0, i + 1);
                    let query = "";
                    i = task.url.lastIndexOf("?");
                    if (i != -1)
                        query = task.url.substring(i);
                    let pics = data.meta.image.split(",");
                    for (let pic of pics) {
                        if (!pic.startsWith("res://"))
                            pic = folderPath + pic + query;
                        toloadPics.push(task.loader.load(pic, null, task.progress.createCallback()));
                    }
                }
                else {
                    toloadPics.push(task.loader.load(Utils.replaceFileExtension(task.url, "png"), null, task.progress.createCallback()));
                }
                return Promise.all(toloadPics).then(pics => {
                    pics = pics.filter(pic => pic != null);
                    let baseUrl = task.options.baseUrl || "";
                    let frames = data.frames;
                    let directory = (data.meta && data.meta.prefix != null) ? data.meta.prefix : task.url.substring(0, task.url.lastIndexOf(".")) + "/";
                    let subTextures = [];
                    let scaleRate = 1;
                    if (data.meta && data.meta.scale && data.meta.scale != 1)
                        scaleRate = parseFloat(data.meta.scale);
                    for (let tPic of pics)
                        tPic.scaleRate = scaleRate;
                    for (let name in frames) {
                        let obj = frames[name];
                        let tPic = pics[obj.frame.idx ? obj.frame.idx : 0];
                        if (!tPic)
                            continue;
                        let url = baseUrl + directory + (obj.filename || name);
                        let tt = Texture.create(tPic, obj.frame.x, obj.frame.y, obj.frame.w, obj.frame.h, obj.spriteSourceSize.x, obj.spriteSourceSize.y, obj.sourceSize.w, obj.sourceSize.h);
                        tt._sizeGrid = obj.sizeGrid;
                        tt._stateNum = obj.stateNum;
                        task.loader.cacheRes(url, tt);
                        tt.url = url;
                        subTextures.push(tt);
                    }
                    let res = task.obsoluteInst;
                    if (res) {
                        res.update(pics, subTextures);
                        res.dir = directory;
                        res.animation = data.animation;
                        res.event("reload");
                        return res;
                    }
                    else {
                        res = new AtlasResource(directory, pics, subTextures);
                        res.animation = data.animation;
                        return res;
                    }
                });
            });
        }
    }
    Loader.registerLoader(["atlas"], AtlasLoader, Loader.ATLAS, true);

    const TypedArrayClasses = {
        "Int8Array": Int8Array,
        "Uint8Array": Uint8Array,
        "Int16Array": Int16Array,
        "Uint16Array": Uint16Array,
        "Int32Array": Int32Array,
        "Uint32Array": Uint32Array,
        "Float32Array": Float32Array,
        "Float64Array": Float64Array
    };
    class SerializeUtil {
        static hasProp(...keys) {
            for (let k of keys) {
                if (SerializeUtil._data[k] !== undefined)
                    return true;
            }
            return false;
        }
        static decodeObj(data, obj) {
            return ObjDecoder.decodeObj(data, obj);
        }
        static getLoadTypeByEngineType(type) {
            return Loader.assetTypeToLoadType[type];
        }
        static bakeOverrideData(overrideData) {
            let dataMap = null;
            for (let n = overrideData.length, i = n - 1; i >= 0; i--) {
                let arr = overrideData[i];
                if (arr && arr.length > 0) {
                    for (let d of arr) {
                        let od = d._$override || d._$parent;
                        let k;
                        if (Array.isArray(od))
                            k = od[n - i - 1];
                        else if (i === n - 1)
                            k = od;
                        if (k != null) {
                            if (!dataMap)
                                dataMap = {};
                            let arr2 = dataMap[k];
                            if (!arr2)
                                dataMap[k] = arr2 = [];
                            arr2.push(n - i, d);
                        }
                    }
                }
            }
            return dataMap;
        }
        static applyOverrideData(nodeData, overrideDataMap) {
            function test(obj) {
                if (overrideDataMap[obj._$id])
                    return true;
                let children = obj._$child;
                if (children && children.find(child => test(child)))
                    return true;
                return false;
            }
            function cloneTree(obj) {
                let ret = Object.assign({}, obj);
                let children = ret._$child;
                if (children)
                    ret._$child = children.map(c => cloneTree(c));
                let comps = ret._$comp;
                if (comps)
                    ret._$comp = comps.map(c => Object.assign({}, c));
                return ret;
            }
            function visit(data) {
                let children = data._$child;
                if (children) {
                    for (let child of children) {
                        if (child._$id)
                            visit(child);
                    }
                }
                let od = overrideDataMap[data._$id];
                if (od) {
                    for (let i = 0; i < od.length; i += 2) {
                        let j = od[i];
                        let e = od[i + 1];
                        let idPath;
                        if (idPath = e._$override) {
                            let toWrite;
                            if (Array.isArray(idPath)) {
                                if (j === idPath.length - 1) {
                                    let k = idPath[j];
                                    if (!children)
                                        data._$child = children = [];
                                    else
                                        toWrite = children.find(c => c._$override == k);
                                    if (!toWrite) {
                                        toWrite = { _$override: k };
                                        children.push(toWrite);
                                    }
                                }
                                else if (j < idPath.length - 1) {
                                    let k = idPath.slice(j);
                                    if (!children)
                                        data._$child = children = [];
                                    else {
                                        toWrite = children.find(c => {
                                            let o = c._$override;
                                            return Array.isArray(o) && arrayEquals(o, k);
                                        });
                                    }
                                    if (!toWrite) {
                                        toWrite = { _$override: k };
                                        children.push(toWrite);
                                    }
                                }
                                else
                                    toWrite = data;
                            }
                            else
                                toWrite = data;
                            mergeData(toWrite, e);
                            if (e._$comp) {
                                let comps = toWrite._$comp;
                                if (!comps)
                                    toWrite._$comp = comps = [];
                                for (let comp of e._$comp) {
                                    let typeOrId = comp._$type || comp._$override;
                                    let c = comps.find(c => c._$override == typeOrId || c._$type == typeOrId || c._$id == typeOrId);
                                    if (!c) {
                                        c = {};
                                        if (comp._$type)
                                            c._$type = typeOrId;
                                        else
                                            c._$override = typeOrId;
                                        comps.push(c);
                                    }
                                    mergeData(c, comp);
                                }
                            }
                        }
                        else if (idPath = e._$parent) {
                            if (!children)
                                data._$child = children = [];
                            let k;
                            if (j < idPath.length) {
                                if (j === idPath.length - 1)
                                    k = idPath[j];
                                else
                                    k = idPath.slice(j);
                                let toWrite = Object.assign({}, e);
                                toWrite._$parent = k;
                                children.push(toWrite);
                            }
                            else {
                                let toWrite = Object.assign({}, e);
                                delete toWrite._$parent;
                                if (data._$prefab) {
                                    children.push(toWrite);
                                }
                                else {
                                    delete toWrite._$index;
                                    if (e._$index < children.length)
                                        children.splice(e._$index, 0, toWrite);
                                    else
                                        children.push(toWrite);
                                }
                            }
                        }
                    }
                }
            }
            if (test(nodeData)) {
                nodeData = cloneTree(nodeData);
                visit(nodeData);
            }
            return nodeData;
        }
    }
    SerializeUtil.isDeserializing = false;
    function mergeData(target, overrided) {
        for (let k in overrided) {
            if (k.startsWith("_$"))
                continue;
            let v = overrided[k];
            if (v != null && typeof (v) === "object" && !Array.isArray(v) && !(v._$type || v._$uuid || v._$ref)) {
                let v2 = target[k];
                if (v2 != null && typeof (v2) === "object") {
                    target[k] = v2 = Object.assign({}, v2);
                    mergeData(v2, v);
                }
                else
                    target[k] = v;
            }
            else
                target[k] = v;
        }
    }
    function arrayEquals(a, b) {
        if (a.length === b.length) {
            for (var i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }
        else {
            return false;
        }
    }

    class ObjDecoder {
        constructor() {
            this.getNodeByRef = dummy;
            this.getNodeData = dummy;
        }
        static decodeObj(data, obj) {
            decoder.errors = null;
            decoder.getNodeByRef = dummy;
            decoder.getNodeData = dummy;
            return decoder.decodeObj(data, obj);
        }
        decodeObj(data, obj, excludeKeys) {
            SerializeUtil.isDeserializing = true;
            try {
                return this._decode(data, obj, excludeKeys);
            }
            finally {
                SerializeUtil.isDeserializing = false;
            }
        }
        decodeObjBounds(data, obj) {
            SerializeUtil.isDeserializing = true;
            try {
                let v0 = data["x"];
                let v1 = data["y"];
                if (v0 !== undefined && v1 !== undefined)
                    obj.pos(v0, v1);
                else if (v0 !== undefined)
                    obj.x = v0;
                else if (v1 !== undefined)
                    obj.y = v1;
                v0 = data["width"];
                v1 = data["height"];
                if (v0 !== undefined && v1 !== undefined)
                    obj.size(v0, v1);
                else if (v0 !== undefined)
                    obj.width = v0;
                else if (v1 !== undefined)
                    obj.height = v1;
                v0 = data["controllers"];
                if (v0 !== undefined)
                    obj.controllers = this._decode(v0);
            }
            finally {
                SerializeUtil.isDeserializing = false;
            }
        }
        _decode(data, obj, excludeKeys) {
            if (data == null)
                return null;
            else if (Array.isArray(data)) {
                let arr = [];
                for (let i = 0; i < data.length; i++) {
                    let v = data[i];
                    if (v != null) {
                        try {
                            arr[i] = this._decode(v);
                        }
                        catch (error) {
                            if (this.errors)
                                this.errors.push(error);
                            else
                                console.error(error);
                            arr[i] = null;
                        }
                    }
                    else
                        arr[i] = null;
                }
                return arr;
            }
            else if (typeof (data) === "object") {
                if (data._$uuid != null) {
                    let url = URL.getResURLByUUID(data._$uuid);
                    return ILaya.loader.getRes(url, Loader.assetTypeToLoadType[data._$type]);
                }
                if (data._$ref != null) {
                    let node = this.getNodeByRef(data._$ref);
                    if (!node)
                        return null;
                    if (data._$type) {
                        let cls = ClassUtils.getClass(data._$type);
                        if (cls)
                            return node.getComponent(cls);
                        else
                            return null;
                    }
                    else if (data._$ctrl !== undefined) {
                        let cls = crefClass || (crefClass = ClassUtils.getClass("ControllerRef"));
                        if (cls)
                            return new cls(node, data._$ctrl);
                        else
                            return null;
                    }
                    else
                        return node;
                }
                let type = data._$type;
                if (type === "any") {
                    if (data._$type)
                        return data.value;
                    else
                        return data;
                }
                let typedArray = TypedArrayClasses[type];
                if (typedArray != null) {
                    if (data._$type)
                        return new typedArray(data.value);
                    else
                        return new typedArray(data);
                }
                if (!obj) {
                    let cls = ClassUtils.getClass(type);
                    if (!cls) {
                        return null;
                    }
                    obj = new cls();
                }
                for (let key in data) {
                    if (key.startsWith("_$") || excludeKeys && excludeKeys.has(key))
                        continue;
                    let v = data[key];
                    if (v == null || typeof (v) !== "object" || Array.isArray(v)
                        || v._$type || v._$uuid || v._$ref) {
                        try {
                            let v2 = this._decode(v);
                            obj[key] = v2;
                            if (v2 != null && v != null && v._$tmpl)
                                obj[v._$tmpl] = new PrefabImpl(null, this.getNodeData(v2));
                        }
                        catch (error) {
                            if (this.errors)
                                this.errors.push(error);
                            else
                                console.error(error);
                        }
                    }
                    else {
                        let childObj = obj[key];
                        if (childObj) {
                            try {
                                this._decode(v, childObj);
                            }
                            catch (error) {
                                if (this.errors)
                                    this.errors.push(error);
                                else
                                    console.error(error);
                            }
                        }
                    }
                }
                if (obj.onAfterDeserialize) {
                    try {
                        SerializeUtil._data = data;
                        obj.onAfterDeserialize();
                    }
                    catch (error) {
                        if (this.errors)
                            this.errors.push(error);
                        else
                            console.error(error);
                    }
                }
                return obj;
            }
            else
                return data;
        }
    }
    function dummy(...args) { return null; }
    var crefClass;
    const decoder = new ObjDecoder();

    const excludeKeys = new Set(["x", "y", "width", "height", "controllers", "relations", "gears"]);
    class HierarchyParser {
        static parse(data, options, errors) {
            let printErrors = errors == null;
            errors = errors || [];
            let nodeMap = {};
            let dataList = [];
            let allNodes = [];
            let outNodes = [];
            let toDestroy = [];
            let scene;
            let inPrefab;
            let prefabNodeDict;
            let skinBaseUrl;
            let overrideData;
            let hasRuntime;
            let hasUI;
            if (options) {
                inPrefab = options.inPrefab;
                if (inPrefab)
                    prefabNodeDict = options.prefabNodeDict;
                skinBaseUrl = options.skinBaseUrl;
                overrideData = options.overrideData;
            }
            function createChildren(data, prefab) {
                for (let child of data._$child) {
                    if (child._$child) {
                        let node = createNode(child, prefab);
                        createChildren(child, child._$prefab ? node : prefab);
                        dataList.push(child);
                        allNodes.push(node);
                    }
                    else {
                        let node = createNode(child, prefab);
                        dataList.push(child);
                        allNodes.push(node);
                    }
                }
            }
            function createNode(nodeData, prefab) {
                let node;
                let pstr;
                if (pstr = nodeData._$override) {
                    if (prefab && prefabNodeDict) {
                        if (Array.isArray(pstr)) {
                            node = prefab;
                            for (let i = 0, n = pstr.length; i < n; i++) {
                                let map = prefabNodeDict.get(node);
                                node = map === null || map === void 0 ? void 0 : map[pstr[i]];
                                if (!node)
                                    break;
                                if (node == prefab) {
                                    node = null;
                                    break;
                                }
                            }
                        }
                        else {
                            let map = prefabNodeDict.get(prefab);
                            if (map) {
                                node = map[nodeData._$override];
                                if (node == prefab)
                                    node = null;
                            }
                        }
                    }
                }
                else {
                    if (pstr = nodeData._$prefab) {
                        let res = Loader.getRes(URL.getResURLByUUID(pstr), Loader.HIERARCHY);
                        if (res) {
                            if (!prefabNodeDict)
                                prefabNodeDict = new Map();
                            let overrideData2 = [];
                            let testId = nodeData._$id;
                            if (overrideData) {
                                for (let i = 0, n = overrideData.length; i < n; i++) {
                                    let arr = overrideData[i];
                                    if (arr && arr.length > 0) {
                                        overrideData2[i] = arr.filter(d => {
                                            let od = d._$override || d._$parent;
                                            return Array.isArray(od) && od.length > n - i && od[n - i - 1] == testId;
                                        });
                                    }
                                    else
                                        overrideData2[i] = arr;
                                }
                            }
                            overrideData2.push(nodeData._$child);
                            node = res.create({ inPrefab: true, prefabNodeDict: prefabNodeDict, overrideData: overrideData2 }, errors);
                        }
                    }
                    else if (pstr = nodeData._$type) {
                        let cls = ClassUtils.getClass(pstr);
                        if (cls) {
                            try {
                                node = new cls();
                            }
                            catch (err) {
                                errors.push(err);
                            }
                        }
                        else {
                            errors.push(new Error(`missing node type '${pstr}' (in ${nodeData.name || 'noname'})`));
                        }
                    }
                    if (node) {
                        nodeMap[nodeData._$id] = node;
                        if (node._nodeType === 2)
                            hasUI = true;
                    }
                }
                return node;
            }
            function getNodeByRef(idPath) {
                if (Array.isArray(idPath)) {
                    let prefab = nodeMap[idPath[0]];
                    if (prefab && idPath.length > 1)
                        return findNodeInPrefab(prefab, idPath, 1);
                    else
                        return prefab;
                }
                else
                    return nodeMap[idPath];
            }
            function findNodeInPrefab(prefab, idPath, startIndex = 0) {
                if (!idPath)
                    return prefab;
                let map = prefabNodeDict === null || prefabNodeDict === void 0 ? void 0 : prefabNodeDict.get(prefab);
                if (!map)
                    return null;
                if (Array.isArray(idPath)) {
                    let node;
                    for (let i = startIndex, n = idPath.length; i < n; i++) {
                        if (!map)
                            return null;
                        node = map[idPath[i]];
                        if (!node)
                            break;
                        map = prefabNodeDict.get(node);
                    }
                    return node;
                }
                else
                    return map[idPath];
            }
            let bakedOverrideData;
            function getNodeData(node) {
                let i = allNodes.indexOf(node);
                let nodeData = dataList[i];
                node.removeSelf();
                toDestroy.push(nodeData._$id);
                allNodes[i] = null;
                if (!overrideData)
                    return nodeData;
                if (bakedOverrideData === undefined)
                    bakedOverrideData = SerializeUtil.bakeOverrideData(overrideData);
                if (bakedOverrideData)
                    return SerializeUtil.applyOverrideData(nodeData, bakedOverrideData);
                else
                    return nodeData;
            }
            if (data._$type || data._$prefab) {
                let runtime = data._$runtime;
                if (runtime) {
                    hasRuntime = true;
                    if (runtime.startsWith("res://"))
                        runtime = runtime.substring(6);
                    runtime = ClassUtils.getClass(runtime);
                    if (!runtime)
                        errors.push(new Error(`missing runtime class '${data._$runtime}'`));
                }
                if (options && options.runtime)
                    runtime = options.runtime;
                let node;
                if (runtime) {
                    node = new runtime();
                    if (!(node instanceof Node)) {
                        errors.push(new Error(`runtime class invalid - '${runtime}', must derive from Node`));
                        node = null;
                    }
                    nodeMap[data._$id] = node;
                }
                else
                    node = createNode(data, null);
                if (node) {
                    if (data._$child)
                        createChildren(data, data._$prefab ? node : null);
                    dataList.push(data);
                    allNodes.push(node);
                    if (node instanceof Scene)
                        scene = node;
                }
            }
            else {
                if (data._$child)
                    createChildren(data, null);
            }
            let nodeCnt = dataList.length;
            let k = 0;
            let outNodeData = [];
            for (let i = 0; i < nodeCnt; i++) {
                let nodeData = dataList[i];
                let node = allNodes[i];
                let children = nodeData._$child;
                if (children) {
                    let num = children.length;
                    if (node) {
                        if (nodeData._$prefab) {
                            for (let j = 0; j < num; j++) {
                                let m = k - num + j;
                                let n = outNodes[m];
                                if (n && !n.parent) {
                                    let nodeData2 = outNodeData[m];
                                    let parentNode = findNodeInPrefab(node, nodeData2._$parent);
                                    if (parentNode) {
                                        let pos = nodeData2._$index;
                                        if (pos != null && pos < parentNode.numChildren)
                                            parentNode.addChildAt(n, pos);
                                        else
                                            parentNode.addChild(n);
                                    }
                                    else {
                                        node.addChildAt(n, 0);
                                    }
                                }
                            }
                        }
                        else {
                            for (let j = 0; j < num; j++) {
                                let n = outNodes[k - num + j];
                                if (n) {
                                    if (node === scene && n.is3D)
                                        scene._scene3D = n;
                                    else
                                        node.addChild(n);
                                }
                            }
                        }
                    }
                    k -= num;
                }
                outNodes[k] = node;
                outNodeData[k] = nodeData;
                k++;
            }
            outNodes.length = k;
            outNodes = outNodes.filter(n => n != null);
            let topNode = outNodes[0];
            let compInitList = [];
            for (let i = 0; i < nodeCnt; i++) {
                let components = dataList[i]._$comp;
                if (!components)
                    continue;
                let node = allNodes[i];
                if (!node)
                    continue;
                for (let compData of components) {
                    let comp;
                    let typeOrId = compData._$override;
                    if (compData._$override) {
                        let cls = ClassUtils.getClass(typeOrId);
                        if (cls)
                            comp = node.getComponent(cls);
                        else
                            comp = node.components.find(comp => comp._extra.storeId == typeOrId);
                    }
                    else {
                        let cls = ClassUtils.getClass(compData._$type);
                        if (cls) {
                            if (!compData._$id)
                                comp = node.getComponent(cls);
                            if (!comp) {
                                try {
                                    comp = node.addComponent(cls);
                                    comp._extra.storeId = compData._$id;
                                }
                                catch (err) {
                                    errors.push(err);
                                }
                            }
                        }
                        else
                            errors.push(new Error(`missing component type '${compData._$type}' (in ${dataList[i].name || 'noname'})`));
                    }
                    if (comp)
                        compInitList.push(compData, comp);
                }
            }
            const decoder = new ObjDecoder();
            decoder.errors = errors;
            decoder.getNodeByRef = getNodeByRef;
            decoder.getNodeData = getNodeData;
            for (let i = 0; i < nodeCnt; i++) {
                let nodeData = dataList[i];
                let node = allNodes[i];
                if (node && (node._nodeType === 2 || node === scene))
                    decoder.decodeObjBounds(nodeData, node);
            }
            if (hasUI) {
                if (topNode._nodeType === 2) {
                    topNode.sourceWidth = topNode.width;
                    topNode.sourceHeight = topNode.height;
                }
                for (let i = 0; i < nodeCnt; i++) {
                    let nodeData = dataList[i];
                    let node = allNodes[i];
                    if (node && node._nodeType === 2) {
                        let v = nodeData["relations"];
                        if (v != null) {
                            if (nodeData._$prefab != null)
                                node._addRelations(decoder.decodeObj(v));
                            else
                                node.relations = decoder.decodeObj(v);
                        }
                    }
                }
            }
            for (let i = 0; i < nodeCnt; i++) {
                let nodeData = dataList[i];
                let node = allNodes[i];
                if (node) {
                    if (skinBaseUrl != null && node._nodeType === 0)
                        node._skinBaseUrl = skinBaseUrl;
                    decoder.decodeObj(nodeData, node, (node._nodeType === 2 || node === scene) ? excludeKeys : null);
                    if (hasRuntime && nodeData._$var && node.name) {
                        try {
                            topNode[node.name] = node;
                        }
                        catch (err) {
                            errors.push(err);
                        }
                    }
                }
            }
            let compCnt = compInitList.length;
            for (let i = 0; i < compCnt; i += 2) {
                let compData = compInitList[i];
                let comp = compInitList[i + 1];
                decoder.decodeObj(compData, comp);
            }
            if (hasUI) {
                for (let i = 0; i < nodeCnt; i++) {
                    let nodeData = dataList[i];
                    let node = allNodes[i];
                    if (node && node._nodeType === 2) {
                        let v = nodeData["gears"];
                        if (v != null) {
                            if (nodeData._$prefab != null)
                                node._addGears(decoder.decodeObj(v));
                            else
                                node.gears = decoder.decodeObj(v);
                        }
                    }
                }
                if (topNode._nodeType === 2 && (!prefabNodeDict || !prefabNodeDict.has(topNode))) {
                    try {
                        topNode._onConstruct(inPrefab);
                    }
                    catch (error) {
                        errors.push(error);
                    }
                }
            }
            for (let nodeId of toDestroy) {
                let node = nodeMap[nodeId];
                if (!node._destroyed)
                    node.destroy();
                delete nodeMap[nodeId];
            }
            if (inPrefab && prefabNodeDict && topNode)
                prefabNodeDict.set(topNode, nodeMap);
            if (printErrors && errors.length > 0)
                errors.forEach(err => console.error(err));
            return outNodes;
        }
        static collectResourceLinks(data, basePath) {
            let test = {};
            let innerUrls = [];
            function addInnerUrl(url, type, absolutePath) {
                if (!url)
                    return "";
                let entry = test[url];
                if (entry === undefined) {
                    let url2;
                    if (Utils.isUUID(url))
                        url2 = "res://" + url;
                    else if (absolutePath)
                        url2 = url;
                    else
                        url2 = URL.join(basePath, url);
                    innerUrls.push({ url: url2, type: type });
                    test[url] = entry = [url2, type];
                }
                else if (entry.indexOf(type, 1) == -1) {
                    entry.push(type);
                    innerUrls.push({ url: entry[0], type: type });
                }
                return entry[0];
            }
            let type;
            function checkData(data) {
                if (data._$uuid != null) {
                    data._$uuid = addInnerUrl(data._$uuid, Loader.assetTypeToLoadType[data._$type]);
                    return;
                }
                if (data._$prefab != null)
                    data._$prefab = addInnerUrl(data._$prefab, Loader.HIERARCHY);
                else if ((type = data._$type) != null) {
                    if (type.endsWith(".bp"))
                        addInnerUrl(type, null, true);
                    else if (LayaEnv.isPreview && Utils.isUUID(type)) {
                        let cls = ClassUtils.getClass(type);
                        if (cls == null || cls._$loadable)
                            addInnerUrl("res://" + type, null);
                    }
                }
                check(data);
            }
            function check(data) {
                for (let key in data) {
                    let child = data[key];
                    if (child == null)
                        continue;
                    if (Array.isArray(child)) {
                        for (let item of child) {
                            if (item == null)
                                continue;
                            if (typeof (item) === "object") {
                                checkData(item);
                            }
                            else if (typeof (item) === "string" && item.startsWith("i18n:")) {
                                let i = item.indexOf(":", 5);
                                if (i != -1)
                                    addInnerUrl(AssetDb.inst.getI18nSettingsURL(item.substring(5, i)), null);
                            }
                        }
                    }
                    else if (typeof (child) === "object") {
                        checkData(child);
                    }
                    else if (typeof (child) === "string" && child.startsWith("i18n:")) {
                        let i = child.indexOf(":", 5);
                        if (i != -1)
                            addInnerUrl(AssetDb.inst.getI18nSettingsURL(child.substring(5, i)), null);
                    }
                }
            }
            check(data);
            if (data._$preloads) {
                let types = data._$preloadTypes;
                let pi = 0;
                for (let url of data._$preloads) {
                    if (types && types[pi])
                        addInnerUrl(url, Loader.assetTypeToLoadType[types[pi]]);
                    else
                        innerUrls.push(url);
                    pi++;
                }
            }
            return innerUrls;
        }
    }

    class PrefabImpl extends Prefab {
        constructor(api, data) {
            super();
            this.api = api || PrefabImpl.v3;
            this.data = data;
        }
        create(options, errors) {
            let runtime = ClassUtils.getRuntime(this.url);
            if (runtime) {
                if (!options)
                    options = { runtime };
                else if (!options.runtime)
                    options = Object.assign({ runtime }, options);
            }
            let ret = this.api.parse(this.data, options, errors);
            if (Array.isArray(ret)) {
                if (ret.length == 1) {
                    ret[0].url = this.url;
                }
                return ret[0];
            }
            else {
                ret.url = this.url;
                return ret;
            }
        }
    }
    PrefabImpl.v3 = HierarchyParser;
    PrefabImpl.v2 = null;

    class HierarchyLoader {
        load(task) {
            let url = task.url;
            let fromDCC = task.ext == "gltf" || task.ext == "fbx" || task.ext == "glb" || task.ext == "obj";
            if (fromDCC)
                url = AssetDb.inst.getSubAssetURL(url, task.uuid, "0", "lh");
            return task.loader.fetch(url, "json", task.progress.createCallback(0.2), task.options).then(data => {
                if (!data)
                    return null;
                if (data._$ver != null)
                    return this._load(PrefabImpl.v3, task, data, fromDCC);
                else if (task.ext == "ls" || task.ext == "lh")
                    return this._load(PrefabImpl.v2, task, data, fromDCC);
                else if (task.ext == "scene" || task.ext == "prefab")
                    return this._load(PrefabImpl.legacySceneOrPrefab, task, data, fromDCC);
                else
                    return null;
            });
        }
        _load(api, task, data, fromDCC) {
            let basePath = URL.getPath(task.url);
            let links = api.collectResourceLinks(data, basePath);
            let options = Object.assign({}, task.options);
            options.initiator = task;
            delete options.cache;
            delete options.ignoreCache;
            return task.loader.load(links, options, task.progress.createCallback()).then((resArray) => {
                let res = new PrefabImpl(api, data);
                res.fromDCC = fromDCC;
                res.onLoad();
                res.addDeps(resArray);
                return res;
            });
        }
    }
    Loader.registerLoader(["lh", "ls", "scene", "prefab"], HierarchyLoader, Loader.HIERARCHY);

    class HDRTextureInfo {
        static _parseHDRTexture(data, propertyParams = null, constructParams = null) {
            let hdrInfo = HDRTextureInfo.getHDRInfo(data);
            let texture = new Texture2D(hdrInfo.width, hdrInfo.height, hdrInfo.format, false, false, false);
            texture.setHDRData(hdrInfo);
            if (propertyParams) {
                if (propertyParams.wrapModeU != null)
                    texture.wrapModeU = propertyParams.wrapModeU;
                if (propertyParams.wrapModeV != null)
                    texture.wrapModeV = propertyParams.wrapModeV;
                if (propertyParams.filterMode != null)
                    texture.filterMode = propertyParams.filterMode;
                if (propertyParams.anisoLevel != null)
                    texture.anisoLevel = propertyParams.anisoLevel;
            }
            return texture;
        }
        static getHDRInfo(source) {
            let data = new Uint8Array(source);
            let readByteOffset = 0;
            const readLine = () => {
                let lineStr = HDRTextureInfo.getLineString(data, readByteOffset);
                readByteOffset += lineStr.length + 1;
                return lineStr;
            };
            let identifier = readLine();
            if (identifier != "#?RADIANCE") {
                throw "HDR image: identifier wrong.";
            }
            let commandsMap = new Map();
            let line = "";
            do {
                line = readLine();
                if (line[0] != "#") {
                    let commands = line.split("=");
                    commandsMap.set(commands[0], commands[1]);
                }
            } while (line != "");
            let hdrFormat = commandsMap.get("FORMAT");
            if (hdrFormat != "32-bit_rle_rgbe") {
                throw "HDR image: unsupported format.";
            }
            let resolutionStr = readLine();
            let resolutions = resolutionStr.split(" ");
            let decreaseY = resolutions[0] == "-Y";
            let decreaseX = resolutions[2] == "-X";
            let height = parseInt(resolutions[1]);
            let width = parseInt(resolutions[3]);
            let hdrInfo = new HDRTextureInfo(source, readByteOffset, decreaseX, decreaseY, width, height, exports.TextureFormat.R32G32B32A32);
            return hdrInfo;
        }
        static getLineString(data, readByteOffset) {
            let dataLength = data.length;
            let index = readByteOffset;
            let res = "";
            let char = "";
            while (index < dataLength && char != "\n") {
                res = `${res}${char}`;
                char = String.fromCharCode(data[index]);
                index++;
            }
            return res;
        }
        constructor(source, byteOffset, decreaseX, decreaseY, width, height, format) {
            this.source = source;
            this.byteOffset = byteOffset;
            this.decreaseX = decreaseX;
            this.decreaseY = decreaseY;
            this.width = width;
            this.height = height;
            this.format = format;
        }
        get_32_bit_rle_rgbe() {
            let width = this.width;
            let height = this.height;
            this.decreaseX;
            this.decreaseY;
            let data = new Uint8Array(this.source, this.byteOffset);
            let dataIndex = 0;
            let rgbeBuffer = new ArrayBuffer(width * 4);
            let rgbeArray = new Uint8Array(rgbeBuffer);
            let pixelBuffer = new ArrayBuffer(width * height * 4 * 3);
            let pixelArray = new Float32Array(pixelBuffer);
            for (let y = height; y > 0; y--) {
                data[dataIndex++];
                data[dataIndex++];
                let c = data[dataIndex++];
                let d = data[dataIndex++];
                let scanlineLength = (c << 8) | d;
                if (scanlineLength != width) {
                    throw "HDR info: scanlineLength wrong.";
                }
                let index = 0;
                for (let i = 0; i < 4; i++) {
                    let endIndex = (i + 1) * scanlineLength;
                    while (index < endIndex) {
                        let a = data[dataIndex++];
                        let b = data[dataIndex++];
                        if (a > 128) {
                            let count = a - 128;
                            if (count > endIndex - index) {
                                throw "HDR info: ??";
                            }
                            while (count-- > 0) {
                                rgbeArray[index++] = b;
                            }
                        }
                        else {
                            let count = a;
                            if (count == 0 || count > endIndex - index) {
                                throw "HDR info: ??";
                            }
                            rgbeArray[index++] = b;
                            if (--count > 0) {
                                for (let j = 0; j < count; j++) {
                                    rgbeArray[index++] = data[dataIndex++];
                                }
                            }
                        }
                    }
                }
                for (let i = 0; i < scanlineLength; i++) {
                    let r = rgbeArray[i];
                    let g = rgbeArray[i + scanlineLength];
                    let b = rgbeArray[i + 2 * scanlineLength];
                    let e = rgbeArray[i + 3 * scanlineLength];
                    let index = (height - y) * scanlineLength * 3 + i * 3;
                    const Ldexp = (mantissa, exponent) => {
                        if (exponent > 1023) {
                            return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);
                        }
                        if (exponent < -1074) {
                            return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);
                        }
                        return mantissa * Math.pow(2, exponent);
                    };
                    if (e > 0) {
                        let exponent = Ldexp(1.0, e - (128 + 8));
                        pixelArray[index] = r * exponent;
                        pixelArray[index + 1] = g * exponent;
                        pixelArray[index + 2] = b * exponent;
                    }
                    else {
                        pixelArray[index] = 0;
                        pixelArray[index + 1] = 0;
                        pixelArray[index + 2] = 0;
                    }
                }
            }
            return pixelArray;
        }
        readScanLine() {
            let width = this.width;
            let height = this.height;
            let decreaseX = this.decreaseX;
            let decreaseY = this.decreaseY;
            let n = 3;
            if (this.format == exports.TextureFormat.R32G32B32A32) {
                n = 4;
            }
            let pixelArray = new Float32Array(width * height * n);
            let scanlineArray = new Uint8Array(width * 4);
            let data = new Uint8Array(this.source, this.byteOffset);
            let dataLength = data.length;
            let dataIndex = 0;
            const getc = () => {
                if (dataIndex >= dataLength) {
                    throw "HDR info: data wrong.";
                }
                return data[dataIndex++];
            };
            const wrong = () => {
                throw "HDR info: data wrong.";
            };
            for (let y = (height - 1); y >= 0; y--) {
                this.readcolors(scanlineArray, getc, wrong);
                for (let i = 0; i < width; i++) {
                    let index = 4 * i;
                    let byter = scanlineArray[index];
                    let byteg = scanlineArray[index + 1];
                    let byteb = scanlineArray[index + 2];
                    let bytee = scanlineArray[index + 3];
                    let offsetY = y;
                    let offsetX = i;
                    if (decreaseY) {
                        offsetY = height - 1 - y;
                    }
                    if (decreaseX) {
                        offsetX = width - 1 - i;
                    }
                    let pixelIndex = offsetY * width * n + offsetX * n;
                    if (bytee == 0) {
                        pixelArray[pixelIndex] = 0;
                        pixelArray[pixelIndex + 1] = 0;
                        pixelArray[pixelIndex + 2] = 0;
                        if (n == 4) {
                            pixelArray[pixelIndex + 3] = 1;
                        }
                    }
                    else {
                        let f = ldexp(1.0, bytee - (128 + 8));
                        pixelArray[pixelIndex] = (byter + 0.5) * f;
                        pixelArray[pixelIndex + 1] = (byteg + 0.5) * f;
                        pixelArray[pixelIndex + 2] = (byteb + 0.5) * f;
                        if (n == 4) {
                            pixelArray[pixelIndex + 3] = 1;
                        }
                    }
                }
            }
            return pixelArray;
        }
        readcolors(scanlineArray, getc, wrong) {
            const setScanLineData = (w, channel, value) => {
                scanlineArray[w * 4 + channel] = value;
            };
            let width = this.width;
            let unnormalizedr = getc();
            let unnormalizedg = getc();
            let unnormalizedb = getc();
            let unnormalizede = getc();
            if (width < 8 || width > 32767) {
                this.olddreadcolors(scanlineArray, getc, unnormalizedr, unnormalizedg, unnormalizedb, unnormalizede);
                return;
            }
            if (unnormalizedr != 2 || unnormalizedg != 2 || unnormalizedb & 128) {
                this.olddreadcolors(scanlineArray, getc, unnormalizedr, unnormalizedg, unnormalizedb, unnormalizede);
                return;
            }
            if ((unnormalizedb << 8 | unnormalizede) != width) {
                wrong();
            }
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < width;) {
                    let code = getc();
                    if (code > 128) {
                        code &= 127;
                        let val = getc();
                        if (j + code > width) {
                            wrong();
                        }
                        while (code--) {
                            setScanLineData(j++, i, val);
                        }
                    }
                    else {
                        if (j + code > width) {
                            wrong();
                        }
                        while (code--) {
                            let val = getc();
                            setScanLineData(j++, i, val);
                        }
                    }
                }
            }
        }
        olddreadcolors(scanlineArray, getc, r, g, b, e) {
            let rshift = 0;
            let len = this.width;
            scanlineArray[0] = r;
            scanlineArray[1] = g;
            scanlineArray[2] = b;
            scanlineArray[3] = e;
            for (let w = 1; w < len; w++) {
                let unnormalizedr = getc();
                let unnormalizedg = getc();
                let unnormalizedb = getc();
                let unnormalizede = getc();
                let scanIndex = w * 4;
                scanlineArray[scanIndex] = unnormalizedr;
                scanlineArray[scanIndex + 1] = unnormalizedg;
                scanlineArray[scanIndex + 2] = unnormalizedb;
                scanlineArray[scanIndex + 3] = unnormalizede;
                if (unnormalizedr == 1 && unnormalizedg == 1 && unnormalizedb == 1) {
                    let lastIndex = scanIndex - 4;
                    for (let i = unnormalizede << rshift; i > 0; i--) {
                        scanlineArray[scanIndex] = scanlineArray[lastIndex];
                        scanlineArray[scanIndex + 1] = scanlineArray[lastIndex + 1];
                        scanlineArray[scanIndex + 2] = scanlineArray[lastIndex + 2];
                        scanlineArray[scanIndex + 3] = scanlineArray[lastIndex + 3];
                    }
                    rshift += 8;
                }
                else {
                    rshift = 0;
                }
            }
        }
        color_color(col, clr) {
            let f = 0;
            if (clr.w == 0) {
                col.x = col.y = col.z = 0;
            }
            else {
                f = ldexp(1.0, clr.w - (128 + 8));
                col.x = (clr.x) * f;
                col.y = (clr.y) * f;
                col.z = (clr.z) * f;
            }
        }
    }
    HDRTextureInfo.HDRTEXTURE = "HDRTEXTURE";
    function ldexp(value, exponent) {
        return value * Math.pow(2, exponent);
    }

    class VideoTexture extends BaseTexture {
        static createInstance() {
            return PAL.media.createVideoTexture();
        }
        constructor() {
            super(1, 1, exports.RenderTargetFormat.R8G8B8);
            this.allowBackground = false;
            this._playing = false;
            this._loaded = false;
            this._frameRender = true;
            this._interval = 0;
            this._lastTimer = 0;
            this._frameRate = 0;
            this._useMediaFrameRate = true;
            this._loop = false;
            this._autoResume = false;
            this._dimension = exports.TextureDimension.Tex2D;
        }
        get frameRate() {
            return this._frameRate;
        }
        set frameRate(value) {
            if (value < 0.001)
                this._interval = 0;
            else
                this._interval = 1000 / value;
            this._frameRate = value;
        }
        get useMediaFrameRate() {
            return this._useMediaFrameRate;
        }
        set useMediaFrameRate(value) {
            this._useMediaFrameRate = value;
        }
        get frameRender() {
            return this._frameRender;
        }
        set frameRender(value) {
            if (this._loaded) {
                if (this._frameRender && !value)
                    ILaya.timer.clear(this, this.render);
                if (!this._frameRender && value && this._playing)
                    ILaya.timer.frameLoop(1, this, this.render);
            }
            this._frameRender = value;
        }
        get source() {
            return this._source;
        }
        set source(url) {
            this.load(url);
        }
        get currentTime() {
            return 0;
        }
        set currentTime(value) {
        }
        get volume() {
            return 0;
        }
        set volume(value) {
        }
        get muted() {
            return false;
        }
        set muted(value) {
        }
        get readyState() {
            return 0;
        }
        get videoWidth() {
            return this._width;
        }
        get videoHeight() {
            return this._height;
        }
        get duration() {
            return 0;
        }
        get ended() {
            return false;
        }
        get loop() {
            return this._loop;
        }
        set loop(value) {
            this._loop = value;
        }
        get playbackRate() {
            return 1;
        }
        set playbackRate(value) {
        }
        get paused() {
            return false;
        }
        canPlayType(type) {
            return PAL.media.canPlayType(type);
        }
        setLoaded(width, height, rgba) {
            this._width = width;
            this._height = height;
            this._loaded = true;
            this._texture = LayaGL.textureContext.createTextureInternal(this._dimension, width, height, rgba ? exports.TextureFormat.R8G8B8A8 : exports.TextureFormat.R8G8B8, false, false, false);
            this.wrapModeU = exports.WrapMode.Clamp;
            this.wrapModeV = exports.WrapMode.Clamp;
            this.filterMode = exports.FilterMode.Bilinear;
            LayaGL.textureContext.initVideoTextureData(this._texture);
            this._texture.gammaCorrection = 2.2;
            if (this._frameRender && this._playing)
                ILaya.timer.frameLoop(1, this, this.render);
            if (this._playing)
                this.onPlay();
            this.event(Event.READY, this);
        }
        render(force) {
            if (!this._loaded)
                return;
            if (!this._useMediaFrameRate && !force) {
                let now = performance.now();
                if (now - this._lastTimer < this._interval)
                    return;
                this._lastTimer = now;
            }
            if (this.onRender())
                this.event("videoUpdate");
        }
        load(url) {
            this._source = url;
            if (url) {
                if (this._texture) {
                    this._texture.dispose();
                    this._texture = null;
                }
                AssetDb.inst.resolveURL(url, url2 => {
                    if (this._source === url)
                        this.onLoad(url2);
                });
            }
            else
                this.pause();
        }
        play() {
            if (this._playing || !LayaEnv.isPlaying)
                return;
            this._playing = true;
            ILaya.stage.on(Event.BLUR, this, this.onBlur);
            if (this._loaded) {
                if (this._frameRender)
                    ILaya.timer.frameLoop(1, this, this.render);
                this.onPlay();
            }
        }
        pause() {
            this._autoResume = false;
            if (!this._playing)
                return;
            this._playing = false;
            ILaya.stage.off(Event.BLUR, this, this.onBlur);
            ILaya.timer.clear(this, this.render);
            if (this._loaded)
                this.onPause();
        }
        resume() {
            this.play();
        }
        get gammaCorrection() {
            return 2.2;
        }
        _getSource() {
            return this._texture ? this._texture.resource : Texture2D.blackTexture._getSource();
        }
        get defaultTexture() {
            return Texture2D.blackTexture;
        }
        destroy() {
            this._playing = false;
            ILaya.timer.clear(this, this.render);
            ILaya.stage.off(Event.BLUR, this, this.onBlur);
            this.onDestroy();
            super.destroy();
        }
        onBlur() {
            if (!this.allowBackground)
                PAL.media.resumeUntilGotFocus(this);
        }
        onLoad(url) {
        }
        onRender() {
            return false;
        }
        onPlay() {
        }
        onPause() {
        }
        onDestroy() {
        }
        get currentSrc() {
            return this._source;
        }
        get updateFrame() {
            return this.frameRate;
        }
        set updateFrame(value) {
            this.frameRate = value;
        }
        get useFrame() {
            return this.useMediaFrameRate;
        }
        set useFrame(value) {
            this.useMediaFrameRate = value;
        }
    }

    var internalResources;
    class Texture2DLoader {
        constructor() {
            if (!internalResources) {
                internalResources = {
                    "WhiteTexture.png": Texture2D.whiteTexture,
                    "BlackTexture.png": Texture2D.blackTexture,
                    "GrayTexture.png": Texture2D.grayTexture,
                    "NormalTexture.png": Texture2D.normalTexture,
                };
            }
        }
        load(task) {
            if (task.url.indexOf("internal/") != -1) {
                let tex = internalResources[Utils.getBaseName(task.url)];
                if (tex)
                    return Promise.resolve(tex);
            }
            let meta;
            if (!task.url.startsWith("data:")) {
                meta = AssetDb.inst.metaMap[task.url];
                if (!meta && LayaEnv.isPreview) {
                    return AssetDb.inst.getMeta(task.url, task.uuid).then(meta => {
                        return this.load2(task, meta);
                    });
                }
            }
            return this.load2(task, meta);
        }
        load2(task, meta) {
            let constructParams;
            let propertyParams;
            let ext = task.ext;
            let url = task.url;
            if (meta) {
                const RGBA = { format: exports.TextureFormat.R8G8B8A8, file: null, ext: null };
                let fileInfo = RGBA;
                if (meta.platforms && meta.files) {
                    if (Browser.platform in meta.platforms) {
                        const fileIndex = meta.platforms[Browser.platform];
                        fileInfo = meta.files[fileIndex];
                    }
                    let capable = getCompressTextureRenderCapable(fileInfo.format);
                    if (capable && !LayaGL.renderEngine.getCapable(capable)) {
                        const fallback = meta.files.find(f => {
                            const c = getCompressTextureRenderCapable(f.format);
                            return LayaGL.renderEngine.getCapable(c);
                        });
                        fileInfo = fallback || RGBA;
                    }
                }
                if (fileInfo.file) {
                    url = AssetDb.inst.getSubAssetURL(url, task.uuid, fileInfo.file, fileInfo.ext);
                    ext = fileInfo.ext;
                }
                constructParams = [0, 0, fileInfo.format, meta.mipmap, meta.readWrite, meta.sRGB];
                propertyParams = {
                    wrapModeU: meta.wrapMode,
                    wrapModeV: meta.wrapMode,
                    filterMode: meta.filterMode,
                    anisoLevel: meta.anisoLevel,
                    premultiplyAlpha: !!meta.pma,
                    hdrEncodeFormat: meta.hdrEncodeFormat,
                };
            }
            else {
                constructParams = task.options.constructParams;
                propertyParams = task.options.propertyParams;
            }
            let compress = compressedFormats.indexOf(ext) != -1 ? ext : null;
            if (compress != null) {
                return task.loader.fetch(url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                    if (!data)
                        return null;
                    let tex;
                    switch (compress) {
                        case "dds":
                            let ddsInfo = DDSTextureInfo.getDDSTextureInfo(data);
                            if (ddsInfo.isCube) {
                                let cls = ClassUtils.getClass("TextureCube");
                                if (cls) {
                                    let srgb = constructParams ? !!constructParams[5] : false;
                                    let tc = new cls(ddsInfo.width, ddsInfo.format, ddsInfo.mipmapCount > 1, srgb);
                                    tc.setDDSData(ddsInfo);
                                    tex = tc;
                                }
                                else {
                                    return null;
                                }
                            }
                            else {
                                tex = Texture2D._parseDDS(data, propertyParams, constructParams);
                            }
                            break;
                        case "ktx":
                            let ktxInfo = KTXTextureInfo.getKTXTextureInfo(data);
                            if (ktxInfo.dimension == exports.TextureDimension.Cube) {
                                let cls = ClassUtils.getClass("TextureCube");
                                if (cls) {
                                    let tc = new cls(ktxInfo.width, ktxInfo.format, ktxInfo.mipmapCount > 1, ktxInfo.sRGB);
                                    tc.setKTXData(ktxInfo);
                                    tex = tc;
                                }
                                else
                                    return null;
                            }
                            else if (ktxInfo.dimension == exports.TextureDimension.Tex2D) {
                                tex = Texture2D._parseKTX(data, propertyParams, constructParams);
                            }
                            break;
                        case "pvr":
                            tex = Texture2D._parsePVR(data, propertyParams, constructParams);
                            break;
                        case "hdr":
                            tex = HDRTextureInfo._parseHDRTexture(data, propertyParams, constructParams);
                            break;
                        case "lanit.ls":
                            tex = Texture2D._SimpleAnimatorTextureParse(data, propertyParams, constructParams);
                            break;
                    }
                    let obsoluteInst = task.obsoluteInst;
                    if (obsoluteInst && Object.getPrototypeOf(obsoluteInst) == Object.getPrototypeOf(tex))
                        tex = this.move(obsoluteInst, tex);
                    if (propertyParams && propertyParams.hdrEncodeFormat)
                        tex.hdrEncodeFormat = propertyParams.hdrEncodeFormat;
                    if (meta) {
                        tex._sizeGrid = meta.sizeGrid;
                        tex._stateNum = meta.stateNum;
                    }
                    return tex;
                });
            }
            else {
                let options = task.options;
                let premultiplyAlpha = (propertyParams && propertyParams.premultiplyAlpha) ? "premultiply" : "none";
                if (options.useWorkerLoader && premultiplyAlpha === "none")
                    options = Object.assign({ workerLoaderOptions: { premultiplyAlpha } }, options);
                return task.loader.fetch(url, "image", task.progress.createCallback(), options).then(img => {
                    if (LayaGL.textureContext.needBitmap) {
                        if (img instanceof ImageBitmap)
                            return img;
                        else
                            return createImageBitmap(img, options.workerLoaderOptions || { premultiplyAlpha });
                    }
                    else {
                        return img;
                    }
                }).then(bitmapimage => {
                    if (!bitmapimage)
                        return null;
                    let tex = Texture2D._parseImage(bitmapimage, propertyParams, constructParams);
                    let obsoluteInst = task.obsoluteInst;
                    if (obsoluteInst && Object.getPrototypeOf(obsoluteInst) == Object.getPrototypeOf(tex))
                        tex = this.move(obsoluteInst, tex);
                    if (meta) {
                        tex._sizeGrid = meta.sizeGrid;
                        tex._stateNum = meta.stateNum;
                    }
                    return tex;
                });
            }
        }
        move(obsoluteInst, tex) {
            obsoluteInst._texture = tex._texture;
            obsoluteInst._format = tex.format;
            obsoluteInst.width = tex.width;
            obsoluteInst.height = tex.height;
            obsoluteInst.obsolute = false;
            delete Resource._idResourcesMap[tex.id];
            return obsoluteInst;
        }
    }
    class RenderTextureLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                if (data.width == null)
                    data.width = 256;
                if (data.height == null)
                    data.height = 256;
                if (data.colorFormat == null)
                    data.colorFormat = exports.RenderTargetFormat.R8G8B8A8;
                if (data.depthFormat == null)
                    data.depthFormat = exports.RenderTargetFormat.DEPTHSTENCIL_24_8;
                if (data.multiSamples == null)
                    data.multiSamples = 1;
                let rt = task.obsoluteInst;
                if (rt)
                    rt.recreate(data.width, data.height, data.colorFormat, data.depthFormat, !!data.generateMipmap, data.multiSamples, !!data.generateDepthTexture, !!data.sRGB, !!data.storage);
                else
                    rt = new RenderTexture(data.width, data.height, data.colorFormat, data.depthFormat, !!data.generateMipmap, data.multiSamples, !!data.generateDepthTexture, !!data.sRGB, !!data.storage);
                if (null != data.anisoLevel)
                    rt.anisoLevel = data.anisoLevel;
                if (null != data.filterMode)
                    rt.filterMode = data.filterMode;
                if (null != data.wrapModeU)
                    rt.wrapModeU = data.wrapModeU;
                if (null != data.wrapModeV)
                    rt.wrapModeV = data.wrapModeV;
                return rt;
            });
        }
    }
    class VideoTextureLoader {
        load(task) {
            let inst = task.obsoluteInst || VideoTexture.createInstance();
            inst.source = task.url;
            return Promise.resolve(inst);
        }
    }
    const propertyParams2d = { premultiplyAlpha: true };
    const constructParams2d = [null, null, exports.TextureFormat.R8G8B8A8, false, false, true];
    class TextureLoader {
        wrapTex2D(task, tex2D) {
            if (!tex2D)
                return null;
            let tex = task.obsoluteInst;
            if (tex) {
                tex.setTo(tex2D);
                tex.obsolute = false;
                tex._sizeGrid = tex2D._sizeGrid;
                tex._stateNum = tex2D._stateNum;
                tex.event("reload");
                if (tex._clipCache) {
                    tex._clipCache.forEach(t => {
                        t.event("reload");
                        t._sizeGrid = tex._sizeGrid;
                        t._stateNum = tex._stateNum;
                    });
                }
            }
            else {
                tex = new Texture(tex2D);
                tex._sizeGrid = tex2D._sizeGrid;
                tex._stateNum = tex2D._stateNum;
            }
            return tex;
        }
        load(task) {
            let tex2D = task.loader.getRes(task.url, Loader.TEXTURE2D);
            if (!tex2D || tex2D.obsolute) {
                let url = { url: task.url, type: Loader.TEXTURE2D };
                if (!task.options.propertyParams)
                    url.propertyParams = propertyParams2d;
                else if (task.options.propertyParams.premultiplyAlpha == null)
                    url.propertyParams = Object.assign({}, propertyParams2d, task.options.propertyParams);
                if (!task.options.constructParams)
                    url.constructParams = constructParams2d;
                else if (task.options.constructParams[5] == null)
                    url.constructParams = Object.assign([], constructParams2d, task.options.constructParams);
                return task.loader.load(url, task.options, task.progress.createCallback()).then(tex2D => {
                    return this.wrapTex2D(task, tex2D);
                });
            }
            else
                return Promise.resolve(this.wrapTex2D(task, tex2D));
        }
    }
    const compressedFormats = ["ktx", "pvr", "dds", "hdr", "exr", "lanit.ls"];
    const videoFormats = ["mp4", "webm"];
    Loader.registerLoader(["tga", "tif", "tiff", "png", "jpg", "jpeg", "webp", "rendertexture", ...videoFormats, ...compressedFormats], TextureLoader, Loader.IMAGE, true);
    Loader.registerLoader([], Texture2DLoader, Loader.TEXTURE2D, true);
    Loader.registerLoader(["rendertexture"], RenderTextureLoader, Loader.TEXTURE2D, true);
    Loader.registerLoader(videoFormats, VideoTextureLoader, Loader.TEXTURE2D);

    class AnimationClip2DLoader {
        load(task) {
            return task.loader.fetch(task.url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return AnimationClip2D._parse(data);
            });
        }
    }
    Loader.registerLoader(["mc"], AnimationClip2DLoader);

    class AnimationController2DLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(0.2), task.options).then(data => {
                let ret = new AnimatorController2D(data);
                if (ret.data && ret.data.controllerLayers) {
                    let layers = ret.data.controllerLayers;
                    let promises = [];
                    for (let i = layers.length - 1; i >= 0; i--) {
                        let states = layers[i].states;
                        this.loadStates(states, promises, task);
                    }
                    return Promise.all(promises).then(deps => {
                        ret.addDeps(deps);
                        return ret;
                    });
                }
                else
                    return ret;
            });
        }
        loadStates(states, promises, task) {
            let basePath = URL.getPath(task.url);
            for (let j = states.length - 1; j >= 0; j--) {
                if (states[j].clip && states[j].clip._$uuid) {
                    let url = URL.getResURLByUUID(states[j].clip._$uuid);
                    if (!url.startsWith("res://"))
                        url = URL.join(basePath, url);
                    promises.push(task.loader.load(url).then(res => {
                        states[j].clip = res;
                        return res;
                    }));
                }
                if (states[j].states) {
                    this.loadStates(states[j].states, promises, task);
                }
            }
        }
    }
    Loader.registerLoader(["mcc"], AnimationController2DLoader);

    class NullLoader {
        load(task) {
            return Promise.resolve(null);
        }
    }
    Loader.registerLoader(["lighting"], NullLoader);

    class BitmapFontLoader {
        load(task) {
            let picUrl = Utils.replaceFileExtension(task.url, "png");
            return Promise.all([
                task.loader.fetch(task.url, "xml", task.progress.createCallback(0.2), task.options),
                task.loader.load(picUrl, task.options, task.progress.createCallback(0.8))
            ]).then(([xml, tex]) => {
                if (!xml || !tex)
                    return null;
                let font = new BitmapFont();
                font.parseFont(xml, tex);
                return font;
            });
        }
    }
    Loader.registerLoader(["fnt"], BitmapFontLoader, Loader.FONT);

    class TTFFontLoader {
        load(task) {
            return PAL.font.loadFont(task);
        }
    }
    Loader.registerLoader(["ttf", "woff", "woff2", "otf"], TTFFontLoader, Loader.TTF);

    class MaterialParser {
        static parse(data) {
            let props = data.props;
            switch (data.version) {
                case "LAYAMATERIAL:01":
                case "LAYAMATERIAL:02":
                case "LAYAMATERIAL:03":
                    let mat = MaterialParser.parseLegacy(data);
                    mat.oldparseEndEvent();
                    return mat;
                case "LAYAMATERIAL:04":
                    break;
                default:
                    throw new Error(`unkonwn material version: ${data.version}`);
            }
            let mat = new Material();
            mat.setShaderName(props.type);
            let renderQueue;
            for (let key in props) {
                switch (key) {
                    case "type":
                    case "name":
                        break;
                    case "defines":
                        let defineNames = props[key];
                        for (let i = 0, n = defineNames.length; i < n; i++) {
                            let define = Shader3D.getDefineByName(defineNames[i]);
                            mat._shaderValues.addDefine(define);
                        }
                        break;
                    case "textures":
                        let textures = props[key];
                        for (let i = 0, n = textures.length; i < n; i++) {
                            let texture = textures[i];
                            let path = texture.path;
                            (path) && (mat._shaderValues.setTexture(Shader3D.propertyNameToID(texture.name), Loader.getBaseTexture(path)));
                        }
                        break;
                    case "renderQueue":
                        renderQueue = props[key];
                        break;
                    case "alphaTest":
                        mat.alphaTest = props[key];
                        break;
                    case "materialRenderMode":
                        mat.materialRenderMode = props[key];
                        break;
                    default:
                        let property = props[key];
                        let uniName = Shader3D.propertyNameToID(key);
                        switch (uniName) {
                            case Shader3D.CULL:
                                mat.cull = property;
                                break;
                            case Shader3D.BLEND:
                                mat.blend = property;
                                break;
                            case Shader3D.BLEND_SRC:
                                mat.blendSrc = property;
                                break;
                            case Shader3D.BLEND_DST:
                                mat.blendDst = property;
                                break;
                            case Shader3D.BLEND_DST_ALPHA:
                                mat.blendDstAlpha = property;
                                break;
                            case Shader3D.BLEND_SRC_ALPHA:
                                mat.blendSrcAlpha = property;
                                break;
                            case Shader3D.BLEND_SRC_RGB:
                                mat.blendSrcRGB = property;
                                break;
                            case Shader3D.BLEND_DST_RGB:
                                mat.blendDstRGB = property;
                                break;
                            case Shader3D.DEPTH_TEST:
                                mat.depthTest = property;
                                break;
                            case Shader3D.DEPTH_WRITE:
                                mat.depthWrite = !!props[key];
                                break;
                            case Shader3D.STENCIL_TEST:
                                mat.stencilTest = property;
                                break;
                            case Shader3D.STENCIL_Op:
                                mat.stencilOp = property;
                                break;
                            case Shader3D.STENCIL_Ref:
                                mat.stencilRef = property;
                                break;
                            case Shader3D.STENCIL_WRITE:
                                mat.stencilWrite = property;
                                break;
                            case Shader3D.BLEND_EQUATION:
                                mat.blendEquation = property;
                                break;
                            case Shader3D.BLEND_EQUATION_RGB:
                                mat.blendEquationRGB = property;
                                break;
                            case Shader3D.BLEND_EQUATION_ALPHA:
                                mat.blendEquationAlpha = property;
                                break;
                            default:
                                if (!property.length) {
                                    if (typeof property == 'boolean')
                                        mat._shaderValues.setBool(uniName, props[key]);
                                    else {
                                        mat._shaderValues.setNumber(uniName, props[key]);
                                    }
                                }
                                else {
                                    var vectorValue = property;
                                    switch (vectorValue.length) {
                                        case 2:
                                            mat._shaderValues.setVector2(uniName, new Vector2(vectorValue[0], vectorValue[1]));
                                            break;
                                        case 3:
                                            mat._shaderValues.setVector3(uniName, new Vector3(vectorValue[0], vectorValue[1], vectorValue[2]));
                                            break;
                                        case 4:
                                            if (mat._shaderValues.getColor(uniName)) {
                                                mat._shaderValues.setColor(uniName, new Color(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]));
                                            }
                                            else
                                                mat._shaderValues.setVector(uniName, new Vector4(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]));
                                            break;
                                        case 9:
                                            let matrix3 = new Matrix3x3();
                                            matrix3.elements = new Float32Array(vectorValue);
                                            mat._shaderValues.setMatrix3x3(uniName, matrix3);
                                            break;
                                        case 16:
                                            let matrix4 = new Matrix4x4();
                                            matrix4.elements = new Float32Array(vectorValue);
                                            mat._shaderValues.setMatrix4x4(uniName, matrix4);
                                            break;
                                        default:
                                            mat._shaderValues.setBuffer(uniName, vectorValue);
                                    }
                                }
                                break;
                        }
                }
            }
            if (null != renderQueue) {
                mat.renderQueue = renderQueue;
            }
            return mat;
        }
        static collectLinks(data, basePath) {
            var _a;
            let urls = [];
            let textures = (_a = data.props) === null || _a === void 0 ? void 0 : _a.textures;
            if (textures) {
                for (let i = 0, n = textures.length; i < n; i++) {
                    let tex2D = textures[i];
                    let tex2DPath = tex2D.path;
                    if (tex2DPath) {
                        tex2D.path = URL.join(basePath, tex2DPath);
                        urls.push({ url: tex2D.path, type: Loader.TEXTURE2D, constructParams: tex2D.constructParams, propertyParams: tex2D.propertyParams });
                    }
                }
            }
            return urls;
        }
        static parseLegacy(data) {
            let jsonData = data;
            let props = jsonData.props;
            let mat;
            let classType = props.type;
            let clas = ClassUtils.getClass(classType);
            if (!clas && classType && classType.startsWith("Laya."))
                clas = ClassUtils.getClass(classType.substring(5));
            if (clas)
                mat = new clas();
            else {
                mat = new Material();
                mat.setShaderName(classType);
            }
            switch (jsonData.version) {
                case "LAYAMATERIAL:01":
                case "LAYAMATERIAL:02":
                    for (let key in props) {
                        switch (key) {
                            case "type":
                                break;
                            case "vectors":
                                let vectors = props[key];
                                for (let i = 0, n = vectors.length; i < n; i++) {
                                    let vector = vectors[i];
                                    let vectorValue = vector.value;
                                    switch (vectorValue.length) {
                                        case 2:
                                            mat[vector.name] = new Vector2(vectorValue[0], vectorValue[1]);
                                            break;
                                        case 3:
                                            if (mat[vector.name] instanceof Color) {
                                                mat[vector.name] = new Color(vectorValue[0], vectorValue[1], vectorValue[2], 1.0);
                                            }
                                            else
                                                mat[vector.name] = new Vector3(vectorValue[0], vectorValue[1], vectorValue[2]);
                                            break;
                                        case 4:
                                            if (mat[vector.name] instanceof Color) {
                                                mat[vector.name] = new Color(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]);
                                            }
                                            else
                                                mat[vector.name] = new Vector4(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]);
                                            break;
                                        default:
                                            throw new Error("unknown material color length: " + vectorValue.length);
                                    }
                                }
                                break;
                            case "colors":
                                let colors = props[key];
                                for (let i = 0, n = colors.length; i < n; i++) {
                                    let color = colors[i];
                                    let vectorValue = color.value;
                                    mat[color.name] = new Color(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]);
                                }
                                break;
                            case "textures":
                                let textures = props[key];
                                for (let i = 0, n = textures.length; i < n; i++) {
                                    let texture = textures[i];
                                    let path = texture.path;
                                    (path) && (mat[texture.name] = Loader.getBaseTexture(path));
                                }
                                break;
                            case "defines":
                                let defineNames = props[key];
                                for (let i = 0, n = defineNames.length; i < n; i++) {
                                    let define = Shader3D.getDefineByName(defineNames[i]);
                                    mat._shaderValues.addDefine(define);
                                }
                                break;
                            case "renderStates":
                                let renderStatesData = props[key];
                                let renderStateData = renderStatesData[0];
                                mat.blend = renderStateData.blend;
                                mat.cull = this._getRenderStateParams(renderStateData.cull);
                                mat.depthTest = this._getRenderStateParams(renderStateData.depthTest);
                                mat.depthWrite = renderStateData.depthWrite;
                                mat.blendSrc = this._getRenderStateParams(renderStateData.srcBlend);
                                mat.blendDst = this._getRenderStateParams(renderStateData.dstBlend);
                                break;
                            case "cull":
                                mat.cull = this._getRenderStateParams(props[key]);
                                break;
                            case "blend":
                                mat.blend = this._getRenderStateParams(props[key]);
                                break;
                            case "depthWrite":
                                mat.depthWrite = !!props[key];
                                break;
                            case "srcBlend":
                                mat.blendSrc = this._getRenderStateParams(props[key]);
                                break;
                            case "dstBlend":
                                mat.blendDst = this._getRenderStateParams(props[key]);
                                break;
                            case "depthTest":
                                mat.depthTest = this._getRenderStateParams(props[key]);
                                break;
                            case "blendDst":
                                mat.blendDst = this._getRenderStateParams(props[key]);
                                break;
                            case "blendSrc":
                                mat.blendSrc = this._getRenderStateParams(props[key]);
                                break;
                            default:
                                mat[key] = props[key];
                        }
                    }
                    break;
                case "LAYAMATERIAL:03":
                    for (let key in props) {
                        switch (key) {
                            case "type":
                            case "name":
                                break;
                            case "defines":
                                let defineNames = props[key];
                                for (let i = 0, n = defineNames.length; i < n; i++) {
                                    let define = Shader3D.getDefineByName(defineNames[i]);
                                    mat._shaderValues.addDefine(define);
                                }
                                break;
                            case "textures":
                                let textures = props[key];
                                for (let i = 0, n = textures.length; i < n; i++) {
                                    let texture = textures[i];
                                    let path = texture.path;
                                    (path) && (mat._shaderValues.setTexture(Shader3D.propertyNameToID(texture.name), Loader.getBaseTexture(path)));
                                }
                                break;
                            case "renderQueue":
                                mat.renderQueue = props[key];
                                break;
                            default:
                                let property = props[key];
                                let uniName = Shader3D.propertyNameToID(key);
                                switch (uniName) {
                                    case Shader3D.CULL:
                                        mat.cull = this._getRenderStateParams(property);
                                        break;
                                    case Shader3D.BLEND:
                                        mat.blend = this._getRenderStateParams(property);
                                        break;
                                    case Shader3D.BLEND_SRC:
                                        mat.blendSrc = this._getRenderStateParams(property);
                                        break;
                                    case Shader3D.BLEND_DST:
                                        mat.blendDst = this._getRenderStateParams(property);
                                        break;
                                    case Shader3D.DEPTH_TEST:
                                        mat.depthTest = this._getRenderStateParams(property);
                                        break;
                                    case Shader3D.DEPTH_WRITE:
                                        mat.depthWrite = !!props[key];
                                        break;
                                    case Shader3D.BLEND_EQUATION:
                                        mat.blendEquation = props[key];
                                        break;
                                    case Shader3D.BLEND_EQUATION_ALPHA:
                                        mat.blendEquationAlpha = props[key];
                                        break;
                                    case Shader3D.BLEND_EQUATION_RGB:
                                        mat.blendEquationRGB = props[key];
                                        break;
                                    default:
                                        if (!property.length) {
                                            if (typeof property == 'boolean')
                                                mat._shaderValues.setBool(uniName, props[key]);
                                            else {
                                                mat._shaderValues.setNumber(uniName, props[key]);
                                            }
                                        }
                                        else {
                                            var vectorValue = property;
                                            switch (vectorValue.length) {
                                                case 2:
                                                    mat._shaderValues.setVector2(uniName, new Vector2(vectorValue[0], vectorValue[1]));
                                                    break;
                                                case 3:
                                                    mat._shaderValues.setVector3(uniName, new Vector3(vectorValue[0], vectorValue[1], vectorValue[2]));
                                                    break;
                                                case 4:
                                                    if (mat._shaderValues.getColor(uniName)) {
                                                        mat._shaderValues.setColor(uniName, new Color(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]));
                                                    }
                                                    else
                                                        mat._shaderValues.setVector(uniName, new Vector4(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]));
                                                    break;
                                                default:
                                                    throw new Error("unknown material color length: " + vectorValue.length);
                                            }
                                        }
                                        break;
                                }
                        }
                    }
                    break;
                default:
                    throw new Error("unknown material version: " + jsonData.version);
            }
            return mat;
        }
        static _getRenderStateParams(type) {
            switch (type) {
                case 0x0300:
                    return exports.BlendFactor.SourceColor;
                case 0x0301:
                    return exports.BlendFactor.OneMinusSourceColor;
                case 0x0306:
                    return exports.BlendFactor.DestinationColor;
                case 0x0307:
                    return exports.BlendFactor.OneMinusDestinationColor;
                case 0x0302:
                    return exports.BlendFactor.SourceAlpha;
                case 0x0303:
                    return exports.BlendFactor.OneMinusSourceAlpha;
                case 0x0304:
                    return exports.BlendFactor.DestinationAlpha;
                case 0x0305:
                    return exports.BlendFactor.OneMinusDestinationAlpha;
                case 0x0308:
                    return exports.BlendFactor.SourceAlphaSaturate;
                case 0x8006:
                    return exports.BlendEquationSeparate.ADD;
                case 0x800A:
                    return exports.BlendEquationSeparate.SUBTRACT;
                case 0x800B:
                    return exports.BlendEquationSeparate.REVERSE_SUBTRACT;
                case 0x0200:
                    return exports.CompareFunction.Never;
                case 0x0201:
                    return exports.CompareFunction.Less;
                case 0x0202:
                    return exports.CompareFunction.Equal;
                case 0x0203:
                    return exports.CompareFunction.LessEqual;
                case 0x0204:
                    return exports.CompareFunction.Greater;
                case 0x0205:
                    return exports.CompareFunction.NotEqual;
                case 0x0206:
                    return exports.CompareFunction.GreaterEqual;
                case 0x0207:
                    return exports.CompareFunction.Always;
                default:
                    return type;
            }
        }
    }

    class MaterialLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(0.3), task.options).then(data => {
                if (!data)
                    return null;
                let basePath = URL.getPath(task.url);
                let urls = MaterialParser.collectLinks(data, basePath);
                if (data.version === "LAYAMATERIAL:04") {
                    let shaderName = data.props.type;
                    if (!Shader3D.find(shaderName)) {
                        let url = AssetDb.inst.shaderName_to_URL(shaderName);
                        if (url)
                            urls.push(url);
                        else {
                            return AssetDb.inst.shaderName_to_URL_async(shaderName).then(url => {
                                if (url)
                                    urls.push(url);
                                else if (data.props.shaderPath)
                                    urls.push(URL.join(basePath, data.props.shaderPath));
                                else
                                    Loader.warn(`unknown shaderName: ${shaderName}`);
                                return this.load2(task, data, urls);
                            });
                        }
                    }
                }
                return this.load2(task, data, urls);
            });
        }
        load2(task, data, urls) {
            if (urls.length == 0) {
                let mat = MaterialParser.parse(data);
                let obsoluteInst = task.obsoluteInst;
                if (obsoluteInst)
                    mat = this.move(obsoluteInst, mat);
                return Promise.resolve(mat);
            }
            let options = Object.assign({}, task.options);
            options.initiator = task;
            delete options.cache;
            delete options.ignoreCache;
            return task.loader.load(urls, options, task.progress.createCallback()).then(() => {
                let mat = MaterialParser.parse(data);
                let obsoluteInst = task.obsoluteInst;
                if (task.obsoluteInst)
                    mat = this.move(obsoluteInst, mat);
                return mat;
            });
        }
        move(obsoluteInst, mat) {
            obsoluteInst._shaderValues.clearData();
            obsoluteInst.setShaderName(mat._shader.name);
            mat._shaderValues.cloneTo(obsoluteInst._shaderValues);
            obsoluteInst.materialRenderMode = mat.materialRenderMode;
            obsoluteInst.renderQueue = mat.renderQueue;
            obsoluteInst.obsolute = false;
            mat.destroy();
            return obsoluteInst;
        }
    }
    Loader.registerLoader(["lmat"], MaterialLoader, Loader.MATERIAL, true);

    class ParseJSON {
        static parse(str) {
            return this.parseStart(str);
        }
        static findIndex(str, i, fstr, len) {
            var fi = str.indexOf(fstr, i + 1);
            if (0 > fi) {
                fi = len;
            }
            return { str: str.substring(i + 1, fi), i: fi };
        }
        static finCurrObj() {
            this.type = 1;
            if (null == this.cobj) {
                return null;
            }
            if (0 == this.currArr.length) {
                if (this.cobj.k) {
                    this.ret[this.cobj.k] = this.cobj.val;
                }
                return null;
            }
            else {
                var pobj = this.currArr.pop();
                if (this.cobj.k) {
                    if (Array.isArray(pobj.val)) {
                        if (null != this.cobj.k) {
                            var obj = {};
                            obj[this.cobj.k] = this.cobj.val;
                            pobj.val.push(obj);
                        }
                    }
                    else {
                        pobj.val[this.cobj.k] = this.cobj.val;
                    }
                }
                else if (Array.isArray(this.cobj.val)) {
                    if (Array.isArray(pobj.val)) {
                        pobj.val.push(this.cobj.val);
                    }
                    else {
                        pobj.val = this.cobj.val;
                    }
                }
                else ;
                return pobj;
            }
        }
        static formatVal(str) {
            if (null == str) {
                return null;
            }
            var numVal = Number(str);
            if (!isNaN(numVal)) {
                return numVal;
            }
            if ("false" == str.toLowerCase()) {
                return false;
            }
            else if ("true" == str.toLowerCase()) {
                return true;
            }
            else if ("null" == str) {
                return null;
            }
            return str;
        }
        static finCurrStr() {
            if (null != this.currStr) {
                this.currStr = this.currStr.trim();
                if ("" != this.currStr) {
                    if (null != this.cobj) {
                        if (Array.isArray(this.cobj.val)) {
                            this.cobj.val.push(this.formatVal(this.currStr));
                        }
                        else {
                            this.cobj.val = this.formatVal(this.currStr);
                            this.cobj = this.finCurrObj();
                        }
                    }
                    this.currStr = "";
                }
            }
        }
        static parseStart(str) {
            this.len = str.length;
            var i = 0;
            this.ret = {};
            this.currStr = null;
            this.currArr = [];
            this.cobj = null;
            this.type = 0;
            while (i < this.len) {
                var c = str.charAt(i);
                if ("/" == c) {
                    if (i + 1 < this.len) {
                        i += 1;
                        var cNext = str.charAt(i);
                        var cstr = null;
                        if ("/" == cNext) {
                            cstr = "\n";
                        }
                        else if ("*" == cNext) {
                            cstr = "*/";
                        }
                        if (null != cstr) {
                            this.finCurrStr();
                            var fi = str.indexOf(cstr, i);
                            if (0 > fi) {
                                console.log("没有找到注释结尾，应该是一直注释到最后了");
                                i = this.len;
                            }
                            else {
                                i = fi + cstr.length - 1;
                            }
                        }
                    }
                }
                else if ("}" == c) {
                    if (null != this.cobj) {
                        this.finCurrStr();
                        if (null != this.cobj) {
                            this.cobj = this.finCurrObj();
                        }
                    }
                    this.currStr = "";
                    this.type = 1;
                }
                else if ("{" == c) {
                    this.currStr = "";
                    this.type = 1;
                }
                else if ("'" == c || "\"" == c || "‘" == c || "“" == c) {
                    if ("‘" == c) {
                        c = "’";
                    }
                    else if ("“" == c) {
                        c = "”";
                    }
                    var obj = this.findIndex(str, i, c, this.len);
                    if (2 == this.type && null != this.cobj && Array.isArray(this.cobj.val)) {
                        if (null != this.currStr) {
                            this.currStr = this.currStr.trim();
                            if ("" != this.currStr) {
                                this.cobj.val.push(this.formatVal(this.currStr));
                            }
                        }
                        this.cobj.val.push(obj.str);
                        this.currStr = "";
                    }
                    else if (null != this.currStr) {
                        this.currStr += obj.str;
                    }
                    i = obj.i;
                }
                else if (";" == c || "," == c || "\n" == c) {
                    this.finCurrStr();
                }
                else if ("]" == c) {
                    if (null != this.currStr && null != this.cobj && Array.isArray(this.cobj.val)) {
                        this.currStr = this.currStr.trim();
                        if ("" != this.currStr) {
                            this.cobj.val.push(this.formatVal(this.currStr));
                        }
                    }
                    if (null != this.cobj) {
                        this.cobj = this.finCurrObj();
                        this.cobj = this.finCurrObj();
                    }
                    this.currStr = "";
                }
                else if ("[" == c) {
                    if (2 != this.type) {
                        console.warn("没有key值，忽略掉一个数组");
                    }
                    else {
                        if (null != this.cobj) {
                            this.currArr.push(this.cobj);
                        }
                        this.cobj = { val: [] };
                    }
                }
                else if (":" == c) {
                    if (null != this.currStr && 1 == this.type) {
                        this.type = 2;
                        if (null != this.cobj) {
                            this.currArr.push(this.cobj);
                        }
                        if (null != this.cobj && Array.isArray(this.cobj.val)) {
                            var pcobj = this.cobj;
                            this.cobj = { val: {} };
                            pcobj.val.push(this.cobj.val);
                            this.currArr.push(this.cobj);
                        }
                        this.cobj = { k: this.currStr.trim(), val: {} };
                        this.currStr = "";
                    }
                }
                else if (null != this.currStr) {
                    this.currStr += c;
                }
                i++;
            }
            return this.ret;
        }
    }

    const CGBlock = ["GLSL Start", "GLSL End"];
    const split = ["#defineGLSL", "#endGLSL"];
    const shaderBlock = ["Shader3D Start", "Shader3D End"];
    const shaderDataOBJ = {
        "Color": exports.ShaderDataType.Color,
        "Int": exports.ShaderDataType.Int,
        "Bool": exports.ShaderDataType.Bool,
        "Float": exports.ShaderDataType.Float,
        "Vector2": exports.ShaderDataType.Vector2,
        "Vector3": exports.ShaderDataType.Vector3,
        "Vector4": exports.ShaderDataType.Vector4,
        "Matrix4x4": exports.ShaderDataType.Matrix4x4,
        "Matrix3x3": exports.ShaderDataType.Matrix3x3,
        "Texture2D": exports.ShaderDataType.Texture2D,
        "TextureCube": exports.ShaderDataType.TextureCube,
        "Texture2DArray": exports.ShaderDataType.Texture2DArray,
        "Texture3D": exports.ShaderDataType.Texture3D,
    };
    class ShaderParser {
        static parse(data, basePath) {
            let obj = ShaderParser.getShaderBlock(data);
            let cgmap = ShaderParser.getCGBlock(data);
            ShaderParser.bindCG(obj, cgmap);
            let shader = Shader3D.parse(obj, basePath);
            return shader;
        }
        static compileToTree(sliceFlag, data, sliceIndex) {
            if (sliceIndex == sliceFlag.length)
                return [data];
            let slicedata = sliceFlag[sliceIndex];
            let splitmap = data.split(slicedata);
            if (splitmap.length == 1)
                return splitmap;
            let map = [];
            for (let i = 0, n = splitmap.length; i < n; i++) {
                map = map.concat(ShaderParser.compileToTree(sliceFlag, splitmap[i], sliceIndex + 1));
                (i != n - 1) && map.push(slicedata);
            }
            return map;
        }
        static getMapKey(value) {
            let index = value.indexOf("\n");
            value = value.slice(0, index).replace("\r", "");
            value = value.slice(0, index).replace(" ", "");
            value = value.trim();
            return value;
        }
        static getShaderBlock(source) {
            var _a, _b;
            let shaderObj = null;
            try {
                let i1 = source.indexOf(shaderBlock[0]);
                if (i1 == -1)
                    throw new Error(`no '${shaderBlock[0]}' tag`);
                let i2 = source.indexOf(shaderBlock[1]);
                if (i2 == -1)
                    throw new Error(`no '${shaderBlock[1]}' tag`);
                let shaderData = source.substring(i1 + shaderBlock[0].length, i2);
                shaderObj = ParseJSON.parse(shaderData);
                if (typeof shaderObj.shaderType === 'string') {
                    shaderObj.shaderType = (_a = exports.ShaderFeatureType[shaderObj.shaderType]) !== null && _a !== void 0 ? _a : exports.ShaderFeatureType.None;
                }
                else {
                    shaderObj.shaderType = (_b = shaderObj.shaderType) !== null && _b !== void 0 ? _b : exports.ShaderFeatureType.None;
                }
                if (shaderObj.shaderType === exports.ShaderFeatureType.D2_primitive) {
                    shaderObj.shaderType = exports.ShaderFeatureType.D2_TextureSV;
                }
            }
            catch (err) {
                console.error("Shader parse error: " + err + "\n" + source.substring(0, 100) + "...");
            }
            return shaderObj;
        }
        static getCGBlock(source) {
            let cgmap = {};
            try {
                let i1 = source.indexOf(CGBlock[0]);
                if (i1 == -1)
                    throw new Error(`no '${shaderBlock[0]}' tag`);
                let i2 = source.indexOf(CGBlock[1]);
                if (i2 == -1)
                    throw new Error(`no '${shaderBlock[1]}' tag`);
                let cgdata = source.substring(i1, i2);
                let map = ShaderParser.compileToTree(split, cgdata, 0);
                for (let i = 0, n = map.length; i < n; i++) {
                    let value = map[i];
                    if (value == split[0]) {
                        i += 1;
                        let datavalue = map[i];
                        let key = ShaderParser.getMapKey(datavalue);
                        cgmap[key] = datavalue.slice(datavalue.indexOf("\n"), datavalue.length - 1);
                    }
                }
            }
            catch (err) {
                console.error("Shader parse error: " + err + "\n" + source.substring(0, 100) + "...");
            }
            return cgmap;
        }
        static bindCG(shaderObj, cgmap) {
            let passArray = shaderObj.shaderPass;
            if (passArray) {
                passArray.forEach(element => {
                    if (element.VS) {
                        element.VS = cgmap[element.VS];
                    }
                    if (element.FS) {
                        element.FS = cgmap[element.FS];
                    }
                });
            }
            let attributemap = shaderObj.attributeMap;
            if (attributemap) {
                let indexofAttribute = 0;
                for (let i in attributemap) {
                    if (attributemap[i] instanceof Array) {
                        let dataArray = attributemap[i];
                        let type = ShaderParser.getShaderDataType(dataArray[0]);
                        if (type == null) {
                            console.warn(`${shaderObj.name}: unkown attribute type '${dataArray[0]}'`);
                            continue;
                        }
                        attributemap[i] = [dataArray[1], type];
                    }
                    else {
                        let type = ShaderParser.getShaderDataType(attributemap[i]);
                        if (type == null) {
                            console.warn(`${shaderObj.name}: unkown attribute type '${attributemap[i]}'`);
                            continue;
                        }
                        attributemap[i] = [indexofAttribute, type];
                        indexofAttribute++;
                    }
                }
            }
            let uniformMap = shaderObj.uniformMap;
            if (uniformMap) {
                let defaultmap = {};
                shaderObj.defaultValue = defaultmap;
                let newUniformMap = {};
                shaderObj.uniformMap = newUniformMap;
                for (let k in uniformMap) {
                    let entry = uniformMap[k];
                    if (entry.serializable === false)
                        continue;
                    let dataType = ShaderParser.getShaderDataType(entry.type);
                    if (dataType == null) {
                        console.warn(`${shaderObj.name}: unkown uniform type '${entry.type}'`);
                        continue;
                    }
                    if (entry.default != null)
                        defaultmap[k] = ShaderParser.getDefaultData(dataType, entry.default);
                    if (entry.block) {
                        let block = newUniformMap[entry.block];
                        if (!block)
                            newUniformMap[entry.block] = block = {};
                        block[k] = dataType;
                    }
                    else
                        newUniformMap[k] = dataType;
                }
            }
        }
        static getShaderDataType(value) {
            return shaderDataOBJ[value];
        }
        static getDefaultData(type, data) {
            switch (type) {
                case exports.ShaderDataType.Int:
                case exports.ShaderDataType.Float:
                case exports.ShaderDataType.Bool:
                    return data;
                case exports.ShaderDataType.Vector2:
                    return new Vector2(data[0], data[1]);
                case exports.ShaderDataType.Vector3:
                    return new Vector3(data[0], data[1], data[2]);
                case exports.ShaderDataType.Vector4:
                    return new Vector4(data[0], data[1], data[2], data[3]);
                case exports.ShaderDataType.Color:
                    return new Color(data[0], data[1], data[2], data[3]);
                case exports.ShaderDataType.Matrix4x4:
                    let mat = new Matrix4x4();
                    mat.cloneByArray(data);
                    return mat;
                case exports.ShaderDataType.Matrix3x3:
                    let mat3 = new Matrix3x3();
                    mat3.cloneByArray(data);
                    return mat3;
                case exports.ShaderDataType.Texture2D:
                    let tex = null;
                    if (data == "white")
                        tex = Texture2D.whiteTexture;
                    else if (data == "black")
                        tex = Texture2D.blackTexture;
                    else if (data == "gray")
                        tex = Texture2D.grayTexture;
                    else if (data == "normal")
                        tex = Texture2D.normalTexture;
                    return tex;
                case exports.ShaderDataType.TextureCube:
                    let texcube = TextureCube.grayTexture;
                    if (data == "white")
                        texcube = TextureCube.whiteTexture;
                    else if (data == "black")
                        texcube = TextureCube.blackTexture;
                    else if (data == "gray")
                        texcube = TextureCube.grayTexture;
                    return texcube;
            }
        }
    }

    class ShaderLoader {
        load(task) {
            let url = task.url;
            if (task.ext === "bps")
                url = AssetDb.inst.getSubAssetURL(url, task.uuid, "0", "shader");
            return task.loader.fetch(url, "text", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                let obj = ShaderParser.getShaderBlock(data);
                let cgmap = ShaderParser.getCGBlock(data);
                ShaderParser.bindCG(obj, cgmap);
                if (!obj.name || !obj.uniformMap)
                    return null;
                let basePath = URL.getPath(task.url);
                let passArray = obj.shaderPass;
                return Promise.all(passArray.map(pass => ShaderCompile.compileAsync(pass.VS, pass.FS, basePath))).then(compiledObjs => {
                    var _a;
                    if (compiledObjs.findIndex(obj => obj == null) != -1) {
                        Loader.warn("some pass null " + task.url);
                        return null;
                    }
                    let shader = Shader3D.add(obj.name, obj.enableInstancing, obj.supportReflectionProbe);
                    shader._supportVolumetricGI = obj.supportVolumetricGI;
                    shader.shaderType = obj.shaderType;
                    let subshader = new SubShader(obj.attributeMap ? obj.attributeMap : SubShader.DefaultAttributeMap, obj.uniformMap, obj.defaultValue);
                    shader.addSubShader(subshader);
                    for (let i in passArray) {
                        let pass = subshader._addShaderPass(compiledObjs[i], passArray[i].pipeline);
                        pass.statefirst = (_a = passArray[i].statefirst) !== null && _a !== void 0 ? _a : false;
                        ShaderCompile.getRenderState(passArray[i].renderState, pass.renderState);
                    }
                    return shader;
                });
            });
        }
    }
    Loader.registerLoader(["shader", "bps"], ShaderLoader);

    class GLSLLoader {
        load(task) {
            let url = task.url;
            return task.loader.fetch(url, "text", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return ShaderCompile.addInclude(task.url, data, true);
            });
        }
    }
    Loader.registerLoader(["glsl", "vs", "fs"], GLSLLoader);

    class WebAudioLoader {
        load(task) {
            return task.loader.fetch(task.url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                let size = data.byteLength;
                return PAL.media.decodeAudioData(data).then(buffer => {
                    if (buffer)
                        buffer.__byteLength = size;
                    return buffer;
                });
            });
        }
    }
    Loader.registerLoader(["mp3", "wav", "ogg"], WebAudioLoader, Loader.SOUND);

    class GradientMode {
    }
    GradientMode.Blend = 0;
    GradientMode.Fixed = 1;

    class Gradient {
        get maxColorRGBKeysCount() {
            return this._maxColorRGBKeysCount;
        }
        get colorRGBKeysCount() {
            return this._colorRGBKeysCount;
        }
        get _rgbElements() {
            return this._rgbElementDatas;
        }
        set _rgbElements(value) {
            this._rgbElementDatas = value;
            this._maxColorRGBKeysCount = value ? value.length / 4 : 0;
        }
        get maxColorAlphaKeysCount() {
            return this._maxColorAlphaKeysCount;
        }
        get colorAlphaKeysCount() {
            return this._colorAlphaKeysCount;
        }
        get _alphaElements() {
            return this._alphaElementDatas;
        }
        set _alphaElements(value) {
            this._alphaElementDatas = value;
            this._maxColorAlphaKeysCount = value ? value.length / 2 : 0;
        }
        get maxColorKeysCount() {
            return Math.max(this._maxColorAlphaKeysCount, this._maxColorRGBKeysCount);
        }
        ;
        get mode() {
            return this._mode;
        }
        set mode(value) {
            this._mode = value;
        }
        constructor() {
            this._mode = 0;
            this._maxColorRGBKeysCount = 0;
            this._colorRGBKeysCount = 0;
            this._maxColorAlphaKeysCount = 0;
            this._colorAlphaKeysCount = 0;
            this._keyRanges = new Vector4(1, 0, 1, 0);
        }
        addColorRGB(key, value) {
            if (this._colorRGBKeysCount >= this._maxColorRGBKeysCount) {
                let newRGBElementDatas = new Float32Array((this._maxColorRGBKeysCount + 4) * 4);
                this._rgbElementDatas && newRGBElementDatas.set(this._rgbElementDatas);
                this._rgbElements = newRGBElementDatas;
            }
            let offset = this._colorRGBKeysCount * 4;
            this._rgbElementDatas[offset] = key;
            this._rgbElementDatas[offset + 1] = value.r;
            this._rgbElementDatas[offset + 2] = value.g;
            this._rgbElementDatas[offset + 3] = value.b;
            this._colorRGBKeysCount++;
        }
        addColorAlpha(key, value) {
            if (this._colorAlphaKeysCount >= this._maxColorAlphaKeysCount) {
                let newAlphaElementDatas = new Float32Array((this._maxColorAlphaKeysCount + 4) * 2);
                this._alphaElementDatas && newAlphaElementDatas.set(this._alphaElementDatas);
                this._alphaElements = newAlphaElementDatas;
            }
            let offset = this._colorAlphaKeysCount * 2;
            this._alphaElementDatas[offset] = key;
            this._alphaElementDatas[offset + 1] = value;
            this._colorAlphaKeysCount++;
        }
        updateColorRGB(index, key, value) {
            if (index < this._colorRGBKeysCount) {
                var offset = index * 4;
                this._rgbElements[offset] = key;
                this._rgbElements[offset + 1] = value.r;
                this._rgbElements[offset + 2] = value.g;
                this._rgbElements[offset + 3] = value.b;
                if (this._gpuRGBData4 && index < 4) {
                    this._gpuRGBData4[offset] = key;
                    this._gpuRGBData4[offset + 1] = value.r;
                    this._gpuRGBData4[offset + 2] = value.g;
                    this._gpuRGBData4[offset + 3] = value.b;
                }
                if (this._gpuRGBData8 && index < 8) {
                    this._gpuRGBData8[offset] = key;
                    this._gpuRGBData8[offset + 1] = value.r;
                    this._gpuRGBData8[offset + 2] = value.g;
                    this._gpuRGBData8[offset + 3] = value.b;
                }
            }
            else {
                console.warn("Gradient:warning:index must lessEqual than colorRGBKeysCount:" + this._colorRGBKeysCount);
            }
        }
        updateColorAlpha(index, key, value) {
            if (index < this._colorAlphaKeysCount) {
                var offset = index * 2;
                this._alphaElements[offset] = key;
                this._alphaElements[offset + 1] = value;
                if (this._gpuAlphaData4 && index < 4) {
                    this._gpuAlphaData4[offset] = key;
                    this._gpuAlphaData4[offset + 1] = value;
                }
                if (this._gpuAlphaData8 && index < 8) {
                    this._gpuAlphaData8[offset] = key;
                    this._gpuAlphaData8[offset + 1] = value;
                }
            }
            else {
                console.warn("Gradient:warning:index must lessEqual than colorAlphaKeysCount:" + this._colorAlphaKeysCount);
            }
        }
        evaluateColorRGB(lerpFactor, out, startSearchIndex = 0, reverseSearch = false) {
            lerpFactor = Math.min(Math.max(lerpFactor, 0.0), 1.0);
            var rgbElements = this._rgbElements;
            var curIndex = startSearchIndex;
            if (reverseSearch) {
                for (var i = curIndex; i >= 0; i--) {
                    var offset = i * 4;
                    var left = rgbElements[offset];
                    if (lerpFactor === left) {
                        out.r = rgbElements[offset + 1];
                        out.g = rgbElements[offset + 2];
                        out.b = rgbElements[offset + 3];
                        return curIndex;
                    }
                    var right = rgbElements[offset + 4];
                    switch (this._mode) {
                        case GradientMode.Blend:
                            if (lerpFactor > left && right) {
                                if (lerpFactor > right)
                                    continue;
                                var diff = right - left;
                                var y1 = right - lerpFactor;
                                var y2 = lerpFactor - left;
                                out.r = (y1 * rgbElements[offset + 1] + y2 * rgbElements[offset + 5]) / diff;
                                out.g = (y1 * rgbElements[offset + 2] + y2 * rgbElements[offset + 6]) / diff;
                                out.b = (y1 * rgbElements[offset + 3] + y2 * rgbElements[offset + 7]) / diff;
                                return curIndex;
                            }
                            else {
                                curIndex--;
                                continue;
                            }
                        case GradientMode.Fixed:
                            if (lerpFactor > left) {
                                if (lerpFactor > rgbElements[offset + 4])
                                    throw "Gradient:wrong startSearchIndex.";
                                out.r = rgbElements[offset + 5];
                                out.g = rgbElements[offset + 6];
                                out.b = rgbElements[offset + 7];
                                return curIndex;
                            }
                            else {
                                curIndex--;
                                continue;
                            }
                        default:
                            throw "Gradient:unknown mode.";
                    }
                }
            }
            else {
                for (var i = 0, n = this._rgbElements.length; i < n; i++) {
                    offset = i * 4;
                    var right = rgbElements[offset];
                    if (lerpFactor === right) {
                        out.r = rgbElements[offset + 1];
                        out.g = rgbElements[offset + 2];
                        out.b = rgbElements[offset + 3];
                        return curIndex;
                    }
                    switch (this._mode) {
                        case GradientMode.Blend:
                            if (lerpFactor < right) {
                                var left = rgbElements[offset - 4];
                                if (lerpFactor < left)
                                    throw "Gradient:wrong startSearchIndex.";
                                var diff = right - left;
                                var y1 = right - lerpFactor;
                                var y2 = lerpFactor - left;
                                out.r = (y1 * rgbElements[offset - 3] + y2 * rgbElements[offset + 1]) / diff;
                                out.g = (y1 * rgbElements[offset - 2] + y2 * rgbElements[offset + 2]) / diff;
                                out.b = (y1 * rgbElements[offset - 1] + y2 * rgbElements[offset + 3]) / diff;
                                return curIndex;
                            }
                            else {
                                curIndex++;
                                continue;
                            }
                        case GradientMode.Fixed:
                            if (lerpFactor < right) {
                                if (lerpFactor < rgbElements[offset - 4])
                                    throw "Gradient:wrong startSearchIndex.";
                                out.r = rgbElements[offset + 1];
                                out.g = rgbElements[offset + 2];
                                out.b = rgbElements[offset + 3];
                                return curIndex;
                            }
                            else {
                                curIndex++;
                                continue;
                            }
                        default:
                            throw "Gradient:unknown mode.";
                    }
                }
            }
            return curIndex;
        }
        evaluateColorAlpha(lerpFactor, outColor, startSearchIndex = 0, reverseSearch = false) {
            lerpFactor = Math.min(Math.max(lerpFactor, 0.0), 1.0);
            var alphaElements = this._alphaElements;
            var curIndex = startSearchIndex;
            if (reverseSearch) {
                for (var i = curIndex; i >= 0; i--) {
                    var offset = i * 2;
                    var left = alphaElements[offset];
                    if (lerpFactor === left) {
                        outColor.a = alphaElements[offset + 1];
                        return curIndex;
                    }
                    var right = alphaElements[offset + 2];
                    switch (this._mode) {
                        case GradientMode.Blend:
                            if (lerpFactor > left && right) {
                                if (lerpFactor > right)
                                    continue;
                                var diff = right - left;
                                var x1 = right - lerpFactor;
                                var x2 = lerpFactor - left;
                                outColor.a = (x1 * alphaElements[offset + 1] + x2 * alphaElements[offset + 3]) / diff;
                                return curIndex;
                            }
                            else {
                                curIndex--;
                                continue;
                            }
                        case GradientMode.Fixed:
                            if (lerpFactor > left) {
                                if (lerpFactor > alphaElements[offset + 2])
                                    throw "Gradient:wrong startSearchIndex.";
                                outColor.a = alphaElements[offset + 3];
                                return curIndex;
                            }
                            else {
                                curIndex--;
                                continue;
                            }
                        default:
                            throw "Gradient:unknown mode.";
                    }
                }
            }
            else {
                for (var i = curIndex, n = this._alphaElements.length; i < n; i++) {
                    var offset = i * 2;
                    var right = alphaElements[offset];
                    if (lerpFactor === right) {
                        outColor.a = alphaElements[offset + 1];
                        return curIndex;
                    }
                    switch (this._mode) {
                        case GradientMode.Blend:
                            if (lerpFactor < right) {
                                var left = alphaElements[offset - 2];
                                if (lerpFactor < left)
                                    throw "Gradient:wrong startSearchIndex.";
                                var diff = right - left;
                                var x1 = right - lerpFactor;
                                var x2 = lerpFactor - left;
                                outColor.a = (x1 * alphaElements[offset - 1] + x2 * alphaElements[offset + 1]) / diff;
                                return curIndex;
                            }
                            else {
                                curIndex++;
                                continue;
                            }
                        case GradientMode.Fixed:
                            if (lerpFactor < right) {
                                if (lerpFactor < alphaElements[offset - 2])
                                    throw "Gradient:wrong startSearchIndex.";
                                outColor.a = alphaElements[offset + 1];
                                return curIndex;
                            }
                            else {
                                curIndex++;
                                continue;
                            }
                        default:
                            throw "Gradient:unknown mode.";
                    }
                }
            }
            return curIndex;
        }
        _updateGpuData(data, elements) {
            let length = Math.min(data.length, elements.length);
            for (let index = 0; index < length; index++) {
                data[index] = elements[index];
            }
        }
        _fixGPUAlphaData(data) {
            if (this.colorAlphaKeysCount == 1) {
                let alpha = this._alphaElements[1];
                data[0] = 0;
                data[1] = alpha;
                data[2] = 1;
                data[3] = alpha;
            }
            else if (this.colorAlphaKeysCount == 2) {
                data[0] = 0;
                data[1] = this._alphaElements[1];
                data[2] = 1;
                data[3] = this._alphaElements[3];
            }
            else {
                this._updateGpuData(data, this._alphaElements);
            }
        }
        _fixGPURGBData(data) {
            if (this.colorRGBKeysCount == 1) {
                let r = this._rgbElements[1];
                let g = this._rgbElements[2];
                let b = this._rgbElements[3];
                data[0] = 0;
                data[1] = r;
                data[2] = g;
                data[3] = b;
                data[4] = 1;
                data[5] = r;
                data[6] = g;
                data[7] = b;
            }
            else if (this.colorRGBKeysCount == 2) {
                data[0] = 0;
                data[1] = this._rgbElements[1];
                data[2] = this._rgbElements[2];
                data[3] = this._rgbElements[3];
                data[4] = 1;
                data[5] = this._rgbElements[5];
                data[6] = this._rgbElements[6];
                data[7] = this._rgbElements[7];
            }
            else {
                this._updateGpuData(data, this._rgbElements);
            }
        }
        _getGPURGBData4() {
            if (!this._gpuRGBData4) {
                this._gpuRGBData4 = new Float32Array(16);
            }
            this._fixGPURGBData(this._gpuRGBData4);
            return this._gpuRGBData4;
        }
        _getGPURGBData8() {
            if (!this._gpuRGBData8) {
                this._gpuRGBData8 = new Float32Array(32);
            }
            this._fixGPURGBData(this._gpuRGBData8);
            return this._gpuRGBData8;
        }
        _getGPUAlphaData4() {
            if (!this._gpuAlphaData4) {
                this._gpuAlphaData4 = new Float32Array(8);
            }
            this._fixGPUAlphaData(this._gpuAlphaData4);
            return this._gpuAlphaData4;
        }
        _getGPUAlphaData8() {
            if (!this._gpuAlphaData8) {
                this._gpuAlphaData8 = new Float32Array(16);
            }
            this._fixGPUAlphaData(this._gpuAlphaData8);
            return this._gpuAlphaData8;
        }
        cloneTo(destObject) {
            destObject._colorAlphaKeysCount = this._colorAlphaKeysCount;
            let destAlphaElements = destObject._alphaElements = new Float32Array(this._alphaElements.length);
            for (let i = 0, n = this._alphaElements.length; i < n; i++)
                destAlphaElements[i] = this._alphaElements[i];
            destObject._colorRGBKeysCount = this._colorRGBKeysCount;
            var destRGBElements = destObject._rgbElements = new Float32Array(this._rgbElements.length);
            for (let i = 0, n = this._rgbElements.length; i < n; i++)
                destRGBElements[i] = this._rgbElements[i];
        }
        clone() {
            var destGradientDataColor = new Gradient();
            this.cloneTo(destGradientDataColor);
            return destGradientDataColor;
        }
    }

    exports.WeightedMode = void 0;
    (function (WeightedMode) {
        WeightedMode[WeightedMode["None"] = 0] = "None";
        WeightedMode[WeightedMode["In"] = 1] = "In";
        WeightedMode[WeightedMode["Out"] = 2] = "Out";
        WeightedMode[WeightedMode["Both"] = 3] = "Both";
    })(exports.WeightedMode || (exports.WeightedMode = {}));
    class Keyframe {
        constructor() {
        }
        cloneTo(destObject) {
            destObject.time = this.time;
        }
        clone() {
            var dest = new Keyframe();
            this.cloneTo(dest);
            return dest;
        }
    }
    Keyframe.defaultWeight = 0.33333;

    class FloatKeyframe extends Keyframe {
        constructor() {
            super();
            this.inWeight = Keyframe.defaultWeight;
            this.outWeight = Keyframe.defaultWeight;
            this.weightedMode = exports.WeightedMode.None;
        }
        cloneTo(destObject) {
            super.cloneTo(destObject);
            destObject.inTangent = this.inTangent;
            destObject.outTangent = this.outTangent;
            destObject.value = this.value;
            destObject.inTangent = this.inTangent;
            destObject.outTangent = this.outTangent;
            destObject.value = this.value;
            destObject.inWeight = this.inWeight;
            destObject.outWeight = this.outWeight;
            destObject.weightedMode = this.weightedMode;
        }
        clone() {
            let f = new FloatKeyframe();
            this.cloneTo(f);
            return f;
        }
    }

    class Area2D extends Sprite {
        constructor() {
            super();
            this._renderType |= SpriteConst.AREA2D;
            this._initShaderData();
            this._globalRenderData = LayaGL.render2DRenderPassFactory.create2DGlobalRenderDataHandle();
            this._globalRenderData.globalShaderData = this._globalShaderData = LayaGL.renderDeviceFactory.createShaderData(null);
            this._globalRenderData.renderLayerMask = -1;
            this._struct.globalRenderData = this._globalRenderData;
        }
        get mainCamera() {
            return this._mainCamera;
        }
        _setMainCamera(camera) {
            if (camera == this._mainCamera || !LayaEnv.isPlaying)
                return;
            this._mainCamera && (this._mainCamera._isMain = false);
            if (camera) {
                camera._isMain = true;
                this._globalShaderData.addDefine(Camera2D.SHADERDEFINE_CAMERA2D);
            }
            else {
                this._globalShaderData.removeDefine(Camera2D.SHADERDEFINE_CAMERA2D);
            }
            this._mainCamera = camera;
        }
        render() {
            if (this._mainCamera) {
                if (this._globalShaderData) {
                    this._globalRenderData.renderLayerMask = this._mainCamera.visiableLayer;
                    this._globalRenderData.cullRect = this._mainCamera._rect;
                    this._globalShaderData.setMatrix3x3(Camera2D.VIEW2D, this._mainCamera._getCameraTransform());
                }
            }
        }
        _setBelongScene(scene) {
            super._setBelongScene(scene);
            this._scene._area2Ds.add(this);
        }
        _setUnBelongScene() {
            this._scene._area2Ds.delete(this);
            super._setUnBelongScene();
        }
        localToView(x, y, out) {
            out = out || new Point();
            out.setTo(x, y);
            this.localToGlobal(out);
            this.transformPoint(out.x, out.y, out);
            return out;
        }
        transformPoint(x, y, out) {
            out = out || new Point();
            out.setTo(x, y);
            if (!this._mainCamera) {
                return out;
            }
            let halfWidth = RenderState2D.width * 0.5;
            let halfHeight = RenderState2D.height * 0.5;
            let c_x = x - halfWidth;
            let c_y = y - halfHeight;
            this._mainCamera._getCameraTransform();
            let cameraMatrix = this._mainCamera.cameraMatrix;
            let elements = cameraMatrix.elements;
            let newX = elements[0] * c_x + elements[3] * c_y + elements[6];
            let newY = elements[1] * c_x + elements[4] * c_y + elements[7];
            let matrix = Matrix.TEMP;
            this._globalTrans.getMatrixInv(matrix);
            out.x = matrix.a * newX + matrix.c * newY + matrix.tx;
            out.y = matrix.b * newX + matrix.d * newY + matrix.ty;
            return out;
        }
    }

    class OpenDataContextView extends Sprite {
        constructor() {
            super();
            this._fps = 30;
            this._width = this._height = 200;
            this._widget = Widget.EMPTY;
            let tex = new Texture(new Texture2D(this._width, this._height, exports.TextureFormat.R8G8B8A8, false, false, true));
            tex.bitmap.lock = true;
            this.texture = tex;
            this._canvas = PAL.browser.getOpenDataContextCanvas();
        }
        get fps() {
            return this._fps;
        }
        set fps(value) {
            if (this._fps != value) {
                this._fps = value;
                if (LayaEnv.isPlaying && this.activeInHierarchy && this._canvas) {
                    ILaya.timer.clear(this, this._onLoop);
                    ILaya.timer.loop(1000 / value, this, this._onLoop);
                }
            }
        }
        _onActive() {
            if (!LayaEnv.isPlaying)
                return;
            if (this._canvas)
                ILaya.timer.loop(1000 / this._fps, this, this._onLoop);
        }
        _onInActive() {
            if (!LayaEnv.isPlaying)
                return;
            this.postMsg({ type: "close" });
            ILaya.timer.clear(this, this._onLoop);
        }
        get top() {
            return this._widget.top;
        }
        set top(value) {
            if (value != this._widget.top) {
                this._getWidget().top = value;
            }
        }
        get bottom() {
            return this._widget.bottom;
        }
        set bottom(value) {
            if (value != this._widget.bottom) {
                this._getWidget().bottom = value;
            }
        }
        get left() {
            return this._widget.left;
        }
        set left(value) {
            if (value != this._widget.left) {
                this._getWidget().left = value;
            }
        }
        get right() {
            return this._widget.right;
        }
        set right(value) {
            if (value != this._widget.right) {
                this._getWidget().right = value;
            }
        }
        get centerX() {
            return this._widget.centerX;
        }
        set centerX(value) {
            if (value != this._widget.centerX) {
                this._getWidget().centerX = value;
            }
        }
        get centerY() {
            return this._widget.centerY;
        }
        set centerY(value) {
            if (value != this._widget.centerY) {
                this._getWidget().centerY = value;
            }
        }
        _getWidget() {
            this._widget === Widget.EMPTY && (this._widget = this.addComponent(Widget));
            return this._widget;
        }
        _onLoop() {
            let tex = this.texture;
            let canvas = this._canvas;
            if (tex.width != canvas.width || tex.height != canvas.height) {
                tex.bitmap.destroy();
                tex.bitmap = new Texture2D(canvas.width, canvas.height, exports.TextureFormat.R8G8B8A8, false, false, true, true);
                tex.bitmap.lock = true;
                this._graphics.repaint();
            }
            if (this._canvas)
                tex.bitmap.setImageData(canvas, true, false);
        }
        _transChanged(kind) {
            super._transChanged(kind);
            if ((kind & exports.TransformKind.Size) != 0) {
                if (this._canvas) {
                    this._canvas.width = this._width;
                    this._canvas.height = this._height;
                }
                if (this._widget !== Widget.EMPTY)
                    this._widget.resetLayout();
                this.callLater(this.updateViewPort);
            }
            if ((kind & exports.TransformKind.Pos) != 0)
                this.callLater(this.updateViewPort);
        }
        updateViewPort() {
            let stage = ILaya.stage;
            let sx = stage._canvasTransform.getScaleX() * this.scaleX * stage.transform.getScaleX();
            let sy = stage._canvasTransform.getScaleY() * this.scaleY * stage.transform.getScaleY();
            this.postMsg({
                type: "updateViewPort",
                box: {
                    x: this.x * sx,
                    y: this.y * sy,
                    width: this.width * sx,
                    height: this.height * sy,
                }
            });
        }
        postMsg(msg) {
            PAL.browser.postMessageToOpenDataContext(msg);
        }
    }

    class PostProcess2DEffect {
        constructor() {
            this._active = true;
            this.destroyed = false;
            this._singleton = false;
        }
        get singleton() {
            return this._singleton;
        }
        get active() {
            return this._active;
        }
        set active(value) {
            if (this._active != value) {
                this._active = value;
                if (this._owner)
                    this._owner._onChangeRender();
            }
        }
        destroy() {
            this.destroyed = true;
        }
    }

    let c = ClassUtils.regClass;
    c("Record", Object);
    c("Node", Node);
    c("Sprite", Sprite);
    c("Widget", Widget);
    c("Text", Text);
    c("Input", Input);
    c("Animation", Animation);
    c("SoundNode", SoundNode);
    c("VideoNode", VideoNode);
    c("Area2D", Area2D);
    c("OpenDataContextView", OpenDataContextView);
    c("Scene", Scene);
    c("Stage", Stage);
    c("Component", Component);
    c("Script", Script);
    c("BitmapFont", BitmapFont);
    c("Point", Point);
    c("Rectangle", Rectangle);
    c("Texture", Texture);
    c("Texture2D", Texture2D);
    c("Prefab", Prefab);
    c("Animator2D", Animator2D);
    c("AnimatorControllerLayer2D", AnimatorControllerLayer2D);
    c("AnimatorState2D", AnimatorState2D);
    c("AnimationClip2D", AnimationClip2D);
    c("AnimatorController2D", AnimatorController2D);
    c("Animation2DParm", Animation2DParm);
    c("Animation2DCondition", Animation2DCondition);
    c("FrameAnimation", FrameAnimation);
    c("Vector2", Vector2);
    c("Vector3", Vector3);
    c("Vector4", Vector4);
    c("Quaternion", Quaternion);
    c("Color", Color);
    c("Matrix", Matrix);
    c("Matrix3x3", Matrix3x3);
    c("Matrix4x4", Matrix4x4);
    c("Camera2D", Camera2D);
    c("Mesh2DRender", Mesh2DRender);
    c("BaseRenderNode2D", BaseRenderNode2D);
    c("Mesh2D", Mesh2D);
    c("Gradient", Gradient);
    c("FloatKeyframe", FloatKeyframe);
    c("PostProcess2D", PostProcess2D);
    c("PostProcess2DEffect", PostProcess2DEffect);

    class SetRendertarget2DCMD {
        constructor() {
            this.size = new Vector2;
        }
        get invertY() {
            return this._invertY;
        }
        set invertY(value) {
            this._invertY = value;
        }
        get clearColorValue() {
            return this._clearColorValue;
        }
        set clearColorValue(value) {
            this._clearColorValue = value;
        }
        get rt() {
            return this._rt;
        }
        set rt(value) {
            this._rt = value;
        }
        get clearColor() {
            return this._clearColor;
        }
        set clearColor(value) {
            this._clearColor = value;
        }
        apply(context) {
            throw new NotImplementedError();
        }
    }
    class Draw2DElementCMD {
        setRenderelements(value) {
            throw new NotImplementedError();
        }
        apply(context) {
            throw new NotImplementedError();
        }
    }
    class Blit2DQuadCMD {
        get element() {
            return this._element;
        }
        set element(value) {
            this._element = value;
        }
        get dest() {
            return this._dest;
        }
        set dest(value) {
            this._dest = value;
        }
        get source() {
            return this._source;
        }
        set source(value) {
            this._source = value;
        }
        get offsetScale() {
            return this._offsetScale;
        }
        set offsetScale(value) {
            this._offsetScale = value;
        }
        apply(context) {
            throw new NotImplementedError();
        }
    }

    class CommandUniformMap {
        constructor(stateName) {
        }
        addShaderUniform(propertyID, propertyKey, uniformtype) {
            throw "need override it";
        }
        addShaderUniformArray(propertyID, propertyName, uniformtype, arrayLength) {
            throw "need override it";
        }
    }

    class ComputeCommandBuffer {
        constructor() {
            if (LayaGL.renderDeviceFactory.createComputeContext) {
                this._context = LayaGL.renderDeviceFactory.createComputeContext();
            }
        }
        getResource() {
            return this._context;
        }
        clearCMDs() {
            this._context.clearCMDs();
        }
        addDispatchCommand(computeshader, kernel, shaderDefine, datas, dispatchParams) {
            let cmd = {
                shader: computeshader.getCacheShader(shaderDefine),
                Kernel: kernel,
                shaderData: datas,
                dispatchParams: dispatchParams.clone()
            };
            this._context.addDispatchCommand(cmd);
        }
        ;
        addSetShaderDataCommand(shaderData, propertyID, shaderDataType, value) {
            this._context.addSetShaderDataCommand(shaderData, propertyID, shaderDataType, value);
        }
        ;
        addBufferToBufferCommand(src, dest, sourceOffset, destinationOffset, size) {
            this._context.addBufferToBufferCommand(src, dest, sourceOffset, destinationOffset, size);
        }
        ;
        addClearBufferCommand(dest, destoffset, destCount) {
            this._context.addClearBufferCommand(dest, destoffset, destCount);
        }
        addBufferToTextureCommand(src, srcTextureInfo, destTextureInfo, copySize) {
        }
        ;
        addTextureToBufferCommand(srcTextureInfo, rc, destTextureInfo, copySize) {
        }
        ;
        addTextureToTextureCommand(srcTextureInfo, destTextureInfo, copySize) {
            this._context.addTextureToTextureCommand(srcTextureInfo, destTextureInfo, copySize);
        }
        ;
        executeCMDs() {
            this._context.executeCMDs();
        }
        ;
        destroy() {
            this._context.destroy();
        }
        ;
    }

    class ComputeShader {
        static createComputeShader(name, code, other) {
            if (!ComputeShader._CompileShader[name]) {
                return new ComputeShader(name, code, other);
            }
            else
                return ComputeShader._CompileShader[name];
        }
        constructor(name, code, other) {
            this._cacheSharders = {};
            this._cacheShaderHierarchy = 1;
            this.name = name;
            this.code = code;
            this.other = other;
        }
        setCacheShader(compileDefine, shader) {
            var cacheShaders = this._cacheSharders;
            var mask = compileDefine._mask;
            var endIndex = compileDefine._length - 1;
            var maxEndIndex = this._cacheShaderHierarchy - 1;
            for (var i = 0; i < maxEndIndex; i++) {
                var subMask = endIndex < i ? 0 : mask[i];
                var subCacheShaders = cacheShaders[subMask];
                (subCacheShaders) || (cacheShaders[subMask] = subCacheShaders = {});
                cacheShaders = subCacheShaders;
            }
            var cacheKey = endIndex < maxEndIndex ? 0 : mask[maxEndIndex];
            cacheShaders[cacheKey] = shader;
        }
        getCacheShader(compileDefine) {
            var cacheShaders = this._cacheSharders;
            var maskLength = compileDefine._length;
            if (maskLength > this._cacheShaderHierarchy) {
                this._resizeCacheShaderMap(cacheShaders, 0, maskLength);
                this._cacheShaderHierarchy = maskLength;
            }
            var mask = compileDefine._mask;
            var endIndex = compileDefine._length - 1;
            var maxEndIndex = this._cacheShaderHierarchy - 1;
            for (var i = 0; i < maxEndIndex; i++) {
                var subMask = endIndex < i ? 0 : mask[i];
                var subCacheShaders = cacheShaders[subMask];
                (subCacheShaders) || (cacheShaders[subMask] = subCacheShaders = {});
                cacheShaders = subCacheShaders;
            }
            var cacheKey = endIndex < maxEndIndex ? 0 : mask[maxEndIndex];
            var shader = cacheShaders[cacheKey];
            if (!shader) {
                shader = LayaGL.renderDeviceFactory.createComputeShader({
                    name: this.name,
                    code: this.code,
                    other: this.other,
                    defineData: compileDefine
                });
                this.setCacheShader(compileDefine, shader);
            }
            return shader;
        }
        _resizeCacheShaderMap(cacheMap, hierarchy, resizeLength) {
            var end = this._cacheShaderHierarchy - 1;
            if (hierarchy == end) {
                for (var k in cacheMap) {
                    var shader = cacheMap[k];
                    for (var i = 0, n = resizeLength - end; i < n; i++) {
                        if (i === n - 1)
                            cacheMap[0] = shader;
                        else
                            cacheMap = cacheMap[i == 0 ? k : 0] = {};
                    }
                }
            }
            else {
                ++hierarchy;
                for (var k in cacheMap)
                    this._resizeCacheShaderMap(cacheMap[k], hierarchy, resizeLength);
            }
        }
    }
    ComputeShader._CompileShader = {};

    exports.ComputeCommandType = void 0;
    (function (ComputeCommandType) {
        ComputeCommandType[ComputeCommandType["DispatchCompute"] = 0] = "DispatchCompute";
        ComputeCommandType[ComputeCommandType["SetRenderData"] = 1] = "SetRenderData";
        ComputeCommandType[ComputeCommandType["ClearBuffer"] = 2] = "ClearBuffer";
        ComputeCommandType[ComputeCommandType["CopyBufferToBuffer"] = 3] = "CopyBufferToBuffer";
        ComputeCommandType[ComputeCommandType["copyBufferToTexture"] = 4] = "copyBufferToTexture";
        ComputeCommandType[ComputeCommandType["copyTextureToBuffer"] = 5] = "copyTextureToBuffer";
        ComputeCommandType[ComputeCommandType["copyTextureToTexture"] = 6] = "copyTextureToTexture";
    })(exports.ComputeCommandType || (exports.ComputeCommandType = {}));
    exports.EComputeCMDMemoryOperate = void 0;
    (function (EComputeCMDMemoryOperate) {
        EComputeCMDMemoryOperate[EComputeCMDMemoryOperate["ClearBuffer"] = 0] = "ClearBuffer";
        EComputeCMDMemoryOperate[EComputeCMDMemoryOperate["BufferToBuffer"] = 1] = "BufferToBuffer";
        EComputeCMDMemoryOperate[EComputeCMDMemoryOperate["BufferToTexture"] = 2] = "BufferToTexture";
        EComputeCMDMemoryOperate[EComputeCMDMemoryOperate["TextureToBuffer"] = 3] = "TextureToBuffer";
        EComputeCMDMemoryOperate[EComputeCMDMemoryOperate["TextureToTexture"] = 4] = "TextureToTexture";
    })(exports.EComputeCMDMemoryOperate || (exports.EComputeCMDMemoryOperate = {}));
    class CopyTextureInfo {
        constructor() {
            this.mipLevel = 0;
            this.origin = new Vector3(0, 0, 0);
        }
    }

    exports.EDeviceBufferUsage = void 0;
    (function (EDeviceBufferUsage) {
        EDeviceBufferUsage[EDeviceBufferUsage["MAP_READ"] = 1] = "MAP_READ";
        EDeviceBufferUsage[EDeviceBufferUsage["MAP_WRITE"] = 2] = "MAP_WRITE";
        EDeviceBufferUsage[EDeviceBufferUsage["COPY_SRC"] = 4] = "COPY_SRC";
        EDeviceBufferUsage[EDeviceBufferUsage["COPY_DST"] = 8] = "COPY_DST";
        EDeviceBufferUsage[EDeviceBufferUsage["STORAGE"] = 16] = "STORAGE";
        EDeviceBufferUsage[EDeviceBufferUsage["INDIRECT"] = 32] = "INDIRECT";
    })(exports.EDeviceBufferUsage || (exports.EDeviceBufferUsage = {}));

    exports.RenderCMDType = void 0;
    (function (RenderCMDType) {
        RenderCMDType[RenderCMDType["DrawNode"] = 0] = "DrawNode";
        RenderCMDType[RenderCMDType["DrawElement"] = 1] = "DrawElement";
        RenderCMDType[RenderCMDType["Blit"] = 2] = "Blit";
        RenderCMDType[RenderCMDType["ChangeData"] = 3] = "ChangeData";
        RenderCMDType[RenderCMDType["ChangeShaderDefine"] = 4] = "ChangeShaderDefine";
        RenderCMDType[RenderCMDType["ChangeViewPort"] = 5] = "ChangeViewPort";
        RenderCMDType[RenderCMDType["ChangeRenderTarget"] = 6] = "ChangeRenderTarget";
        RenderCMDType[RenderCMDType["ComputeCommandAppatch"] = 7] = "ComputeCommandAppatch";
    })(exports.RenderCMDType || (exports.RenderCMDType = {}));
    class SetRenderDataCMD {
        get value() {
            return this._value;
        }
        set value(value) {
            this._value = value;
        }
        get dataType() {
            return this._dataType;
        }
        set dataType(value) {
            this._dataType = value;
        }
        get propertyID() {
            return this._propertyID;
        }
        set propertyID(value) {
            this._propertyID = value;
        }
        get dest() {
            return this._dest;
        }
        set dest(value) {
            this._dest = value;
        }
        apply(context) {
            throw new NotImplementedError();
        }
    }
    class SetShaderDefineCMD {
        get define() {
            return this._define;
        }
        set define(value) {
            this._define = value;
        }
        get dest() {
            return this._dest;
        }
        set dest(value) {
            this._dest = value;
        }
        get add() {
            return this._add;
        }
        set add(value) {
            this._add = value;
        }
        apply(context) {
            throw new NotImplementedError();
        }
    }
    class ComputeCommandAppatchCMD {
        apply(context) {
            throw new NotImplementedError();
        }
    }

    class UniformBufferBlock {
        constructor(cluster, index, size, alignedSize, user) {
            this._destroyed = false;
            this._id = UniformBufferBlock._idCounter++;
            this.cluster = cluster;
            this.index = index;
            this.size = size;
            this._alignedSize = alignedSize;
            this.offset = alignedSize * index;
            this.user = user;
            this.uploadNum = 0;
            this.moved = false;
        }
        needUpload() {
            this.cluster._addUploadBlock(this.index);
            if (!this.moved && this.uploadNum++ > this.cluster.manager.uploadThreshold)
                this.cluster.manager._addOptimizeBufferPos(this.cluster);
        }
        destroy() {
            if (!this._destroyed) {
                this._destroyed = true;
                this.cluster = null;
                this.user = null;
                return true;
            }
            console.warn('UniformBufferBlock: object alreay destroyed!');
            return false;
        }
    }
    UniformBufferBlock._idCounter = 0;

    class UniformBufferCluster {
        constructor(blockSize, blockNum, manager) {
            this._inManagerUpdateArray = false;
            this._sn = 0;
            this._id = 0;
            this._destroyed = false;
            this._blocks = [];
            this._holeNum = 0;
            this._expand = 16;
            this._id = UniformBufferCluster._idCounter++;
            this.manager = manager;
            this._blockSize = blockSize;
            this._blockNum = blockNum;
            this._totalSize = blockSize * blockNum;
            this._needUpload = new Array(blockNum).fill(false);
            this.data = new ArrayBuffer(this._totalSize);
            this._move = new Uint8Array(this._blockSize);
            this.buffer = this.manager.createGPUBuffer(this._totalSize);
            this.manager.statisGPUMemory(this._totalSize);
        }
        get usedNum() {
            return this._blocks.length;
        }
        _expandBuffer() {
            let expandNum = this._blockNum;
            this._blockNum += this._expand;
            if (this._blockNum > this.manager.clusterMaxBlock)
                this._blockNum = this.manager.clusterMaxBlock;
            expandNum = this._blockNum - expandNum;
            if (expandNum < 1)
                return false;
            this._totalSize = this._blockSize * this._blockNum;
            const expandSize = this._blockSize * this._expand;
            this._needUpload = this._needUpload.concat(new Array(expandNum).fill(false));
            const newArrayBuffer = new ArrayBuffer(this._totalSize);
            new Uint8Array(newArrayBuffer).set(new Uint8Array(this.data));
            this.data = newArrayBuffer;
            this.buffer = this.manager.createGPUBuffer(this._totalSize, null, this.data);
            this.manager.statisGPUMemory(expandSize);
            this._blocks.forEach(block => block && block.user.notifyGPUBufferChange('expand'));
            return true;
        }
        _moveBlock(index) {
            const len = this._blocks.length;
            if (index >= len)
                return false;
            const dataView = new Uint8Array(this.data);
            const size = this._blockSize;
            for (let i = index + 1; i < len; i++) {
                const start = i * size;
                const end = start + size;
                const target = start - size;
                dataView.copyWithin(target, start, end);
                this._needUpload[i - 1] = this._needUpload[i];
                this._blocks[i - 1] = this._blocks[i];
                if (this._blocks[i - 1]) {
                    this._blocks[i - 1].index--;
                    this._blocks[i - 1].offset -= size;
                    this._blocks[i - 1].user.notifyGPUBufferChange('moveBlock');
                }
            }
            this._blocks.length--;
            return true;
        }
        _createBufferBlock(index, size, alignedSize, user) {
            return new UniformBufferBlock(this, index, size, alignedSize, user);
        }
        getBlock(size, user) {
            const alignedSize = roundUp(size, this.manager.byteAlign);
            if (alignedSize !== this._blockSize) {
                console.warn('WebGPUBufferCluster: 获取内存块时, 长度错误!');
                return null;
            }
            const index = this._getBlockWithExpand();
            const bb = this._createBufferBlock(index, size, alignedSize, user);
            this._blocks[index] = bb;
            return bb;
        }
        freeBlock(bb) {
            const index = this._blocks.indexOf(bb);
            if (index !== -1) {
                if (index === this._blocks.length - 1)
                    this._blocks.length--;
                else {
                    this._blocks[index] = null;
                    this._holeNum++;
                }
                bb.destroy();
                if (this._holeNum > this.manager.removeHoleThreshold) {
                    this.manager._addRemoveHoleCluster(this);
                    this._holeNum = 0;
                }
                return true;
            }
            return false;
        }
        upload() {
            var _a;
            let next = false;
            let startIndex = -1;
            let endIndex = -1;
            let offset = 0;
            let size = 0;
            for (let i = 0, len = this._blocks.length; i < len; i++) {
                if (this._needUpload[i]) {
                    if (startIndex === -1)
                        startIndex = i;
                    endIndex = i;
                    next = true;
                    this._needUpload[i] = false;
                    (_a = this._blocks[i]) === null || _a === void 0 ? void 0 : _a.user.updateOver();
                }
                else {
                    if (next) {
                        offset = startIndex * this._blockSize;
                        size = (endIndex - startIndex + 1) * this._blockSize;
                        this.manager.writeBuffer(this.buffer, this.data, offset, size);
                        startIndex = -1;
                        endIndex = -1;
                        next = false;
                    }
                }
            }
            if (next) {
                offset = startIndex * this._blockSize;
                size = (endIndex - startIndex + 1) * this._blockSize;
                this.manager.writeBuffer(this.buffer, this.data, offset, size);
            }
        }
        _addUploadBlock(index) {
            this._needUpload[index] = true;
            if (!this._inManagerUpdateArray)
                this.manager._addUpdateArray(this);
        }
        optimize() {
            let ret = false;
            for (let i = 0, len = this._blocks.length; i < len; i++) {
                const bb = this._blocks[i];
                if (bb && !bb.moved && bb.uploadNum > this.manager.uploadThreshold && i > 0) {
                    const size = this._blockSize;
                    const dataView = new Uint8Array(this.data);
                    this._move.set(new Uint8Array(this.data, size * i, size));
                    for (let j = i - 1; j >= 0; j--) {
                        const start = j * size;
                        const end = start + size;
                        const target = start + size;
                        dataView.copyWithin(target, start, end);
                        this._needUpload[j + 1] = this._needUpload[j];
                        this._blocks[j + 1] = this._blocks[j];
                        if (this._blocks[j + 1]) {
                            this._blocks[j + 1].index++;
                            this._blocks[j + 1].offset += size;
                            this._blocks[j + 1].user.notifyGPUBufferChange('optimize');
                        }
                    }
                    dataView.set(this._move);
                    bb.index = 0;
                    bb.offset = 0;
                    bb.moved = true;
                    this._blocks[0] = bb;
                    this._blocks[0].user.notifyGPUBufferChange('optimize');
                    ret = true;
                }
            }
            return ret;
        }
        removeHole() {
            let ret = false;
            for (let i = this._blocks.length - 1; i > -1; i--) {
                if (!this._blocks[i]) {
                    if (this._moveBlock(i)) {
                        ret = true;
                    }
                }
            }
            this._holeNum = 0;
            return ret;
        }
        clear(blockNum) {
            this._blocks.forEach(block => block && block.destroy());
            this._blocks.length = 0;
            if (blockNum != undefined && blockNum > 0 && blockNum !== this._blockNum) {
                this._blockNum = blockNum;
                this._totalSize = this._blockSize * this._blockNum;
                this.buffer = this.manager.createGPUBuffer(this._totalSize);
                this.data = new ArrayBuffer(this._totalSize);
            }
            else {
                this._blockNum = 0;
                this._totalSize = 0;
                this.buffer = null;
                this.data = null;
            }
            this._needUpload.length = this._blockNum;
            this._needUpload.fill(false);
        }
        _getBlockWithExpand() {
            for (let i = this._blocks.length - 1; i > -1; i--) {
                if (!this._blocks[i]) {
                    this._holeNum--;
                    return i;
                }
            }
            if (this._blocks.length < this._blockNum)
                return this._blocks.length;
            else {
                this._expandBuffer();
                return this._blocks.length;
            }
        }
        destroy() {
            var _a;
            if (!this._destroyed) {
                this.clear();
                (_a = this.buffer.destroy) !== null && _a !== void 0 ? _a : this.buffer.destroy();
                this.manager.statisGPUMemory(-this._totalSize);
                this._destroyed = true;
                return true;
            }
            console.warn('UniformBufferCluster: object alreay destroyed!');
            return false;
        }
    }
    UniformBufferCluster._idCounter = 0;

    function roundUp(n, align) {
        return (((n + align - 1) / align) | 0) * align;
    }
    function roundDown(n, align) {
        const res = (((n + align - 1) / align) | 0) * align;
        return res > n ? res - align : res;
    }
    class UniformBufferManager {
        constructor(useBigBuffer) {
            this._destroyed = false;
            this._needUpdateClusters = [];
            this._removeHoleArray = [];
            this._optimizeBufferPosArray = [];
            this._useBigBuffer = true;
            this.byteAlign = 256;
            this.clusterMaxBlock = 256;
            this.uploadThreshold = 200;
            this.removeHoleThreshold = 10;
            this.aloneBuffers = [];
            this._useBigBuffer = useBigBuffer;
            this._clustersAll = new Map();
            this._clustersCur = new Map();
        }
        _createBufferCluster(size, blockNum) {
            return new UniformBufferCluster(size, blockNum, this);
        }
        _addCluster(size, blockNum = 16) {
            const alignedSize = roundUp(size, this.byteAlign);
            const cluster = this._createBufferCluster(alignedSize, blockNum);
            const clusters = this._clustersAll.get(alignedSize);
            if (clusters) {
                clusters.push(cluster);
                cluster._sn = clusters.length - 1;
            }
            else
                this._clustersAll.set(alignedSize, [cluster]);
            this._clustersCur.set(alignedSize, cluster);
            return cluster;
        }
        startFrame() { }
        endFrame() {
        }
        getBufferAlone(size, name) {
            const alignedSize = roundUp(size, this.byteAlign);
            return this.createGPUBuffer(alignedSize, name);
        }
        removeCluster(size, sn) {
            var _a;
            const alignedSize = roundUp(size, this.byteAlign);
            if (sn < 0) {
                this._clustersAll.delete(alignedSize);
                this._clustersCur.delete(alignedSize);
                return;
            }
            const cluster_sn = (_a = this._clustersCur.get(alignedSize)) === null || _a === void 0 ? void 0 : _a._sn;
            const clusters = this._clustersAll.get(alignedSize);
            if (clusters.length > sn) {
                clusters.splice(sn, 1);
                if (clusters.length === 0) {
                    this._clustersAll.delete(alignedSize);
                    this._clustersCur.delete(alignedSize);
                    return;
                }
                else {
                    for (let i = sn; i < clusters.length; i++)
                        clusters[i]._sn--;
                }
            }
            else
                return;
            if (cluster_sn !== undefined
                && cluster_sn === sn) {
                let usedNumMax = -1, usedNum = -1, index = -1;
                for (let i = clusters.length - 1; i > -1; i--) {
                    usedNum = clusters[i].usedNum;
                    if (usedNum > usedNumMax
                        && usedNum < this.clusterMaxBlock) {
                        index = i;
                        usedNumMax = usedNum;
                    }
                }
                if (index >= 0)
                    this._clustersCur.set(alignedSize, clusters[index]);
                else
                    this._clustersCur.delete(alignedSize);
            }
        }
        getBlock(size, user) {
            const alignedSize = roundUp(size, this.byteAlign);
            let cluster = this._clustersCur.get(alignedSize);
            if (!cluster)
                return this._addCluster(alignedSize).getBlock(size, user);
            if (cluster.usedNum < this.clusterMaxBlock)
                return cluster.getBlock(size, user);
            cluster = null;
            const clusters = this._clustersAll.get(alignedSize);
            let usedNumMax = -1, usedNum = -1, index = -1;
            for (let i = clusters.length - 1; i > 0; i--) {
                usedNum = clusters[i].usedNum;
                if (usedNum > usedNumMax
                    && usedNum < this.clusterMaxBlock) {
                    index = i;
                    usedNumMax = usedNum;
                }
            }
            if (index >= 0) {
                cluster = clusters[index];
                this._clustersCur.set(alignedSize, cluster);
            }
            else
                this._clustersCur.delete(alignedSize);
            if (cluster)
                return cluster.getBlock(size, user);
            return this._addCluster(alignedSize).getBlock(size, user);
        }
        freeBlock(bb) {
            const cluster = bb.cluster;
            if (cluster) {
                if (cluster.freeBlock(bb)) {
                    if (cluster.usedNum === 0)
                        this.removeCluster(cluster._blockSize, cluster._sn);
                    return true;
                }
                return false;
            }
            return false;
        }
        upload() {
            if (this._useBigBuffer) {
                let cluster;
                for (let i = this._needUpdateClusters.length - 1; i > -1; i--) {
                    cluster = this._needUpdateClusters[i];
                    cluster.upload();
                    cluster._inManagerUpdateArray = false;
                }
                this._needUpdateClusters.length = 0;
            }
        }
        _addUpdateArray(cluster) {
            if (!cluster._inManagerUpdateArray) {
                this._needUpdateClusters.push(cluster);
                cluster._inManagerUpdateArray = true;
            }
        }
        _addRemoveHoleCluster(cluster) {
            if (this._removeHoleArray.indexOf(cluster) === -1)
                this._removeHoleArray.push(cluster);
        }
        _addOptimizeBufferPos(cluster) {
            if (this._optimizeBufferPosArray.indexOf(cluster) === -1)
                this._optimizeBufferPosArray.push(cluster);
        }
        clear() {
            this._clustersAll.forEach(clusters => {
                for (let i = clusters.length - 1; i > -1; i--)
                    clusters[i].clear();
            });
        }
        destroy() {
            if (!this._destroyed) {
                this.clear();
                this._clustersAll.clear();
                this._clustersCur.clear();
                this._destroyed = true;
                return true;
            }
            console.warn('UniformBufferManager: object alreay destroyed!');
            return false;
        }
        createGPUBuffer(size, name, data) {
        }
        writeBuffer(buffer, data, offset, size) {
        }
        statisGPUMemory(bytes) {
        }
    }

    class UniformBufferAlone {
        constructor(size, manager, user) {
            this._destroyed = false;
            this.uploadNum = 0;
            this.data = new ArrayBuffer(size);
            this.buffer = manager.getBufferAlone(size);
            this._manager = manager;
            this._size = size;
            this._alignedSize = roundUp(size, manager.byteAlign);
            this.user = user;
            manager.aloneBuffers.push(this);
        }
        upload() {
            this._manager.writeBuffer(this.buffer, this.data, 0, this._size);
        }
        destroy() {
            if (!this._destroyed) {
                this.data = null;
                if (this.buffer.destroy)
                    this.buffer.destroy();
                this._manager.statisGPUMemory(-this._size);
                this._manager.aloneBuffers.splice(this._manager.aloneBuffers.indexOf(this), 1);
                this._destroyed = true;
                return true;
            }
            console.warn('UniformBufferAlone: object alreay destroyed!');
            return false;
        }
    }

    class UniformBufferUser {
        constructor(name, size, manager, data) {
            this.destroyed = false;
            this.name = name;
            this._strId = '';
            this._items = new Map();
            this._itemNum = 0;
            this.data = data;
            this._size = size;
            this.manager = manager;
            this.needUpload = false;
            if (manager._useBigBuffer) {
                this.bufferBlock = manager.getBlock(size, this);
                this.offset = this.bufferBlock.offset;
            }
            else
                this.bufferAlone = this._createBufferAlone(size, manager);
        }
        _createBufferAlone(size, manager) {
            return new UniformBufferAlone(size, manager, this);
        }
        updateOver() {
            this.needUpload = false;
        }
        notifyGPUBufferChange() {
            const offset = this.bufferBlock.offset - this.offset;
            this.offset = this.bufferBlock.offset;
            this._items.forEach(item => {
                const tac = UniformBufferUser._typeArray(item.type);
                item.view = new tac(this.bufferBlock.cluster.data, item.view.byteOffset + offset, item.size / tac.BYTES_PER_ELEMENT);
            });
            this.clearGPUBufferBind();
            this.needUpload = true;
        }
        clearGPUBufferBind() { }
        addUniform(id, name, type, offset, align, size, elements, count) {
            if (this._items.has(id))
                return;
            this._items.set(id, this._getUniformItem(name, UniformBufferUser._typeArray(type), type, offset, align, size, elements, count));
            if (this._strId.length > 0)
                this._strId += '|';
            this._strId += id;
            this._itemNum++;
        }
        setUniformData(id, data) {
            const item = this._items.get(id);
            if (item) {
                this.needUpload = true;
                if (item.count == 1) {
                    switch (item.type) {
                        case 'int':
                        case 'float':
                            item.view[0] = data;
                            break;
                        case 'vec2':
                            item.view[0] = data.x;
                            item.view[1] = data.y;
                            break;
                        case 'vec3':
                            item.view[0] = data.x;
                            item.view[1] = data.y;
                            item.view[2] = data.z;
                            break;
                        case 'vec4':
                            item.view[0] = data.x;
                            item.view[1] = data.y;
                            item.view[2] = data.z;
                            item.view[3] = data.w;
                            break;
                        case 'mat3':
                            for (let i = 0; i < 3; i++) {
                                item.view[i * 4 + 0] = data.elements[i * 3 + 0];
                                item.view[i * 4 + 1] = data.elements[i * 3 + 1];
                                item.view[i * 4 + 2] = data.elements[i * 3 + 2];
                            }
                            break;
                        case 'mat4':
                            item.view.set(data.elements);
                            break;
                    }
                }
                else {
                    const arraySize = item.count * item.elements;
                    const alignElements = item.size / item.count / item.view.BYTES_PER_ELEMENT;
                    for (let i = 0, j = 0; i < arraySize; i += item.elements, j += alignElements)
                        item.view.set(data.subarray(i, i + item.elements), j);
                }
            }
        }
        setBool(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data ? 1 : 0;
                this.needUpload = true;
            }
        }
        setBoolArray(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++)
                    item.view[i] = data[i] ? 1 : 0;
                this.needUpload = true;
            }
        }
        setInt(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data;
                this.needUpload = true;
            }
        }
        setIntArray(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++)
                    item.view[i] = data[i];
                this.needUpload = true;
            }
        }
        setFloat(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data;
                this.needUpload = true;
            }
        }
        setFloatArray(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++)
                    item.view[i] = data[i];
                this.needUpload = true;
            }
        }
        setVector2(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data.x;
                item.view[1] = data.y;
                this.needUpload = true;
            }
        }
        setVector2Array(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++) {
                    item.view[i * 2 + 0] = data[i].x;
                    item.view[i * 2 + 1] = data[i].y;
                }
                this.needUpload = true;
            }
        }
        setVector3(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data.x;
                item.view[1] = data.y;
                item.view[2] = data.z;
                this.needUpload = true;
            }
        }
        setVector3Array(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++) {
                    item.view[i * 4 + 0] = data[i].x;
                    item.view[i * 4 + 1] = data[i].y;
                    item.view[i * 4 + 2] = data[i].z;
                }
                this.needUpload = true;
            }
        }
        setVector4(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data.x;
                item.view[1] = data.y;
                item.view[2] = data.z;
                item.view[3] = data.w;
                this.needUpload = true;
            }
        }
        setVector4Array(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++) {
                    item.view[i * 4 + 0] = data[i].x;
                    item.view[i * 4 + 1] = data[i].y;
                    item.view[i * 4 + 2] = data[i].z;
                    item.view[i * 4 + 3] = data[i].w;
                }
                this.needUpload = true;
            }
        }
        setMatrix3x3(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0; i < 3; i++) {
                    item.view[i * 4 + 0] = data.elements[i * 3 + 0];
                    item.view[i * 4 + 1] = data.elements[i * 3 + 1];
                    item.view[i * 4 + 2] = data.elements[i * 3 + 2];
                }
                this.needUpload = true;
            }
        }
        setMatrix3x3Array(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let j = 0, len = Math.min(item.count, data.length); j < len; j++) {
                    for (let i = 0; i < 3; i++) {
                        item.view[j * 16 + i * 4 + 0] = data[j].elements[i * 3 + 0];
                        item.view[j * 16 + i * 4 + 1] = data[j].elements[i * 3 + 1];
                        item.view[j * 16 + i * 4 + 2] = data[j].elements[i * 3 + 2];
                    }
                }
                this.needUpload = true;
            }
        }
        setMatrix4x4(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view.set(data.elements);
                this.needUpload = true;
            }
        }
        setMatrix4x4Array(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++)
                    item.view.set(data[i].elements, i * 16);
                this.needUpload = true;
            }
        }
        setBuffer(id, data) {
            this.setUniformData(id, data);
        }
        getUniform(id) {
            return this._items.get(id);
        }
        hasUniform(id) {
            return this._items.has(id);
        }
        isMe(strId) {
            return this._strId === strId;
        }
        upload() {
            if (this.needUpload) {
                if (this.manager._useBigBuffer)
                    this.bufferBlock.needUpload();
                else
                    this.bufferAlone.upload();
                this.needUpload = false;
            }
        }
        clear() {
            if (this.manager._useBigBuffer)
                new Uint8Array(this.bufferBlock.cluster.data).fill(0, this.bufferBlock.offset, this.bufferBlock.offset + this.bufferBlock.size);
            else
                new Uint8Array(this.bufferAlone.data).fill(0);
            this._strId = '';
            this._items.clear();
            this._itemNum = 0;
            this.needUpload = false;
        }
        destroy() {
            if (!this.destroyed) {
                if (this.manager._useBigBuffer)
                    this.manager.freeBlock(this.bufferBlock);
                else
                    this.bufferAlone.destroy();
                this.destroyed = true;
                return true;
            }
            console.warn('UniformBufferUser: object alreay destroyed!');
            return false;
        }
        _getUniformItem(name, tac, type, offset, align, size, elements, count) {
            let view;
            if (this.manager._useBigBuffer)
                view = new tac(this.bufferBlock.cluster.data, this.bufferBlock.offset + offset, size / tac.BYTES_PER_ELEMENT);
            else
                view = new tac(this.bufferAlone.data, offset, size / tac.BYTES_PER_ELEMENT);
            return { name, view, type, align, size, elements, count };
        }
        static _typeArray(type) {
            switch (type) {
                case 'int':
                    return Int32Array;
                case 'float':
                case 'vec2':
                case 'vec3':
                case 'vec4':
                case 'mat3':
                case 'mat4':
                    return Float32Array;
                default:
                    return Float32Array;
            }
        }
    }

    exports.BaseRenderType = void 0;
    (function (BaseRenderType) {
        BaseRenderType[BaseRenderType["BaseRender"] = 0] = "BaseRender";
        BaseRenderType[BaseRenderType["MeshRender"] = 1] = "MeshRender";
        BaseRenderType[BaseRenderType["ParticleRender"] = 2] = "ParticleRender";
        BaseRenderType[BaseRenderType["TrailRender"] = 3] = "TrailRender";
        BaseRenderType[BaseRenderType["LineRender"] = 4] = "LineRender";
        BaseRenderType[BaseRenderType["TerrainRender"] = 5] = "TerrainRender";
        BaseRenderType[BaseRenderType["SkyRender"] = 7] = "SkyRender";
        BaseRenderType[BaseRenderType["SimpleSkinRender"] = 8] = "SimpleSkinRender";
        BaseRenderType[BaseRenderType["SkinnedMeshRender"] = 9] = "SkinnedMeshRender";
    })(exports.BaseRenderType || (exports.BaseRenderType = {}));
    exports.ENodeCustomData = void 0;
    (function (ENodeCustomData) {
        ENodeCustomData[ENodeCustomData["custom_0"] = 0] = "custom_0";
        ENodeCustomData[ENodeCustomData["custom_1"] = 1] = "custom_1";
        ENodeCustomData[ENodeCustomData["custom_2"] = 2] = "custom_2";
    })(exports.ENodeCustomData || (exports.ENodeCustomData = {}));

    class ShaderDefine {
        constructor(index, value) {
            this._index = index;
            this._value = value;
        }
    }

    class BlendState {
        static create(blendType, colorBlendhash, alphaBlendComponent) {
        }
        constructor(blendType) {
            this.blendType = 0;
        }
    }
    BlendState._blend_All_pool = {};
    BlendState._blend_seperate_pool = {};
    class BlendComponent {
        static getHash(blendOperationGLData, sourceBlendFactor, destinationFactor) {
            return (blendOperationGLData) + (sourceBlendFactor << 3) + (destinationFactor << 7);
        }
        static getBlendComponent(blendOperationGLData, sourceBlendFactor, destinationFactor) {
            let index = BlendComponent.getHash(blendOperationGLData, sourceBlendFactor, destinationFactor);
            if (!BlendComponent._pool[index])
                BlendComponent._pool[index] = new BlendComponent(blendOperationGLData, sourceBlendFactor, destinationFactor, index);
            return BlendComponent._pool[index];
        }
        constructor(blendOperationGLData, sourceBlendFactor, destinationFactor, hashindex) {
            this._hashIndex = 0;
            this._hashIndex = hashindex;
            this._blendOperationGLData = blendOperationGLData;
            this._sourceBlendFactor = sourceBlendFactor;
            this._destinationFactor = destinationFactor;
        }
    }
    BlendComponent._pool = {};

    class Buffer {
        get bufferUsage() {
            return this._bufferUsage;
        }
        constructor(targetType, bufferUsageType) {
            this._byteLength = 0;
            this._bufferType = targetType;
            this._bufferUsage = bufferUsageType;
        }
        destroy() {
        }
    }

    class IndexBuffer extends Buffer {
        constructor(targetType, bufferUsageType) {
            super(targetType, bufferUsageType);
            this._indexType = exports.IndexFormat.UInt16;
        }
    }

    exports.RenderClearFlag = void 0;
    (function (RenderClearFlag) {
        RenderClearFlag[RenderClearFlag["Nothing"] = 0] = "Nothing";
        RenderClearFlag[RenderClearFlag["Color"] = 1] = "Color";
        RenderClearFlag[RenderClearFlag["Depth"] = 2] = "Depth";
        RenderClearFlag[RenderClearFlag["Stencil"] = 4] = "Stencil";
    })(exports.RenderClearFlag || (exports.RenderClearFlag = {}));

    exports.RenderDrawMode = void 0;
    (function (RenderDrawMode) {
        RenderDrawMode[RenderDrawMode["TRIANGLES"] = 0] = "TRIANGLES";
        RenderDrawMode[RenderDrawMode["POINTS"] = 1] = "POINTS";
        RenderDrawMode[RenderDrawMode["LINES"] = 2] = "LINES";
    })(exports.RenderDrawMode || (exports.RenderDrawMode = {}));

    exports.RenderIndexMode = void 0;
    (function (RenderIndexMode) {
        RenderIndexMode[RenderIndexMode["UNSIGNED_BYTE"] = 0] = "UNSIGNED_BYTE";
        RenderIndexMode[RenderIndexMode["UNSIGNED_SHORT"] = 1] = "UNSIGNED_SHORT";
        RenderIndexMode[RenderIndexMode["UNSIGNED_INT"] = 2] = "UNSIGNED_INT";
    })(exports.RenderIndexMode || (exports.RenderIndexMode = {}));

    exports.RenderStateType = void 0;
    (function (RenderStateType) {
        RenderStateType[RenderStateType["DepthTest"] = 0] = "DepthTest";
        RenderStateType[RenderStateType["DepthMask"] = 1] = "DepthMask";
        RenderStateType[RenderStateType["DepthFunc"] = 2] = "DepthFunc";
        RenderStateType[RenderStateType["StencilTest"] = 3] = "StencilTest";
        RenderStateType[RenderStateType["StencilMask"] = 4] = "StencilMask";
        RenderStateType[RenderStateType["StencilFunc"] = 5] = "StencilFunc";
        RenderStateType[RenderStateType["StencilOp"] = 6] = "StencilOp";
        RenderStateType[RenderStateType["BlendType"] = 7] = "BlendType";
        RenderStateType[RenderStateType["BlendEquation"] = 8] = "BlendEquation";
        RenderStateType[RenderStateType["BlendEquationSeparate"] = 9] = "BlendEquationSeparate";
        RenderStateType[RenderStateType["BlendFunc"] = 10] = "BlendFunc";
        RenderStateType[RenderStateType["BlendFuncSeperate"] = 11] = "BlendFuncSeperate";
        RenderStateType[RenderStateType["CullFace"] = 12] = "CullFace";
        RenderStateType[RenderStateType["FrontFace"] = 13] = "FrontFace";
    })(exports.RenderStateType || (exports.RenderStateType = {}));

    exports.TextureCompareMode = void 0;
    (function (TextureCompareMode) {
        TextureCompareMode[TextureCompareMode["None"] = 0] = "None";
        TextureCompareMode[TextureCompareMode["LEQUAL"] = 1] = "LEQUAL";
        TextureCompareMode[TextureCompareMode["GEQUAL"] = 2] = "GEQUAL";
        TextureCompareMode[TextureCompareMode["LESS"] = 3] = "LESS";
        TextureCompareMode[TextureCompareMode["GREATER"] = 4] = "GREATER";
        TextureCompareMode[TextureCompareMode["EQUAL"] = 5] = "EQUAL";
        TextureCompareMode[TextureCompareMode["NOTEQUAL"] = 6] = "NOTEQUAL";
        TextureCompareMode[TextureCompareMode["ALWAYS"] = 7] = "ALWAYS";
        TextureCompareMode[TextureCompareMode["NEVER"] = 8] = "NEVER";
    })(exports.TextureCompareMode || (exports.TextureCompareMode = {}));

    exports.TextureDecodeFormat = void 0;
    (function (TextureDecodeFormat) {
        TextureDecodeFormat[TextureDecodeFormat["Normal"] = 0] = "Normal";
        TextureDecodeFormat[TextureDecodeFormat["RGBM"] = 1] = "RGBM";
    })(exports.TextureDecodeFormat || (exports.TextureDecodeFormat = {}));

    class GLSLCodeGenerator {
        static glslAttributeString(attributeMap) {
            let res = "";
            for (const key in attributeMap) {
                let type = getAttributeType(attributeMap[key][1]);
                if (type != "") {
                    res = `${res}attribute ${type} ${key};\n`;
                }
            }
            return res;
        }
        static glslUniformString(uniformsMap, useUniformBlock, blockName) {
            if (uniformsMap.size == 0) {
                return "";
            }
            if (useUniformBlock) {
                let uniformsStr = "";
                let blockStr = `uniform ${blockName}{\n`;
                let blockPropertyCount = 0;
                uniformsMap.forEach((uniform, key) => {
                    let dataType = uniform.uniformtype;
                    let uniformName = uniform.propertyName;
                    if (uniform.arrayLength > 0) {
                        uniformName = `${uniformName}[${uniform.arrayLength}]`;
                    }
                    let typeStr = getAttributeType(dataType);
                    if (typeStr != "") {
                        if (supportUniformBlock(dataType)) {
                            blockStr += `${typeStr} ${uniformName};\n`;
                            blockPropertyCount++;
                        }
                        else {
                            uniformsStr += `uniform ${typeStr} ${uniformName};\n`;
                        }
                    }
                });
                blockStr += "};\n";
                if (blockPropertyCount > 0) {
                    return blockStr + uniformsStr;
                }
                else {
                    return uniformsStr;
                }
            }
            else {
                let uniformsStr = "";
                uniformsMap.forEach((uniform, id) => {
                    let dataType = uniform.uniformtype;
                    let uniformName = uniform.propertyName;
                    if (uniform.arrayLength > 0) ;
                    let typeStr = getAttributeType(dataType);
                    if (typeStr != "") {
                        uniformsStr += `uniform ${typeStr} ${uniformName};\n`;
                    }
                });
                return uniformsStr;
            }
        }
        static GLShaderLanguageProcess3D(defineString, attributeMap, uniformMap, VS, FS) {
            var clusterSlices = Config3D.lightClusterCount;
            var defMap = {};
            var vertexHead;
            var fragmentHead;
            var defineStr = "";
            let useUniformBlock = Config.matUseUBO;
            let attributeglsl = GLSLCodeGenerator.glslAttributeString(attributeMap);
            let materialUniformGlsl = GLSLCodeGenerator.glslUniformString(uniformMap, useUniformBlock, "Material");
            if (LayaGL.renderEngine.getParams(exports.RenderParams.SHADER_CAPAILITY_LEVEL) > 30) {
                if (defineString.indexOf("GRAPHICS_API_GLES3") === -1) {
                    defineString.push("GRAPHICS_API_GLES3");
                }
                vertexHead =
                    `#version 300 es
#if defined(GL_FRAGMENT_PRECISION_HIGH)
    precision highp float;
    precision highp int;
    precision highp sampler2DArray;
    precision highp sampler3D;
#else
    precision mediump float;
    precision mediump int;
    precision mediump sampler2DArray;
    precision mediump sampler3D;
#endif
layout(std140, column_major) uniform;
#define attribute in
#define varying out
#define textureCube texture
#define texture2D texture
${attributeglsl}

${materialUniformGlsl}
`;
                fragmentHead =
                    `#version 300 es
#if defined(GL_FRAGMENT_PRECISION_HIGH)
    precision highp float;
    precision highp int;
    precision highp sampler2DArray;
	precision highp sampler3D;
#else
    precision mediump float;
    precision mediump int;
    precision mediump sampler2DArray;
	precision mediump sampler3D;
#endif
layout(std140, column_major) uniform;
#define varying in
out highp vec4 pc_fragColor;
#define gl_FragColor pc_fragColor
#define gl_FragDepthEXT gl_FragDepth
#define texture2D texture
#define textureCube texture
#define texture2DProj textureProj
#define texture2DLodEXT textureLod
#define texture2DProjLodEXT textureProjLod
#define textureCubeLodEXT textureLod
#define texture2DGradEXT textureGrad
#define texture2DProjGradEXT textureProjGrad
#define textureCubeGradEXT textureGrad

${materialUniformGlsl}`;
            }
            else {
                vertexHead =
                    `#if defined(GL_FRAGMENT_PRECISION_HIGH)
    precision highp float;
    precision highp int;
#else
    precision mediump float;
    precision mediump int;
#endif
${attributeglsl}
${materialUniformGlsl}`;
                fragmentHead =
                    `#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif

#ifdef GL_OES_standard_derivatives
	#extension GL_OES_standard_derivatives : enable 
#endif

#if defined(GL_FRAGMENT_PRECISION_HIGH)
    precision highp float;
    precision highp int;
#else
    precision mediump float;
    precision mediump int;
#endif

#if !defined(GL_EXT_shader_texture_lod)
    #define texture1DLodEXT texture1D
    #define texture2DLodEXT texture2D
    #define texture2DProjLodEXT texture2DProj
    #define texture3DLodEXT texture3D
    #define textureCubeLodEXT textureCube
#endif
${materialUniformGlsl}`;
            }
            defineStr += "#define MAX_LIGHT_COUNT " + Config3D.maxLightCount + "\n";
            defineStr += "#define MAX_LIGHT_COUNT_PER_CLUSTER " + Config3D._maxAreaLightCountPerClusterAverage + "\n";
            defineStr += "#define CLUSTER_X_COUNT " + clusterSlices.x + "\n";
            defineStr += "#define CLUSTER_Y_COUNT " + clusterSlices.y + "\n";
            defineStr += "#define CLUSTER_Z_COUNT " + clusterSlices.z + "\n";
            defineStr += "#define MORPH_MAX_COUNT " + Config3D.maxMorphTargetCount + "\n";
            defineStr += "#define SHADER_CAPAILITY_LEVEL " + LayaGL.renderEngine.getParams(exports.RenderParams.SHADER_CAPAILITY_LEVEL) + "\n";
            for (var i = 0, n = defineString.length; i < n; i++) {
                var def = defineString[i];
                defineStr += "#define " + def + "\n";
                defMap[def] = true;
            }
            var vs = VS.toscript(defMap, []);
            var vsVersion = '';
            if (vs[0].indexOf('#version') == 0) {
                vsVersion = vs[0] + '\n';
                vs.shift();
            }
            var ps = FS.toscript(defMap, []);
            var psVersion = '';
            if (ps[0].indexOf('#version') == 0) {
                psVersion = ps[0] + '\n';
                ps.shift();
            }
            let dstVS = vsVersion + vertexHead + defineStr + vs.join('\n');
            let detFS = psVersion + fragmentHead + defineStr + ps.join('\n');
            return { vs: dstVS, fs: detFS };
        }
    }
    function getAttributeType(type) {
        switch (type) {
            case exports.ShaderDataType.Int:
                return "int";
            case exports.ShaderDataType.Bool:
                return "bool";
            case exports.ShaderDataType.Float:
                return "float";
            case exports.ShaderDataType.Vector2:
                return "vec2";
            case exports.ShaderDataType.Vector3:
                return "vec3";
            case exports.ShaderDataType.Vector4:
            case exports.ShaderDataType.Color:
                return "vec4";
            case exports.ShaderDataType.Matrix4x4:
                return "mat4";
            case exports.ShaderDataType.Matrix3x3:
                return "mat3";
            case exports.ShaderDataType.Texture2D:
                return "sampler2D";
            case exports.ShaderDataType.TextureCube:
                return "samplerCube";
            case exports.ShaderDataType.Texture2DArray:
                if (LayaGL.renderEngine.getCapable(exports.RenderCapable.Texture3D)) {
                    return "sampler2DArray";
                }
                else {
                    return "";
                }
            case exports.ShaderDataType.Texture3D:
                if (LayaGL.renderEngine.getCapable(exports.RenderCapable.Texture3D)) {
                    return "sampler3D";
                }
                else {
                    return "";
                }
            default:
                return "";
        }
    }
    function supportUniformBlock(type) {
        switch (type) {
            case exports.ShaderDataType.Int:
            case exports.ShaderDataType.Float:
            case exports.ShaderDataType.Vector2:
            case exports.ShaderDataType.Vector3:
            case exports.ShaderDataType.Vector4:
            case exports.ShaderDataType.Color:
            case exports.ShaderDataType.Matrix4x4:
            case exports.ShaderDataType.Matrix3x3:
            case exports.ShaderDataType.Bool:
                return true;
            default:
                return false;
        }
    }

    class ShaderVariable {
        constructor() {
            this.onID = ShaderVariable.pointID++;
            this.textureID = -1;
        }
    }
    ShaderVariable.pointID = 0;

    class ShaderVariantCollection {
        constructor(items) {
            this.items = items || {};
        }
        add(shaderPass, defines, is2D) {
            let shader = shaderPass._owner._owner;
            let subShaderIndex = shader._subShaders.indexOf(shaderPass._owner);
            let passIndex = shaderPass._owner._passes.indexOf(shaderPass);
            let nodeCommonMap = shaderPass.nodeCommonMap ? shaderPass.nodeCommonMap.slice().sort() : [];
            let additionMap = shaderPass.additionShaderData ? shaderPass.additionShaderData.slice().sort() : [];
            let attributeLocationSet = shaderPass.moduleData.attributeLocations;
            let attributeLocations = attributeLocationSet ? Array.from(attributeLocationSet) : [];
            let configDefs = [];
            defines = defines.slice().filter((v) => {
                let configDef = Shader3D._configDefineValues.has(Shader3D.getDefineByName(v));
                if (v == "GRAPHICS_API_GLES3") {
                    configDef = true;
                }
                if (configDef) {
                    configDefs.push(v);
                }
                return !configDef;
            }).sort();
            let col = this.items[shader._name];
            if (!col) {
                col = [];
                this.items[shader._name] = col;
            }
            if (col.some(v => {
                return (v.is2D === is2D &&
                    v.subShaderIndex === subShaderIndex &&
                    v.passIndex === passIndex &&
                    v.defines.length === defines.length &&
                    v.defines.every((name, index) => name === defines[index]) &&
                    v.nodeCommonMap.length === nodeCommonMap.length &&
                    v.nodeCommonMap.every((name, index) => name === nodeCommonMap[index]) &&
                    v.additionMap.length === additionMap.length &&
                    v.additionMap.every((name, index) => name === additionMap[index]) &&
                    v.attributeLocations.length === attributeLocations.length &&
                    v.attributeLocations.every((location, index) => location === attributeLocations[index]));
            }))
                return;
            col.push({
                is2D: is2D,
                subShaderIndex: subShaderIndex,
                passIndex: passIndex,
                defines: defines,
                nodeCommonMap: nodeCommonMap,
                additionMap: additionMap,
                attributeLocations: attributeLocations
            });
            console.debug(`Shader variant: ${shader._name}/${subShaderIndex}/${passIndex}/${defines.join(",")}/${nodeCommonMap ? nodeCommonMap.join(",") : ""}/${additionMap ? additionMap.join(",") : ""}_${configDefs.join(",")}`);
        }
        compileAll() {
            let items = this.items;
            for (let shaderName in items) {
                let variants = items[shaderName];
                for (let variant of variants) {
                    let suc = Shader3D.compileShaderByDefineNames(shaderName, variant.subShaderIndex, variant.passIndex, variant.defines, variant.nodeCommonMap, variant.additionMap, variant.is2D, variant.attributeLocations);
                    let msg = `${shaderName}/${variant.subShaderIndex}/${variant.passIndex}/${variant.defines.join(",")}/${variant.nodeCommonMap ? variant.nodeCommonMap.join(",") : ""}/${variant.additionMap ? variant.additionMap.join(",") : ""}`;
                    if (suc)
                        console.debug("Warm up", msg);
                    else
                        console.warn("Warm up failed!", msg);
                }
            }
        }
        destroy() {
            this.items = {};
        }
    }
    ShaderVariantCollection.active = new ShaderVariantCollection();

    class StencilState {
    }

    class VertexAttributeLayout {
        static getVertexLayoutByPool(vertexs) {
            let pool = VertexAttributeLayout._pool;
            for (var i in pool) {
                let layout = pool[i];
                if (layout.deepthEqaul(vertexs)) {
                    return layout;
                }
            }
            return new VertexAttributeLayout(vertexs);
        }
        constructor(vertexs) {
            this.VAElements = new Array();
            this.attributeByteSize = new Array();
            this.instanceMode = new Array();
            for (let i = 0; i < vertexs.length; i++) {
                let vaelements = [];
                let oneAttributeSize = vertexs[i].vertexDeclaration.vertexStride;
                let vdec = vertexs[i].vertexDeclaration._VAElements;
                for (let j = 0; j < vdec.length; j++) {
                    vaelements.push({ format: vdec[j].format, stride: vdec[j].stride, shaderLocation: vdec[j].shaderLocation });
                }
                this.attributeByteSize.push(oneAttributeSize);
                this.VAElements.push(vaelements);
                this.instanceMode.push(vertexs[i].instanceBuffer);
            }
            this.id = VertexAttributeLayout.IPoint;
            VertexAttributeLayout._pool[VertexAttributeLayout.IPoint++] = this;
        }
        deepthEqaul(vertexs) {
            if (vertexs.length != this.VAElements.length) {
                return false;
            }
            for (var i = 0; i < vertexs.length; i++) {
                let vaelemets = vertexs[i]._vertexDeclaration._VAElements;
                let thisVaeEs = this.VAElements[i];
                if (vaelemets.length != thisVaeEs.length) {
                    return false;
                }
                else {
                    for (var ii = 0, nn = vaelemets.length; ii < nn; ii++) {
                        let v0 = vaelemets[ii];
                        let v1 = thisVaeEs[ii];
                        if (v0.format != v1.format || v0.stride != v1.stride || v0.shaderLocation != v1.shaderLocation)
                            return false;
                    }
                }
            }
            return true;
        }
    }
    VertexAttributeLayout.IPoint = 0;
    VertexAttributeLayout._pool = {};

    class VertexBuffer extends Buffer {
        get vertexDeclaration() {
            return this._vertexDeclaration;
        }
        set vertexDeclaration(value) {
            this._vertexDeclaration = value;
        }
        get instanceBuffer() {
            return this._instanceBuffer;
        }
        set instanceBuffer(value) {
            this._instanceBuffer = value;
        }
        constructor(targetType, bufferUsageType) {
            super(targetType, bufferUsageType);
            this._instanceBuffer = false;
            this._vertexDeclaration = null;
        }
    }

    class AnimatorState2DScript {
        setPlayScriptInfo(animator, layerindex, playstate) {
            this.playStateInfo.animator = animator;
            this.playStateInfo.layerindex = layerindex;
            this.playStateInfo.playState = playstate;
        }
        constructor() {
            this.playStateInfo = { animator: null, layerindex: -1, playState: null };
        }
        onStateEnter() {
        }
        onStateUpdate(normalizeTime) {
        }
        onStateExit() {
        }
        onStateSwitch(currentState) {
        }
        onStateLoop() {
        }
    }

    var _definiteIntegralMap = {};
    class BlurEffect2D extends PostProcess2DEffect {
        get shaderV1() {
            return this._shaderV1;
        }
        set shaderV1(value) {
            if (value != this._shaderV1) {
                value.cloneTo(this._shaderV1);
            }
            this._mat && this._mat.setVector4("u_strength_sig2_2sig2_gauss1", this._shaderV1);
            this._owner && this._owner._onChangeRender();
        }
        constructor(strength) {
            super();
            this._centerScale = new Vector2();
            this._shaderV1 = new Vector4();
            this._blurInfo = new Vector2();
            this._shaderV1 = new Vector4();
            this.strength = strength !== null && strength !== void 0 ? strength : 4;
        }
        effectInit(postprocess) {
            this._owner = postprocess;
            (!this._mat) && (this._mat = new Material());
            this._mat.setShaderName("BlurEffect2D");
            if (!this._renderElement) {
                this._renderElement = LayaGL.render2DRenderPassFactory.createRenderElement2D();
                this._renderElement.geometry = Blit2DCMD.InvertQuadGeometry;
                this._renderElement.nodeCommonMap = null;
                this._renderElement.renderStateIsBySprite = false;
                this._renderElement.materialShaderData = this._mat.shaderData;
                this._renderElement.subShader = this._mat.shader.getSubShaderAt(0);
            }
            this._mat.setVector4("u_strength_sig2_2sig2_gauss1", this._shaderV1);
            this._mat.setVector2("u_centerScale", this._centerScale);
            this._mat.lock = true;
        }
        render(context) {
            let marginLeft = 50;
            let marginTop = 50;
            let width = context.indirectTarget.width;
            let height = context.indirectTarget.height;
            let texwidth = width + 2 * marginLeft;
            let texheight = height + 2 * marginTop;
            this._blurInfo.setValue(texwidth, texheight);
            this._checkRenderTarget(texwidth, texheight, context);
            this._centerScale.setValue(width / texwidth, height / texheight);
            this._mat.setVector2("u_centerScale", this._centerScale);
            this._mat.setVector2("u_blurInfo", this._blurInfo);
            this._mat.setTexture("u_MainTex", context.indirectTarget);
            context.command.setRenderTarget(this._destRT, true, Color.CLEAR);
            context.command.drawRenderElement(this._renderElement, Matrix.EMPTY);
            context.destination = this._destRT;
        }
        _checkRenderTarget(width, height, context) {
            if (this._destRT && (this._destRT._inPool || this._destRT.destroyed || this._destRT.width !== width || this._destRT.height !== height)) {
                RenderTexture2D.recoverToPool(this._destRT);
                this._destRT = null;
            }
            if (!this._destRT) {
                this._destRT = context.getRenderTexture(width, height, exports.RenderTargetFormat.R8G8B8A8, exports.RenderTargetFormat.None);
            }
        }
        clearRT(context) {
            if (this._destRT && this._destRT !== context.destination) {
                RenderTexture2D.recoverToPool(this._destRT);
                this._destRT = null;
            }
        }
        get strength() {
            return this._strength;
        }
        set strength(v) {
            if (v == this._strength)
                return;
            this._strength = Math.max(Math.abs(v), 2);
            var sigma = this._strength / 3.0;
            var sigma2 = sigma * sigma;
            let v1 = this._shaderV1.setValue(this.strength, sigma2, 2.0 * sigma2, 1.0 / (2.0 * Math.PI * sigma2));
            let s = 0;
            let key = Math.floor(this.strength * 10);
            if (_definiteIntegralMap[key] != undefined) {
                s = _definiteIntegralMap[key];
            }
            else {
                for (let y = -4; y <= 4; ++y) {
                    for (let x = -4; x <= 4; ++x) {
                        s += v1.w * Math.exp(-(x * x + y * y) / v1.z);
                    }
                }
                _definiteIntegralMap[key] = s;
            }
            v1.w /= s;
            this.shaderV1 = v1;
        }
        destroy() {
            var _a;
            super.destroy();
            if (this._destRT) {
                RenderTexture2D.recoverToPool(this._destRT);
            }
            this._destRT = null;
            this._mat.destroy();
            this._mat = null;
            (_a = this._renderElement) === null || _a === void 0 ? void 0 : _a.destroy();
            this._renderElement = null;
        }
    }
    ClassUtils.regClass("BlurEffect2D", BlurEffect2D);

    const DELTA_INDEX = [0, 0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1, 0.11, 0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24, 0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42, 0.44, 0.46, 0.48, 0.5, 0.53, 0.56, 0.59, 0.62, 0.65, 0.68, 0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98, 1.0, 1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54, 1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0, 2.12, 2.25, 2.37, 2.50, 2.62, 2.75, 2.87, 3.0, 3.2, 3.4, 3.6, 3.8, 4.0, 4.3, 4.7, 4.9, 5.0, 5.5, 6.0, 6.5, 6.8, 7.0, 7.3, 7.5, 7.8, 8.0, 8.4, 8.7, 9.0, 9.4, 9.6, 9.8, 10.0];
    const GRAY_MATRIX = [0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0, 0, 0, 1, 0];
    const IDENTITY_MATRIX = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
    const LENGTH = 25;
    class ColorEffect2D extends PostProcess2DEffect {
        constructor(matrix) {
            super();
            this._colorMat = new Matrix4x4();
            this._centerScale = new Vector2();
            this._alpha = new Vector4();
            this._colorArray = new Float32Array(16);
            this._alphaArray = new Float32Array(4);
            this.setByMatrix(matrix || IDENTITY_MATRIX);
        }
        get colorMat() {
            return this._colorMat;
        }
        set colorMat(value) {
            if (value != this._colorMat) {
                value.cloneTo(this._colorMat);
            }
            this._mat && this._mat.setMatrix4x4("u_colorMat", this.colorMat);
            this._owner && this._owner._onChangeRender();
        }
        gray() {
            return this.setByMatrix(GRAY_MATRIX);
        }
        get alpha() {
            return this._alpha;
        }
        set alpha(value) {
            if (value != this._alpha) {
                value.cloneTo(this._alpha);
            }
            this._mat && this._mat.setVector4("u_colorAlpha", this.alpha);
            this._owner && this._owner._onChangeRender();
        }
        effectInit(postprocess) {
            this._owner = postprocess;
            (!this._mat || this._mat.destroyed) && (this._mat = new Material());
            this._mat.setShaderName("ColorEffect2D");
            this._mat.setMatrix4x4("u_colorMat", this._colorMat);
            this._mat.setVector4("u_colorAlpha", this._alpha);
            this._mat.addDefine(Shader3D.getDefineByName("COLORFILTER"));
            this._centerScale.setValue(1, 1);
            this._mat.setVector2("u_centerScale", this._centerScale);
            this._mat.lock = true;
            if (!this._renderElement) {
                this._renderElement = LayaGL.render2DRenderPassFactory.createRenderElement2D();
                this._renderElement.geometry = Blit2DCMD.InvertQuadGeometry;
                this._renderElement.nodeCommonMap = null;
                this._renderElement.renderStateIsBySprite = false;
                this._renderElement.materialShaderData = this._mat.shaderData;
                this._renderElement.subShader = this._mat.shader.getSubShaderAt(0);
            }
        }
        setByMatrix(matrix) {
            if (this._matrix != matrix) {
                if (!this._matrix)
                    this._matrix = [];
                for (var i = 0; i < LENGTH; i++) {
                    this._matrix[i] = matrix[i];
                }
            }
            var j = 0;
            var z = 0;
            for (var i = 0; i < 20; i++) {
                if (i % 5 != 4) {
                    this._colorArray[j++] = matrix[i];
                }
                else {
                    this._alphaArray[z++] = matrix[i];
                }
            }
            this.alpha.setValue(this._alphaArray[0], this._alphaArray[1], this._alphaArray[2], this._alphaArray[3]);
            this.alpha = this.alpha;
            Matrix4x4.TEMP.cloneByArray(this._colorArray);
            this.colorMat = Matrix4x4.TEMP;
            return this;
        }
        color(red = 0, green = 0, blue = 0, alpha = 1) {
            return this.setByMatrix([red, 0, 0, 0, 1, 0, green, 0, 0, 1, 0, 0, blue, 0, 1, 0, 0, 0, alpha, 0]);
        }
        setColor(color) {
            tmpColor.parse(color);
            return this.color(tmpColor.r, tmpColor.g, tmpColor.b, 1);
        }
        adjustColor(brightness, contrast, saturation, hue) {
            this.adjustHue(hue);
            this.adjustContrast(contrast);
            this.adjustBrightness(brightness);
            this.adjustSaturation(saturation);
            return this;
        }
        adjustBrightness(brightness) {
            brightness = this._clampValue(brightness, 100);
            if (brightness == 0 || isNaN(brightness))
                return this;
            return this._multiplyMatrix([1, 0, 0, 0, brightness, 0, 1, 0, 0, brightness, 0, 0, 1, 0, brightness, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        adjustContrast(contrast) {
            contrast = this._clampValue(contrast, 100);
            if (contrast == 0 || isNaN(contrast))
                return this;
            var x;
            if (contrast < 0) {
                x = 127 + contrast / 100 * 127;
            }
            else {
                x = contrast % 1;
                if (x == 0) {
                    x = DELTA_INDEX[contrast];
                }
                else {
                    x = DELTA_INDEX[(contrast << 0)] * (1 - x) + DELTA_INDEX[(contrast << 0) + 1] * x;
                }
                x = x * 127 + 127;
            }
            var x1 = x / 127;
            var x2 = (127 - x) * 0.5;
            return this._multiplyMatrix([x1, 0, 0, 0, x2, 0, x1, 0, 0, x2, 0, 0, x1, 0, x2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        adjustSaturation(saturation) {
            saturation = this._clampValue(saturation, 100);
            if (saturation == 0 || isNaN(saturation))
                return this;
            var x = 1 + ((saturation > 0) ? 3 * saturation / 100 : saturation / 100);
            var dx = 1 - x;
            var r = 0.3086 * dx;
            var g = 0.6094 * dx;
            var b = 0.0820 * dx;
            return this._multiplyMatrix([r + x, g, b, 0, 0, r, g + x, b, 0, 0, r, g, b + x, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        adjustHue(hue) {
            hue = this._clampValue(hue, 180) / 180 * Math.PI;
            if (hue == 0 || isNaN(hue))
                return this;
            var cos = Math.cos(hue);
            var sin = Math.sin(hue);
            var r = 0.213;
            var g = 0.715;
            var b = 0.072;
            return this._multiplyMatrix([r + cos * (1 - r) + sin * (-r), g + cos * (-g) + sin * (-g), b + cos * (-b) + sin * (1 - b), 0, 0, r + cos * (-r) + sin * (0.143), g + cos * (1 - g) + sin * (0.140), b + cos * (-b) + sin * (-0.283), 0, 0, r + cos * (-r) + sin * (-(1 - r)), g + cos * (-g) + sin * (g), b + cos * (1 - b) + sin * (b), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        reset() {
            return this.setByMatrix(IDENTITY_MATRIX);
        }
        _multiplyMatrix(matrix) {
            var col = [];
            this._matrix = this._fixMatrix(this._matrix);
            for (var i = 0; i < 5; i++) {
                for (var j = 0; j < 5; j++) {
                    col[j] = this._matrix[j + i * 5];
                }
                for (j = 0; j < 5; j++) {
                    var val = 0;
                    for (var k = 0; k < 5; k++) {
                        val += matrix[j + k * 5] * col[k];
                    }
                    this._matrix[j + i * 5] = val;
                }
            }
            return this.setByMatrix(this._matrix);
        }
        _fixMatrix(matrix = null) {
            if (matrix == null)
                return IDENTITY_MATRIX;
            if (matrix.length < LENGTH)
                matrix = matrix.slice(0, matrix.length).concat(IDENTITY_MATRIX.slice(matrix.length, LENGTH));
            else if (matrix.length > LENGTH)
                matrix = matrix.slice(0, LENGTH);
            return matrix;
        }
        _clampValue(val, limit) {
            return Math.min(limit, Math.max(-limit, val));
        }
        render(context) {
            this._checkRenderTarget(context.indirectTarget.width, context.indirectTarget.height, context);
            this._mat.setTexture("u_MainTex", context.indirectTarget);
            context.command.setRenderTarget(this._destRT, true, Color.CLEAR);
            context.command.drawRenderElement(this._renderElement, Matrix.EMPTY);
            context.destination = this._destRT;
        }
        _checkRenderTarget(width, height, context) {
            if (this._destRT && (this._destRT._inPool || this._destRT.destroyed || this._destRT.width !== width || this._destRT.height !== height)) {
                RenderTexture2D.recoverToPool(this._destRT);
                this._destRT = null;
            }
            if (!this._destRT) {
                this._destRT = context.getRenderTexture(width, height, exports.RenderTargetFormat.R8G8B8A8, exports.RenderTargetFormat.None);
            }
        }
        clearRT(context) {
            if (this._destRT && this._destRT !== context.destination) {
                RenderTexture2D.recoverToPool(this._destRT);
                this._destRT = null;
            }
        }
        onAfterDeserialize() {
            if (SerializeUtil.hasProp("_color"))
                this.setColor(this._color || "#ffffff");
            if (SerializeUtil.hasProp("_brightness", "_contrast", "_saturation", "_hue"))
                this.adjustColor(this._brightness || 0, this._contrast || 0, this._saturation || 0, this._hue || 0);
        }
        destroy() {
            super.destroy();
            if (this._destRT) {
                RenderTexture2D.recoverToPool(this._destRT);
            }
            this._destRT = null;
            this._mat && (this._mat.destroy());
            this._renderElement && (this._renderElement.destroy());
        }
    }
    const tmpColor = new Color();
    ClassUtils.regClass("ColorEffect2D", ColorEffect2D);
    class GrayscaleEffect2D extends ColorEffect2D {
        constructor() {
            super(GRAY_MATRIX);
        }
    }
    ClassUtils.regClass("GrayscaleEffect2D", GrayscaleEffect2D);

    class GlowEffect2D extends PostProcess2DEffect {
        get sv_blurInfo1() {
            return this._sv_blurInfo1;
        }
        set sv_blurInfo1(value) {
            if (value !== this._sv_blurInfo1) {
                value.cloneTo(this._sv_blurInfo1);
            }
            this._glowMat && (this._glowMat.setVector4("u_blurInfo1", this._sv_blurInfo1));
            this._owner && this._owner._onChangeRender();
        }
        get sv_blurInfo2() {
            return this._sv_blurInfo2;
        }
        set sv_blurInfo2(value) {
            if (value !== this._sv_blurInfo2) {
                value.cloneTo(this._sv_blurInfo2);
            }
            this._glowMat && (this._glowMat.setVector4("u_blurInfo2", this._sv_blurInfo2));
            this._owner && this._owner._onChangeRender();
        }
        get color() {
            return this._color;
        }
        set color(value) {
            this._color = value;
            this._colorVec.fromArray(ColorUtils.create(value).arrColor);
            this._glowMat && (this._glowMat.setVector4("u_color", this._colorVec));
            this._owner && this._owner._onChangeRender();
        }
        get blur() {
            return this._sv_blurInfo1.y;
        }
        set blur(value) {
            this._sv_blurInfo1.x = this._sv_blurInfo1.y = value;
            this.sv_blurInfo1 = this._sv_blurInfo1;
        }
        get offsetY() {
            return this._sv_blurInfo1.w;
        }
        set offsetY(value) {
            if (value !== this._sv_blurInfo1.w) {
                this._sv_blurInfo1.w = value;
                this.sv_blurInfo1 = this._sv_blurInfo1;
            }
        }
        get offsetX() {
            return this._sv_blurInfo1.z;
        }
        set offsetX(value) {
            if (value !== this._sv_blurInfo1.z) {
                this._sv_blurInfo1.z = value;
                this.sv_blurInfo1 = this._sv_blurInfo1;
            }
        }
        constructor(color, blur, offX, offY) {
            super();
            this._blitcenterScale = new Vector2();
            this._sv_blurInfo1 = new Vector4();
            this._sv_blurInfo2 = new Vector4(0, 0, 1, 0);
            this._colorVec = new Vector4();
            this.color = color || "#000";
            this.blur = blur !== null && blur !== void 0 ? blur : 4;
            this.offsetX = offX !== null && offX !== void 0 ? offX : 6;
            this.offsetY = offY !== null && offY !== void 0 ? offY : 6;
        }
        effectInit(postprocess) {
            this._owner = postprocess;
            (!this._blitmat) && (this._blitmat = new Material());
            this._blitmat.setShaderName("ColorEffect2D");
            if (!this._blitElement) {
                this._blitElement = LayaGL.render2DRenderPassFactory.createRenderElement2D();
                this._blitElement.geometry = Blit2DCMD.InvertQuadGeometry;
                this._blitElement.nodeCommonMap = null;
                this._blitElement.renderStateIsBySprite = false;
                this._blitElement.materialShaderData = this._blitmat.shaderData;
                this._blitElement.subShader = this._blitmat.shader.getSubShaderAt(0);
            }
            (!this._glowMat) && (this._glowMat = new Material());
            this._glowMat.setShaderName("glow2D");
            this._glowMat.setVector4("u_color", this._colorVec);
            this._glowMat.setVector4("u_blurInfo1", this.sv_blurInfo1);
            this._glowMat.lock = true;
            if (!this._glowElement) {
                this._glowElement = LayaGL.render2DRenderPassFactory.createRenderElement2D();
                this._glowElement.geometry = Blit2DCMD.InvertQuadGeometry;
                this._glowElement.nodeCommonMap = null;
                this._glowElement.renderStateIsBySprite = false;
                this._glowElement.materialShaderData = this._glowMat.shaderData;
                this._glowElement.subShader = this._glowMat.shader.getSubShaderAt(0);
            }
            (!this._compositeMat) && (this._compositeMat = new Material());
            this._compositeMat.setShaderName("ColorEffect2D");
            if (!this._compositeElement) {
                this._compositeElement = LayaGL.render2DRenderPassFactory.createRenderElement2D();
                this._compositeElement.geometry = Blit2DCMD.InvertQuadGeometry;
                this._compositeElement.nodeCommonMap = null;
                this._compositeElement.renderStateIsBySprite = false;
                this._compositeElement.materialShaderData = this._compositeMat.shaderData;
                this._compositeElement.subShader = this._compositeMat.shader.getSubShaderAt(0);
            }
        }
        render(context) {
            let marginLeft = 50;
            let marginTop = 50;
            let width = context.indirectTarget.width;
            let height = context.indirectTarget.height;
            let texwidth = width + 2 * marginLeft;
            let texheight = height + 2 * marginTop;
            this._checkRenderTarget(texwidth, texheight, context);
            this._blitmat.setTexture("u_MainTex", context.indirectTarget);
            this._blitcenterScale.setValue(width / texwidth, height / texheight);
            this._blitmat.setVector2("u_centerScale", this._blitcenterScale);
            context.command.setRenderTarget(this._blitExtendRT, true, Color.CLEAR);
            context.command.drawRenderElement(this._blitElement, Matrix.EMPTY);
            this._glowMat.setVector2("u_centerScale", Vector2.ONE);
            this._glowMat.setTexture("u_MainTex", this._blitExtendRT);
            this._sv_blurInfo2.x = width;
            this._sv_blurInfo2.y = height;
            this._glowMat.setVector4("u_blurInfo2", this._sv_blurInfo2);
            context.command.setRenderTarget(this._destRT, true, Color.CLEAR);
            context.command.drawRenderElement(this._glowElement, Matrix.EMPTY);
            this._compositeMat.setTexture("u_MainTex", this._blitExtendRT);
            this._compositeMat.setVector2("u_centerScale", Vector2.ONE);
            context.command.drawRenderElement(this._compositeElement, Matrix.EMPTY);
            context.destination = this._destRT;
        }
        _checkRenderTarget(width, height, context) {
            if (this._destRT && (this._destRT._inPool || this._destRT.destroyed || this._destRT.width !== width || this._destRT.height !== height)) {
                RenderTexture2D.recoverToPool(this._destRT);
                this._destRT = null;
            }
            if (this._blitExtendRT && (this._blitExtendRT._inPool || this._blitExtendRT.destroyed || this._blitExtendRT.width !== width || this._blitExtendRT.height !== height)) {
                RenderTexture2D.recoverToPool(this._blitExtendRT);
                this._blitExtendRT = null;
            }
            if (!this._destRT) {
                this._destRT = context.getRenderTexture(width, height, exports.RenderTargetFormat.R8G8B8A8, exports.RenderTargetFormat.None);
            }
            if (!this._blitExtendRT) {
                this._blitExtendRT = context.getRenderTexture(width, height, exports.RenderTargetFormat.R8G8B8A8, exports.RenderTargetFormat.None);
            }
        }
        clearRT(context) {
            if (this._blitExtendRT && this._blitExtendRT !== context.destination) {
                RenderTexture2D.recoverToPool(this._blitExtendRT);
                this._blitExtendRT = null;
            }
            if (this._destRT && this._destRT !== context.destination) {
                RenderTexture2D.recoverToPool(this._destRT);
                this._destRT = null;
            }
        }
        destroy() {
            super.destroy();
            if (this._destRT) {
                RenderTexture2D.recoverToPool(this._destRT);
            }
            this._destRT = null;
            if (this._blitExtendRT) {
                RenderTexture2D.recoverToPool(this._blitExtendRT);
            }
            this._blitExtendRT = null;
            this._blitmat && (this._blitmat.destroy());
            this._blitmat = null;
            this._blitElement && (this._blitElement.destroy());
            this._blitElement = null;
            this._glowMat && (this._glowMat.destroy());
            this._glowMat = null;
            this._glowElement && (this._glowElement.destroy());
            this._glowElement = null;
            this._compositeMat && (this._compositeMat.destroy());
            this._compositeMat = null;
            this._compositeElement && (this._compositeElement.destroy());
            this._compositeElement = null;
        }
    }
    ClassUtils.regClass("GlowEffect2D", GlowEffect2D);

    class CircleMesh {
        onPopulateMesh(vb) {
            let rect = vb.contentRect;
            const radiusX = rect.width / 2;
            const radiusY = rect.height / 2;
            let sides = Math.ceil(Math.PI * (radiusX + radiusY) / 4);
            sides = MathUtil.clamp(sides, 40, 800);
            const angleDelta = 2 * Math.PI / sides;
            let angle = 0;
            const centerX = rect.x + radiusX;
            const centerY = rect.y + radiusY;
            vb.addVert(centerX, centerY);
            for (let i = 0; i < sides; i++) {
                let vx = Math.cos(angle) * radiusX + centerX;
                let vy = Math.sin(angle) * radiusY + centerY;
                vb.addVert(vx, vy);
                angle += angleDelta;
            }
            for (let i = 0; i < sides; i++) {
                if (i != sides - 1)
                    vb.addTriangle(0, i + 1, i + 2);
                else
                    vb.addTriangle(0, i + 1, 1);
            }
        }
    }
    ClassUtils.regClass("CircleMesh", CircleMesh);

    class FlipMesh {
        constructor() {
            this.flipX = true;
            this.flipY = false;
        }
        onPopulateMesh(vb) {
            var _a;
            const tmpUV = Rectangle.create();
            let uvRect = tmpUV.copyFrom(vb.uvRect);
            if (this.flipX) {
                let tmp = uvRect.x;
                uvRect.x = uvRect.right;
                uvRect.right = tmp;
            }
            if (this.flipY) {
                let tmp = uvRect.y;
                uvRect.y = uvRect.bottom;
                uvRect.bottom = tmp;
            }
            let sizeGrid = (_a = vb.mainTex) === null || _a === void 0 ? void 0 : _a._sizeGrid;
            if (sizeGrid) {
                let gridRect = Rectangle.create();
                let sourceWidth = vb.mainTex.sourceWidth;
                let sourceHeight = vb.mainTex.sourceHeight;
                gridRect.setTo(sizeGrid[3], sizeGrid[0], sourceWidth - sizeGrid[1] - sizeGrid[3], sourceHeight - sizeGrid[0] - sizeGrid[2]);
                if (this.flipX)
                    gridRect.x = sourceWidth - gridRect.right;
                if (this.flipY)
                    gridRect.y = sourceHeight - gridRect.bottom;
                genSliceMesh(vb, vb.contentRect, uvRect, gridRect, sizeGrid[4] === 1 ? 0xff : 0);
            }
            else {
                vb.addQuad(vb.contentRect, null, uvRect);
                vb.triangulateQuad(0);
            }
            tmpUV.recover();
        }
    }
    ClassUtils.regClass("FlipMesh", FlipMesh);

    exports.FillMethod = void 0;
    (function (FillMethod) {
        FillMethod[FillMethod["None"] = 0] = "None";
        FillMethod[FillMethod["Horizontal"] = 1] = "Horizontal";
        FillMethod[FillMethod["Vertical"] = 2] = "Vertical";
        FillMethod[FillMethod["Radial90"] = 3] = "Radial90";
        FillMethod[FillMethod["Radial180"] = 4] = "Radial180";
        FillMethod[FillMethod["Radial360"] = 5] = "Radial360";
    })(exports.FillMethod || (exports.FillMethod = {}));
    exports.FillOrigin = void 0;
    (function (FillOrigin) {
        FillOrigin[FillOrigin["Top"] = 0] = "Top";
        FillOrigin[FillOrigin["Bottom"] = 1] = "Bottom";
        FillOrigin[FillOrigin["Left"] = 2] = "Left";
        FillOrigin[FillOrigin["Right"] = 3] = "Right";
        FillOrigin[FillOrigin["TopLeft"] = 0] = "TopLeft";
        FillOrigin[FillOrigin["TopRight"] = 1] = "TopRight";
        FillOrigin[FillOrigin["BottomLeft"] = 2] = "BottomLeft";
        FillOrigin[FillOrigin["BottomRight"] = 3] = "BottomRight";
    })(exports.FillOrigin || (exports.FillOrigin = {}));
    class ProgressMesh {
        constructor() {
            this.origin = 0;
            this.amount = 0.6;
            this.clockwise = true;
            this._method = 5;
        }
        get method() {
            return this._method;
        }
        set method(value) {
            if (this._method != value) {
                this._method = value;
                if (!LayaEnv.isPlaying
                    && (value === exports.FillMethod.Horizontal || value === exports.FillMethod.Vertical)
                    && this.origin > 1)
                    this.origin = 0;
            }
        }
        onPopulateMesh(vb) {
            let amount = MathUtil.clamp01(this.amount);
            switch (this.method) {
                case exports.FillMethod.Horizontal:
                    fillHorizontal(vb, vb.contentRect, this.origin, amount);
                    break;
                case exports.FillMethod.Vertical:
                    fillVertical(vb, vb.contentRect, this.origin, amount);
                    break;
                case exports.FillMethod.Radial90:
                    fillRadial90(vb, vb.contentRect, this.origin, amount, this.clockwise);
                    break;
                case exports.FillMethod.Radial180:
                    fillRadial180(vb, vb.contentRect, this.origin, amount, this.clockwise);
                    break;
                case exports.FillMethod.Radial360:
                    fillRadial360(vb, vb.contentRect, this.origin, amount, this.clockwise);
                    break;
                default:
                    vb.addQuad(vb.contentRect);
                    vb.triangulateQuad(0);
                    break;
            }
        }
    }
    ClassUtils.regClass("ProgressMesh", ProgressMesh);
    function fillHorizontal(vb, vertRect, origin, amount) {
        const tmpRect = Rectangle.create();
        let rect = tmpRect.copyFrom(vertRect);
        let a = rect.width * amount;
        if (origin === exports.FillOrigin.Right || origin === exports.FillOrigin.Bottom)
            rect.x += (rect.width - a);
        rect.width = a;
        vb.addQuad(rect);
        vb.triangulateQuad(0);
        tmpRect.recover();
    }
    function fillVertical(vb, vertRect, origin, amount) {
        const tmpRect = Rectangle.create();
        let rect = tmpRect.copyFrom(vertRect);
        let a = rect.height * amount;
        if (origin === exports.FillOrigin.Right || origin === exports.FillOrigin.Bottom)
            rect.y += (rect.height - a);
        rect.height = a;
        vb.addQuad(rect);
        vb.triangulateQuad(0);
        tmpRect.recover();
    }
    function fillRadial90(vb, vertRect, origin, amount, clockwise) {
        let flipX = origin === exports.FillOrigin.TopRight || origin === exports.FillOrigin.BottomRight;
        let flipY = origin === exports.FillOrigin.BottomLeft || origin === exports.FillOrigin.BottomRight;
        if (flipX !== flipY)
            clockwise = !clockwise;
        let ratio = clockwise ? amount : (1 - amount);
        let tan = Math.tan(Math.PI * 0.5 * ratio);
        let thresold = false;
        if (ratio !== 1)
            thresold = (vertRect.height / vertRect.width - tan) > 0;
        if (!clockwise)
            thresold = !thresold;
        let x = vertRect.x + (ratio === 0 ? Number.MAX_VALUE : (vertRect.height / tan));
        let y = vertRect.y + (ratio === 1 ? Number.MAX_VALUE : (vertRect.width * tan));
        let x2 = x;
        let y2 = y;
        if (flipX)
            x2 = vertRect.width - x;
        if (flipY)
            y2 = vertRect.height - y;
        let xMin = flipX ? (vertRect.width - vertRect.x) : vertRect.x;
        let yMin = flipY ? (vertRect.height - vertRect.y) : vertRect.y;
        let xMax = flipX ? -vertRect.x : vertRect.right;
        let yMax = flipY ? -vertRect.y : vertRect.bottom;
        vb.addVert(xMin, yMin);
        if (clockwise)
            vb.addVert(xMax, yMin);
        if (y > vertRect.bottom) {
            if (thresold)
                vb.addVert(x2, yMax);
            else
                vb.addVert(xMax, yMax);
        }
        else
            vb.addVert(xMax, y2);
        if (x > vertRect.right) {
            if (thresold)
                vb.addVert(xMax, y2);
            else
                vb.addVert(xMax, yMax);
        }
        else
            vb.addVert(x2, yMax);
        if (!clockwise)
            vb.addVert(xMin, yMax);
        if (flipX === flipY) {
            vb.addTriangle(0, 1, 2);
            vb.addTriangle(0, 2, 3);
        }
        else {
            vb.addTriangle(2, 1, 0);
            vb.addTriangle(3, 2, 0);
        }
    }
    function fillRadial180(vb, vertRect, origin, amount, clockwise) {
        const tmpRect = Rectangle.create();
        let rect = tmpRect.copyFrom(vertRect);
        switch (origin) {
            case exports.FillOrigin.Top:
                if (amount <= 0.5) {
                    rect.width /= 2;
                    if (clockwise)
                        rect.x += rect.width;
                    fillRadial90(vb, rect, clockwise ? exports.FillOrigin.TopLeft : exports.FillOrigin.TopRight, amount / 0.5, clockwise);
                    let vec = vb.getPos(-4);
                    vb.addQuad(Rectangle.TEMP.setTo(vec.x, vec.y, 0, 0));
                    vb.triangulateQuad(-4);
                }
                else {
                    rect.width /= 2;
                    if (!clockwise)
                        rect.x += rect.width;
                    fillRadial90(vb, rect, clockwise ? exports.FillOrigin.TopRight : exports.FillOrigin.TopLeft, (amount - 0.5) / 0.5, clockwise);
                    if (clockwise)
                        rect.x += rect.width;
                    else
                        rect.x -= rect.width;
                    vb.addQuad(rect);
                    vb.triangulateQuad(-4);
                }
                break;
            case exports.FillOrigin.Bottom:
                if (amount <= 0.5) {
                    rect.width /= 2;
                    if (!clockwise)
                        rect.x += rect.width;
                    fillRadial90(vb, rect, clockwise ? exports.FillOrigin.BottomRight : exports.FillOrigin.BottomLeft, amount / 0.5, clockwise);
                    let vec = vb.getPos(-4);
                    vb.addQuad(Rectangle.TEMP.setTo(vec.x, vec.y, 0, 0));
                    vb.triangulateQuad(-4);
                }
                else {
                    rect.width /= 2;
                    if (clockwise)
                        rect.x += rect.width;
                    fillRadial90(vb, rect, clockwise ? exports.FillOrigin.BottomLeft : exports.FillOrigin.BottomRight, (amount - 0.5) / 0.5, clockwise);
                    if (clockwise)
                        rect.x -= rect.width;
                    else
                        rect.x += rect.width;
                    vb.addQuad(rect);
                    vb.triangulateQuad(-4);
                }
                break;
            case exports.FillOrigin.Left:
                if (amount <= 0.5) {
                    rect.height /= 2;
                    if (!clockwise)
                        rect.y += rect.height;
                    fillRadial90(vb, rect, clockwise ? exports.FillOrigin.BottomLeft : exports.FillOrigin.TopLeft, amount / 0.5, clockwise);
                    let vec = vb.getPos(-4);
                    vb.addQuad(Rectangle.TEMP.setTo(vec.x, vec.y, 0, 0));
                    vb.triangulateQuad(-4);
                }
                else {
                    rect.height /= 2;
                    if (clockwise)
                        rect.y += rect.height;
                    fillRadial90(vb, rect, clockwise ? exports.FillOrigin.TopLeft : exports.FillOrigin.BottomLeft, (amount - 0.5) / 0.5, clockwise);
                    if (clockwise)
                        rect.y -= rect.height;
                    else
                        rect.y += rect.height;
                    vb.addQuad(rect);
                    vb.triangulateQuad(-4);
                }
                break;
            case exports.FillOrigin.Right:
                if (amount <= 0.5) {
                    rect.height /= 2;
                    if (clockwise)
                        rect.y += rect.height;
                    fillRadial90(vb, rect, clockwise ? exports.FillOrigin.TopRight : exports.FillOrigin.BottomRight, amount / 0.5, clockwise);
                    let vec = vb.getPos(-4);
                    vb.addQuad(Rectangle.TEMP.setTo(vec.x, vec.y, 0, 0));
                    vb.triangulateQuad(-4);
                }
                else {
                    rect.height /= 2;
                    if (!clockwise)
                        rect.y += rect.height;
                    fillRadial90(vb, rect, clockwise ? exports.FillOrigin.BottomRight : exports.FillOrigin.TopRight, (amount - 0.5) / 0.5, clockwise);
                    if (clockwise)
                        rect.y += rect.height;
                    else
                        rect.y -= rect.height;
                    vb.addQuad(rect);
                    vb.triangulateQuad(-4);
                }
                break;
        }
        tmpRect.recover();
    }
    function fillRadial360(vb, vertRect, origin, amount, clockwise) {
        const tmpRect = Rectangle.create();
        let rect = tmpRect.copyFrom(vertRect);
        switch (origin) {
            case exports.FillOrigin.Top:
                if (amount < 0.5) {
                    rect.width /= 2;
                    if (clockwise)
                        rect.x += rect.width;
                    fillRadial180(vb, rect, clockwise ? exports.FillOrigin.Left : exports.FillOrigin.Right, amount / 0.5, clockwise);
                    let vec = vb.getPos(-8);
                    vb.addQuad(Rectangle.TEMP.setTo(vec.x, vec.y, 0, 0));
                    vb.triangulateQuad(-4);
                }
                else {
                    rect.width /= 2;
                    if (!clockwise)
                        rect.x += rect.width;
                    fillRadial180(vb, rect, clockwise ? exports.FillOrigin.Right : exports.FillOrigin.Left, (amount - 0.5) / 0.5, clockwise);
                    if (clockwise)
                        rect.x += rect.width;
                    else
                        rect.x -= rect.width;
                    vb.addQuad(rect);
                    vb.triangulateQuad(-4);
                }
                break;
            case exports.FillOrigin.Bottom:
                if (amount < 0.5) {
                    rect.width /= 2;
                    if (!clockwise)
                        rect.x += rect.width;
                    fillRadial180(vb, rect, clockwise ? exports.FillOrigin.Right : exports.FillOrigin.Left, amount / 0.5, clockwise);
                    let vec = vb.getPos(-8);
                    vb.addQuad(Rectangle.TEMP.setTo(vec.x, vec.y, 0, 0));
                    vb.triangulateQuad(-4);
                }
                else {
                    rect.width /= 2;
                    if (clockwise)
                        rect.x += rect.width;
                    fillRadial180(vb, rect, clockwise ? exports.FillOrigin.Left : exports.FillOrigin.Right, (amount - 0.5) / 0.5, clockwise);
                    if (clockwise)
                        rect.x -= rect.width;
                    else
                        rect.x += rect.width;
                    vb.addQuad(rect);
                    vb.triangulateQuad(-4);
                }
                break;
            case exports.FillOrigin.Left:
                if (amount < 0.5) {
                    rect.height /= 2;
                    if (!clockwise)
                        rect.y += rect.height;
                    fillRadial180(vb, rect, clockwise ? exports.FillOrigin.Bottom : exports.FillOrigin.Top, amount / 0.5, clockwise);
                    let vec = vb.getPos(-8);
                    vb.addQuad(Rectangle.TEMP.setTo(vec.x, vec.y, 0, 0));
                    vb.triangulateQuad(-4);
                }
                else {
                    rect.height /= 2;
                    if (clockwise)
                        rect.y += rect.height;
                    fillRadial180(vb, rect, clockwise ? exports.FillOrigin.Top : exports.FillOrigin.Bottom, (amount - 0.5) / 0.5, clockwise);
                    if (clockwise)
                        rect.y -= rect.height;
                    else
                        rect.y += rect.height;
                    vb.addQuad(rect);
                    vb.triangulateQuad(-4);
                }
                break;
            case exports.FillOrigin.Right:
                if (amount < 0.5) {
                    rect.height /= 2;
                    if (clockwise)
                        rect.y += rect.height;
                    fillRadial180(vb, rect, clockwise ? exports.FillOrigin.Top : exports.FillOrigin.Bottom, amount / 0.5, clockwise);
                    let vec = vb.getPos(-8);
                    vb.addQuad(Rectangle.TEMP.setTo(vec.x, vec.y, 0, 0));
                    vb.triangulateQuad(-4);
                }
                else {
                    rect.height /= 2;
                    if (!clockwise)
                        rect.y += rect.height;
                    fillRadial180(vb, rect, clockwise ? exports.FillOrigin.Bottom : exports.FillOrigin.Top, (amount - 0.5) / 0.5, clockwise);
                    if (clockwise)
                        rect.y += rect.height;
                    else
                        rect.y -= rect.height;
                    vb.addQuad(rect);
                    vb.triangulateQuad(-4);
                }
                break;
        }
        tmpRect.recover();
    }

    class RegularPolygonMesh {
        constructor() {
            this.sides = 6;
            this.distances = [];
            this.rotation = 0;
            this.lineWidth = 0;
            this.lineColor = null;
            this.centerColor = null;
            this.fillColor = null;
        }
        onPopulateMesh(vb) {
            var _a;
            let color = this.fillColor || vb.color;
            let lineColor = this.lineColor || vb.color;
            const angleDelta = 2 * Math.PI / this.sides;
            let angle = this.rotation * MathUtils3D.Deg2Rad;
            const radius = Math.min(vb.contentRect.width / 2, vb.contentRect.height / 2);
            const lineWidth = this.lineWidth;
            const centerX = radius + vb.contentRect.x;
            const centerY = radius + vb.contentRect.y;
            vb.addVert(centerX, centerY, this.centerColor || color);
            for (let i = 0; i < this.sides; i++) {
                let r = radius;
                if (this.distances != null)
                    r *= (_a = this.distances[i]) !== null && _a !== void 0 ? _a : 1;
                let xv = centerX + Math.cos(angle) * (r - lineWidth);
                let yv = centerY + Math.sin(angle) * (r - lineWidth);
                vb.addVert(xv, yv, color);
                if (lineWidth > 0) {
                    vb.addVert(xv, yv, lineColor);
                    vb.addVert(Math.cos(angle) * r + centerX, Math.sin(angle) * r + centerY, lineColor);
                }
                angle += angleDelta;
            }
            if (lineWidth > 0) {
                let tmp = this.sides * 3;
                for (let i = 0; i < tmp; i += 3) {
                    if (i != tmp - 3) {
                        vb.addTriangle(0, i + 1, i + 4);
                        vb.addTriangle(i + 5, i + 2, i + 3);
                        vb.addTriangle(i + 3, i + 6, i + 5);
                    }
                    else {
                        vb.addTriangle(0, i + 1, 1);
                        vb.addTriangle(2, i + 2, i + 3);
                        vb.addTriangle(i + 3, 3, 2);
                    }
                }
            }
            else {
                for (let i = 0; i < this.sides; i++)
                    vb.addTriangle(0, i + 1, (i === this.sides - 1) ? 1 : i + 2);
            }
        }
    }
    ClassUtils.regClass("RegularPolygonMesh", RegularPolygonMesh);

    class RoundedRectMesh {
        constructor() {
            this.lt = 6;
            this.rt = 6;
            this.lb = 6;
            this.rb = 6;
        }
        onPopulateMesh(vb) {
            let x = vb.contentRect.x;
            let y = vb.contentRect.y;
            let w = vb.contentRect.width;
            let h = vb.contentRect.height;
            let radiusX = w / 2;
            let radiusY = h / 2;
            let cornerMaxRadius = Math.min(radiusX, radiusY);
            let centerX = x + radiusX;
            let centerY = y + radiusY;
            vb.addVert(centerX, centerY);
            let cnt = vb.vertCount;
            for (let i = 0; i < 4; i++) {
                let radius = 0;
                switch (i) {
                    case 0:
                        radius = this.rb;
                        break;
                    case 1:
                        radius = this.lb;
                        break;
                    case 2:
                        radius = this.lt;
                        break;
                    case 3:
                        radius = this.rt;
                        break;
                }
                radius = Math.min(cornerMaxRadius, radius);
                let offsetX = 0;
                let offsetY = 0;
                if (i === 0 || i === 3)
                    offsetX = w - radius * 2;
                if (i === 0 || i === 1)
                    offsetY = h - radius * 2;
                offsetX += x;
                offsetY += y;
                if (radius !== 0) {
                    let partNumSides = Math.max(1, Math.ceil(Math.PI * radius / 8)) + 1;
                    let angleDelta = Math.PI / 2 / partNumSides;
                    let angle = Math.PI / 2 * i;
                    let startAngle = angle;
                    for (let j = 1; j <= partNumSides; j++) {
                        if (j === partNumSides)
                            angle = startAngle + Math.PI / 2;
                        vb.addVert(offsetX + Math.cos(angle) * radius + radius, offsetY + Math.sin(angle) * radius + radius);
                        angle += angleDelta;
                    }
                }
                else {
                    vb.addVert(offsetX, offsetY);
                }
            }
            cnt = vb.vertCount - cnt;
            for (let i = 0; i < cnt; i++)
                vb.addTriangle(0, i + 1, i === cnt - 1 ? 1 : i + 2);
        }
    }
    ClassUtils.regClass("RoundedRectMesh", RoundedRectMesh);

    class TileMesh {
        constructor() {
            this.repeatX = true;
            this.repeatY = true;
        }
        onPopulateMesh(vb) {
            let tex = vb.mainTex;
            if (tex != null
                && vb.uvRect.x == 0 && vb.uvRect.y == 0 && vb.uvRect.width == 1 && vb.uvRect.height == 1
                && tex.bitmap.wrapModeU == exports.WrapMode.Repeat
                && tex.bitmap.wrapModeV == exports.WrapMode.Repeat) {
                let tmpRect = Rectangle.create();
                tmpRect.copyFrom(vb.uvRect);
                if (this.repeatX)
                    tmpRect.width *= vb.contentRect.width / tex.width;
                if (this.repeatY)
                    tmpRect.height *= vb.contentRect.height / tex.height;
                vb.addQuad(vb.contentRect, null, tmpRect);
                vb.triangulateQuad(0);
                tmpRect.recover();
            }
            else {
                genTileMesh(vb, vb.contentRect, vb.uvRect, tex ? tex.sourceWidth : vb.contentRect.width, tex ? tex.sourceHeight : vb.contentRect.height, this.repeatX, this.repeatY);
            }
        }
    }
    ClassUtils.regClass("TileMesh", TileMesh);

    class ButtonEffect {
        constructor() {
            this._curState = 0;
            this.effectScale = 1.5;
            this.tweenTime = 300;
        }
        set target(tar) {
            this._tar = tar;
            tar.on(Event.MOUSE_DOWN, this, this.toChangedState);
            tar.on(Event.MOUSE_UP, this, this.toInitState);
            tar.on(Event.MOUSE_OUT, this, this.toInitState);
        }
        toChangedState() {
            this._curState = 1;
            if (this._curTween)
                Tween.clear(this._curTween);
            this._curTween = Tween.to(this._tar, { scaleX: this.effectScale, scaleY: this.effectScale }, this.tweenTime, Ease[this.effectEase], Handler.create(this, this.tweenComplete));
        }
        toInitState() {
            if (this._curState == 2)
                return;
            if (this._curTween)
                Tween.clear(this._curTween);
            this._curState = 2;
            this._curTween = Tween.to(this._tar, { scaleX: 1, scaleY: 1 }, this.tweenTime, Ease[this.backEase], Handler.create(this, this.tweenComplete));
        }
        tweenComplete() {
            this._curState = 0;
            this._curTween = null;
        }
    }

    class EffectBase extends Component {
        constructor() {
            super(...arguments);
            this.duration = 1000;
            this.delay = 0;
            this.repeat = 0;
            this.autoDestroyAtComplete = true;
        }
        _onAwake() {
            this.target = this.target || this.owner;
            if (this.autoDestroyAtComplete)
                this._comlete = Handler.create(this.target, this.target.destroy, null, false);
            if (this.eventName)
                this.owner.on(this.eventName, this, this._exeTween);
            else
                this._exeTween();
        }
        _exeTween() {
            this._tween = this._doTween();
            this._tween.repeat(this.repeat);
        }
        _doTween() {
            return null;
        }
        onReset() {
            this.duration = 1000;
            this.delay = 0;
            this.repeat = 0;
            this.ease = null;
            this.target = null;
            if (this.eventName) {
                this.owner.off(this.eventName, this, this._exeTween);
                this.eventName = null;
            }
            if (this._comlete) {
                this._comlete.recover();
                this._comlete = null;
            }
            if (this._tween) {
                this._tween.clear();
                this._tween = null;
            }
        }
    }

    class FadeIn extends EffectBase {
        _doTween() {
            this.target.alpha = 0;
            return Tween.to(this.target, { alpha: 1 }, this.duration, Ease[this.ease], this._comlete, this.delay);
        }
    }

    class FadeOut extends EffectBase {
        _doTween() {
            this.target.alpha = 1;
            return Tween.to(this.target, { alpha: 0 }, this.duration, Ease[this.ease], this._comlete, this.delay);
        }
    }

    class KeyLocation {
    }
    KeyLocation.STANDARD = 0;
    KeyLocation.LEFT = 1;
    KeyLocation.RIGHT = 2;
    KeyLocation.NUM_PAD = 3;

    class Keyboard {
    }
    Keyboard.NUMBER_0 = 48;
    Keyboard.NUMBER_1 = 49;
    Keyboard.NUMBER_2 = 50;
    Keyboard.NUMBER_3 = 51;
    Keyboard.NUMBER_4 = 52;
    Keyboard.NUMBER_5 = 53;
    Keyboard.NUMBER_6 = 54;
    Keyboard.NUMBER_7 = 55;
    Keyboard.NUMBER_8 = 56;
    Keyboard.NUMBER_9 = 57;
    Keyboard.A = 65;
    Keyboard.B = 66;
    Keyboard.C = 67;
    Keyboard.D = 68;
    Keyboard.E = 69;
    Keyboard.F = 70;
    Keyboard.G = 71;
    Keyboard.H = 72;
    Keyboard.I = 73;
    Keyboard.J = 74;
    Keyboard.K = 75;
    Keyboard.L = 76;
    Keyboard.M = 77;
    Keyboard.N = 78;
    Keyboard.O = 79;
    Keyboard.P = 80;
    Keyboard.Q = 81;
    Keyboard.R = 82;
    Keyboard.S = 83;
    Keyboard.T = 84;
    Keyboard.U = 85;
    Keyboard.V = 86;
    Keyboard.W = 87;
    Keyboard.X = 88;
    Keyboard.Y = 89;
    Keyboard.Z = 90;
    Keyboard.F1 = 112;
    Keyboard.F2 = 113;
    Keyboard.F3 = 114;
    Keyboard.F4 = 115;
    Keyboard.F5 = 116;
    Keyboard.F6 = 117;
    Keyboard.F7 = 118;
    Keyboard.F8 = 119;
    Keyboard.F9 = 120;
    Keyboard.F10 = 121;
    Keyboard.F11 = 122;
    Keyboard.F12 = 123;
    Keyboard.F13 = 124;
    Keyboard.F14 = 125;
    Keyboard.F15 = 126;
    Keyboard.NUMPAD = 21;
    Keyboard.NUMPAD_0 = 96;
    Keyboard.NUMPAD_1 = 97;
    Keyboard.NUMPAD_2 = 98;
    Keyboard.NUMPAD_3 = 99;
    Keyboard.NUMPAD_4 = 100;
    Keyboard.NUMPAD_5 = 101;
    Keyboard.NUMPAD_6 = 102;
    Keyboard.NUMPAD_7 = 103;
    Keyboard.NUMPAD_8 = 104;
    Keyboard.NUMPAD_9 = 105;
    Keyboard.NUMPAD_ADD = 107;
    Keyboard.NUMPAD_DECIMAL = 110;
    Keyboard.NUMPAD_DIVIDE = 111;
    Keyboard.NUMPAD_ENTER = 108;
    Keyboard.NUMPAD_MULTIPLY = 106;
    Keyboard.NUMPAD_SUBTRACT = 109;
    Keyboard.SEMICOLON = 186;
    Keyboard.EQUAL = 187;
    Keyboard.COMMA = 188;
    Keyboard.MINUS = 189;
    Keyboard.PERIOD = 190;
    Keyboard.SLASH = 191;
    Keyboard.BACKQUOTE = 192;
    Keyboard.LEFTBRACKET = 219;
    Keyboard.BACKSLASH = 220;
    Keyboard.RIGHTBRACKET = 221;
    Keyboard.QUOTE = 222;
    Keyboard.ALTERNATE = 18;
    Keyboard.BACKSPACE = 8;
    Keyboard.CAPS_LOCK = 20;
    Keyboard.COMMAND = 15;
    Keyboard.CONTROL = 17;
    Keyboard.DELETE = 46;
    Keyboard.ENTER = 13;
    Keyboard.ESCAPE = 27;
    Keyboard.PAGE_UP = 33;
    Keyboard.PAGE_DOWN = 34;
    Keyboard.END = 35;
    Keyboard.HOME = 36;
    Keyboard.LEFT = 37;
    Keyboard.UP = 38;
    Keyboard.RIGHT = 39;
    Keyboard.DOWN = 40;
    Keyboard.SHIFT = 16;
    Keyboard.SPACE = 32;
    Keyboard.TAB = 9;
    Keyboard.INSERT = 45;

    class Filter extends EventDispatcher {
        onChange() {
            this.event(Event.CHANGED);
        }
    }

    class BlurFilter extends Filter {
        getEffect() {
            return this._effect2D;
        }
        constructor(strength = 4) {
            super();
            this._effect2D = new BlurEffect2D(strength);
        }
        get strength() {
            return this._effect2D.strength;
        }
        set strength(v) {
            this._effect2D.strength = v;
            this.onChange();
        }
    }
    ClassUtils.regClass("BlurFilter", BlurFilter);

    class ColorFilter extends Filter {
        getEffect() {
            return this._effect2D;
        }
        constructor(mat = null) {
            super();
            this._effect2D = new ColorEffect2D(mat);
        }
        gray() {
            this._effect2D.gray();
            return this;
        }
        color(red = 0, green = 0, blue = 0, alpha = 1) {
            this._effect2D.color(red, green, blue, alpha);
            return this;
        }
        setColor(color) {
            this._effect2D.setColor(color);
            return this;
        }
        setByMatrix(matrix) {
            this._effect2D.setByMatrix(matrix);
            this.onChange();
            return this;
        }
        adjustColor(brightness, contrast, saturation, hue) {
            this._effect2D.adjustColor(brightness, contrast, saturation, hue);
            return this;
        }
        adjustBrightness(brightness) {
            this._effect2D.adjustBrightness(brightness);
            return this;
        }
        adjustContrast(contrast) {
            this._effect2D.adjustContrast(contrast);
            return this;
        }
        adjustSaturation(saturation) {
            this._effect2D.adjustSaturation(saturation);
            return this;
        }
        adjustHue(hue) {
            this._effect2D.adjustHue(hue);
            return this;
        }
        reset() {
            this._effect2D.reset();
            return this;
        }
        onAfterDeserialize() {
            if (SerializeUtil.hasProp("_color"))
                this.setColor(this._color);
            if (SerializeUtil.hasProp("_brightness", "_contrast", "_saturation", "_hue"))
                this.adjustColor(this._brightness || 0, this._contrast || 0, this._saturation || 0, this._hue || 0);
        }
    }
    ClassUtils.regClass("ColorFilter", ColorFilter);

    class GlowFilter extends Filter {
        constructor(color, blur = 4, offX = 6, offY = 6) {
            super();
            this._effect2D = new GlowEffect2D(color, blur, offX, offY);
        }
        getEffect() {
            return this._effect2D;
        }
        get offY() {
            return this._effect2D.offsetY;
        }
        set offY(value) {
            this._effect2D.offsetY = value;
            this.onChange();
        }
        get offX() {
            return this._effect2D.offsetX;
        }
        set offX(value) {
            this._effect2D.offsetX = value;
            this.onChange();
        }
        get color() {
            return this._effect2D.color;
        }
        set color(value) {
            this._effect2D.color = value;
            this.onChange();
        }
        get blur() {
            return this._effect2D.blur;
        }
        set blur(value) {
            this._effect2D.blur = value;
            this.onChange();
        }
    }
    ClassUtils.regClass("GlowFilter", GlowFilter);

    class CommandEncoder {
        constructor() {
            this._idata = [];
        }
        getArrayData() {
            return this._idata;
        }
        getCount() {
            return this._idata.length;
        }
        addShaderUniform(variable) {
            this._idata.push(variable);
        }
    }

    class BooleanKeyframe extends Keyframe {
        cloneTo(destObject) {
            super.cloneTo(destObject);
            destObject.value = this.value;
        }
        clone() {
            let f = new BooleanKeyframe();
            this.cloneTo(f);
            return f;
        }
    }

    class QuaternionKeyframe extends Keyframe {
        constructor(weightMode = false) {
            super();
            this.inTangent = new Vector4();
            this.outTangent = new Vector4();
            this.value = new Quaternion();
            if (weightMode) {
                this.inWeight = new Vector4();
                this.outWeight = new Vector4();
                this.weightedMode = new Vector4();
            }
        }
        cloneTo(dest) {
            super.cloneTo(dest);
            var destKeyFarme = dest;
            this.inTangent.cloneTo(destKeyFarme.inTangent);
            this.outTangent.cloneTo(destKeyFarme.outTangent);
            this.value.cloneTo(destKeyFarme.value);
            if (this.weightedMode) {
                this.inWeight.cloneTo(destKeyFarme.inWeight);
                this.outWeight.cloneTo(destKeyFarme.outWeight);
                this.weightedMode.cloneTo(destKeyFarme.weightedMode);
            }
        }
    }

    class Vector2Keyframe extends Keyframe {
        constructor(weightMode = false) {
            super();
            this.inTangent = new Vector2();
            this.outTangent = new Vector2();
            this.value = new Vector2();
            if (weightMode) {
                this.inWeight = new Vector2(Keyframe.defaultWeight, Keyframe.defaultWeight);
                this.outWeight = new Vector2(Keyframe.defaultWeight, Keyframe.defaultWeight);
                this.weightedMode = new Vector2(exports.WeightedMode.None, exports.WeightedMode.None);
            }
        }
        cloneTo(dest) {
            super.cloneTo(dest);
            this.inTangent.cloneTo(dest.inTangent);
            this.outTangent.cloneTo(dest.outTangent);
            this.value.cloneTo(dest.value);
            if (this.weightedMode) {
                this.inWeight.cloneTo(dest.inWeight);
                this.outWeight.cloneTo(dest.outWeight);
                this.weightedMode.cloneTo(dest.weightedMode);
            }
        }
    }

    class Vector3Keyframe extends Keyframe {
        constructor(weightMode = false) {
            super();
            this.inTangent = new Vector3();
            this.outTangent = new Vector3();
            this.value = new Vector3();
            if (weightMode) {
                this.inWeight = new Vector3(Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight);
                this.outWeight = new Vector3(Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight);
                this.weightedMode = new Vector3(exports.WeightedMode.None, exports.WeightedMode.None, exports.WeightedMode.None);
            }
        }
        cloneTo(dest) {
            super.cloneTo(dest);
            this.inTangent.cloneTo(dest.inTangent);
            this.outTangent.cloneTo(dest.outTangent);
            this.value.cloneTo(dest.value);
            if (this.weightedMode) {
                this.inWeight.cloneTo(dest.inWeight);
                this.outWeight.cloneTo(dest.outWeight);
                this.weightedMode.cloneTo(dest.weightedMode);
            }
        }
    }

    class Vector4Keyframe extends Keyframe {
        constructor(weightMode = false) {
            super();
            this.inTangent = new Vector4();
            this.outTangent = new Vector4();
            this.value = new Vector4();
            if (weightMode) {
                this.inWeight = new Vector4(Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight);
                this.outWeight = new Vector4(Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight);
                this.weightedMode = new Vector4(exports.WeightedMode.None, exports.WeightedMode.None, exports.WeightedMode.None, exports.WeightedMode.None);
            }
        }
        cloneTo(dest) {
            super.cloneTo(dest);
            this.inTangent.cloneTo(dest.inTangent);
            this.outTangent.cloneTo(dest.outTangent);
            this.value.cloneTo(dest.value);
            if (this.weightedMode) {
                this.inWeight.cloneTo(dest.inWeight);
                this.outWeight.cloneTo(dest.outWeight);
                this.weightedMode.cloneTo(dest.weightedMode);
            }
        }
    }

    class Viewport {
        constructor(x, y, width, height) {
            this.minDepth = 0.0;
            this.maxDepth = 1.0;
            this.x = x !== null && x !== void 0 ? x : 0;
            this.y = y !== null && y !== void 0 ? y : 0;
            this.width = width !== null && width !== void 0 ? width : 0;
            this.height = height !== null && height !== void 0 ? height : 0;
        }
        project(source, matrix, out) {
            Vector3.transformV3ToV4(source, matrix, out);
            var x = out.x, y = out.y, z = out.z;
            var w = out.w;
            if (w !== 1.0) {
                x = x / w;
                y = y / w;
                z = z / w;
            }
            out.x = (x + 1.0) * 0.5 * this.width + this.x;
            out.y = (-y + 1.0) * 0.5 * this.height + this.y;
            out.z = z * (this.maxDepth - this.minDepth) + this.minDepth;
        }
        unprojectFromMat(source, matrix, out) {
            var matrixEleme = matrix.elements;
            out.x = (((source.x - this.x) / this.width) * 2.0) - 1.0;
            out.y = -((((source.y - this.y) / this.height) * 2.0) - 1.0);
            out.z = (source.z - this.minDepth) / (this.maxDepth - this.minDepth);
            var a = (((out.x * matrixEleme[3]) + (out.y * matrixEleme[7])) + (out.z * matrixEleme[11])) + matrixEleme[15];
            Vector3.transformV3ToV3(out, matrix, out);
            if (a !== 1.0) {
                out.x = out.x / a;
                out.y = out.y / a;
                out.z = out.z / a;
            }
        }
        unprojectFromWVP(source, projection, view, world, out) {
            Matrix4x4.multiply(projection, view, _tempMatrix4x4);
            (world) && (Matrix4x4.multiply(_tempMatrix4x4, world, _tempMatrix4x4));
            _tempMatrix4x4.invert(_tempMatrix4x4);
            this.unprojectFromMat(source, _tempMatrix4x4, out);
        }
        set(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        cloneTo(out) {
            out.x = this.x;
            out.y = this.y;
            out.width = this.width;
            out.height = this.height;
            out.minDepth = this.minDepth;
            out.maxDepth = this.maxDepth;
        }
    }
    Viewport.TEMP = new Viewport(0, 0, 0, 0);
    const _tempMatrix4x4 = new Matrix4x4();

    const EXPIRE_TIME = 30000;
    const CHECK_INTERVAL = 10000;
    class AudioDataCache {
        constructor() {
            this._size = 0;
            this._lastCheck = 0;
            this._items = {};
        }
        add(url, obj, size) {
            if (this._items[url])
                this._size -= this._items[url].size;
            let time = performance.now();
            this._items[url] = { obj, size: size, time };
            this._size += size;
            if (this._size > Config.audioBufferCacheMaxSize && time - this._lastCheck > CHECK_INTERVAL) {
                this._lastCheck = time;
                for (let key in this._items) {
                    let item2 = this._items[key];
                    if (time - item2.time > EXPIRE_TIME) {
                        this._size -= item2.size;
                        delete this._items[key];
                        console.debug("AudioDataCache: remove " + key);
                    }
                }
            }
        }
        get(url, callback, callbackThis) {
            let item = this._items[url];
            if (item != null) {
                item.time = performance.now();
                callback.call(callbackThis, item.obj);
                return;
            }
            ILaya.loader.load(url, { type: Loader.SOUND, cache: false }).then(buffer => {
                if (buffer)
                    this.add(url, buffer, buffer.__byteLength);
                callback.call(callbackThis, buffer);
            });
        }
    }

    class SoundChannel extends EventDispatcher {
        constructor(url) {
            super();
            this.playbackRate = 1;
            this._started = false;
            this._paused = false;
            this._loaded = false;
            this._completed = false;
            this._repeated = 0;
            this._volumeSet = 1;
            this._volume = 1;
            this._muted = false;
            this._startTime = 0;
            this._pauseTime = 0;
            this._isMusic = false;
            this._autoResume = false;
            this.url = url;
        }
        get volume() {
            return this._volumeSet;
        }
        set volume(value) {
            this._volumeSet = value;
            let t = value * (this._isMusic ? SoundManager.musicVolume : SoundManager.soundVolume);
            if (t !== this._volume) {
                this._volume = t;
                if (this._loaded)
                    this.onVolumeChanged();
            }
        }
        get muted() {
            return this._muted;
        }
        set muted(value) {
            value = !!value;
            if (this._muted == value)
                return;
            this._muted = value;
            if (this._loaded)
                this.onMuted();
        }
        get position() {
            if (this._paused)
                return this._pauseTime;
            else if (this._startTime != 0)
                return (performance.now() - this._startTime) / 1000 + this.startTime;
            else
                return this.startTime;
        }
        get duration() {
            return 0;
        }
        get paused() {
            return this._paused;
        }
        get isStopped() {
            return !this._started;
        }
        play() {
            if (this._started) {
                if (this._paused)
                    this.resume();
                return;
            }
            this._started = true;
            this._loaded = false;
            this._completed = false;
            this._repeated = 0;
            this._startTime = performance.now();
            SoundManager.addChannel(this);
            AssetDb.inst.resolveURL(this.url, url => {
                if (!this._started)
                    return;
                if (!url) {
                    this.stop();
                    return;
                }
                this.onPlay(url);
            });
        }
        stop() {
            if (!this._started)
                return;
            this._started = false;
            this._loaded = false;
            SoundManager.removeChannel(this);
            this.onStop();
            this.callComplete(this._completed);
        }
        pause() {
            if (!this._started || this._paused)
                return;
            this._pauseTime = this.position;
            this._paused = true;
            this._autoResume = false;
            if (this._loaded)
                this.onPause();
        }
        resume() {
            if (!this._started || !this._paused)
                return;
            this._paused = false;
            if (this._loaded)
                this.onResume();
        }
        onPlay(url) {
        }
        onPlayAgain() {
        }
        onStop() {
        }
        onPause() {
        }
        onResume() {
        }
        onVolumeChanged() {
        }
        onMuted() {
        }
        onPlayEnd() {
            this._repeated++;
            if (this.loops > 0 && this._repeated >= this.loops) {
                this._completed = true;
                this.stop();
            }
            else
                this.onPlayAgain();
        }
        callComplete(success) {
            if (success)
                this.event(Event.COMPLETE);
            if (!this.completeHandler)
                return;
            let handler = this.completeHandler;
            this.completeHandler = null;
            if (handler instanceof Handler)
                handler.runWith(success !== null && success !== void 0 ? success : true);
            else
                handler(success !== null && success !== void 0 ? success : true);
        }
    }

    class HTMLAudioChannel extends SoundChannel {
        get position() {
            if (this._ele)
                return this._ele.currentTime;
            else
                return 0;
        }
        get duration() {
            if (this._ele)
                return this._ele.duration;
            else
                return 0;
        }
        onPlay(url) {
            this._ele = HTMLAudioChannel.elementPool.take();
            Browser.container.appendChild(this._ele);
            this._loaded = true;
            let ele = this._ele;
            ele.onerror = (event) => {
                console.error("HTMLAudioChannel: ", event);
                this.stop();
            };
            ele.onended = () => this.onPlayEnd();
            ele.src = URL.postFormatURL(URL.formatURL(url));
            ele.playbackRate = this.playbackRate;
            ele.currentTime = this.startTime;
            ele.loop = this.loops === 0;
            ele.volume = this._volume;
            ele.muted = this._muted;
            if (!this._paused) {
                if (ele.readyState > 0 && !ele.paused)
                    return;
                Promise.resolve().then(() => {
                    if (!this._ele)
                        return;
                    this._ele.play().catch(e => {
                        if (e.name === "NotAllowedError" && this._isMusic)
                            PAL.media.resumeUntilGotFocus(this);
                        else
                            console.warn(e);
                    });
                });
            }
        }
        onPlayAgain() {
            this._ele.currentTime = this.startTime;
            this._ele.play().catch(e => { });
        }
        onStop() {
            this._ele.pause();
            HTMLAudioChannel.elementPool.recover(this._ele);
            this._ele = null;
        }
        onPause() {
            this._ele.pause();
        }
        onResume() {
            if (this._ele.readyState === 0)
                this._ele.load();
            this._ele.play().catch(e => { });
        }
        onVolumeChanged() {
            this._ele.volume = this._volume;
        }
        onMuted() {
            this._ele.muted = this._muted;
        }
    }
    HTMLAudioChannel.elementPool = Pool.createPool2(() => createAudioElement(), null, ele => resetAudioElement(ele));
    function createAudioElement() {
        return Browser.createElement("audio");
    }
    function resetAudioElement(ele) {
        ele.remove();
        ele.src = "";
        ele.onended = null;
        ele.onerror = null;
        ele.oncanplay = null;
        ele.oncanplaythrough = null;
    }

    class VideoPlayer {
        constructor() {
            this.options = {};
            this.allowBackground = false;
            this._playing = false;
            this._loaded = false;
            this._autoResume = false;
        }
        get currentTime() {
            return 0;
        }
        set currentTime(value) {
        }
        get volume() {
            return 0;
        }
        set volume(value) {
        }
        get muted() {
            return false;
        }
        set muted(value) {
        }
        get duration() {
            return 0;
        }
        get ended() {
            return false;
        }
        get loop() {
            return false;
        }
        set loop(value) {
        }
        get playbackRate() {
            return 1;
        }
        set playbackRate(value) {
        }
        get paused() {
            return false;
        }
        attachTo(owner) {
            if (this._owner) {
                this._owner.off(Event.TRANSFORM_CHANGED, this, this.onTransformChanged);
                ILaya.stage.off(Event.RESIZE, this, this.onTransformChanged);
            }
            this._owner = owner;
            if (this._owner) {
                this._owner.on(Event.TRANSFORM_CHANGED, this, this.onTransformChanged);
                ILaya.stage.on(Event.RESIZE, this, this.onTransformChanged);
            }
        }
        load(url) {
            if (!url)
                return;
            AssetDb.inst.resolveURL(url, url2 => this.onLoad(url2));
        }
        play() {
            if (this._playing || !LayaEnv.isPlaying)
                return;
            this._playing = true;
            ILaya.stage.on(Event.BLUR, this, this.onBlur);
            if (this._loaded)
                this.onPlay();
        }
        pause() {
            this._autoResume = false;
            if (!this._playing)
                return;
            this._playing = false;
            ILaya.stage.off(Event.BLUR, this, this.onBlur);
            if (this._loaded)
                this.onPause();
        }
        resume() {
            this.play();
        }
        setLoaded() {
            this._loaded = true;
            this.onTransformChanged();
            if (this._playing)
                this.onPlay();
        }
        getNodeTransform() {
            let trans;
            if (Browser.onTTMiniGame) {
                trans = SpriteUtils.getGlobalPosAndScale(this._owner);
                trans.x *= ILaya.stage.clientScaleX;
                trans.y *= ILaya.stage.clientScaleY;
                trans.scaleX *= ILaya.stage.clientScaleX;
                trans.scaleY *= ILaya.stage.clientScaleY;
            }
            else
                trans = SpriteUtils.getTransformRelativeToWindow(this._owner, 0, 0);
            return { x: trans.x, y: trans.y, width: Math.round(this._owner.width * trans.scaleX), height: Math.round(this._owner.height * trans.scaleY) };
        }
        onTransformChanged() {
        }
        destroy() {
            this.onDestroy();
            this.attachTo(null);
            ILaya.stage.off(Event.BLUR, this, this.onBlur);
        }
        onBlur() {
            if (!this.allowBackground)
                PAL.media.resumeUntilGotFocus(this);
        }
        onLoad(url) {
        }
        onPlay() {
        }
        onPause() {
        }
        onDestroy() {
        }
    }

    class HTMLVideoPlayer extends VideoPlayer {
        constructor() {
            super();
            this.element = HTMLVideoPlayer.createElement();
        }
        get currentTime() {
            return this.element.currentTime;
        }
        set currentTime(value) {
            this.element.currentTime = value;
        }
        get volume() {
            return this.element.volume;
        }
        set volume(value) {
            this.element.volume = value;
        }
        get readyState() {
            return this.element.readyState;
        }
        get duration() {
            return this.element.duration;
        }
        get ended() {
            return this.element.ended;
        }
        get loop() {
            return this.element.loop;
        }
        set loop(value) {
            this.element.loop = value;
        }
        get playbackRate() {
            return this.element.playbackRate;
        }
        set playbackRate(value) {
            this.element.playbackRate = value;
        }
        get muted() {
            return this.element.muted;
        }
        set muted(value) {
            this.element.muted = value;
        }
        onLoad(url) {
            var _a;
            this.element.controls = (_a = this.options.controls) !== null && _a !== void 0 ? _a : false;
            HTMLVideoPlayer.setSrc(this.element, url);
            if (this.options.underGameView) {
                let c = Browser.container;
                if (c !== Browser.document.body)
                    Browser.document.body.insertBefore(this.element, c);
                else
                    Browser.document.body.appendChild(this.element);
            }
            else
                Browser.document.body.appendChild(this.element);
            this.onTransformChanged();
            this.setLoaded();
        }
        onPlay() {
            this.element.play().catch(e => {
                if (e.name === "NotAllowedError")
                    PAL.media.resumeUntilGotFocus(this);
                else
                    console.warn(e);
            });
        }
        onPause() {
            this.element.pause();
        }
        onTransformChanged() {
            let { x, y, width, height } = this.getNodeTransform();
            let style = this.element.style;
            style.left = x + "px";
            style.top = y + "px";
            style.width = width + "px";
            style.height = height + "px";
            PAL.browser.setStyleTransform(style, "rotate(" + (ILaya.stage.canvasDegree) + "deg)");
        }
        onDestroy() {
            HTMLVideoPlayer.setSrc(this.element, null);
            this.element.remove();
        }
        static createElement() {
            let ele = Browser.createElement("video");
            let style = ele.style;
            style.position = 'absolute';
            style.top = '0px';
            style.left = '0px';
            PAL.browser.setStyleTransformOrigin(style, "0 0");
            ele.setAttribute('crossorigin', 'anonymous');
            if (Browser.onMobile) {
                ele["x5-playsInline"] = true;
                ele["x5-playsinline"] = true;
                ele.x5PlaysInline = true;
                ele.playsInline = true;
                ele["webkit-playsInline"] = true;
                ele["webkit-playsinline"] = true;
                ele.webkitPlaysInline = true;
                ele.playsinline = true;
                ele.style.playsInline = true;
                ele.crossOrigin = "anonymous";
                ele.setAttribute('playsinline', 'true');
                ele.setAttribute('x5-playsinline', 'true');
                ele.setAttribute('webkit-playsinline', 'true');
                ele.autoplay = true;
            }
            return ele;
        }
        static setSrc(ele, url) {
            while (ele.childElementCount)
                ele.firstChild.remove();
            if (url) {
                if (url.startsWith("blob:"))
                    ele.src = url;
                else {
                    let sourceElement = Browser.createElement("source");
                    sourceElement.src = URL.postFormatURL(URL.formatURL(url));
                    let extension = Utils.getFileExtension(url);
                    sourceElement.type = extension == "m3u8" ? "application/vnd.apple.mpegurl" : ("video/" + extension);
                    ele.appendChild(sourceElement);
                }
            }
            else {
                ele.pause();
                ele.src = "";
            }
        }
    }

    class HTMLVideoTexture extends VideoTexture {
        constructor() {
            super();
            this._needUpdate = true;
            this._hasRequestVideoFrame = false;
            let ele = this.element = HTMLVideoPlayer.createElement();
            ele.addEventListener("loadedmetadata", () => this.setLoaded(this.element.videoWidth, this.element.videoHeight, Browser.onLayaRuntime));
            ele.addEventListener("canplay", () => {
                if (!this._playing)
                    this.render(true);
            });
            ele.addEventListener("ended", () => {
                this.event("ended");
            });
            if ("requestVideoFrameCallback" in HTMLVideoElement.prototype) {
                const scope = this;
                function updateVideo() {
                    scope._needUpdate = true;
                    ele.requestVideoFrameCallback(updateVideo);
                }
                ele.requestVideoFrameCallback(updateVideo);
                this._hasRequestVideoFrame = true;
            }
        }
        get currentTime() {
            return this.element.currentTime;
        }
        set currentTime(value) {
            this.element.currentTime = value;
            if (!this._playing && this._loaded)
                this.render();
        }
        get volume() {
            return this.element.volume;
        }
        set volume(value) {
            this.element.volume = value;
        }
        get readyState() {
            return this.element.readyState;
        }
        get duration() {
            return this.element.duration;
        }
        get ended() {
            return this.element.ended;
        }
        get loop() {
            return this.element.loop;
        }
        set loop(value) {
            this.element.loop = value;
        }
        get playbackRate() {
            return this.element.playbackRate;
        }
        set playbackRate(value) {
            this.element.playbackRate = value;
        }
        get muted() {
            return this.element.muted;
        }
        set muted(value) {
            this.element.muted = value;
        }
        onLoad(url) {
            HTMLVideoPlayer.setSrc(this.element, url);
            this.element.load();
        }
        onPlay() {
            this.element.play().catch(e => {
                if (e.name === "NotAllowedError")
                    PAL.media.resumeUntilGotFocus(this);
                else
                    console.warn(e);
            });
        }
        onPause() {
            this.element.pause();
        }
        onRender() {
            if (!this._hasRequestVideoFrame || this._needUpdate) {
                LayaGL.textureContext.updateVideoTexture(this._texture, this.element, false, false);
                this._needUpdate = false;
                return true;
            }
            else
                return false;
        }
        onDestroy() {
            HTMLVideoPlayer.setSrc(this.element, null);
            this.element.remove();
        }
    }

    class WebAudioChannel extends SoundChannel {
        get duration() {
            if (this._buffer)
                return this._buffer.duration;
            else
                return 0;
        }
        onPlay(url) {
            PAL.media.audioDataCache.get(url, this.onLoaded, this);
        }
        onPlayAgain() {
            this.reset();
            this.startPlay(false);
        }
        onStop() {
            this.reset();
            this._buffer = null;
        }
        onPause() {
            this.reset();
        }
        onResume() {
            this.startPlay(true);
        }
        onVolumeChanged() {
            if (!this._sourceNode)
                return;
            let volume = this._muted ? 0 : this._volume;
            if (this._gainNode.gain.setTargetAtTime)
                this._gainNode.gain.setTargetAtTime(volume, PAL.media.audioCtx.currentTime, 0.001);
            else
                this._gainNode.gain.value = volume;
        }
        onMuted() {
            this.onVolumeChanged();
        }
        onLoaded(buffer) {
            if (!this._started)
                return;
            this._buffer = buffer;
            if (!buffer || this.startTime >= this.duration) {
                this.stop();
                return;
            }
            this._loaded = true;
            if (this._paused)
                return;
            this.startPlay(false);
        }
        startPlay(isResuming) {
            let ctx = PAL.media.audioCtx;
            this._gainNode = WebAudioChannel.gainNodePool.take();
            let sourceNode = this._sourceNode = ctx.createBufferSource();
            sourceNode.buffer = this._buffer;
            sourceNode.connect(this._gainNode);
            sourceNode.onended = () => this.onPlayEnd();
            if (sourceNode.playbackRate) {
                if (sourceNode.playbackRate.setTargetAtTime)
                    sourceNode.playbackRate.setTargetAtTime(this.playbackRate, ctx.currentTime, 0.001);
                else
                    sourceNode.playbackRate.value = this.playbackRate;
            }
            sourceNode.loop = this.loops === 0;
            sourceNode.loopStart = this.startTime;
            sourceNode.loopEnd = this._buffer.duration;
            this._gainNode.gain.value = this._muted ? 0 : this._volume;
            sourceNode.start(0, isResuming ? this._pauseTime : this.startTime);
            if (ctx.state != null && ctx.state !== "running") {
                this._startTime = 0;
                PAL.media.resumeUntilGotFocus(this);
            }
            else
                this._startTime = performance.now();
        }
        reset() {
            if (!this._sourceNode)
                return;
            let sourceNode = this._sourceNode;
            if (sourceNode.stop)
                sourceNode.stop(0);
            else
                sourceNode.noteOff(0);
            sourceNode.disconnect(0);
            sourceNode.onended = null;
            this._sourceNode = null;
            WebAudioChannel.gainNodePool.recover(this._gainNode);
            this._gainNode = null;
        }
    }
    WebAudioChannel.gainNodePool = Pool.createPool2(() => createGainNode(), node => initGainNode(node), node => resetGainNode(node));
    function createGainNode() {
        let node;
        if (PAL.media.audioCtx.createGain)
            node = PAL.media.audioCtx.createGain();
        else
            node = PAL.media.audioCtx.createGainNode();
        return node;
    }
    function initGainNode(node) {
        node.connect(PAL.media.audioCtx.destination);
    }
    function resetGainNode(node) {
        node.disconnect(0);
    }

    class LocalStorage {
        static setItem(key, value) {
            PAL.storage.setItem(key, value);
        }
        static getItem(key) {
            return PAL.storage.getItem(key);
        }
        static setJSON(key, value) {
            PAL.storage.setItem(key, JSON.stringify(value));
        }
        static getJSON(key) {
            return JSON.parse(PAL.storage.getItem(key) || null);
        }
        static removeItem(key) {
            PAL.storage.removeItem(key);
        }
        static clear() {
            PAL.storage.clear();
        }
        static get count() {
            return PAL.storage.getCount();
        }
    }

    class Socket extends EventDispatcher {
        constructor(host, port, byteClass, protocols, isSecure) {
            super();
            this.disableInput = false;
            if (Array.isArray(byteClass))
                protocols = byteClass;
            if (typeof (protocols) === "boolean") {
                isSecure = protocols;
                protocols = null;
            }
            this.output = new Byte();
            this.input = new Byte();
            this.endian = Byte.BIG_ENDIAN;
            if (host && port > 0 && port < 65535)
                this.connect(host, port, isSecure, protocols);
        }
        get connected() {
            return this._connected;
        }
        get endian() {
            return this.output.endian;
        }
        set endian(value) {
            this.input.endian = value;
            this.output.endian = value;
        }
        connect(host, port, isSecure, options) {
            this.connectByUrl(`${isSecure ? "wss" : "ws"}://${host}:${port}`, options);
        }
        connectByUrl(url, options) {
            if (this._socket != null)
                this.close();
            this.output.length = 0;
            this.input.length = 0;
            this._inputPos = 0;
            if (Array.isArray(options)) {
                options = { protocols: options };
            }
            this._socket = PAL.browser.createWebSocket();
            if (this._socket == null) {
                console.warn("WebSocket is not supported in this platform.");
                return;
            }
            this._socket.onOpen = () => {
                this._connected = true;
                this.event(Event.OPEN);
            };
            this._socket.onClose = () => {
                this._connected = false;
                this.event(Event.CLOSE);
            };
            this._socket.onError = (e) => {
                if (this.hasListener(Event.ERROR))
                    this.event(Event.ERROR, e);
                else
                    console.error("Socket Error: " + getErrorMsg(e));
            };
            this._socket.onMessage = (msg) => this._onMessage(msg);
            this._socket.open(url, options);
        }
        close() {
            if (this._socket != null) {
                try {
                    this._socket.close();
                }
                catch (e) {
                }
                this._socket = null;
            }
            this._connected = false;
        }
        cleanSocket() {
            this.close();
        }
        send(data) {
            return this._socket.send(data);
        }
        flush() {
            if (this.output.length === 0 || !this._socket || !this._connected)
                return;
            let err;
            try {
                this._socket.send(this.output.rawBuffer.slice(0, this.output.length));
            }
            catch (e) {
                err = e;
            }
            this.output.clear();
            if (err)
                this.event(Event.ERROR, err);
        }
        _onMessage(data) {
            if (this.disableInput) {
                this.event(Event.MESSAGE, data);
                return;
            }
            if (this.input.length > 0 && this.input.bytesAvailable < 1) {
                this.input.clear();
                this._inputPos = 0;
            }
            let pre = this.input.pos;
            !this._inputPos && (this._inputPos = 0);
            this.input.pos = this._inputPos;
            if (typeof (data) == 'string') {
                this.input.writeUTFBytes(data);
            }
            else {
                this.input.writeArrayBuffer(data);
            }
            this._inputPos = this.input.pos;
            this.input.pos = pre;
            this.event(Event.MESSAGE, data);
        }
    }

    class _WebSocket {
        open(url, options) {
            let protocols = options === null || options === void 0 ? void 0 : options.protocols;
            if (!protocols || protocols.length == 0)
                this.ws = new Browser.window.WebSocket(url);
            else
                this.ws = new Browser.window.WebSocket(url, protocols);
            this.ws.binaryType = "arraybuffer";
            this.ws.onopen = e => this.onOpen({});
            this.ws.onclose = e => this.onClose();
            this.ws.onerror = err => this.onError(err);
            this.ws.onmessage = msg => {
                if (msg.data)
                    this.onMessage(msg.data);
            };
        }
        close() {
            this.ws.close();
        }
        send(data) {
            this.ws.send(data);
            return Promise.resolve();
        }
    }

    class BrowserAdapter extends EventDispatcher {
        constructor() {
            super();
            this.webSocketClass = _WebSocket;
            this._pixelRatio = 1;
            this.init();
            this.initRequestFrameFunction();
        }
        init() {
            var _a;
            let doc = Browser.document;
            let win = Browser.window;
            this._pixelRatio = Math.max(1, (win.devicePixelRatio || 1));
            this.setPlatform(win.navigator.userAgent || "", win.navigator.platform || "");
            let state = "visibilityState", visibilityChange = "visibilitychange";
            let fullscreenchange = "fullscreenchange";
            if (typeof doc.hidden !== "undefined") {
                visibilityChange = "visibilitychange";
                state = "visibilityState";
                fullscreenchange = "fullscreenchange";
            }
            else if (typeof doc.mozHidden !== "undefined") {
                visibilityChange = "mozvisibilitychange";
                state = "mozVisibilityState";
                fullscreenchange = "mozfullscreenchange";
            }
            else if (typeof doc.msHidden !== "undefined") {
                visibilityChange = "msvisibilitychange";
                state = "msVisibilityState";
                fullscreenchange = "msfullscreenchange";
            }
            else if (typeof doc.webkitHidden !== "undefined") {
                visibilityChange = "webkitvisibilitychange";
                state = "webkitVisibilityState";
                fullscreenchange = "webkitfullscreenchange";
            }
            this._visibilityStateKey = state;
            doc.addEventListener(visibilityChange, () => {
                this.event(Event.VISIBILITY_CHANGE, this.getVisibility());
                if (Browser.onAndroid && !Browser.onLayaRuntime) {
                    if (this.getVisibility())
                        this.event(Event.FOCUS);
                    else
                        this.event(Event.BLUR);
                }
            });
            doc.addEventListener(fullscreenchange, () => this.event(Event.FULL_SCREEN_CHANGE));
            win.addEventListener("resize", () => this.event(Event.RESIZE));
            win.addEventListener("orientationchange", (e) => this.event(Event.ORIENTATION_CHANGE, e));
            win.addEventListener("focus", () => this.event(Event.FOCUS));
            win.addEventListener("blur", () => this.event(Event.BLUR));
            win.addEventListener("unhandledrejection", e => this.event("unhandledrejection", e));
            let bodyStyle = doc.body.style;
            bodyStyle.margin = 0;
            bodyStyle.overflow = 'hidden';
            bodyStyle['-webkit-user-select'] = 'none';
            bodyStyle['-webkit-tap-highlight-color'] = 'rgba(200,200,200,0)';
            let metas = doc.getElementsByTagName('meta');
            let viewportContent = {
                "width": "device-width",
                "initial-scale": "1.0",
                "minimum-scale": "1.0",
                "maximum-scale": "1.0",
                "user-scalable": "no"
            };
            let viewport;
            for (let i = 0; i < metas.length; i++) {
                let meta = metas[i];
                if (meta.name === "viewport") {
                    viewport = meta;
                    break;
                }
            }
            if (!viewport) {
                viewport = doc.createElement('meta');
                viewport.name = 'viewport';
                (_a = doc.getElementsByTagName('head')[0]) === null || _a === void 0 ? void 0 : _a.appendChild(viewport);
            }
            else {
                let arr = (viewport.content || "").split(",");
                for (let ele of arr) {
                    let arr2 = ele.split("=");
                    if (!viewportContent[arr2[0].trim()])
                        viewportContent[arr2[0]] = arr2[1];
                }
            }
            viewport.content = Object.keys(viewportContent).map(k => k + "=" + viewportContent[k]);
        }
        setPlatform(u, platform) {
            platform = platform.toLowerCase();
            Browser.userAgent = u;
            Browser.onMobile = u.indexOf("Mobile") > -1;
            Browser.onIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
            Browser.onIPhone = u.indexOf("iPhone") > -1;
            Browser.onMac = u.indexOf("Mac OS X") > -1;
            Browser.onIPad = u.indexOf("iPad") > -1;
            Browser.onAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1;
            Browser.onOpenHarmonyOS = u.indexOf('OpenHarmony') > -1;
            Browser.onWP = u.indexOf("Windows Phone") > -1;
            Browser.onQQBrowser = u.indexOf("QQBrowser") > -1;
            Browser.onMQQBrowser = u.indexOf("MQQBrowser") > -1 || (u.indexOf("Mobile") > -1 && u.indexOf("QQ") > -1);
            Browser.onIE = !!window.ActiveXObject || "ActiveXObject" in window;
            Browser.onWeiXin = u.indexOf('MicroMessenger') > -1;
            Browser.onSafari = u.indexOf("Safari") > -1 && u.indexOf("Chrome") === -1;
            Browser.onChrome = u.indexOf("Chrome") > -1;
            Browser.onFirefox = u.indexOf('Firefox') > -1;
            Browser.onEdge = u.indexOf('Edge') > -1 || u.indexOf('Edg') > -1;
            if (platform.indexOf("ios") !== -1) {
                Browser.onIOS = true;
                Browser.onMobile = true;
                if (!u) {
                    Browser.onIPhone = true;
                    Browser.onIPad = true;
                }
                Browser.platform = Browser.PLATFORM_IOS;
                Browser.platformName = "ios";
            }
            else if (platform.indexOf("android") !== -1) {
                Browser.onAndroid = true;
                Browser.onMobile = true;
                Browser.platform = Browser.PLATFORM_ANDROID;
                Browser.platformName = "android";
            }
            else if (platform.indexOf("ohos") !== -1) {
                Browser.onOpenHarmonyOS = true;
                Browser.onMobile = true;
                Browser.platform = Browser.PLATFORM_ANDROID;
                Browser.platformName = "ohos";
            }
            else if (platform.indexOf("mac") !== -1) {
                Browser.onMac = true;
                Browser.platform = Browser.PLATFORM_PC;
                Browser.platformName = "mac";
            }
            else if (platform.indexOf("win") !== -1) {
                Browser.platform = Browser.PLATFORM_PC;
                Browser.platformName = "windows";
            }
            else if (Browser.onAndroid) {
                Browser.platform = Browser.PLATFORM_ANDROID;
                Browser.platformName = "android";
            }
            else if (Browser.onIOS) {
                Browser.platform = Browser.PLATFORM_IOS;
                Browser.platformName = "ios";
            }
            else {
                Browser.platform = Browser.PLATFORM_PC;
                Browser.platformName = platform;
            }
            Browser.onPC = !Browser.onMobile;
            Browser.onDevTools = Browser.platformName === "devtools";
            Browser.isTouchDevice = true;
            if (u.indexOf("Mozilla/6.0(Linux; Android 6.0; HUAWEI NXT-AL10 Build/HUAWEINXT-AL10)") != -1)
                this._pixelRatio = 2;
        }
        initRequestFrameFunction() {
            this.requestFrame = window.requestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.oRequestAnimationFrame
                || window.msRequestAnimationFrame;
            if (!this.requestFrame)
                this.requestFrame = function (fun) {
                    return setTimeout(fun, 1000 / 60);
                };
        }
        start() {
            return Promise.resolve();
        }
        onInitRender() {
        }
        getScreenOrientation() {
            let ret = window.screen.orientation.type;
            if (ret == null) {
                let o = window.orientation;
                switch (o) {
                    case 0:
                        ret = "portrait-primary";
                        break;
                    case 180:
                        ret = "portrait-secondary";
                        break;
                    case 90:
                        ret = "landscape-primary";
                        break;
                    case -90:
                        ret = "landscape-secondary";
                        break;
                }
            }
            return ret;
        }
        getPixelRatio() {
            return this._pixelRatio;
        }
        getClientWidth() {
            return Browser.window.innerWidth || Browser.document.body.clientWidth || Browser.document.documentElement.clientWidth;
        }
        getClientHeight() {
            return Browser.window.innerHeight || Browser.document.body.clientHeight || Browser.document.documentElement.clientHeight;
        }
        getVisibility() {
            return Browser.document[this._visibilityStateKey] !== "hidden";
        }
        requestFullscreen() {
            let ele = Browser.document.documentElement;
            if (!ele)
                return;
            if (ele.requestFullscreen)
                ele.requestFullscreen();
            else if (ele.mozRequestFullScreen)
                ele.mozRequestFullScreen();
            else if (ele.webkitRequestFullscreen)
                ele.webkitRequestFullscreen();
            else if (ele.msRequestFullscreen)
                ele.msRequestFullscreen();
        }
        exitFullscreen() {
            let doc = document;
            if (doc.exitFullscreen)
                doc.exitFullscreen();
            else if (doc.mozCancelFullScreen)
                doc.mozCancelFullScreen();
            else if (doc.webkitExitFullscreen)
                doc.webkitExitFullscreen();
        }
        createElement(tagName) {
            return Browser.document.createElement(tagName);
        }
        createMainCanvas() {
            let canvas = this.createElement("canvas");
            canvas.id = "layaCanvas";
            canvas.width = 2;
            canvas.height = 2;
            let style = canvas.style;
            style.position = 'absolute';
            style.top = style.left = "0px";
            style.background = "#000000";
            let container = Browser.document.createElement("div");
            container.id = "layaContainer";
            Browser.document.body.appendChild(container);
            container.appendChild(canvas);
            return canvas;
        }
        setCursor(cursor) {
            if (Browser.isDomSupported)
                Browser.document.body.style.cursor = cursor;
        }
        get supportArrayBufferURL() {
            return !!window.Blob;
        }
        createBufferURL(data) {
            if (window.Blob) {
                let blob = new Blob([data], { type: 'application/octet-binary' });
                return window.URL.createObjectURL(blob);
            }
            else
                return null;
        }
        revokeBufferURL(url) {
            window.URL.revokeObjectURL(url);
        }
        getOpenDataContextCanvas() {
            return null;
        }
        postMessageToOpenDataContext(msg) {
        }
        captureGlobalError(callback) {
            this._globalErrorCallback = callback;
            this.onCaptureGlobalError(callback != null, onError);
        }
        onCaptureGlobalError(enabled, func) {
            if (enabled) {
                Browser.window.addEventListener("error", func);
                Browser.window.addEventListener("unhandledrejection", func);
            }
            else {
                Browser.window.removeEventListener("error", func);
                Browser.window.removeEventListener("unhandledrejection", func);
            }
        }
        alert(msg) {
            Browser.window.alert(msg);
        }
        setStyleTransformOrigin(style, value) {
            style.transformOrigin = style.webkitTransformOrigin
                = style.msTransformOrigin = style.mozTransformOrigin
                    = style.oTransformOrigin = value;
        }
        setStyleTransform(style, value) {
            style.transform = style.webkitTransform
                = style.msTransform = style.mozTransform
                    = style.oTransform = value;
        }
        createWebSocket() {
            if (this.webSocketClass)
                return new this.webSocketClass();
            else
                return null;
        }
    }
    function onError(e) {
        PAL.browser._globalErrorCallback(e);
    }
    PAL.register("browser", BrowserAdapter);

    class DeviceAdapter extends EventDispatcher {
        get supportedLocation() {
            return false;
        }
        get supportedGetUserMedia() {
            return false;
        }
        getCurrentPosition(successCallback, errorCallback, options) {
        }
        watchPosition(successCallback, errorCallback, options) {
            return -1;
        }
        clearWatchPosition(id) {
        }
        getUserMedia(constraints, successCallback, errorCallback) {
        }
        onStartListeningToType(type) {
            if (type === "devicemotion")
                this.startListeningDeviceMotion();
            else if (type === "deviceorientation")
                this.startListeningDeviceOrientation();
            return this;
        }
        startListeningDeviceMotion() {
        }
        startListeningDeviceOrientation() {
        }
    }
    PAL.register("device", DeviceAdapter);

    class FileSystemAdapter {
        readFile(path, encoding) {
            throw new NotImplementedError();
        }
        writeFile(path, data, encoding) {
            throw new NotImplementedError();
        }
        unlink(path) {
            throw new NotImplementedError();
        }
        copyFile(srcPath, destPath) {
            throw new NotImplementedError();
        }
        exists(path) {
            throw new NotImplementedError();
        }
        getFileSize(path) {
            throw new NotImplementedError();
        }
        mkdir(path, options) {
            throw new NotImplementedError();
        }
        rmdir(path, options) {
            throw new NotImplementedError();
        }
        readdir(path) {
            throw new NotImplementedError();
        }
        unzip(zipFilePath, targetPath) {
            throw new NotImplementedError();
        }
    }
    PAL.register("fs", FileSystemAdapter);

    class FontAdapter {
        loadFont(task) {
            let fontName = Utils.replaceFileExtension(Utils.getBaseName(task.url), "");
            let url = URL.postFormatURL(URL.formatURL(task.url));
            if (Browser.window.FontFace)
                return this.loadByFontFace(task, url, fontName);
            else
                return this.loadByCSS(task, url, fontName);
        }
        loadByFontFace(task, url, fontName) {
            let fontFace = new Browser.window.FontFace(fontName, "url('" + url + "')");
            Browser.document.fonts.add(fontFace);
            return fontFace.load().then(() => {
                return fontFace;
            });
        }
        loadByCSS(task, url, fontName) {
            let fontTxt = "40px " + fontName;
            Browser.context.font = fontTxt;
            let oldWidth = Browser.context.measureText(testString).width;
            let fontStyle = Browser.createElement("style");
            fontStyle.type = "text/css";
            Browser.document.body.appendChild(fontStyle);
            fontStyle.textContent = "@font-face { font-family:'" + fontName + "'; src:url('" + url + "');}";
            return new Promise((resolve) => {
                let checkComplete = () => {
                    Browser.context.font = fontTxt;
                    let newWidth = Browser.context.measureText(testString).width;
                    if (newWidth != oldWidth)
                        complete();
                };
                let complete = () => {
                    ILaya.systemTimer.clear(this, checkComplete);
                    ILaya.systemTimer.clear(this, complete);
                    resolve({ family: fontName });
                };
                ILaya.systemTimer.once(10000, this, complete);
                ILaya.systemTimer.loop(20, this, checkComplete);
            });
        }
    }
    const testString = "LayaTTFFont";
    PAL.register("font", FontAdapter);

    class MediaAdapter {
        constructor() {
            this.touchToStart = true;
            this._firstTouch = true;
            this.audioDataCache = new AudioDataCache();
            this.suspendedMedias = new Set();
            this.touchToStart = PAL.g == null;
            this.init();
        }
        init() {
            let ctxClass = window.AudioContext || window["webkitAudioContext"] || window["mozAudioContext"];
            if (ctxClass != null)
                this.audioCtx = new ctxClass();
            this.shortAudioClass = this.audioCtx ? WebAudioChannel : HTMLAudioChannel;
            this.longAudioClass = HTMLAudioChannel;
            this.videoTextureClass = HTMLVideoTexture;
            this.videoPlayerClass = HTMLVideoPlayer;
        }
        createSoundChannel(url, longAudioUsage) {
            return longAudioUsage ? new this.longAudioClass(url) : new this.shortAudioClass(url);
        }
        createVideoTexture() {
            if (this.videoTextureClass == null) {
                PAL.warnIncompatibility("VideoTexture");
                return new VideoTexture();
            }
            else
                return new this.videoTextureClass();
        }
        createVideoPlayer() {
            if (this.videoPlayerClass == null) {
                PAL.warnIncompatibility("VideoPlayer");
                return new VideoPlayer();
            }
            else
                return new this.videoPlayerClass();
        }
        decodeAudioData(data) {
            if (this.audioCtx)
                return this.audioCtx.decodeAudioData(data);
            else
                return Promise.resolve(null);
        }
        resumeUntilGotFocus(media) {
            if (this.suspendedMedias.size === 0) {
                ILaya.stage.on(Event.MOUSE_UP, this, this.onGotFocus);
                if (!this._firstTouch || !this.touchToStart)
                    ILaya.stage.on(Event.FOCUS, this, this.onGotFocus);
            }
            this.suspendedMedias.add(media);
            media.pause();
            media._autoResume = true;
        }
        canPlayType(type) {
            if (typeof (HTMLAudioElement) !== "undefined" && typeof (HTMLAudioElement.prototype.canPlayType) === "function") {
                if (!this._testElement)
                    this._testElement = Browser.createElement("audio");
                return this._testElement.canPlayType(type);
            }
            else
                return "";
        }
        onGotFocus() {
            this._firstTouch = false;
            ILaya.stage.off(Event.MOUSE_UP, this, this.onGotFocus);
            ILaya.stage.off(Event.FOCUS, this, this.onGotFocus);
            if (this.suspendedMedias.size === 0)
                return;
            let arr = Array.from(this.suspendedMedias).filter(c => c._autoResume);
            this.suspendedMedias.clear();
            this.beforeResumeMedias(arr).then(() => {
                for (let medias of arr) {
                    medias._autoResume = false;
                    medias.resume();
                }
            });
        }
        beforeResumeMedias(medias) {
            let checkCtx = false;
            for (let channel of medias) {
                if (channel instanceof WebAudioChannel && !checkCtx) {
                    checkCtx = true;
                    if (this.audioCtx.state === "suspended") {
                        return this.audioCtx.resume().catch(e => { });
                    }
                }
            }
            return Promise.resolve();
        }
    }
    PAL.register("media", MediaAdapter);

    class StorageAdapter {
        constructor() {
            this._storage = Browser.window.localStorage;
            this._supported = this.checkSupport();
        }
        checkSupport() {
            return this._storage != null && typeof (this._storage.getItem) === 'function' &&
                typeof (this._storage.setItem) === 'function';
        }
        getItem(key) {
            if (this._supported)
                return this._storage.getItem(key);
            else
                return null;
        }
        setItem(key, value) {
            this._supported && this._storage.setItem(key, value);
        }
        removeItem(key) {
            this._supported && this._storage.removeItem(key);
        }
        clear() {
            this._supported && this._storage.clear();
        }
        getCount() {
            if (this._supported)
                return this._storage.length || 0;
            else
                return 0;
        }
    }
    PAL.register("storage", StorageAdapter);

    class TextInputAdapter {
        constructor() {
            this._beginFlag = 0;
            this._editInline = true;
            this._enterEvent = new Event();
            this._lastTransform = {};
            Laya.addAfterInitCallback(() => {
                ILaya.stage.on(Event.MOUSE_UP, this, this.onTouchEnd);
                InputManager.onMouseDownCapture.add(this.onTouchBegin, this);
            });
        }
        begin(target, fromTouchBegin) {
            if (this.target === target || this._beginFlag !== 0)
                return Promise.resolve();
            this._beginFlag = 1;
            return (this.target ? this.end(false, this.target.editable) : Promise.resolve()).then(() => {
                this.target = target;
                ILaya.stage.focus = target;
                this.updateRestrictPattern();
                this._lastTransform.x = null;
                target.on(Event.UNDISPLAY, this, this.end);
                return this.onBegin().catch(e => {
                    console.error("TextInputAdapter begin error:", e);
                });
            }).then(() => {
                if (this._editInline) {
                    this.target.hideText(true);
                    ILaya.stage.on(Event.KEY_DOWN, this, this.onKeyDown);
                }
                target.event(Event.FOCUS);
            }).then(() => {
                if (!fromTouchBegin) {
                    this._beginFlag = 0;
                    return this.onCanShowKeyboard().catch(e => {
                        console.error("TextInputAdapter begin error:", e);
                    });
                }
                else {
                    this._beginFlag = 2;
                    return Promise.resolve();
                }
            });
        }
        end(complete, switching) {
            let target = this.target;
            if (!target)
                return Promise.resolve();
            this.target = null;
            ILaya.stage.focus = null;
            target.off(Event.UNDISPLAY, this, this.end);
            if (this._editInline)
                ILaya.stage.off(Event.KEY_DOWN, this, this.onKeyDown);
            return this.onEnd(target, !!complete, !!switching).then(() => {
                if (this._editInline)
                    target.hideText(false);
                if (target.editable)
                    target.event(Event.CHANGE);
                target.event(Event.BLUR);
            }).catch(e => {
                console.error("TextInputAdapter end error:", e);
            });
        }
        onBegin() {
            this.showInputElement();
            let ele = this._visEle;
            let target = this.target;
            if (ele instanceof HTMLInputElement)
                ele.type = this.target.type;
            ele.readOnly = !target.editable;
            ele.maxLength = target.maxChars <= 0 ? 1E5 : target.maxChars;
            ele.value = this.target.text;
            ele.placeholder = target.prompt;
            let style = ele.style;
            style.fontFamily = target.realFont;
            style.color = target.color;
            style.fontSize = target.fontSize + 'px';
            style.whiteSpace = (target.wordWrap ? "pre-wrap" : "nowrap");
            style.lineHeight = (target.leading + target.fontSize) + "px";
            style.fontStyle = (target.italic ? "italic" : "normal");
            style.fontWeight = (target.bold ? "bold" : "normal");
            style.textAlign = target.align;
            style.padding = "0 0";
            style.direction = Text.RightToLeft ? "rtl" : "";
            this.setPromptColor();
            this.syncTransform();
            if (this._editInline)
                ILaya.systemTimer.frameLoop(1, this, this.syncTransform);
            return Promise.resolve();
        }
        onCanShowKeyboard() {
            if (this._visEle)
                this._visEle.focus();
            return Promise.resolve();
        }
        onEnd(target, complete, switching) {
            Browser.document.body.scrollTop = 0;
            target.text = this._visEle.value;
            this._visEle.blur();
            this.hideInputElement();
            this._visEle = null;
            if (this._editInline)
                ILaya.systemTimer.clear(this, this.syncTransform);
            return Promise.resolve();
        }
        syncText() {
            if (this._visEle && this._beginFlag === 0)
                this.updateTargetText(this._visEle.value);
        }
        setText(value) {
            if (this._visEle)
                this._visEle.value = value;
        }
        setSelection(startIndex, endIndex) {
            if (this._visEle) {
                this._visEle.selectionStart = startIndex;
                this._visEle.selectionEnd = endIndex;
            }
        }
        onTouchBegin() {
            let lastFocus = ILaya.stage.focus;
            let touchTarget = InputManager.touchTarget;
            if (lastFocus != touchTarget) {
                if (touchTarget instanceof Input)
                    this.begin(touchTarget, true);
                else if (lastFocus instanceof Input)
                    this.end();
            }
        }
        onTouchEnd() {
            if (this._beginFlag !== 0) {
                if (this._beginFlag === 1) {
                    ILaya.systemTimer.frameOnce(1, this, this.onTouchEnd);
                }
                else {
                    this._beginFlag = 0;
                    this.onCanShowKeyboard().catch(e => {
                        console.error("TextInputAdapter begin error:", e);
                    });
                }
            }
        }
        setPromptColor() {
            this._promptStyleDOM = Browser.document.getElementById("promptStyle");
            if (!this._promptStyleDOM) {
                this._promptStyleDOM = Browser.document.createElement("style");
                this._promptStyleDOM.setAttribute("id", "promptStyle");
                Browser.document.head.appendChild(this._promptStyleDOM);
            }
            let color = this.target.promptColor;
            this._promptStyleDOM.innerText = `input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {
                color: ${color}
            }
            input:-moz-placeholder, textarea:-moz-placeholder {
                color: ${color}
            }
            input::-moz-placeholder, textarea::-moz-placeholder {
                color: ${color}
            }
            input:-ms-input-placeholder, textarea:-ms-input-placeholder {
                color: ${color}
            }
        `;
        }
        updateRestrictPattern() {
            let value = this.target.restrict;
            if (value) {
                value = "[^" + value + "]";
                if (value.indexOf("^^") > -1)
                    value = value.replace("^^", "");
                this._restrictPattern = new RegExp(value, "g");
            }
            else
                this._restrictPattern = null;
        }
        validateText(str) {
            if (str == null)
                str = "";
            if (!this.target.multiline)
                str = str.replace(/\r?\n/g, '');
            if (this._restrictPattern) {
                str = str.replace(/\u2006|\x27/g, "");
                if (this._restrictPattern.test(str)) {
                    str = str.replace(this._restrictPattern, "");
                }
            }
            return str;
        }
        showInputElement() {
            if (!this._eInput)
                this.createElements();
            let password = this.target.type === "password";
            let multiline = this.target.multiline && !password;
            let inputElement = (multiline ? this._eTextArea : password ? this._ePassword : this._eInput);
            this._visEle = inputElement;
            this._container.appendChild(inputElement);
        }
        hideInputElement() {
            if (this._visEle && this._visEle.parentElement)
                this._visEle.remove();
        }
        updateTargetText(value) {
            let target = this.target;
            this.target = null;
            let ret = target.text != value;
            target.text = value;
            this.target = target;
            return ret;
        }
        getTargetTransform() {
            let padding = this.target.padding;
            let { x, y, scaleX, scaleY } = SpriteUtils.getTransformRelativeToWindow(this.target, padding[3], padding[0]);
            let w = this.target.width - padding[1] - padding[3];
            let h = this.target.height - padding[0] - padding[2];
            let t = this._lastTransform;
            if (x !== t.x || y !== t.y || w !== t.width || h !== t.height || scaleX !== t.scaleX || scaleY !== t.scaleY) {
                t.x = x;
                t.y = y;
                t.width = w;
                t.height = h;
                t.scaleX = scaleX;
                t.scaleY = scaleY;
                return t;
            }
            else
                return null;
        }
        syncTransform() {
            let t = this.getTargetTransform();
            if (t != null) {
                let style = this._visEle.style;
                style.width = t.width + 'px';
                style.height = t.height + 'px';
                PAL.browser.setStyleTransform(style, "scale(" + t.scaleX + "," + t.scaleY + ") rotate(" + (ILaya.stage.canvasDegree) + "deg)");
                this._container.style.left = t.x + 'px';
                this._container.style.top = t.y + 'px';
            }
        }
        createElements() {
            this._container = Browser.document.createElement("div");
            Browser.container.appendChild(this._container);
            let style = this._container.style;
            style.position = "absolute";
            style.zIndex = '1E5';
            this.initElement(this._eTextArea = Browser.document.createElement("textarea"));
            this.initElement(this._eInput = Browser.document.createElement("input"));
            this.initElement(this._ePassword = Browser.document.createElement("input"));
        }
        initElement(input) {
            let style = input.style;
            style.cssText = "position:absolute;overflow:hidden;resize:none;";
            style.resize = 'none';
            style.backgroundColor = 'transparent';
            style.border = 'none';
            style.outline = 'none';
            style.zIndex = '1';
            PAL.browser.setStyleTransformOrigin(style, "0 0");
            input.addEventListener('input', ev => !ev.isComposing && this.processInputting(ev));
            input.addEventListener("compositionend", ev => this.processInputting(ev));
            input.addEventListener('mousemove', ev => this.stopEvent(ev), { passive: false });
            input.addEventListener('mousedown', ev => this.stopEvent(ev), { passive: false });
            input.addEventListener('touchmove', ev => this.stopEvent(ev), { passive: false });
        }
        processInputting(ev) {
            if (!this.target)
                return;
            let ele = ev.target;
            let value = this.validateText(ele.value);
            ele.value = value;
            if (this.updateTargetText(value))
                this.target.event(Event.INPUT);
        }
        stopEvent(e) {
            if (e.type == 'touchmove')
                e.preventDefault();
            e.stopPropagation && e.stopPropagation();
        }
        onKeyDown(e) {
            if (e.key === "Enter" || e.key === "NumpadEnter") {
                let target = this.target;
                if (!target.multiline) {
                    e.preventDefault();
                    this._enterEvent.setTo(Event.ENTER, this.target, this.target);
                    target.event(Event.ENTER, this._enterEvent);
                    if (!this._enterEvent._defaultPrevented && this.target === target)
                        this.end();
                }
            }
        }
    }
    PAL.register("textInput", TextInputAdapter);

    class RenderTextureCube extends RenderTexture {
        constructor(size, colorFormat, depthFormat, generateMipmap, multiSamples) {
            super(size, size, colorFormat, depthFormat, generateMipmap, multiSamples);
            this.faceIndex = 0;
        }
        _createRenderTarget() {
            this._dimension = exports.TextureDimension.Cube;
            this._renderTarget = LayaGL.textureContext.createRenderTargetCubeInternal(this.width, this._format, this._depthStencilFormat, this._generateMipmap, this._gammaSpace, this._multiSamples);
            this._texture = this._renderTarget._textures[0];
        }
    }

    class Texture3D extends BaseTexture {
        static get defaultTexture() {
            return this._defaultTexture;
        }
        static __init__() {
            if (LayaGL.renderEngine.getCapable(exports.RenderCapable.Texture3D)) {
                this._defaultTexture = new Texture3D(1, 1, 1, exports.TextureFormat.R8G8B8A8, false, false);
                this._defaultTexture.lock = true;
                this._defaultTexture.setPixelsData(new Uint8Array([255, 255, 255, 255]));
            }
        }
        constructor(width, height, depth, format, mipmap = true, sRGB = false) {
            super(width, height, format);
            this._dimension = exports.TextureDimension.Tex3D;
            this.depth = depth;
            this._gammaSpace = sRGB;
            let context = LayaGL.textureContext;
            this._texture = context.createTexture3DInternal(this._dimension, width, height, depth, format, mipmap, sRGB, false);
        }
        setPixelsData(source) {
            let texture = this._texture;
            let context = LayaGL.textureContext;
            context.setTexture3DPixelsData(texture, source, this.depth, false, false);
        }
        setSubPixelsData(xOffset, yOffset, zOffset, width, height, depth, pixels, mipmapLevel, generateMipmap) {
            let texture = this._texture;
            let context = LayaGL.textureContext;
            context.setTexture3DSubPixelsData(texture, pixels, mipmapLevel, generateMipmap, xOffset, yOffset, zOffset, width, height, depth, false, false);
        }
    }

    class WebGLRTMgr {
        static getRT(w, h) {
            w = w | 0;
            h = h | 0;
            if (w >= 10000) {
                console.error('getRT error! w too big');
            }
            var ret;
            ret = new RenderTexture2D(w, h, exports.RenderTargetFormat.R8G8B8A8, exports.RenderTargetFormat.None);
            return ret;
        }
        static releaseRT(rt) {
            rt.destroy();
            return;
        }
    }
    WebGLRTMgr.dict = {};

    class TimeLine extends EventDispatcher {
        constructor() {
            super(...arguments);
            this._tweenDic = [];
            this._tweenDataList = [];
            this._currTime = 0;
            this._lastTime = 0;
            this._startTime = 0;
            this._index = 0;
            this._firstTweenDic = {};
            this._startTimeSort = false;
            this._endTimeSort = false;
            this._loopKey = false;
            this.scale = 1;
            this._frameRate = 60;
            this._frameIndex = 0;
            this._total = 0;
        }
        static to(target, props, duration, ease = null, offset = 0) {
            return new TimeLine().to(target, props, duration, ease, offset);
        }
        static from(target, props, duration, ease = null, offset = 0) {
            return new TimeLine().from(target, props, duration, ease, offset);
        }
        to(target, props, duration, ease = null, offset = 0) {
            return this._create(target, props, duration, ease, offset, true);
        }
        from(target, props, duration, ease = null, offset = 0) {
            return this._create(target, props, duration, ease, offset, false);
        }
        _create(target, props, duration, ease, offset, isTo) {
            var tTweenData = Pool.getItemByClass("tweenData", tweenData);
            tTweenData.isTo = isTo;
            tTweenData.type = 0;
            tTweenData.target = target;
            tTweenData.duration = duration;
            tTweenData.data = props;
            tTweenData.startTime = this._startTime + offset;
            tTweenData.endTime = tTweenData.startTime + tTweenData.duration;
            tTweenData.ease = ease;
            this._startTime = Math.max(tTweenData.endTime, this._startTime);
            this._tweenDataList.push(tTweenData);
            this._startTimeSort = true;
            this._endTimeSort = true;
            return this;
        }
        addLabel(label, offset) {
            var tTweenData = Pool.getItemByClass("tweenData", tweenData);
            tTweenData.type = 1;
            tTweenData.data = label;
            tTweenData.endTime = tTweenData.startTime = this._startTime + offset;
            this._labelDic || (this._labelDic = {});
            this._labelDic[label] = tTweenData;
            this._tweenDataList.push(tTweenData);
            return this;
        }
        removeLabel(label) {
            if (this._labelDic && this._labelDic[label]) {
                var tTweenData = this._labelDic[label];
                if (tTweenData) {
                    var tIndex = this._tweenDataList.indexOf(tTweenData);
                    if (tIndex > -1) {
                        this._tweenDataList.splice(tIndex, 1);
                    }
                }
                delete this._labelDic[label];
            }
        }
        gotoTime(time) {
            if (this._tweenDataList == null || this._tweenDataList.length == 0)
                return;
            for (let p in this._firstTweenDic) {
                let tObject = this._firstTweenDic[p];
                if (tObject) {
                    for (let tDataP in tObject) {
                        if (tDataP in tObject.diyTarget) {
                            tObject.diyTarget[tDataP] = tObject[tDataP];
                        }
                    }
                }
            }
            for (let p of this._tweenDic)
                Tween.kill(p);
            this._tweenDic.length = 0;
            this._index = 0;
            this._currTime = time;
            this._lastTime = performance.now();
            var tTweenDataCopyList;
            if (this._endTweenDataList == null || this._endTimeSort) {
                this._endTimeSort = false;
                this._endTweenDataList = tTweenDataCopyList = this._tweenDataList.concat();
                function Compare(paraA, paraB) {
                    if (paraA.endTime > paraB.endTime) {
                        return 1;
                    }
                    else if (paraA.endTime < paraB.endTime) {
                        return -1;
                    }
                    else {
                        return 0;
                    }
                }
                tTweenDataCopyList.sort(Compare);
            }
            else {
                tTweenDataCopyList = this._endTweenDataList;
            }
            var tTweenData;
            for (var i = 0, n = tTweenDataCopyList.length; i < n; i++) {
                tTweenData = tTweenDataCopyList[i];
                if (tTweenData.type == 0) {
                    if (time >= tTweenData.endTime) {
                        this._index = Math.max(this._index, i + 1);
                        var props = tTweenData.data;
                        if (tTweenData.isTo) {
                            for (var tP in props) {
                                tTweenData.target[tP] = props[tP];
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            for (i = 0, n = this._tweenDataList.length; i < n; i++) {
                tTweenData = this._tweenDataList[i];
                if (tTweenData.type == 0) {
                    if (time >= tTweenData.startTime && time < tTweenData.endTime) {
                        this._index = Math.max(this._index, i + 1);
                        let tTween;
                        if (tTweenData.isTo)
                            tTween = Tween.to(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete));
                        else
                            tTween = Tween.from(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete));
                        this._tweenDic.push(tTween);
                    }
                }
            }
        }
        gotoLabel(Label) {
            if (this._labelDic == null)
                return;
            var tLabelData = this._labelDic[Label];
            if (tLabelData)
                this.gotoTime(tLabelData.startTime);
        }
        pause() {
            ILaya.timer.clear(this, this._update);
        }
        resume() {
            this.play(this._currTime, this._loopKey);
        }
        play(timeOrLabel = 0, loop = false) {
            if (!this._tweenDataList)
                return;
            if (this._startTimeSort) {
                this._startTimeSort = false;
                function Compare(paraA, paraB) {
                    if (paraA.startTime > paraB.startTime) {
                        return 1;
                    }
                    else if (paraA.startTime < paraB.startTime) {
                        return -1;
                    }
                    else {
                        return 0;
                    }
                }
                this._tweenDataList.sort(Compare);
                for (var i = 0, n = this._tweenDataList.length; i < n; i++) {
                    var tTweenData = this._tweenDataList[i];
                    if (tTweenData != null && tTweenData.type == 0) {
                        var tTarget = tTweenData.target;
                        var gid = Utils.getGID(tTarget);
                        var tSrcData = null;
                        if (this._firstTweenDic[gid] == null) {
                            tSrcData = {};
                            tSrcData.diyTarget = tTarget;
                            this._firstTweenDic[gid] = tSrcData;
                        }
                        else {
                            tSrcData = this._firstTweenDic[gid];
                        }
                        for (var p in tTweenData.data) {
                            if (tSrcData[p] == null) {
                                tSrcData[p] = tTarget[p];
                            }
                        }
                    }
                }
            }
            if (typeof (timeOrLabel) == 'string') {
                this.gotoLabel(timeOrLabel);
            }
            else {
                this.gotoTime(timeOrLabel);
            }
            this._loopKey = loop;
            this._lastTime = performance.now();
            ILaya.timer.frameLoop(1, this, this._update);
        }
        _update() {
            if (this._currTime >= this._startTime) {
                if (this._loopKey) {
                    this._complete();
                    if (!this._tweenDataList)
                        return;
                    this.gotoTime(0);
                }
                else {
                    for (let p of this._tweenDic)
                        p.complete();
                    this.pause();
                    this._complete();
                    return;
                }
            }
            var tNow = performance.now();
            var tFrameTime = tNow - this._lastTime;
            var tCurrTime = this._currTime += tFrameTime * this.scale;
            this._lastTime = tNow;
            if (this._tweenDataList.length != 0 && this._index < this._tweenDataList.length) {
                var tTweenData = this._tweenDataList[this._index];
                if (tCurrTime >= tTweenData.startTime) {
                    this._index++;
                    if (tTweenData.type == 0) {
                        let tTween;
                        if (tTweenData.isTo)
                            tTween = Tween.to(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete));
                        else
                            tTween = Tween.from(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete));
                        this._tweenDic.push(tTween);
                    }
                    else {
                        this.event(Event.LABEL, tTweenData.data);
                    }
                }
            }
        }
        _animComplete(tweener) {
            let i = this._tweenDic.indexOf(tweener.owner);
            if (i > -1)
                this._tweenDic.splice(i, 1);
        }
        _complete() {
            this.event(Event.COMPLETE);
        }
        get index() {
            return this._frameIndex;
        }
        set index(value) {
            this._frameIndex = value;
            this.gotoTime(this._frameIndex / this._frameRate * 1000);
        }
        get total() {
            this._total = Math.floor(this._startTime / 1000 * this._frameRate);
            return this._total;
        }
        reset() {
            var p;
            if (this._labelDic) {
                for (p in this._labelDic) {
                    delete this._labelDic[p];
                }
            }
            for (let p of this._tweenDic)
                Tween.kill(p);
            this._tweenDic.length = 0;
            for (p in this._firstTweenDic) {
                delete this._firstTweenDic[p];
            }
            this._endTweenDataList = null;
            if (this._tweenDataList && this._tweenDataList.length) {
                var i, len;
                len = this._tweenDataList.length;
                for (i = 0; i < len; i++) {
                    if (this._tweenDataList[i])
                        this._tweenDataList[i].destroy();
                }
            }
            this._tweenDataList.length = 0;
            this._currTime = 0;
            this._lastTime = 0;
            this._startTime = 0;
            this._index = 0;
            this.scale = 1;
            ILaya.timer.clear(this, this._update);
        }
        destroy() {
            this.reset();
            this._labelDic = null;
            this._tweenDic = null;
            this._tweenDataList = null;
            this._firstTweenDic = null;
        }
    }
    class tweenData {
        constructor() {
            this.type = 0;
            this.isTo = true;
        }
        destroy() {
            this.target = null;
            this.ease = null;
            this.data = null;
            this.isTo = true;
            this.type = 0;
            Pool.recover("tweenData", this);
        }
    }

    class Base64Tool {
        static init() {
            if (Base64Tool.lookup)
                return;
            Base64Tool.lookup = new Uint8Array(256);
            for (var i = 0; i < Base64Tool.chars.length; i++) {
                Base64Tool.lookup[Base64Tool.chars.charCodeAt(i)] = i;
            }
        }
        static isBase64String(str) {
            return Base64Tool.reg.test(str);
        }
        static encode(arraybuffer) {
            var bytes = new Uint8Array(arraybuffer), i, len = bytes["length"], base64 = "";
            for (i = 0; i < len; i += 3) {
                base64 += Base64Tool.chars[bytes[i] >> 2];
                base64 += Base64Tool.chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
                base64 += Base64Tool.chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
                base64 += Base64Tool.chars[bytes[i + 2] & 63];
            }
            if ((len % 3) === 2) {
                base64 = base64.substring(0, base64.length - 1) + "=";
            }
            else if (len % 3 === 1) {
                base64 = base64.substring(0, base64.length - 2) + "==";
            }
            return base64;
        }
        static decode(base64) {
            Base64Tool.init();
            var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
            if (base64[base64.length - 1] === "=") {
                bufferLength--;
                if (base64[base64.length - 2] === "=") {
                    bufferLength--;
                }
            }
            var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
            for (i = 0; i < len; i += 4) {
                encoded1 = Base64Tool.lookup[base64.charCodeAt(i)];
                encoded2 = Base64Tool.lookup[base64.charCodeAt(i + 1)];
                encoded3 = Base64Tool.lookup[base64.charCodeAt(i + 2)];
                encoded4 = Base64Tool.lookup[base64.charCodeAt(i + 3)];
                if (p + 1 > bufferLength)
                    continue;
                bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
                if (p + 1 > bufferLength)
                    continue;
                bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
                if (p + 1 > bufferLength)
                    continue;
                bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
            }
            return arraybuffer;
        }
    }
    Base64Tool.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    Base64Tool.reg = /^\s*data:([a-z]+\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s]*?)\s*$/i;
    Base64Tool.reghead = /^\s*data:([a-z]+\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,/i;
    Base64Tool.lookup = null;

    const _rect = new Rectangle();
    class HitArea {
        contains(x, y, sp) {
            if (HitArea._isHitGraphic(x, y, sp, this._unHit))
                return false;
            return HitArea._isHitGraphic(x, y, sp, this._hit);
        }
        moveTo(x, y, hit, unhit) {
            if (hit && this._hit) {
                for (let cmd of this._hit.cmds) {
                    cmd.x = x;
                    cmd.y = y;
                }
            }
            if (unhit && this._unHit) {
                for (let cmd of this._unHit.cmds) {
                    cmd.x = x;
                    cmd.y = y;
                }
            }
        }
        static _isHitGraphic(x, y, sp, g) {
            if (!g)
                return false;
            return g.cmds.findIndex(cmd => cmd && HitArea._isHitCmd(x, y, sp, cmd)) !== -1;
        }
        static _isHitCmd(x, y, sp, cmd) {
            if (!cmd)
                return false;
            var rst = false;
            switch (cmd.cmdID) {
                case DrawRectCmd.ID: {
                    let tcmd = cmd;
                    if (tcmd.percent)
                        _rect.setTo(tcmd.x * sp.width, tcmd.y * sp.height, tcmd.width * sp.width, tcmd.height * sp.height);
                    else
                        _rect.setTo(tcmd.x, tcmd.y, tcmd.width, tcmd.height);
                    rst = _rect.contains(x, y);
                    break;
                }
                case DrawCircleCmd.ID: {
                    let tcmd = cmd;
                    let r = tcmd.radius;
                    let d;
                    if (tcmd.percent) {
                        x -= tcmd.x * sp.width;
                        y -= tcmd.y * sp.height;
                        r *= sp.width;
                    }
                    else {
                        x -= tcmd.x;
                        y -= tcmd.y;
                    }
                    d = x * x + y * y;
                    rst = d < r * r;
                    break;
                }
                case DrawEllipseCmd.ID: {
                    let tcmd = cmd;
                    let d;
                    let rx = tcmd.width / 2;
                    let ry = tcmd.height / 2;
                    if (tcmd.percent) {
                        x -= tcmd.x * sp.width;
                        y -= tcmd.y * sp.height;
                        rx *= sp.width;
                        ry *= sp.height;
                    }
                    else {
                        x -= tcmd.x;
                        y -= tcmd.y;
                    }
                    d = Math.pow(x / rx, 2) + Math.pow(x / ry, 2);
                    rst = d < 1;
                    break;
                }
                case DrawPolyCmd.ID: {
                    let tcmd = cmd;
                    x -= tcmd.x;
                    y -= tcmd.y;
                    rst = Utils.testPointInPolygon(x, y, tcmd.points);
                    break;
                }
            }
            return rst;
        }
        get hit() {
            if (!this._hit)
                this._hit = new Graphics();
            return this._hit;
        }
        set hit(value) {
            this._hit = value;
        }
        get unHit() {
            if (!this._unHit)
                this._unHit = new Graphics();
            return this._unHit;
        }
        set unHit(value) {
            this._unHit = value;
        }
        onAfterDeserialize() {
            if (this._hitCmds) {
                this.hit.cmds = this._hitCmds;
                delete this._hitCmds;
            }
            if (this._unHitCmds) {
                this.unHit.cmds = this._unHitCmds;
                delete this._unHitCmds;
            }
        }
    }
    ClassUtils.regClass("HitArea", HitArea);

    class JsonBin {
        static isJsonBin(data) {
            if (data.byteLength < 5)
                return false;
            const value = (new Uint32Array(data, 0, 4))[0];
            return value === ISJSONBIN || value === ISJSONBIN2 || value === ISJSONBIN3;
        }
        static parse(data, createObjWithClass) {
            if (!JsonBin.isJsonBin(data)) {
                let b = new Byte();
                b.writeArrayBuffer(data);
                b.pos = 0;
                let str = b.readUTFBytes();
                return JSON.parse(str);
            }
            _createObjWithClass = createObjWithClass;
            let bData = new Byte();
            let strMap;
            let binMark;
            bData.writeArrayBuffer(data);
            bData.pos = 0;
            _objectRef = {};
            binMark = bData.readInt32();
            switch (binMark) {
                case ISJSONBIN:
                    strMap = bData.readUTFString();
                    break;
                case ISJSONBIN2:
                case ISJSONBIN3:
                    strMap = bData.readUTFString32();
                    break;
                default:
                    bData.pos = 0;
                    return null;
            }
            var keyMap = {
                keys: {},
                strs: ["BEGIN", 0],
                keyArray: [],
                keyIndex: 1
            };
            keyMap.strs = strMap.split(SPLITCHAR);
            keyMap.keyArray.length = keyMap.strs.length / 2;
            for (var i = 0, n = keyMap.strs.length; i < n; i += 2) {
                keyMap.keyArray[i / 2] = [keyMap.strs[i], parseInt(keyMap.strs[i + 1])];
            }
            _dataStartOfs = bData.pos;
            var r = {};
            readOne(r, bData, null, OBJECT, keyMap);
            return binMark == ISJSONBIN3 ? r.top : r;
        }
        static write(o, enableClass) {
            _classEnable_ = enableClass;
            var keyMap = {
                keys: {},
                strs: ["BEGIN", 0],
                keyArray: [],
                keyIndex: 1
            };
            _objectRef = {};
            var out = new Byte();
            writeObject(out, keyMap, { top: o });
            out.writeUint16(OBJECTEND);
            var r = new Byte();
            r.writeInt32(ISJSONBIN3);
            r.writeUTFString32(keyMap.strs.join(SPLITCHAR));
            r.writeArrayBuffer(out.buffer);
            return r.buffer;
        }
    }
    class JsonBinRead {
        static get instance() {
            return JsonBinRead._instance || (JsonBinRead._instance = new JsonBinRead());
        }
        static IsJsonbin(data) {
            return JsonBin.isJsonBin(data);
        }
        static parse(value) {
            return JsonBin.parse(value);
        }
        read(data, createObjWithClass) {
            return JsonBin.parse(data, createObjWithClass);
        }
    }
    class JsonBinWrite {
        static get instance() {
            return JsonBinWrite._instance || (JsonBinWrite._instance = new JsonBinWrite());
        }
        write(o, enableClass) {
            return JsonBin.write(o, enableClass);
        }
    }
    const ISJSONBIN = 0xFFFFFF;
    const ISJSONBIN2 = 0xFFFFFE;
    const ISJSONBIN3 = 0xFFFFFD;
    const SPLITCHAR = String.fromCharCode(3);
    const COMPRESS_NEW = 1;
    const NUM8 = 0;
    const NUM16 = 1;
    const NUM32 = 2;
    const BOOLEAN = 3;
    const DOUBLE = 4;
    const STRING = 5;
    const ARRAY8 = 6;
    const ARRAY16 = 7;
    const ARRAYEMPTY = 8;
    const ARRAYNUM8 = 9;
    const ARRAYNUM16 = 10;
    const ARRAYNUM32 = 11;
    const ARRAYDOUBLE = 12;
    const NULL = 14;
    const OBJECT = 15;
    const NUM16_1000 = 16;
    const NUM32_1000 = 17;
    const WORDTEXT = 18;
    const ARRAYBUFFER = 19;
    const ARRAYREF = 20;
    const ARRAYREFSOURCE8 = 21;
    const ARRAYREFSOURCE16 = 22;
    const ARRAYBUFFER32 = 23;
    const ARRAYREF32 = 24;
    const ARRAY32 = 25;
    const OBJECTTHISCLASS = 26;
    const NUM64 = 27;
    const INT8ARRAY = 28;
    const UINT8ARRAY = 29;
    const INT16ARRAY = 30;
    const FLOAT32ARRAY = 31;
    const OBJECTEND = 0x7FFF;
    var _objectRef;
    var _dataStartOfs;
    var _createObjWithClass;
    function readArray(data, pos, n, type, keyMap) {
        var array = [];
        array.length = n;
        var endPos;
        if (pos >= 0) {
            endPos = data.pos;
            data.pos = pos;
        }
        for (var i = 0; i < n; i++) {
            array[i] = readOne({}, data, null, data.readUint8(), keyMap);
        }
        if (pos >= 0) {
            data.pos = endPos;
        }
        return array;
    }
    function getLen(data) {
        let n = data.readUint8();
        return (n & 0x80) === 0 ? n : (data.readUint8() | ((n & ~0x80) << 8));
    }
    function readOne(parent, data, key, type, keyMap) {
        let n, value;
        switch (type) {
            case NULL:
                value = null;
                break;
            case NUM8:
                value = data.readByte();
                break;
            case NUM16:
                value = data.readInt16();
                break;
            case NUM32:
                value = data.readInt32();
                break;
            case NUM64:
                value = toLargeNumber(data.readInt32(), data.readInt32());
                break;
            case BOOLEAN:
                value = data.readByte() ? true : false;
                break;
            case DOUBLE:
                value = data.readFloat32();
                break;
            case NUM16_1000:
                value = data.readInt16() / 1000;
                break;
            case NUM32_1000:
                value = data.readInt32() / 1000;
                break;
            case STRING:
                value = keyMap.keyArray[data.readUint16()][0];
                break;
            case WORDTEXT:
                break;
            case ARRAYEMPTY:
                data.readUint8();
                value = [];
                break;
            case ARRAYNUM8:
                value = [];
                value.length = n = data.readUint8();
                for (let i = 0; i < n; i++)
                    value[i] = data.readByte();
                break;
            case ARRAYNUM16:
                value = [];
                value.length = n = data.readUint8();
                for (let i = 0; i < n; i++)
                    value[i] = data.readInt16();
                break;
            case ARRAYNUM32:
                value = [];
                value.length = n = data.readUint8();
                for (let i = 0; i < n; i++)
                    value[i] = data.readInt32();
                break;
            case ARRAYDOUBLE:
                value = [];
                value.length = n = data.readUint8();
                for (let i = 0; i < n; i++)
                    value[i] = data.readFloat32();
                break;
            case ARRAYBUFFER:
                value = data.readArrayBuffer(data.readUint16());
                break;
            case ARRAYBUFFER32:
                value = data.readArrayBuffer(data.readUint32());
                break;
            case INT8ARRAY:
                n = getLen(data);
                value = data.readInt8Array(data.pos, n);
                break;
            case UINT8ARRAY:
                n = getLen(data);
                value = data.readUint8Array(data.pos, n);
                break;
            case INT16ARRAY:
                n = getLen(data);
                value = data.readInt16Array(data.pos, n);
                break;
            case FLOAT32ARRAY:
                n = getLen(data);
                value = data.readFloat32Array(data.pos, n);
                break;
            default:
                return readOne_other(parent, data, key, type, keyMap);
        }
        parent && key && (parent[key] = value);
        return value;
    }
    function readOne_other(parent, data, key, type, keyMap) {
        let cur = parent;
        let value;
        let n, i;
        let pos;
        switch (type) {
            case ARRAY8:
            case ARRAY16:
            case ARRAY32:
                switch (type) {
                    case ARRAY8:
                        n = data.readUint8();
                        break;
                    case ARRAY16:
                        n = data.readInt16();
                        break;
                    case ARRAY32:
                        n = data.readUint32();
                        break;
                }
                var array = value = [];
                array.length = n;
                for (i = 0; i < n; i++) {
                    type = data.readUint8();
                    array[i] = readOne(null, data, null, type, keyMap);
                }
                break;
            case ARRAYREFSOURCE8:
            case ARRAYREFSOURCE16:
                n = type === ARRAYREFSOURCE8 ? data.readUint8() : data.readInt16();
                pos = data.pos - _dataStartOfs;
                value = readArray(data, -1, n, type, keyMap);
                _objectRef[pos] = { array: value, pos: pos };
                break;
            case ARRAYREF:
            case ARRAYREF32:
                i = data.readByte();
                pos = type === ARRAYREF ? data.readUint16() : data.readUint32();
                let objectRef = _objectRef[pos];
                if (!objectRef) {
                    throw new Error("load ref err");
                }
                if (i === COMPRESS_NEW) {
                    value = readArray(data, pos + _dataStartOfs, objectRef.array.length, type, keyMap);
                }
                else
                    value = objectRef.array;
                break;
            case OBJECT:
            case OBJECTTHISCLASS:
                if (key != null || !parent) {
                    if (type === OBJECT) {
                        cur = {};
                    }
                    else {
                        n = data.readUint16();
                        cur = _createObjWithClass(keyMap.keyArray[n][0]);
                        if (!cur)
                            throw new Error("jsonbin read err,no this class:" + keyMap.keyArray[n][0]);
                    }
                    key && parent && (parent[key] = cur);
                }
                let keyDef;
                while (true) {
                    n = data.readUint16();
                    if (n === OBJECTEND)
                        break;
                    keyDef = keyMap.keyArray[n];
                    readOne(cur, data, keyDef[0], keyDef[1], keyMap);
                }
                value = cur;
                cur = parent;
                break;
        }
        (key != null) && (cur[key] = value);
        return value;
    }
    function toLargeNumber(n1, n2) {
        let n2str = n2.toString(16);
        if (n2str.length < 7) {
            for (let i = n2str.length; i < 7; i++)
                n2str = "0" + n2str;
        }
        return parseInt(n1.toString(16) + "" + n2str, 16);
    }
    const COMPRESS = "_$TeMpkEy$_CoMpReSs";
    const NOSAVEKEY = "_$TeMpkEyNoSv$_";
    const NOSAVE_KEY_LEN = 15;
    const NOSAVETHISOBJ_DELETE = 2;
    var _objectRef = {};
    var _classEnable_;
    function saveKey(key, valueType, keyMap, out) {
        var keysv = key + "/&&__*?/" + valueType;
        var keyNum = has(keyMap.keys, keysv) ? keyMap.keys[keysv] : undefined;
        if (!keyNum) {
            keyNum = keyMap.keys[keysv] = keyMap.keyIndex;
            keyMap.strs.push(key, valueType);
            keyMap.keyIndex++;
        }
        out.writeUint16(keyNum);
    }
    function getValueArrayType(value) {
        switch (typeof (value)) {
            case "number":
                if (Math.floor(value) !== value)
                    return ARRAYDOUBLE;
                var valueabs = Math.abs(value);
                if (valueabs < 128)
                    return ARRAYNUM8;
                if (valueabs < 0x7FFF)
                    return ARRAYNUM16;
                return ARRAYNUM32;
            case "string":
                return OBJECT;
            case "boolean":
                return BOOLEAN;
        }
        return OBJECT;
    }
    function writeStrOrWordText(keyMap, key, value, out, isWordText) {
        var type = isWordText ? WORDTEXT : STRING;
        (key != null) ? (saveKey(key, type, keyMap, out)) : (out.writeUint8(type));
        var keyNum = has(keyMap.keys, value) ? keyMap.keys[value] : undefined;
        if (keyNum === undefined) {
            keyNum = keyMap.keyIndex;
            keyMap.keys[value] = keyNum;
            keyMap.strs.push(value, 0);
            keyMap.keyIndex++;
        }
        out.writeUint16(keyNum);
    }
    function writeString(keyMap, value, out) {
        var keyNum = has(keyMap.keys, value) ? keyMap.keys[value] : undefined;
        if (keyNum === undefined) {
            keyNum = keyMap.keyIndex;
            keyMap.keys[value] = keyNum;
            keyMap.strs.push(value, 0);
            keyMap.keyIndex++;
        }
        out.writeUint16(keyNum);
    }
    function getObjectTypeof(value) {
        if (value instanceof ArrayBuffer)
            return "ArrayBuffer";
        if (value instanceof Uint8Array)
            return "Uint8Array";
        if (value instanceof Int8Array)
            return "Int8Array";
        if (value instanceof Int16Array)
            return "Int16Array";
        if (value instanceof Float32Array)
            return "Float32Array";
        return "object";
    }
    function writeLen(out, len) {
        if (len < 0x80)
            out.writeUint8(len);
        else if (len < 0x8000) {
            out.writeUint8((len >> 8) | 0x80);
            out.writeUint8(len & 0xFF);
        }
        else
            throw new Error("jsonbin save len must<0x8000" + " " + len);
    }
    function writeBigNumber(out, value) {
        let numstr = value.toString(16);
        let n1 = parseInt(numstr.substring(0, numstr.length - 7), 16);
        let n2 = parseInt(numstr.substring(numstr.length - 7), 16);
        out.writeInt32(n1);
        out.writeInt32(n2);
        if (toLargeNumber(n1, n2) != value)
            throw new Error("save big number err:" + value);
    }
    function writeOne(out, keyMap, key, value, parent) {
        if (value == undefined) {
            return false;
        }
        let type = typeof (value);
        if (type === "object" && value) {
            if (value.$__$disbaleJsonBinSv) {
                if (value.$__$disbaleJsonBinSv === NOSAVETHISOBJ_DELETE) ;
                return false;
            }
            type = getObjectTypeof(value);
        }
        switch (type) {
            case "number":
                if (Math.floor(value) !== value) {
                    var value1000 = value * 1000;
                    if ((value1000 | 0) === value1000) {
                        if (Math.abs(value) < 32) {
                            (key != null) ? saveKey(key, NUM16_1000, keyMap, out) : out.writeUint8(NUM16_1000);
                            out.writeInt16(value1000);
                            return true;
                        }
                        if (Math.abs(value) < 2147483) {
                            (key != null) ? saveKey(key, NUM32_1000, keyMap, out) : out.writeUint8(NUM32_1000);
                            out.writeInt32(value1000);
                            return true;
                        }
                    }
                    (key != null) ? saveKey(key, DOUBLE, keyMap, out) : out.writeUint8(DOUBLE);
                    out.writeFloat32(value);
                    return true;
                }
                var valueabs = Math.abs(value);
                if (valueabs < 128) {
                    (key != null) ? saveKey(key, NUM8, keyMap, out) : out.writeUint8(NUM8);
                    out.writeByte(value);
                    return true;
                }
                if (valueabs < 0x7FFF) {
                    (key != null) ? saveKey(key, NUM16, keyMap, out) : out.writeUint8(NUM16);
                    out.writeInt16(value);
                    return true;
                }
                if (valueabs < 0x7FFFFFFF) {
                    (key != null) ? saveKey(key, NUM32, keyMap, out) : out.writeUint8(NUM32);
                    out.writeInt32(value);
                    return true;
                }
                (key != null) ? saveKey(key, NUM64, keyMap, out) : out.writeUint8(NUM64);
                writeBigNumber(out, value);
                return true;
            case "string":
                writeStrOrWordText(keyMap, key, value, out, false);
                return true;
            case "boolean":
                (key != null) ? saveKey(key, BOOLEAN, keyMap, out) : out.writeUint8(BOOLEAN);
                out.writeByte(value ? 1 : 0);
                return true;
            case 'ArrayBuffer':
                (key != null) ? saveKey(key, ARRAYBUFFER32, keyMap, out) : out.writeUint8(ARRAYBUFFER32);
                out.writeUint32(value.byteLength);
                out.writeArrayBuffer(value);
                return true;
            case 'Uint8Array':
                (key != null) ? saveKey(key, UINT8ARRAY, keyMap, out) : out.writeUint8(UINT8ARRAY);
                writeLen(out, value.length);
                out.writeArrayBuffer(value.buffer);
                return true;
            case 'Int8Array':
                (key != null) ? saveKey(key, INT8ARRAY, keyMap, out) : out.writeUint8(INT8ARRAY);
                writeLen(out, value.length);
                out.writeArrayBuffer(value.buffer);
                return true;
            case 'Int16Array':
                (key != null) ? saveKey(key, INT16ARRAY, keyMap, out) : out.writeUint8(INT16ARRAY);
                writeLen(out, value.length);
                out.writeArrayBuffer(value.buffer);
                return true;
            case 'Float32Array':
                (key != null) ? saveKey(key, FLOAT32ARRAY, keyMap, out) : out.writeUint8(FLOAT32ARRAY);
                writeLen(out, value.length);
                out.writeArrayBuffer(value.buffer);
                return true;
            case 'WordText':
                writeStrOrWordText(keyMap, key, value._text, out, true);
                return true;
            case "object":
                break;
            default:
                throw new Error("jsonbin no this type:" + type);
        }
        if (!value) {
            (key != null) ? saveKey(key, NULL, keyMap, out) : out.writeUint8(NULL);
            return true;
        }
        if (!(value instanceof Array)) {
            if (_classEnable_ && value.__CLASS__) {
                (key != null) ? saveKey(key, OBJECTTHISCLASS, keyMap, out) : out.writeUint8(OBJECTTHISCLASS);
            }
            else
                (key != null) ? saveKey(key, OBJECT, keyMap, out) : out.writeUint8(OBJECT);
            writeObject(out, keyMap, value);
            out.writeUint16(OBJECTEND);
            return true;
        }
        return saveArray(parent, out, keyMap, key, value);
    }
    function saveArray(parent, out, keyMap, key, value) {
        var j, n = value.length;
        if (n === 0) {
            (key != null) ? saveKey(key, ARRAYEMPTY, keyMap, out) : out.writeUint8(ARRAYEMPTY);
            out.writeByte(0);
            return true;
        }
        var startType;
        if (n > 1 && n < 250 && ((startType = getValueArrayType(value[0])) != OBJECT)) {
            for (j = 1; j < n; j++) {
                if (startType !== getValueArrayType(value[j])) {
                    startType = OBJECT;
                    break;
                }
            }
            if (startType != OBJECT && startType != BOOLEAN) {
                (key != null) ? saveKey(key, startType, keyMap, out) : out.writeUint8(startType);
                out.writeUint8(value.length);
                switch (startType) {
                    case ARRAYNUM8:
                        for (j = 0; j < n; j++)
                            out.writeByte(value[j]);
                        break;
                    case ARRAYNUM16:
                        for (j = 0; j < n; j++)
                            out.writeInt16(value[j]);
                        break;
                    case ARRAYNUM32:
                        for (j = 0; j < n; j++)
                            out.writeInt32(value[j]);
                        break;
                    case ARRAYDOUBLE:
                        for (j = 0; j < n; j++)
                            out.writeFloat32(value[j]);
                        break;
                }
                return true;
            }
        }
        var typeArray;
        if (n < 250) {
            typeArray = ARRAY8;
        }
        else if (n < 32700) {
            typeArray = ARRAY16;
        }
        else {
            typeArray = ARRAY32;
        }
        var posHead = out.pos;
        (key != null) ? saveKey(key, typeArray, keyMap, out) : out.writeUint8(typeArray);
        var pos = out.pos, s = 0;
        switch (typeArray) {
            case ARRAY8:
                out.writeUint8(n);
                break;
            case ARRAY16:
                out.writeInt16(n);
                break;
            case ARRAY32:
                out.writeUint32(n);
                break;
        }
        var posData = out.pos;
        for (j = 0; j < n; j++) {
            if (writeOne(out, keyMap, null, value[j], parent))
                s++;
        }
        if (s != n) {
            var tmp = out.pos;
            out.pos = pos;
            typeArray === ARRAY8 ? out.writeUint8(s) : out.writeInt16(s);
            out.pos = tmp;
        }
        var compress;
        if (key && parent && (compress = parent[COMPRESS + key])) {
            useCompress(out, keyMap, key, value, posHead, posData, compress, typeArray);
        }
        return true;
    }
    function useCompress(out, keyMap, key, value, posHead, dataPos, compress, typeArray) {
        var dLen = out.pos - dataPos;
        var hashCode = getHash(out._u8d_, dataPos, dLen);
        var same;
        var src;
        var i, n;
        if (_objectRef[hashCode]) {
            var datas = _objectRef[hashCode];
            n = datas.length;
            for (i = 0; i < n; i++) {
                src = datas[i];
                if (src.value == value) {
                    same = src;
                    break;
                }
            }
            if (!same) {
                for (i = 0; i < n; i++) {
                    src = datas[i];
                    if (isSame(out._u8d_, src.pos, src.len, out._u8d_, dataPos, dLen)) {
                        same = src;
                        break;
                    }
                }
            }
        }
        else
            _objectRef[hashCode] = [];
        if (!same) {
            _objectRef[hashCode].push({ hashCode: hashCode, pos: dataPos, len: dLen, value: value });
            out.pos = posHead;
            saveKey(key, typeArray === ARRAY8 ? ARRAYREFSOURCE8 : ARRAYREFSOURCE16, keyMap, out);
            out.pos = dataPos + dLen;
        }
        else {
            out.pos = posHead;
            saveKey(key, ARRAYREF32, keyMap, out);
            out.writeByte(compress);
            out.writeUint32(same.pos);
        }
    }
    function writeObject(out, keyMap, o) {
        _classEnable_ && o.__CLASS__ && writeString(keyMap, o.__CLASS__, out);
        for (var key in o) {
            if (key && key.length > NOSAVE_KEY_LEN && key.substr(0, NOSAVE_KEY_LEN) == NOSAVEKEY) {
                continue;
            }
            (_classEnable_ && key == "__CLASS__") || writeOne(out, keyMap, key, o[key], o);
        }
    }
    function getHash(buffer, start, len, magic = 9191891) {
        var i;
        var rst = 0;
        for (i = 0; i < len; i++) {
            rst = (rst * 2 + buffer[start + i]) % magic;
        }
        return rst;
    }
    function isSame(buffer1, start1, len1, buffer2, start2, len2) {
        if (len1 != len2)
            return false;
        var i, len;
        len = len1;
        for (i = 0; i < len; i++) {
            if (buffer1[start1 + i] != buffer2[start2 + i])
                return false;
        }
        return true;
    }
    const hasOwnProp = Object.prototype.hasOwnProperty;
    function has(obj, key) {
        return hasOwnProp.call(obj, key);
    }

    class Mouse {
        static set cursor(value) {
            this._cursor = value;
            if (this._hidden)
                return;
            PAL.browser.setCursor(value);
        }
        static get cursor() {
            return this._cursor;
        }
        static hide() {
            this._hidden = true;
            PAL.browser.setCursor("none");
        }
        static show() {
            this._hidden = false;
            PAL.browser.setCursor(this._cursor);
        }
    }
    Mouse._cursor = "auto";
    Mouse._hidden = false;

    class StatUI {
        createUI() {
            this._pass = LayaGL.render2DRenderPassFactory.createRender2DPass();
            let sp = this._sp = new Sprite();
            this._pass.root = this._sp._struct;
            this._sp._struct.pass = this._pass;
            this._pass.doClearColor = false;
            let leftText = this._title = new Text();
            leftText.pos(5, 5);
            leftText.color = "#ffffff";
            leftText.name = "title";
            sp.addChild(leftText);
            let rightText = this._txt = new Text();
            rightText.singleCharRender = true;
            rightText.pos(100, 5);
            rightText.color = "#ffffff";
            rightText.name = "txt";
            sp.addChild(rightText);
            sp.graphics.clear();
            sp.graphics.alpha(0.5);
            sp.graphics.drawRect(0, 0, 1, 1, "#999999", null, null, true);
            Laya.stage.on(Event.RESIZE, this, this.updateSize);
        }
        updateSize() {
            let fontSize = Browser.onMobile ? 10 : 12;
            fontSize = Math.max(fontSize, fontSize / (Laya.stage._canvasTransform.a * Laya.stage.clientScaleX));
            this._txt.fontSize = fontSize;
            this._title.fontSize = fontSize;
            this._txt.x = this._title.textWidth + 10;
            this._sp.size(this._title.textWidth + fontSize * 8, this._title.textHeight + 10);
            this._sp._globalTrans._spTransChanged(exports.TransformKind.TRS);
        }
        _displayChild(node, display) {
            for (let child of node._children) {
                if (child._children.length > 0) {
                    this._displayChild(child, display);
                }
                else {
                    child._setDisplay(display);
                }
            }
            node._setDisplay(display);
        }
        show(x, y) {
            this._items = new Array();
            strArray.length = 0;
            for (let element of Stat.elements) {
                let name = exports.StatElement[element];
                let title = name.replace(/^(T_|C_|M_|CT_)/, "").replace(/_/g, " ");
                let unit = "";
                let fractionDigits = 3;
                if (name.startsWith("CT_") || name.startsWith("C_"))
                    fractionDigits = 0;
                else if (name.startsWith("M_"))
                    unit = "M";
                else if (name.startsWith("T_"))
                    unit = "ms";
                this._items.push({
                    value: element,
                    fractionDigits,
                    unit
                });
                strArray.push(title);
            }
            if (!this._sp)
                this.createUI();
            this._title.text = strArray.join("\n");
            this._sp.pos(x || 0, y || 0);
            this._sp._parent = Laya.stage;
            this.updateSize();
            this._displayChild(this._sp, true);
        }
        hide() {
            if (!this._sp)
                return;
            this._title.text = null;
            this._txt.text = null;
            this._sp._parent = null;
            this._displayChild(this._sp, false);
        }
        update() {
            strArray.length = 0;
            for (let i = 0; i < this._items.length; i++) {
                let item = this._items[i];
                let datavalue = LayaGL.statAgent.getElementData(item.value);
                let str = datavalue.toFixed(item.fractionDigits).replace(digitPattern, '$1');
                if (str == "-0")
                    str = "0";
                strArray.push(str + " " + item.unit);
            }
            this._txt.text = strArray.join("\n");
        }
        render() {
            this._pass && this._pass.fowardRender(Render2DProcessor.rendercontext2D);
        }
    }
    const strArray = [];
    const digitPattern = /\.0*$|(\.\d*[1-9])0+$/;
    Stat._statUIClass = StatUI;

    class WasmAdapter {
        static create(module, wasmFile) {
            var _a;
            let webDir;
            if (typeof document != 'undefined') {
                webDir = (_a = Browser.document.currentScript) === null || _a === void 0 ? void 0 : _a.src;
                if (webDir)
                    webDir = webDir.substring(0, webDir.replace(/[?#].*/, "").lastIndexOf("/") + 1);
            }
            return () => {
                let moduleArg = {};
                if (WasmAdapter.instantiateWasm != null) {
                    moduleArg["instantiateWasm"] = function (imports, receiveInstance) {
                        return WasmAdapter.instantiateWasm(wasmFile, imports).then(exports => {
                            receiveInstance(exports["instance"]);
                            return exports;
                        });
                    };
                }
                moduleArg["locateFile"] = function (path, scriptDirectory) {
                    if (WasmAdapter.locateFile != null)
                        wasmFile = WasmAdapter.locateFile(path, scriptDirectory, webDir);
                    else
                        wasmFile = WasmAdapter.locateFileDefault(path, scriptDirectory);
                    return wasmFile;
                };
                return module(moduleArg);
            };
        }
        static locateFileDefault(path, scriptDirectory) {
            if (URL.urlMapping[path])
                return URL.formatURL(path, '');
            else
                return scriptDirectory != null ? scriptDirectory + path : path;
        }
    }
    WasmAdapter.Memory = typeof (window.WebAssembly) !== "undefined" ? window.WebAssembly.Memory : null;

    class WeakObject {
        static get I() {
            return this._i || (this._i = new WeakObject());
        }
        static clearCache() {
            for (let i = 0, n = WeakObject._maps.length; i < n; i++) {
                let obj = WeakObject._maps[i];
                obj._obj = {};
            }
        }
        constructor() {
            this._obj = {};
            if (!WeakObject._maps) {
                WeakObject._maps = [this];
                ILaya.systemTimer.loop(WeakObject.delInterval, null, WeakObject.clearCache);
            }
            else
                WeakObject._maps.push(this);
        }
        set(key, value) {
            if (key == null)
                return;
            if (typeof (key) == 'string' || typeof (key) == 'number') {
                this._obj[key] = value;
            }
            else {
                this._obj[Utils.getGID(key)] = value;
            }
        }
        get(key) {
            if (key == null)
                return null;
            if (typeof (key) == 'string' || typeof (key) == 'number')
                return this._obj[key];
            else
                return this._obj[Utils.getGID(key)];
        }
        del(key) {
            if (key == null)
                return;
            if (typeof (key) == 'string' || typeof (key) == 'number')
                delete this._obj[key];
            else
                delete this._obj[Utils.getGID(key)];
        }
        has(key) {
            if (key == null)
                return false;
            if (typeof (key) == 'string' || typeof (key) == 'number')
                return this._obj[key] != null;
            else
                return this._obj[Utils.getGID(key)] != null;
        }
    }
    WeakObject.delInterval = 10 * 60 * 1000;

    class BufferState {
        constructor() {
            this._deviceBufferState = LayaGL.renderDeviceFactory.createBufferState();
        }
        applyState(vertexBuffers, indexBuffer) {
            this._vertexBuffers = vertexBuffers;
            this._bindedIndexBuffer = indexBuffer;
            if (!this._deviceBufferState)
                return;
            if (vertexBuffers.length == 1) {
                BufferState.vertexBufferArray.length = 1;
                BufferState.vertexBufferArray[0] = vertexBuffers[0]._deviceBuffer;
            }
            else {
                BufferState.vertexBufferArray.length = 0;
                vertexBuffers.forEach(element => {
                    BufferState.vertexBufferArray.push(element._deviceBuffer);
                });
            }
            this._deviceBufferState.applyState(BufferState.vertexBufferArray, indexBuffer ? indexBuffer._deviceBuffer : null);
        }
        destroy() {
            if (!this._deviceBufferState)
                return;
            this._deviceBufferState.destroy();
            this._deviceBufferState = null;
        }
    }
    BufferState.vertexBufferArray = [];

    exports.AlphaCmd = AlphaCmd;
    exports.Animation = Animation;
    exports.Animation2DCondition = Animation2DCondition;
    exports.Animation2DEvent = Animation2DEvent;
    exports.Animation2DParm = Animation2DParm;
    exports.AnimationClip2D = AnimationClip2D;
    exports.AnimationClip2DParse01 = AnimationClip2DParse01;
    exports.Animator2D = Animator2D;
    exports.AnimatorController2D = AnimatorController2D;
    exports.AnimatorControllerLayer2D = AnimatorControllerLayer2D;
    exports.AnimatorControllerParse = AnimatorControllerParse;
    exports.AnimatorPlayState2D = AnimatorPlayState2D;
    exports.AnimatorState2D = AnimatorState2D;
    exports.AnimatorState2DScript = AnimatorState2DScript;
    exports.AnimatorStateBoolCondition = AnimatorStateBoolCondition;
    exports.AnimatorStateCondition = AnimatorStateCondition;
    exports.AnimatorStateNumberCondition = AnimatorStateNumberCondition;
    exports.AnimatorStateTriggerCondition = AnimatorStateTriggerCondition;
    exports.AnimatorTransition2D = AnimatorTransition2D;
    exports.Area2D = Area2D;
    exports.AssetDb = AssetDb;
    exports.AtlasGrid = AtlasGrid;
    exports.AtlasInfoManager = AtlasInfoManager;
    exports.AtlasResource = AtlasResource;
    exports.AudioDataCache = AudioDataCache;
    exports.Base64Tool = Base64Tool;
    exports.BasePoly = BasePoly;
    exports.BaseRenderNode2D = BaseRenderNode2D;
    exports.BaseTexture = BaseTexture;
    exports.BatchProgress = BatchProgress;
    exports.Bezier = Bezier;
    exports.BitmapFont = BitmapFont;
    exports.BlendComponent = BlendComponent;
    exports.BlendModeHandler = BlendModeHandler;
    exports.BlendState = BlendState;
    exports.Blit2DCMD = Blit2DCMD;
    exports.Blit2DQuadCMD = Blit2DQuadCMD;
    exports.BlurEffect2D = BlurEffect2D;
    exports.BlurFilter = BlurFilter;
    exports.BooleanKeyframe = BooleanKeyframe;
    exports.Browser = Browser;
    exports.BrowserAdapter = BrowserAdapter;
    exports.Buffer = Buffer;
    exports.BufferState = BufferState;
    exports.ButtonEffect = ButtonEffect;
    exports.Byte = Byte;
    exports.Camera2D = Camera2D;
    exports.CircleMesh = CircleMesh;
    exports.ClassUtils = ClassUtils;
    exports.ClipRectCmd = ClipRectCmd;
    exports.Color = Color;
    exports.ColorEffect2D = ColorEffect2D;
    exports.ColorFilter = ColorFilter;
    exports.ColorUtils = ColorUtils;
    exports.Command2D = Command2D;
    exports.CommandBuffer2D = CommandBuffer2D;
    exports.CommandEncoder = CommandEncoder;
    exports.CommandUniformMap = CommandUniformMap;
    exports.Component = Component;
    exports.ComponentDriver = ComponentDriver;
    exports.ComputeCommandAppatchCMD = ComputeCommandAppatchCMD;
    exports.ComputeCommandBuffer = ComputeCommandBuffer;
    exports.ComputeShader = ComputeShader;
    exports.Config = Config;
    exports.Config3D = Config3D;
    exports.Const = Const;
    exports.CopyTextureInfo = CopyTextureInfo;
    exports.CurvePath = CurvePath;
    exports.DDSTextureInfo = DDSTextureInfo;
    exports.DefaultStaticsContext = DefaultStaticsContext;
    exports.Delegate = Delegate;
    exports.DeviceAdapter = DeviceAdapter;
    exports.Downloader = Downloader;
    exports.DragSupport = DragSupport;
    exports.Draw2DElementCMD = Draw2DElementCMD;
    exports.Draw9GridTextureCmd = Draw9GridTextureCmd;
    exports.DrawCircleCmd = DrawCircleCmd;
    exports.DrawCurvesCmd = DrawCurvesCmd;
    exports.DrawEllipseCmd = DrawEllipseCmd;
    exports.DrawImageCmd = DrawImageCmd;
    exports.DrawLineCmd = DrawLineCmd;
    exports.DrawLinesCmd = DrawLinesCmd;
    exports.DrawMesh2DCMD = DrawMesh2DCMD;
    exports.DrawPathCmd = DrawPathCmd;
    exports.DrawPieCmd = DrawPieCmd;
    exports.DrawPolyCmd = DrawPolyCmd;
    exports.DrawRectCmd = DrawRectCmd;
    exports.DrawRenderElement2DCMD = DrawRenderElement2DCMD;
    exports.DrawRoundRectCmd = DrawRoundRectCmd;
    exports.DrawStyle = DrawStyle;
    exports.DrawTextureCmd = DrawTextureCmd;
    exports.DrawTexturesCmd = DrawTexturesCmd;
    exports.DrawTrianglesCmd = DrawTrianglesCmd;
    exports.Earcut = Earcut;
    exports.EarcutNode = EarcutNode;
    exports.Ease = Ease;
    exports.Effect2DShaderInit = Effect2DShaderInit;
    exports.EffectBase = EffectBase;
    exports.Event = Event;
    exports.EventDispatcher = EventDispatcher;
    exports.FadeIn = FadeIn;
    exports.FadeOut = FadeOut;
    exports.FastSinglelist = FastSinglelist;
    exports.FileSystemAdapter = FileSystemAdapter;
    exports.FillTextCmd = FillTextCmd;
    exports.FillTextureCmd = FillTextureCmd;
    exports.Filter = Filter;
    exports.FlipMesh = FlipMesh;
    exports.FloatKeyframe = FloatKeyframe;
    exports.FontAdapter = FontAdapter;
    exports.FrameAnimation = FrameAnimation;
    exports.GLSLCodeGenerator = GLSLCodeGenerator;
    exports.GlowEffect2D = GlowEffect2D;
    exports.GlowFilter = GlowFilter;
    exports.Gradient = Gradient;
    exports.GradientMode = GradientMode;
    exports.GrahamScan = GrahamScan;
    exports.Graphic2DDynamicVIBuffer = Graphic2DDynamicVIBuffer;
    exports.Graphics = Graphics;
    exports.GraphicsBounds = GraphicsBounds;
    exports.GraphicsMesh = GraphicsMesh;
    exports.GraphicsRenderData = GraphicsRenderData;
    exports.GraphicsRunner = GraphicsRunner;
    exports.GraphicsShaderInfo = GraphicsShaderInfo;
    exports.GrayscaleEffect2D = GrayscaleEffect2D;
    exports.HDRTextureInfo = HDRTextureInfo;
    exports.HTMLAudioChannel = HTMLAudioChannel;
    exports.HTMLCanvas = HTMLCanvas;
    exports.HTMLVideoPlayer = HTMLVideoPlayer;
    exports.HTMLVideoTexture = HTMLVideoTexture;
    exports.HalfFloatUtils = HalfFloatUtils;
    exports.Handler = Handler;
    exports.HideFlags = HideFlags;
    exports.HierarchyLoader = HierarchyLoader;
    exports.HierarchyParser = HierarchyParser;
    exports.HierarchyResource = HierarchyResource;
    exports.HitArea = HitArea;
    exports.HtmlElement = HtmlElement;
    exports.HtmlImage = HtmlImage;
    exports.HtmlLink = HtmlLink;
    exports.HtmlParseOptions = HtmlParseOptions;
    exports.HtmlParser = HtmlParser;
    exports.HttpRequest = HttpRequest;
    exports.ILaya = ILaya;
    exports.IncludeFile = IncludeFile;
    exports.IndexBuffer = IndexBuffer;
    exports.Input = Input;
    exports.InputManager = InputManager;
    exports.JsonBin = JsonBin;
    exports.JsonBinRead = JsonBinRead;
    exports.JsonBinWrite = JsonBinWrite;
    exports.KTXTextureInfo = KTXTextureInfo;
    exports.KeyLocation = KeyLocation;
    exports.Keyboard = Keyboard;
    exports.Keyframe = Keyframe;
    exports.Keyframe2D = Keyframe2D;
    exports.KeyframeNode2D = KeyframeNode2D;
    exports.KeyframeNodeList2D = KeyframeNodeList2D;
    exports.Laya = Laya;
    exports.LayaEnv = LayaEnv;
    exports.LayaGL = LayaGL;
    exports.LoadModel2DV01 = LoadModel2DV01;
    exports.Loader = Loader;
    exports.LocalStorage = LocalStorage;
    exports.Material = Material;
    exports.MaterialLoader = MaterialLoader;
    exports.MaterialParser = MaterialParser;
    exports.MathUtil = MathUtil;
    exports.MathUtils3D = MathUtils3D;
    exports.Matrix = Matrix;
    exports.Matrix3x3 = Matrix3x3;
    exports.Matrix4x4 = Matrix4x4;
    exports.MediaAdapter = MediaAdapter;
    exports.Mesh2D = Mesh2D;
    exports.Mesh2DReader = Mesh2DReader;
    exports.Mesh2DRender = Mesh2DRender;
    exports.MeshLoader = MeshLoader;
    exports.Mouse = Mouse;
    exports.Node = Node;
    exports.NodeFlags = NodeFlags;
    exports.NotImplementedError = NotImplementedError;
    exports.NotReadableError = NotReadableError;
    exports.NullLoader = NullLoader;
    exports.ObjDecoder = ObjDecoder;
    exports.OpenDataContextView = OpenDataContextView;
    exports.OutOfRangeError = OutOfRangeError;
    exports.PAL = PAL;
    exports.ParseJSON = ParseJSON;
    exports.Path = Path;
    exports.PathPoint = PathPoint;
    exports.PlayerConfig = PlayerConfig;
    exports.Point = Point;
    exports.Pool = Pool;
    exports.PostProcess2D = PostProcess2D;
    exports.PostProcess2DEffect = PostProcess2DEffect;
    exports.PostProcessRenderContext2D = PostProcessRenderContext2D;
    exports.Prefab = Prefab;
    exports.PrefabImpl = PrefabImpl;
    exports.ProgressMesh = ProgressMesh;
    exports.Quaternion = Quaternion;
    exports.QuaternionKeyframe = QuaternionKeyframe;
    exports.Rectangle = Rectangle;
    exports.RegularPolygonMesh = RegularPolygonMesh;
    exports.Render = Render;
    exports.Render2DProcessor = Render2DProcessor;
    exports.RenderState = RenderState;
    exports.RenderState2D = RenderState2D;
    exports.RenderTexture = RenderTexture;
    exports.RenderTexture2D = RenderTexture2D;
    exports.RenderTextureCube = RenderTextureCube;
    exports.RenderTextureLoader = RenderTextureLoader;
    exports.Resource = Resource;
    exports.RestoreCmd = RestoreCmd;
    exports.RotateCmd = RotateCmd;
    exports.RoundedRectMesh = RoundedRectMesh;
    exports.SaveBase = SaveBase;
    exports.SaveClipRect = SaveClipRect;
    exports.SaveCmd = SaveCmd;
    exports.SaveMark = SaveMark;
    exports.SaveStyle = SaveStyle;
    exports.SaveTransform = SaveTransform;
    exports.SaveTranslate = SaveTranslate;
    exports.ScaleCmd = ScaleCmd;
    exports.Scene = Scene;
    exports.Scene2DSpecialManager = Scene2DSpecialManager;
    exports.Script = Script;
    exports.SerializeUtil = SerializeUtil;
    exports.Set2DDefineCMD = Set2DDefineCMD;
    exports.Set2DRTCMD = Set2DRTCMD;
    exports.Set2DShaderDataCMD = Set2DShaderDataCMD;
    exports.SetRenderDataCMD = SetRenderDataCMD;
    exports.SetRendertarget2DCMD = SetRendertarget2DCMD;
    exports.SetShaderDefineCMD = SetShaderDefineCMD;
    exports.Shader2D = Shader2D;
    exports.Shader3D = Shader3D;
    exports.ShaderCompile = ShaderCompile;
    exports.ShaderCompileDefineBase = ShaderCompileDefineBase;
    exports.ShaderData = ShaderData;
    exports.ShaderDataDefaultValue = ShaderDataDefaultValue;
    exports.ShaderDefine = ShaderDefine;
    exports.ShaderDefines2D = ShaderDefines2D;
    exports.ShaderNode = ShaderNode;
    exports.ShaderParser = ShaderParser;
    exports.ShaderPass = ShaderPass;
    exports.ShaderVariable = ShaderVariable;
    exports.ShaderVariantCollection = ShaderVariantCollection;
    exports.SingletonList = SingletonList;
    exports.Socket = Socket;
    exports.SoundChannel = SoundChannel;
    exports.SoundManager = SoundManager;
    exports.SoundNode = SoundNode;
    exports.Sprite = Sprite;
    exports.SpriteConst = SpriteConst;
    exports.SpriteGlobalTransform = SpriteGlobalTransform;
    exports.SpriteUtils = SpriteUtils;
    exports.Stage = Stage;
    exports.Stat = Stat;
    exports.StatUI = StatUI;
    exports.StencilState = StencilState;
    exports.StorageAdapter = StorageAdapter;
    exports.SubShader = SubShader;
    exports.SubStructRender = SubStructRender;
    exports.SubmitBase = SubmitBase;
    exports.SubmitKey = SubmitKey;
    exports.Text = Text;
    exports.TextInputAdapter = TextInputAdapter;
    exports.TextRender = TextRender;
    exports.TextRenderConfig = TextRenderConfig;
    exports.TextResource = TextResource;
    exports.TextStyle = TextStyle;
    exports.Texture = Texture;
    exports.Texture2D = Texture2D;
    exports.Texture2DArray = Texture2DArray;
    exports.Texture2DLoader = Texture2DLoader;
    exports.Texture3D = Texture3D;
    exports.TextureCube = TextureCube;
    exports.TextureLoader = TextureLoader;
    exports.TileMesh = TileMesh;
    exports.TimeLine = TimeLine;
    exports.Timer = Timer;
    exports.TransformCmd = TransformCmd;
    exports.TranslateCmd = TranslateCmd;
    exports.Tween = Tween;
    exports.TweenValue = TweenValue;
    exports.TweenValueAdapterKey = TweenValueAdapterKey;
    exports.Tweener = Tweener;
    exports.TypedArrayClasses = TypedArrayClasses;
    exports.UBBParser = UBBParser;
    exports.URL = URL;
    exports.UniformBufferAlone = UniformBufferAlone;
    exports.UniformBufferBlock = UniformBufferBlock;
    exports.UniformBufferCluster = UniformBufferCluster;
    exports.UniformBufferManager = UniformBufferManager;
    exports.UniformBufferUser = UniformBufferUser;
    exports.Utils = Utils;
    exports.Vector2 = Vector2;
    exports.Vector2Keyframe = Vector2Keyframe;
    exports.Vector3 = Vector3;
    exports.Vector3Keyframe = Vector3Keyframe;
    exports.Vector4 = Vector4;
    exports.Vector4Keyframe = Vector4Keyframe;
    exports.VertexAttributeLayout = VertexAttributeLayout;
    exports.VertexBuffer = VertexBuffer;
    exports.VertexDeclaration = VertexDeclaration;
    exports.VertexElement = VertexElement;
    exports.VertexElementFormat = VertexElementFormat;
    exports.VertexMesh = VertexMesh;
    exports.VertexMesh2D = VertexMesh2D;
    exports.VertexStateContext = VertexStateContext;
    exports.VertexStream = VertexStream;
    exports.VideoNode = VideoNode;
    exports.VideoPlayer = VideoPlayer;
    exports.VideoTexture = VideoTexture;
    exports.VideoTextureLoader = VideoTextureLoader;
    exports.Viewport = Viewport;
    exports.WasmAdapter = WasmAdapter;
    exports.WeakObject = WeakObject;
    exports.WebAudioChannel = WebAudioChannel;
    exports.WebGLRTMgr = WebGLRTMgr;
    exports.Widget = Widget;
    exports.WorkerLoader = WorkerLoader;
    exports.XML = XML;
    exports.XMLIterator = XMLIterator;
    exports.XMLUtils = XMLUtils;
    exports._WebSocket = _WebSocket;
    exports.addAfterInitCallback = addAfterInitCallback;
    exports.addBeforeInitCallback = addBeforeInitCallback;
    exports.addInitCallback = addInitCallback;
    exports.alertGlobalError = alertGlobalError;
    exports.allowMultiple = allowMultiple;
    exports.checkShaderDataValueLegal = checkShaderDataValueLegal;
    exports.classInfo = classInfo;
    exports.genSliceMesh = genSliceMesh;
    exports.genTileMesh = genTileMesh;
    exports.getCompressTextureRenderCapable = getCompressTextureRenderCapable;
    exports.getErrorMsg = getErrorMsg;
    exports.importNative = importNative;
    exports.init = init;
    exports.isUboBufferShaderType = isUboBufferShaderType;
    exports.measureFont = measureFont;
    exports.property = property;
    exports.regClass = regClass;
    exports.regLoader = regLoader;
    exports.roundDown = roundDown;
    exports.roundUp = roundUp;
    exports.runInEditor = runInEditor;

    return exports;

})({});
