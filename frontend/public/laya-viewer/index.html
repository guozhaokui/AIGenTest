<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
    <meta name="renderer" content="webkit" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="full-screen" content="true" />
    <meta name="x5-fullscreen" content="true" />
    <meta name="360-fullscreen" content="true" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>LayaAir 3D Model Viewer</title>
    <style type="text/css">
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #888888;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
        }
        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 5px 10px;
            margin: 5px 0;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        button:hover {
            background: #45a049;
        }
        select {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 5px;
            border-radius: 3px;
            font-size: 12px;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 50;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div>模型选择：</div>
        <select id="modelSelect"></select>
        <div style="margin-top: 10px;">操作：</div>
        <button id="resetBtn">重置视角</button>
        <button id="fullscreenBtn">全屏</button>
        <button id="updateThumbnailBtn">更新缩略图</button>
    </div>
    <div class="loading" id="loadingText">加载中...</div>

    <!-- LayaAir 3.x 本地库 -->
    <script type="text/javascript" src="libs/laya.core.js"></script>
    <script type="text/javascript" src="libs/laya.d3.js"></script>
    <script type="text/javascript" src="libs/laya.webgl_2D.js"></script>
    <script type="text/javascript" src="libs/laya.webgl_3D.js"></script>
    <script type="text/javascript" src="libs/laya.ui.js"></script>
    <script type="text/javascript" src="libs/laya.gltf.js"></script>

    
    <script>
        // 解析URL参数
        function getQueryParam(name) {
            const url = window.location.href;
            const regex = new RegExp('[/?&]' + name + '(=([^&#]*)|&|#|$)');
            const results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, ' '));
        }

        // 获取后端API地址
        // 优先使用 URL 参数 apiBase，否则使用当前页面的 origin（Vite 代理会处理）
        function getApiBase() {
            const apiBase = getQueryParam('apiBase');
            if (apiBase) return apiBase;
            // 开发环境通过 Vite 代理，使用相对路径即可
            // 生产环境需要配置反向代理或传入 apiBase 参数
            return '';
        }

        const API_BASE = getApiBase();

        // 全局变量
        let scene = null;
        let camera = null;
        let currentModel = null;
        let ground = null;
        let modelOptions = [];

        // 解析模型列表
        // 优先使用 models 参数（JSON 数组格式）
        // 格式: models=[{"name":"模型名","path":"/path/to/model.glb"}, ...]
        // 向后兼容: 也支持单个 url 参数
        const modelsParam = getQueryParam('models');
        const urlParam = getQueryParam('url');
        
        if (modelsParam) {
            // 新格式：直接使用传入的模型列表
            try {
                const parsed = JSON.parse(modelsParam);
                if (Array.isArray(parsed) && parsed.length > 0) {
                    modelOptions = parsed.map(item => ({
                        name: item.name || '3D模型',
                        path: item.path.startsWith('http') ? item.path : `${API_BASE}${item.path}`
                    }));
                }
            } catch (e) {
                console.error('解析 models 参数失败:', e);
            }
        } else if (urlParam) {
            // 向后兼容：单个 url 参数
            modelOptions = [
                { name: '3D模型', path: urlParam.startsWith('http') ? urlParam : `${API_BASE}${urlParam}` }
            ];
        }

        // 填充模型选择下拉框
        const modelSelect = document.getElementById('modelSelect');
        modelOptions.forEach((option, index) => {
            const opt = document.createElement('option');
            opt.value = index;
            opt.text = option.name;
            modelSelect.appendChild(opt);
        });

        // LayaAir 3.x 配置
        const config = {
            resolution: {
                designWidth: window.innerWidth,
                designHeight: window.innerHeight,
                scaleMode: "full",
                alignV: "middle",
                alignH: "center",
                screenMode: "none",
                backgroundColor: "#888888"
            },
            "2D": {
                FPS: 60,
                isAntialias: true,
                isAlpha: false,
                // 保留绘制缓冲区，用于截图
                preserveDrawingBuffer: true
            },
            "3D": {
                enableDynamicBatch: true,
                pixelRatio: 1,
                enableMultiLight: true
            }
        };

        Object.assign(Laya.Config, config["2D"]);
        Laya.Config.preserveDrawingBuffer = true; // 确保设置生效
        Object.assign(Laya.Config3D, config["3D"]);

        // 初始化引擎
        Laya.init(config.resolution).then(() => {
            Laya.stage.bgColor = "#888888";
            
            // 创建3D场景
            scene = new Laya.Scene3D();
            Laya.stage.addChild(scene);

            // 设置环境光颜色
            scene.ambientMode = 0; // Solid Color
            scene.ambientColor = new Laya.Color(0.5, 0.5, 0.5, 1);

            // 创建相机
            camera = new Laya.Camera(0, 0.1, 1000);
            scene.addChild(camera);
            camera.transform.position = new Laya.Vector3(0, 1, 5);
            camera.transform.rotationEuler = new Laya.Vector3(-15, 0, 0);
            camera.clearFlag = Laya.CameraClearFlags.SolidColor;
            camera.clearColor = new Laya.Color(0.3921, 0.5843, 0.9294, 1);
            
            // 添加相机控制脚本
            camera.addComponent(CameraController);

            // 创建方向光
            const directionLight = new Laya.Sprite3D();
            scene.addChild(directionLight);
            directionLight.transform.position = new Laya.Vector3(5, 5, 5);
            directionLight.transform.rotationEuler = new Laya.Vector3(-45, 45, 0);
            const lightCom = directionLight.addComponent(Laya.DirectionLightCom);
            lightCom.color = new Laya.Color(1, 1, 1, 1);
            
            // 开启方向光阴影
            lightCom.shadowMode = Laya.ShadowMode.SoftLow;
            lightCom.shadowDistance = 20;
            lightCom.shadowResolution = 1024;
            lightCom.shadowCascadesMode = Laya.ShadowCascadesMode.NoCascades;
            lightCom.shadowDepthBias = 1.0;
            lightCom.shadowNormalBias = 1.0;

            // 创建地面
            createGround();

            // 加载第一个模型
            if (modelOptions.length > 0) {
                loadModel(0);
            } else {
                document.getElementById('loadingText').textContent = '请在URL中指定模型路径 ?url=xxx';
            }

            // 显示统计信息
            // Laya.Stat.show();
        });

        // 相机控制器
        class CameraController extends Laya.Script {
            constructor() {
                super();
                this.yawPitchRoll = new Laya.Vector3(15, 0, 0);
                this.distance = 5;
                this.target = new Laya.Vector3(0, 0.5, 0);
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                this.isMouseDown = false;
            }

            onStart() {
                Laya.stage.on(Laya.Event.MOUSE_DOWN, this, this.onMouseDown);
                Laya.stage.on(Laya.Event.MOUSE_UP, this, this.onMouseUp);
                Laya.stage.on(Laya.Event.MOUSE_OUT, this, this.onMouseUp);
                Laya.stage.on(Laya.Event.MOUSE_MOVE, this, this.onMouseMove);
                Laya.stage.on(Laya.Event.MOUSE_WHEEL, this, this.onMouseWheel);
                this.updateCamera();
            }

            onMouseDown(e) {
                this.isMouseDown = true;
                this.lastMouseX = Laya.stage.mouseX;
                this.lastMouseY = Laya.stage.mouseY;
            }

            onMouseUp(e) {
                this.isMouseDown = false;
            }

            onMouseMove(e) {
                if (!this.isMouseDown) return;
                
                const deltaX = Laya.stage.mouseX - this.lastMouseX;
                const deltaY = Laya.stage.mouseY - this.lastMouseY;
                
                this.yawPitchRoll.y -= deltaX * 0.3;
                this.yawPitchRoll.x += deltaY * 0.3;
                
                // 限制俯仰角
                this.yawPitchRoll.x = Math.max(-89, Math.min(89, this.yawPitchRoll.x));
                
                this.lastMouseX = Laya.stage.mouseX;
                this.lastMouseY = Laya.stage.mouseY;
                
                this.updateCamera();
            }

            onMouseWheel(e) {
                this.distance += e.delta * 0.01;
                this.distance = Math.max(1, Math.min(50, this.distance));
                this.updateCamera();
            }

            updateCamera() {
                const pitch = this.yawPitchRoll.x * Math.PI / 180;
                const yaw = this.yawPitchRoll.y * Math.PI / 180;
                
                const x = this.distance * Math.cos(pitch) * Math.sin(yaw);
                const y = this.distance * Math.sin(pitch);
                const z = this.distance * Math.cos(pitch) * Math.cos(yaw);
                
                this.owner.transform.position = new Laya.Vector3(
                    this.target.x + x,
                    this.target.y + y,
                    this.target.z + z
                );
                this.owner.transform.lookAt(this.target, new Laya.Vector3(0, 1, 0));
            }

            resetView() {
                this.yawPitchRoll = new Laya.Vector3(15, 0, 0);
                this.distance = 5;
                this.updateCamera();
            }
        }

        // 创建地面
        function createGround() {
            ground = new Laya.Sprite3D();
            scene.addChild(ground);
            ground.addComponent(Laya.MeshFilter).sharedMesh = Laya.PrimitiveMesh.createPlane(10, 10, 10, 10);
            const renderer = ground.addComponent(Laya.MeshRenderer);
            const material = new Laya.BlinnPhongMaterial();
            material.albedoColor = new Laya.Color(0.6, 0.6, 0.6, 1);
            renderer.sharedMaterial = material;
            
            // 地面接收阴影
            renderer.receiveShadow = true;
        }

        // 更新地面位置到模型包围盒底部
        function updateGroundPosition(model) {
            if (!ground || !model) return;
            
            // 重新计算调整后模型的包围盒
            let bounds = null;
            findBounds(model, (renderer) => {
                if (renderer.bounds) {
                    if (!bounds) {
                        bounds = renderer.bounds.clone();
                    } else {
                        Laya.Bounds.merge(bounds, renderer.bounds, bounds);
                    }
                }
            });
            
            if (bounds) {
                // 获取模型底部的 y 坐标，设置地面位置
                const minY = bounds.getMin().y;
                ground.transform.position = new Laya.Vector3(0, minY, 0);
            }
        }

        // 加载模型
        function loadModel(index) {
            const option = modelOptions[index];
            if (!option) return;

            document.getElementById('loadingText').style.display = 'block';
            document.getElementById('loadingText').textContent = '加载中...';

            // 移除当前模型
            if (currentModel) {
                currentModel.destroy();
                currentModel = null;
            }

            // 加载GLB模型
            Laya.Sprite3D.load(option.path, Laya.Handler.create(null, (sprite) => {
                if (sprite) {
                    currentModel = sprite;
                    scene.addChild(currentModel);
                    
                    // 调整模型
                    adjustModel(currentModel);
                    
                    // 设置模型阴影
                    setupModelShadow(currentModel);
                    
                    document.getElementById('loadingText').style.display = 'none';
                    console.log('模型加载成功:', option.path);
                    
                    // 等待渲染完成后截图（等待10帧）
                    waitFramesAndCapture(10, option.path);
                } else {
                    document.getElementById('loadingText').textContent = '模型加载失败';
                    console.error('模型加载失败:', option.path);
                }
            }), null, null, null, null, Laya.Loader.HIERARCHY);
        }
        
        // 截取正方形缩略图（取屏幕中间区域）
        function captureSquareThumbnail(canvas, size) {
            const w = canvas.width;
            const h = canvas.height;
            
            // 计算正方形裁剪区域（取中间）
            const squareSize = Math.min(w, h);
            const sx = Math.floor((w - squareSize) / 2);
            const sy = Math.floor((h - squareSize) / 2);
            
            // 创建临时 canvas 进行裁剪和缩放
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = size;
            tempCanvas.height = size;
            const tempCtx = tempCanvas.getContext('2d');
            
            // 从原始 canvas 裁剪中间正方形区域并缩放
            tempCtx.drawImage(
                canvas,
                sx, sy, squareSize, squareSize,  // 源区域
                0, 0, size, size                  // 目标区域
            );
            
            return tempCanvas.toDataURL('image/jpeg', 0.85);
        }

        // 等待指定帧数后截图
        let captureFrameCount = 0;
        let captureModelPath = '';
        function waitFramesAndCapture(frames, modelPath) {
            captureFrameCount = frames;
            captureModelPath = modelPath;
            Laya.timer.frameLoop(1, null, onCaptureFrame);
        }
        
        function onCaptureFrame() {
            captureFrameCount--;
            if (captureFrameCount <= 0) {
                Laya.timer.clear(null, onCaptureFrame);
                captureAndSendThumbnail(captureModelPath);
            }
        }
        
        // 截图并发送给父窗口
        function captureAndSendThumbnail(modelPath) {
            try {
                if (!currentModel || !camera) return;
                
                // 保存当前相机控制器状态
                const controller = camera.getComponent(CameraController);
                let savedDistance, savedYawPitchRoll, savedTarget;
                if (controller) {
                    savedDistance = controller.distance;
                    savedYawPitchRoll = controller.yawPitchRoll.clone();
                    savedTarget = controller.target.clone();
                }
                
                // 计算模型包围盒
                let bounds = null;
                findBounds(currentModel, (renderer) => {
                    if (renderer.bounds) {
                        if (!bounds) {
                            bounds = renderer.bounds.clone();
                        } else {
                            Laya.Bounds.merge(bounds, renderer.bounds, bounds);
                        }
                    }
                });
                
                if (bounds) {
                    // 计算包围盒中心和大小
                    const center = new Laya.Vector3();
                    bounds.getCenter(center);
                    const extent = bounds.getExtent();
                    
                    // 由于我们截取正方形区域，需要确保模型在正方形内完全可见
                    // 计算从斜上方观察时模型的可见范围
                    const pitch = 25 * Math.PI / 180;  // 俯仰角
                    const yaw = 35 * Math.PI / 180;    // 偏航角
                    
                    // 考虑旋转后的有效尺寸（取最大范围以确保完全可见）
                    const effectiveSize = Math.max(
                        extent.x * 2,
                        extent.y * 2,
                        extent.z * 2,
                        Math.sqrt(extent.x * extent.x + extent.z * extent.z) * 2  // 对角线
                    );
                    
                    // 根据相机 FOV 计算最佳距离
                    // 由于截取正方形，需要用较大的边距（1.5倍）确保模型完全在视野内
                    const fov = camera.fieldOfView * Math.PI / 180;
                    const distance = (effectiveSize * 0.8) / Math.tan(fov / 2);
                    
                    // 设置相机位置
                    const x = distance * Math.cos(pitch) * Math.sin(yaw);
                    const y = distance * Math.sin(pitch);
                    const z = distance * Math.cos(pitch) * Math.cos(yaw);
                    
                    camera.transform.position = new Laya.Vector3(
                        center.x + x,
                        center.y + y,
                        center.z + z
                    );
                    camera.transform.lookAt(center, new Laya.Vector3(0, 1, 0));
                }
                
                // 等待一帧渲染后截图
                Laya.timer.frameOnce(2, null, () => {
                    // 获取 canvas
                    const canvas = document.querySelector('canvas');
                    if (!canvas) {
                        console.error('Canvas not found');
                        restoreCamera();
                        return;
                    }
                    
                    // 确保 canvas 有内容
                    const ctx = canvas.getContext('webgl') || canvas.getContext('webgl2');
                    if (ctx) {
                        ctx.finish();
                    }
                    
                    // 截取正方形缩略图（取屏幕中间区域）
                    const dataUrl = captureSquareThumbnail(canvas, 512);
                    
                    // 检查是否是空白图片
                    if (dataUrl.length < 1000) {
                        console.warn('截图可能是空的，重试...');
                        restoreCamera();
                        waitFramesAndCapture(10, modelPath);
                        return;
                    }
                    
                    // 发送给父窗口
                    if (window.parent !== window) {
                        window.parent.postMessage({
                            type: 'thumbnail',
                            modelPath: modelPath,
                            dataUrl: dataUrl
                        }, '*');
                        console.log('缩略图已发送, 大小:', dataUrl.length);
                    }
                    
                    // 恢复相机位置
                    restoreCamera();
                });
                
                function restoreCamera() {
                    if (controller && savedDistance !== undefined) {
                        controller.distance = savedDistance;
                        controller.yawPitchRoll = savedYawPitchRoll;
                        controller.target = savedTarget;
                        controller.updateCamera();
                    }
                }
                
            } catch (e) {
                console.error('截图失败:', e);
            }
        }

        // 调整模型位置和缩放
        function adjustModel(model) {
            // 计算边界盒
            let bounds = null;
            findBounds(model, (renderer) => {
                if (renderer.bounds) {
                    if (!bounds) {
                        bounds = renderer.bounds.clone();
                    } else {
                        Laya.Bounds.merge(bounds, renderer.bounds, bounds);
                    }
                }
            });

            if (bounds) {
                const size = bounds.getExtent().clone();
                const maxSize = Math.max(size.x, size.y, size.z) * 2;
                
                if (maxSize > 0) {
                    const scale = 2 / maxSize;
                    model.transform.localScale = new Laya.Vector3(scale, scale, scale);
                    
                    // 重新计算边界
                    const center = new Laya.Vector3();
                    bounds.getCenter(center);
                    model.transform.position = new Laya.Vector3(
                        -center.x * scale,
                        -bounds.getMin().y * scale,
                        -center.z * scale
                    );
                    
                    // 在下一帧更新地面位置（确保 transform 已更新）
                    Laya.timer.frameOnce(1, null, () => {
                        updateGroundPosition(model);
                    });
                }
            }
        }

        // 遍历查找渲染器
        function findBounds(node, callback) {
            const renderer = node.getComponent(Laya.MeshRenderer) || node.getComponent(Laya.SkinnedMeshRenderer);
            if (renderer) {
                callback(renderer);
            }
            for (let i = 0; i < node.numChildren; i++) {
                findBounds(node.getChildAt(i), callback);
            }
        }

        // 设置模型阴影（投射和接收）
        function setupModelShadow(model) {
            findBounds(model, (renderer) => {
                renderer.castShadow = true;
                renderer.receiveShadow = true;
            });
        }

        // 事件监听
        modelSelect.addEventListener('change', (e) => {
            loadModel(parseInt(e.target.value));
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            if (camera) {
                const controller = camera.getComponent(CameraController);
                if (controller) {
                    controller.resetView();
                }
            }
        });

        document.getElementById('fullscreenBtn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        document.getElementById('updateThumbnailBtn').addEventListener('click', () => {
            if (currentModel && modelOptions.length > 0) {
                const currentIndex = modelSelect.value;
                const option = modelOptions[currentIndex];
                if (option) {
                    // 使用当前视角截图并发送
                    captureThumbnailCurrentView(option.path);
                }
            }
        });

        // 获取记录 ID（从 URL 参数）
        const recordId = getQueryParam('id');

        // 使用当前视角截图（不调整相机）
        async function captureThumbnailCurrentView(modelPath) {
            try {
                const canvas = document.querySelector('canvas');
                if (!canvas) {
                    console.error('Canvas not found');
                    return;
                }
                
                const ctx = canvas.getContext('webgl') || canvas.getContext('webgl2');
                if (ctx) {
                    ctx.finish();
                }
                
                // 截取正方形缩略图（取屏幕中间区域）
                const dataUrl = captureSquareThumbnail(canvas, 512);
                
                if (dataUrl.length < 1000) {
                    console.warn('截图可能是空的');
                    return;
                }
                
                // 发送给父窗口（嵌入模式）
                if (window.parent !== window) {
                    window.parent.postMessage({
                        type: 'thumbnail',
                        modelPath: modelPath,
                        dataUrl: dataUrl
                    }, '*');
                    console.log('缩略图已更新并发送, 大小:', dataUrl.length);
                    alert('缩略图已更新！');
                } else {
                    // 非嵌入模式，直接调用后端 API
                    if (!recordId) {
                        alert('URL 中缺少记录 ID，无法更新缩略图');
                        return;
                    }
                    
                    try {
                        const response = await fetch(`${API_BASE}/api/live-gen/${recordId}/thumbnail`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ dataUrl })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            console.log('缩略图已保存:', result.thumbnailPath);
                            alert('缩略图已更新！');
                        } else {
                            const error = await response.json();
                            console.error('保存缩略图失败:', error);
                            alert('保存缩略图失败：' + (error.error || '未知错误'));
                        }
                    } catch (e) {
                        console.error('请求失败:', e);
                        alert('请求失败：' + e.message);
                    }
                }
            } catch (e) {
                console.error('截图失败:', e);
                alert('截图失败：' + e.message);
            }
        }
    </script>
</body>
</html>
