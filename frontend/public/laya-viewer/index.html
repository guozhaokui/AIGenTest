<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
    <meta name="renderer" content="webkit" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="full-screen" content="true" />
    <meta name="x5-fullscreen" content="true" />
    <meta name="360-fullscreen" content="true" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>LayaAir 3D Model Viewer</title>
    <style type="text/css">
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #888888;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
        }
        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 5px 10px;
            margin: 5px 0;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        button:hover {
            background: #45a049;
        }
        select {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 5px;
            border-radius: 3px;
            font-size: 12px;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 50;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div>模型选择：</div>
        <select id="modelSelect"></select>
        <div style="margin-top: 10px;">操作：</div>
        <button id="resetBtn">重置视角</button>
        <button id="fullscreenBtn">全屏</button>
    </div>
    <div class="loading" id="loadingText">加载中...</div>

    <!-- LayaAir 3.x 本地库 -->
    <script type="text/javascript" src="libs/laya.core.js"></script>
    <script type="text/javascript" src="libs/laya.d3.js"></script>
    <script type="text/javascript" src="libs/laya.webgl_2D.js"></script>
    <script type="text/javascript" src="libs/laya.webgl_3D.js"></script>
    <script type="text/javascript" src="libs/laya.ui.js"></script>
    <script type="text/javascript" src="libs/laya.gltf.js"></script>

    
    <script>
        // 解析URL参数
        function getQueryParam(name) {
            const url = window.location.href;
            const regex = new RegExp('[/?&]' + name + '(=([^&#]*)|&|#|$)');
            const results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, ' '));
        }

        // 获取后端API地址
        // 优先使用 URL 参数 apiBase，否则使用当前页面的 origin（Vite 代理会处理）
        function getApiBase() {
            const apiBase = getQueryParam('apiBase');
            if (apiBase) return apiBase;
            // 开发环境通过 Vite 代理，使用相对路径即可
            // 生产环境需要配置反向代理或传入 apiBase 参数
            return '';
        }

        const API_BASE = getApiBase();

        // 全局变量
        let scene = null;
        let camera = null;
        let currentModel = null;
        let ground = null;
        let modelOptions = [];

        // 解析模型路径
        const modelPath = getQueryParam('url');
        if (modelPath) {
            // 匹配两级 uuid: /modeldb/{questionUuid}/{resultUuid}
            const uuidMatch = modelPath.match(/\/modeldb\/([^\/]+\/[^\/]+)/);
            if (uuidMatch && uuidMatch[1]) {
                const uuidPath = uuidMatch[1];
                modelOptions = [
                    { name: 'PBR模型', path: `${API_BASE}/modeldb/${uuidPath}/pbr/mesh_textured_pbr.glb` },
                    { name: 'RGB模型', path: `${API_BASE}/modeldb/${uuidPath}/rgb/mesh_textured.glb` }
                ];
            }
        }

        // 填充模型选择下拉框
        const modelSelect = document.getElementById('modelSelect');
        modelOptions.forEach((option, index) => {
            const opt = document.createElement('option');
            opt.value = index;
            opt.text = option.name;
            modelSelect.appendChild(opt);
        });

        // LayaAir 3.x 配置
        const config = {
            resolution: {
                designWidth: window.innerWidth,
                designHeight: window.innerHeight,
                scaleMode: "full",
                alignV: "middle",
                alignH: "center",
                screenMode: "none",
                backgroundColor: "#888888"
            },
            "2D": {
                FPS: 60,
                isAntialias: true,
                isAlpha: false,
                // 保留绘制缓冲区，用于截图
                preserveDrawingBuffer: true
            },
            "3D": {
                enableDynamicBatch: true,
                pixelRatio: 1,
                enableMultiLight: true
            }
        };

        Object.assign(Laya.Config, config["2D"]);
        Laya.Config.preserveDrawingBuffer = true; // 确保设置生效
        Object.assign(Laya.Config3D, config["3D"]);

        // 初始化引擎
        Laya.init(config.resolution).then(() => {
            Laya.stage.bgColor = "#888888";
            
            // 创建3D场景
            scene = new Laya.Scene3D();
            Laya.stage.addChild(scene);

            // 设置环境光颜色
            scene.ambientMode = 0; // Solid Color
            scene.ambientColor = new Laya.Color(0.5, 0.5, 0.5, 1);

            // 创建相机
            camera = new Laya.Camera(0, 0.1, 1000);
            scene.addChild(camera);
            camera.transform.position = new Laya.Vector3(0, 1, 5);
            camera.transform.rotationEuler = new Laya.Vector3(-15, 0, 0);
            camera.clearFlag = Laya.CameraClearFlags.SolidColor;
            camera.clearColor = new Laya.Color(0.3921, 0.5843, 0.9294, 1);
            
            // 添加相机控制脚本
            camera.addComponent(CameraController);

            // 创建方向光
            const directionLight = new Laya.Sprite3D();
            scene.addChild(directionLight);
            directionLight.transform.position = new Laya.Vector3(5, 5, 5);
            directionLight.transform.rotationEuler = new Laya.Vector3(-45, 45, 0);
            const lightCom = directionLight.addComponent(Laya.DirectionLightCom);
            lightCom.color = new Laya.Color(1, 1, 1, 1);
            
            // 开启方向光阴影
            lightCom.shadowMode = Laya.ShadowMode.SoftLow;
            lightCom.shadowDistance = 20;
            lightCom.shadowResolution = 1024;
            lightCom.shadowCascadesMode = Laya.ShadowCascadesMode.NoCascades;
            lightCom.shadowDepthBias = 1.0;
            lightCom.shadowNormalBias = 1.0;

            // 创建地面
            createGround();

            // 加载第一个模型
            if (modelOptions.length > 0) {
                loadModel(0);
            } else {
                document.getElementById('loadingText').textContent = '请在URL中指定模型路径 ?url=xxx';
            }

            // 显示统计信息
            // Laya.Stat.show();
        });

        // 相机控制器
        class CameraController extends Laya.Script {
            constructor() {
                super();
                this.yawPitchRoll = new Laya.Vector3(15, 0, 0);
                this.distance = 5;
                this.target = new Laya.Vector3(0, 0.5, 0);
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                this.isMouseDown = false;
            }

            onStart() {
                Laya.stage.on(Laya.Event.MOUSE_DOWN, this, this.onMouseDown);
                Laya.stage.on(Laya.Event.MOUSE_UP, this, this.onMouseUp);
                Laya.stage.on(Laya.Event.MOUSE_OUT, this, this.onMouseUp);
                Laya.stage.on(Laya.Event.MOUSE_MOVE, this, this.onMouseMove);
                Laya.stage.on(Laya.Event.MOUSE_WHEEL, this, this.onMouseWheel);
                this.updateCamera();
            }

            onMouseDown(e) {
                this.isMouseDown = true;
                this.lastMouseX = Laya.stage.mouseX;
                this.lastMouseY = Laya.stage.mouseY;
            }

            onMouseUp(e) {
                this.isMouseDown = false;
            }

            onMouseMove(e) {
                if (!this.isMouseDown) return;
                
                const deltaX = Laya.stage.mouseX - this.lastMouseX;
                const deltaY = Laya.stage.mouseY - this.lastMouseY;
                
                this.yawPitchRoll.y -= deltaX * 0.3;
                this.yawPitchRoll.x += deltaY * 0.3;
                
                // 限制俯仰角
                this.yawPitchRoll.x = Math.max(-89, Math.min(89, this.yawPitchRoll.x));
                
                this.lastMouseX = Laya.stage.mouseX;
                this.lastMouseY = Laya.stage.mouseY;
                
                this.updateCamera();
            }

            onMouseWheel(e) {
                this.distance += e.delta * 0.01;
                this.distance = Math.max(1, Math.min(50, this.distance));
                this.updateCamera();
            }

            updateCamera() {
                const pitch = this.yawPitchRoll.x * Math.PI / 180;
                const yaw = this.yawPitchRoll.y * Math.PI / 180;
                
                const x = this.distance * Math.cos(pitch) * Math.sin(yaw);
                const y = this.distance * Math.sin(pitch);
                const z = this.distance * Math.cos(pitch) * Math.cos(yaw);
                
                this.owner.transform.position = new Laya.Vector3(
                    this.target.x + x,
                    this.target.y + y,
                    this.target.z + z
                );
                this.owner.transform.lookAt(this.target, new Laya.Vector3(0, 1, 0));
            }

            resetView() {
                this.yawPitchRoll = new Laya.Vector3(15, 0, 0);
                this.distance = 5;
                this.updateCamera();
            }
        }

        // 创建地面
        function createGround() {
            ground = new Laya.Sprite3D();
            scene.addChild(ground);
            ground.addComponent(Laya.MeshFilter).sharedMesh = Laya.PrimitiveMesh.createPlane(10, 10, 10, 10);
            const renderer = ground.addComponent(Laya.MeshRenderer);
            const material = new Laya.BlinnPhongMaterial();
            material.albedoColor = new Laya.Color(0.6, 0.6, 0.6, 1);
            renderer.sharedMaterial = material;
            
            // 地面接收阴影
            renderer.receiveShadow = true;
        }

        // 更新地面位置到模型包围盒底部
        function updateGroundPosition(model) {
            if (!ground || !model) return;
            
            // 重新计算调整后模型的包围盒
            let bounds = null;
            findBounds(model, (renderer) => {
                if (renderer.bounds) {
                    if (!bounds) {
                        bounds = renderer.bounds.clone();
                    } else {
                        Laya.Bounds.merge(bounds, renderer.bounds, bounds);
                    }
                }
            });
            
            if (bounds) {
                // 获取模型底部的 y 坐标，设置地面位置
                const minY = bounds.getMin().y;
                ground.transform.position = new Laya.Vector3(0, minY, 0);
            }
        }

        // 加载模型
        function loadModel(index) {
            const option = modelOptions[index];
            if (!option) return;

            document.getElementById('loadingText').style.display = 'block';
            document.getElementById('loadingText').textContent = '加载中...';

            // 移除当前模型
            if (currentModel) {
                currentModel.destroy();
                currentModel = null;
            }

            // 加载GLB模型
            Laya.Sprite3D.load(option.path, Laya.Handler.create(null, (sprite) => {
                if (sprite) {
                    currentModel = sprite;
                    scene.addChild(currentModel);
                    
                    // 调整模型
                    adjustModel(currentModel);
                    
                    // 设置模型阴影
                    setupModelShadow(currentModel);
                    
                    document.getElementById('loadingText').style.display = 'none';
                    console.log('模型加载成功:', option.path);
                    
                    // 等待渲染完成后截图（等待10帧）
                    waitFramesAndCapture(10, option.path);
                } else {
                    document.getElementById('loadingText').textContent = '模型加载失败';
                    console.error('模型加载失败:', option.path);
                }
            }), null, null, null, null, Laya.Loader.HIERARCHY);
        }
        
        // 等待指定帧数后截图
        let captureFrameCount = 0;
        let captureModelPath = '';
        function waitFramesAndCapture(frames, modelPath) {
            captureFrameCount = frames;
            captureModelPath = modelPath;
            Laya.timer.frameLoop(1, null, onCaptureFrame);
        }
        
        function onCaptureFrame() {
            captureFrameCount--;
            if (captureFrameCount <= 0) {
                Laya.timer.clear(null, onCaptureFrame);
                captureAndSendThumbnail(captureModelPath);
            }
        }
        
        // 截图并发送给父窗口
        function captureAndSendThumbnail(modelPath) {
            try {
                // 获取 canvas
                const canvas = document.querySelector('canvas');
                if (!canvas) {
                    console.error('Canvas not found');
                    return;
                }
                
                // 确保 canvas 有内容
                const ctx = canvas.getContext('webgl') || canvas.getContext('webgl2');
                if (ctx) {
                    // 强制完成所有渲染操作
                    ctx.finish();
                }
                
                // 截图
                const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                
                // 检查是否是空白图片
                if (dataUrl.length < 1000) {
                    console.warn('截图可能是空的，重试...');
                    waitFramesAndCapture(10, modelPath);
                    return;
                }
                
                // 发送给父窗口
                if (window.parent !== window) {
                    window.parent.postMessage({
                        type: 'thumbnail',
                        modelPath: modelPath,
                        dataUrl: dataUrl
                    }, '*');
                    console.log('缩略图已发送, 大小:', dataUrl.length);
                }
            } catch (e) {
                console.error('截图失败:', e);
            }
        }

        // 调整模型位置和缩放
        function adjustModel(model) {
            // 计算边界盒
            let bounds = null;
            findBounds(model, (renderer) => {
                if (renderer.bounds) {
                    if (!bounds) {
                        bounds = renderer.bounds.clone();
                    } else {
                        Laya.Bounds.merge(bounds, renderer.bounds, bounds);
                    }
                }
            });

            if (bounds) {
                const size = bounds.getExtent().clone();
                const maxSize = Math.max(size.x, size.y, size.z) * 2;
                
                if (maxSize > 0) {
                    const scale = 2 / maxSize;
                    model.transform.localScale = new Laya.Vector3(scale, scale, scale);
                    
                    // 重新计算边界
                    const center = new Laya.Vector3();
                    bounds.getCenter(center);
                    model.transform.position = new Laya.Vector3(
                        -center.x * scale,
                        -bounds.getMin().y * scale,
                        -center.z * scale
                    );
                    
                    // 在下一帧更新地面位置（确保 transform 已更新）
                    Laya.timer.frameOnce(1, null, () => {
                        updateGroundPosition(model);
                    });
                }
            }
        }

        // 遍历查找渲染器
        function findBounds(node, callback) {
            const renderer = node.getComponent(Laya.MeshRenderer) || node.getComponent(Laya.SkinnedMeshRenderer);
            if (renderer) {
                callback(renderer);
            }
            for (let i = 0; i < node.numChildren; i++) {
                findBounds(node.getChildAt(i), callback);
            }
        }

        // 设置模型阴影（投射和接收）
        function setupModelShadow(model) {
            findBounds(model, (renderer) => {
                renderer.castShadow = true;
                renderer.receiveShadow = true;
            });
        }

        // 事件监听
        modelSelect.addEventListener('change', (e) => {
            loadModel(parseInt(e.target.value));
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            if (camera) {
                const controller = camera.getComponent(CameraController);
                if (controller) {
                    controller.resetView();
                }
            }
        });

        document.getElementById('fullscreenBtn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });
    </script>
</body>
</html>
