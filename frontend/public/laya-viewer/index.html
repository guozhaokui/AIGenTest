<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
    <meta name="renderer" content="webkit" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="full-screen" content="true" />
    <meta name="x5-fullscreen" content="true" />
    <meta name="360-fullscreen" content="true" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>LayaAir 3D Model Viewer</title>
    <style type="text/css">
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #888888;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: transparent;
            padding: 8px 12px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        button {
            background: rgba(80, 80, 80, 0.9);
            border: 1px solid rgba(100, 100, 100, 0.5);
            color: #ddd;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        button:hover {
            background: rgba(100, 100, 100, 0.9);
            color: #fff;
        }
        button.active {
            background: rgba(70, 130, 180, 0.9);
            border-color: rgba(100, 160, 210, 0.7);
            color: #fff;
        }
        .mode-group {
            display: flex;
            gap: 2px;
            background: rgba(30, 30, 30, 0.5);
            border-radius: 4px;
            padding: 2px;
        }
        .mode-group button {
            border-radius: 3px;
            padding: 6px 10px;
        }
        select {
            background: rgba(80, 80, 80, 0.9);
            border: 1px solid rgba(100, 100, 100, 0.5);
            color: #ddd;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        select:hover {
            background: rgba(100, 100, 100, 0.9);
        }
        .stats {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(40, 40, 40, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            color: #ccc;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            line-height: 1.5;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 50;
        }
    </style>
</head>
<body>
    <div class="controls">
        <select id="modelSelect" title="模型选择"></select>
        <button id="resetBtn">重置视角</button>
        <div class="mode-group">
            <button id="modeWireframe">线框</button>
            <button id="modeBoth">框+实</button>
            <button id="modeSolid" class="active">实体</button>
        </div>
        <button id="groundBtn" class="active">地面</button>
        <button id="updateThumbnailBtn">更新缩略图</button>
    </div>
    <div class="stats" id="modelStats"></div>
    <div class="loading" id="loadingText">加载中...</div>

    <!-- LayaAir 3.x 本地库 -->
    <script type="text/javascript" src="libs/laya.core.js"></script>
    <script type="text/javascript" src="libs/laya.d3.js"></script>
    <script type="text/javascript" src="libs/laya.webgl_2D.js"></script>
    <script type="text/javascript" src="libs/laya.webgl_3D.js"></script>
    <script type="text/javascript" src="libs/laya.ui.js"></script>
    <script type="text/javascript" src="libs/laya.gltf.js"></script>

    
    <script>
        // 解析URL参数
        function getQueryParam(name) {
            const url = window.location.href;
            const regex = new RegExp('[/?&]' + name + '(=([^&#]*)|&|#|$)');
            const results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, ' '));
        }

        // 获取后端API地址
        // 优先使用 URL 参数 apiBase，否则使用当前页面的 origin（Vite 代理会处理）
        function getApiBase() {
            const apiBase = getQueryParam('apiBase');
            if (apiBase) return apiBase;
            // 开发环境通过 Vite 代理，使用相对路径即可
            // 生产环境需要配置反向代理或传入 apiBase 参数
            return '';
        }

        const API_BASE = getApiBase();

        // 全局变量
        let scene = null;
        let camera = null;
        let currentModel = null;
        let ground = null;
        let modelOptions = [];
        let isSolidVisible = true;          // 实体是否显示
        let isWireframeVisible = false;     // 线框是否显示
        let wireframeSprite = null;         // 线框精灵

        // 解析模型列表
        // 优先使用 models 参数（JSON 数组格式）
        // 格式: models=[{"name":"模型名","path":"/path/to/model.glb"}, ...]
        // 向后兼容: 也支持单个 url 参数
        const modelsParam = getQueryParam('models');
        const urlParam = getQueryParam('url');
        
        if (modelsParam) {
            // 新格式：直接使用传入的模型列表
            try {
                const parsed = JSON.parse(modelsParam);
                if (Array.isArray(parsed) && parsed.length > 0) {
                    modelOptions = parsed.map(item => ({
                        name: item.name || '3D模型',
                        path: item.path.startsWith('http') ? item.path : `${API_BASE}${item.path}`
                    }));
                }
            } catch (e) {
                console.error('解析 models 参数失败:', e);
            }
        } else if (urlParam) {
            // 向后兼容：单个 url 参数
            modelOptions = [
                { name: '3D模型', path: urlParam.startsWith('http') ? urlParam : `${API_BASE}${urlParam}` }
            ];
        }

        // 填充模型选择下拉框
        const modelSelect = document.getElementById('modelSelect');
        modelOptions.forEach((option, index) => {
            const opt = document.createElement('option');
            opt.value = index;
            opt.text = option.name;
            modelSelect.appendChild(opt);
        });

        // LayaAir 3.x 配置
        const config = {
            resolution: {
                designWidth: window.innerWidth,
                designHeight: window.innerHeight,
                scaleMode: "full",
                alignV: "middle",
                alignH: "center",
                screenMode: "none",
                backgroundColor: "#888888"
            },
            "2D": {
                FPS: 60,
                isAntialias: true,
                isAlpha: false,
                // 保留绘制缓冲区，用于截图
                preserveDrawingBuffer: true
            },
            "3D": {
                enableDynamicBatch: true,
                pixelRatio: 1,
                enableMultiLight: true
            }
        };

        Object.assign(Laya.Config, config["2D"]);
        Laya.Config.preserveDrawingBuffer = true; // 确保设置生效
        Object.assign(Laya.Config3D, config["3D"]);

        // 初始化引擎
        Laya.init(config.resolution).then(() => {
            Laya.stage.bgColor = "#888888";
            
            // 创建3D场景
            scene = new Laya.Scene3D();
            Laya.stage.addChild(scene);

            // 设置环境光照模式为球谐光照 (Spherical Harmonics)
            scene.ambientMode = 1; // 1 = SphericalHarmonics
            
            // 设置球谐系数（从 Scene.ls 提取）
            scene.ambientSH = new Float32Array([
                0.561861515045166, 0.5691413879394531, 0.5156031250953674,
                0.25098922848701477, 0.29723599553108215, 0.3360276222229004,
                0.18643078207969666, 0.16357596218585968, 0.11102143675088882,
                -0.5348716974258423, -0.507384181022644, -0.4003814160823822,
                -0.24370312690734863, -0.22358225286006927, -0.1722458302974701,
                0.11344613134860992, 0.10041586309671402, 0.07283135503530502,
                -0.04577554389834404, -0.036940183490514755, -0.020133458077907562,
                -0.28794020414352417, -0.2579245865345001, -0.19256529211997986,
                0.20134146511554718, 0.1833409070968628, 0.1309514194726944
            ]);
            
            // 设置环境光颜色
            scene.ambientColor = new Laya.Color(0.424308, 0.4578516, 0.5294118, 1);
            
            // IBL 反射采样数
            scene._reflectionsIblSamples = 1024;
            
            // 加载天空盒和 IBL 环境贴图
            setupSkyAndIBL(scene);

            // 创建相机
            camera = new Laya.Camera(0, 0.1, 1000);
            scene.addChild(camera);
            camera.transform.position = new Laya.Vector3(0, 1, 5);
            camera.transform.rotationEuler = new Laya.Vector3(-15, 0, 0);
            camera.clearFlag = Laya.CameraClearFlags.Sky;
            camera.clearColor = new Laya.Color(0.3921, 0.5843, 0.9294, 1);
            
            // 添加相机控制脚本
            camera.addComponent(CameraController);

            // 创建方向光
            const directionLight = new Laya.Sprite3D();
            scene.addChild(directionLight);
            directionLight.transform.position = new Laya.Vector3(5, 5, 5);
            directionLight.transform.rotationEuler = new Laya.Vector3(-12.5, 77.7, 0);
            const lightCom = directionLight.addComponent(Laya.DirectionLightCom);
            lightCom.color = new Laya.Color(1, 1, 1, 1);
            
            // 开启方向光阴影
            lightCom.shadowMode = Laya.ShadowMode.SoftLow;
            lightCom.shadowDistance = 20;
            lightCom.shadowResolution = 1024;
            lightCom.shadowCascadesMode = Laya.ShadowCascadesMode.NoCascades;
            lightCom.shadowDepthBias = 1.0;
            lightCom.shadowNormalBias = 1.0;

            // 创建地面
            createGround();

            // 加载第一个模型
            if (modelOptions.length > 0) {
                loadModel(0);
            } else {
                document.getElementById('loadingText').textContent = '请在URL中指定模型路径 ?url=xxx';
            }

            // 显示统计信息
            // Laya.Stat.show();
        });

        // 相机控制器
        // 左键拖动：旋转视角
        // 右键拖动：平移视角
        // 滚轮：缩放
        class CameraController extends Laya.Script {
            constructor() {
                super();
                this.yawPitchRoll = new Laya.Vector3(15, 0, 0);
                this.distance = 5;
                this.target = new Laya.Vector3(0, 0.5, 0);
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                this.isLeftMouseDown = false;
                this.isRightMouseDown = false;
                
                // 模型相关参数（根据包围盒动态调整）
                this.modelSize = 2;        // 模型尺寸（用于计算滚轮速度）
                this.minDistance = 0.5;    // 最小距离
                this.maxDistance = 50;     // 最大距离
                this.wheelSpeed = 0.01;    // 滚轮速度系数
            }
            
            // 根据模型包围盒设置参数
            setModelBounds(size) {
                this.modelSize = size;
                // 滚轮速度基于模型大小（模型越大，滚轮速度越快）
                // 使用 0.02 作为基础系数，确保滚轮灵敏度足够
                this.wheelSpeed = Math.max(0.01, size * 0.02);
                // 最小距离为模型大小的 0.2 倍
                this.minDistance = Math.max(0.1, size * 0.2);
                // 最大距离为模型大小的 20 倍
                this.maxDistance = Math.max(10, size * 20);
                // 默认距离为模型大小的 2.5 倍
                this.distance = Math.max(this.minDistance, Math.min(this.maxDistance, size * 2.5));
                
                console.log(`[CameraController] 模型大小: ${size.toFixed(2)}, 滚轮速度: ${this.wheelSpeed.toFixed(4)}, 距离范围: [${this.minDistance.toFixed(2)}, ${this.maxDistance.toFixed(2)}]`);
                
                this.updateCamera();
            }

            onStart() {
                // 左键事件
                Laya.stage.on(Laya.Event.MOUSE_DOWN, this, this.onLeftMouseDown);
                Laya.stage.on(Laya.Event.MOUSE_UP, this, this.onLeftMouseUp);
                
                // 右键事件（LayaAir 专用事件）
                Laya.stage.on(Laya.Event.RIGHT_MOUSE_DOWN, this, this.onRightMouseDown);
                Laya.stage.on(Laya.Event.RIGHT_MOUSE_UP, this, this.onRightMouseUp);
                
                // 通用事件
                Laya.stage.on(Laya.Event.MOUSE_OUT, this, this.onMouseOut);
                Laya.stage.on(Laya.Event.MOUSE_MOVE, this, this.onMouseMove);
                Laya.stage.on(Laya.Event.MOUSE_WHEEL, this, this.onMouseWheel);
                
                // 禁用右键菜单
                document.addEventListener('contextmenu', (e) => e.preventDefault());
                
                this.updateCamera();
            }

            onLeftMouseDown(e) {
                this.isLeftMouseDown = true;
                this.lastMouseX = Laya.stage.mouseX;
                this.lastMouseY = Laya.stage.mouseY;
            }

            onLeftMouseUp(e) {
                this.isLeftMouseDown = false;
            }

            onRightMouseDown(e) {
                this.isRightMouseDown = true;
                this.lastMouseX = Laya.stage.mouseX;
                this.lastMouseY = Laya.stage.mouseY;
            }

            onRightMouseUp(e) {
                this.isRightMouseDown = false;
            }

            onMouseOut(e) {
                this.isLeftMouseDown = false;
                this.isRightMouseDown = false;
            }

            onMouseMove(e) {
                if (!this.isLeftMouseDown && !this.isRightMouseDown) return;
                
                const deltaX = Laya.stage.mouseX - this.lastMouseX;
                const deltaY = Laya.stage.mouseY - this.lastMouseY;
                
                if (this.isLeftMouseDown) {
                    // 左键：旋转视角
                    this.yawPitchRoll.y -= deltaX * 0.3;
                    this.yawPitchRoll.x += deltaY * 0.3;
                    
                    // 限制俯仰角
                    this.yawPitchRoll.x = Math.max(-89, Math.min(89, this.yawPitchRoll.x));
                } else if (this.isRightMouseDown) {
                    // 右键：平移视角
                    // 计算相机的右方向和上方向
                    const pitch = this.yawPitchRoll.x * Math.PI / 180;
                    const yaw = this.yawPitchRoll.y * Math.PI / 180;
                    
                    // 相机右方向（在 XZ 平面上）
                    const rightX = Math.cos(yaw);
                    const rightZ = -Math.sin(yaw);
                    
                    // 相机上方向（世界坐标系 Y 轴）
                    const upY = 1;
                    
                    // 平移速度基于距离
                    const panSpeed = this.distance * 0.002;
                    
                    // 移动目标点
                    this.target.x -= deltaX * rightX * panSpeed;
                    this.target.z -= deltaX * rightZ * panSpeed;
                    this.target.y += deltaY * upY * panSpeed;
                }
                
                this.lastMouseX = Laya.stage.mouseX;
                this.lastMouseY = Laya.stage.mouseY;
                
                this.updateCamera();
            }

            onMouseWheel(e) {
                // 使用动态滚轮速度（基于模型大小）
                this.distance += e.delta * this.wheelSpeed;
                this.distance = Math.max(this.minDistance, Math.min(this.maxDistance, this.distance));
                this.updateCamera();
            }

            updateCamera() {
                const pitch = this.yawPitchRoll.x * Math.PI / 180;
                const yaw = this.yawPitchRoll.y * Math.PI / 180;
                
                const x = this.distance * Math.cos(pitch) * Math.sin(yaw);
                const y = this.distance * Math.sin(pitch);
                const z = this.distance * Math.cos(pitch) * Math.cos(yaw);
                
                this.owner.transform.position = new Laya.Vector3(
                    this.target.x + x,
                    this.target.y + y,
                    this.target.z + z
                );
                this.owner.transform.lookAt(this.target, new Laya.Vector3(0, 1, 0));
            }

            resetView() {
                this.yawPitchRoll = new Laya.Vector3(15, 0, 0);
                this.distance = this.modelSize * 2.5; // 根据模型大小设置默认距离
                this.target = new Laya.Vector3(0, 0.5, 0); // 重置目标点
                this.updateCamera();
            }
        }

        // 设置天空盒和 IBL 环境贴图
        function setupSkyAndIBL(scene) {
            // 尝试加载天空盒材质
            Laya.loader.load('sky.lmat', Laya.Handler.create(null, (material) => {
                if (material) {
                    // 设置天空盒渲染器
                    //scene.skyRenderer.meshType = Laya.SkyMeshType.Dome;
                    scene.skyRenderer.material = material;
                    console.log('[laya-viewer] 天空盒材质加载成功');
                } else {
                    console.log('[laya-viewer] 天空盒材质不存在，使用默认背景');
                }
            }), null, Laya.Loader.MATERIAL);
            
            // 尝试加载 IBL 环境贴图
            Laya.loader.load('Scene/Scene.ktx', Laya.Handler.create(null, (texture) => {
                if (texture) {
                    scene.iblTex = texture;
                    scene.iblTexRGBD = true;
                    console.log('[laya-viewer] IBL 环境贴图加载成功');
                } else {
                    console.log('[laya-viewer] IBL 环境贴图不存在，使用默认环境');
                }
            }), null, Laya.Loader.TEXTURECUBE);
        }

        // 创建地面
        function createGround() {
            ground = new Laya.Sprite3D();
            scene.addChild(ground);
            ground.addComponent(Laya.MeshFilter).sharedMesh = Laya.PrimitiveMesh.createPlane(10, 10, 10, 10);
            const renderer = ground.addComponent(Laya.MeshRenderer);
            // 使用 PBRStandardMaterial，设置粗糙度为1（smoothness=0），金属度为0，消除反光
            const material = new Laya.PBRStandardMaterial();
            material.albedoColor = new Laya.Color(0.9, 0.9, 0.9, 1);
            material.smoothness = 0;  // 粗糙度 = 1 - smoothness，设为0表示完全粗糙
            material.metallic = 0;    // 非金属材质
            renderer.sharedMaterial = material;
            
            // 地面接收阴影
            renderer.receiveShadow = true;
        }

        // 更新地面位置到模型包围盒底部
        function updateGroundPosition(model) {
            if (!ground || !model) return;
            
            // 重新计算调整后模型的包围盒
            let bounds = null;
            findBounds(model, (renderer) => {
                if (renderer.bounds) {
                    if (!bounds) {
                        bounds = renderer.bounds.clone();
                    } else {
                        Laya.Bounds.merge(bounds, renderer.bounds, bounds);
                    }
                }
            });
            
            if (bounds) {
                // 获取模型底部的 y 坐标，设置地面位置
                const minY = bounds.getMin().y;
                ground.transform.position = new Laya.Vector3(0, minY, 0);
            }
        }

        // 加载模型
        function loadModel(index) {
            const option = modelOptions[index];
            if (!option) return;

            document.getElementById('loadingText').style.display = 'block';
            document.getElementById('loadingText').textContent = '加载中...';

            // 移除当前模型和线框
            if (wireframeSprite) {
                wireframeSprite.destroy();
                wireframeSprite = null;
            }
            if (currentModel) {
                currentModel.destroy();
                currentModel = null;
            }
            // 重置显示状态为纯实体模式
            displayMode = 'solid';
            isSolidVisible = true;
            isWireframeVisible = false;
            document.getElementById('modeWireframe').classList.remove('active');
            document.getElementById('modeBoth').classList.remove('active');
            document.getElementById('modeSolid').classList.add('active');

            // 加载GLB模型
            Laya.Sprite3D.load(option.path, Laya.Handler.create(null, (sprite) => {
                if (sprite) {
                    currentModel = sprite;
                    scene.addChild(currentModel);
                    
                    // 调整模型
                    adjustModel(currentModel);
                    
                    // 设置模型阴影
                    setupModelShadow(currentModel);
                    
                    // 更新统计信息
                    updateModelStats(currentModel);
                    
                    document.getElementById('loadingText').style.display = 'none';
                    console.log('模型加载成功:', option.path);
                    
                    // 等待渲染完成后截图（等待10帧）
                    waitFramesAndCapture(10, option.path);
                } else {
                    document.getElementById('loadingText').textContent = '模型加载失败';
                    console.error('模型加载失败:', option.path);
                }
            }), null, null, null, null, Laya.Loader.HIERARCHY);
        }
        
        // 截取正方形缩略图（取屏幕中间区域）
        function captureSquareThumbnail(canvas, size) {
            const w = canvas.width;
            const h = canvas.height;
            
            // 计算正方形裁剪区域（取中间）
            const squareSize = Math.min(w, h);
            const sx = Math.floor((w - squareSize) / 2);
            const sy = Math.floor((h - squareSize) / 2);
            
            // 创建临时 canvas 进行裁剪和缩放
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = size;
            tempCanvas.height = size;
            const tempCtx = tempCanvas.getContext('2d');
            
            // 从原始 canvas 裁剪中间正方形区域并缩放
            tempCtx.drawImage(
                canvas,
                sx, sy, squareSize, squareSize,  // 源区域
                0, 0, size, size                  // 目标区域
            );
            
            return tempCanvas.toDataURL('image/jpeg', 0.85);
        }

        // 等待指定帧数后截图
        let captureFrameCount = 0;
        let captureModelPath = '';
        function waitFramesAndCapture(frames, modelPath) {
            captureFrameCount = frames;
            captureModelPath = modelPath;
            Laya.timer.frameLoop(1, null, onCaptureFrame);
        }
        
        function onCaptureFrame() {
            captureFrameCount--;
            if (captureFrameCount <= 0) {
                Laya.timer.clear(null, onCaptureFrame);
                captureAndSendThumbnail(captureModelPath);
            }
        }
        
        // 截图并发送给父窗口
        function captureAndSendThumbnail(modelPath) {
            try {
                if (!currentModel || !camera) return;
                
                // 保存当前相机控制器状态
                const controller = camera.getComponent(CameraController);
                let savedDistance, savedYawPitchRoll, savedTarget;
                if (controller) {
                    savedDistance = controller.distance;
                    savedYawPitchRoll = controller.yawPitchRoll.clone();
                    savedTarget = controller.target.clone();
                }
                
                // 计算模型包围盒
                let bounds = null;
                findBounds(currentModel, (renderer) => {
                    if (renderer.bounds) {
                        if (!bounds) {
                            bounds = renderer.bounds.clone();
                        } else {
                            Laya.Bounds.merge(bounds, renderer.bounds, bounds);
                        }
                    }
                });
                
                if (bounds) {
                    // 计算包围盒中心和大小
                    const center = new Laya.Vector3();
                    bounds.getCenter(center);
                    const extent = bounds.getExtent();
                    
                    // 由于我们截取正方形区域，需要确保模型在正方形内完全可见
                    // 计算从斜上方观察时模型的可见范围
                    const pitch = 25 * Math.PI / 180;  // 俯仰角
                    const yaw = 35 * Math.PI / 180;    // 偏航角
                    
                    // 考虑旋转后的有效尺寸（取最大范围以确保完全可见）
                    const effectiveSize = Math.max(
                        extent.x * 2,
                        extent.y * 2,
                        extent.z * 2,
                        Math.sqrt(extent.x * extent.x + extent.z * extent.z) * 2  // 对角线
                    );
                    
                    // 根据相机 FOV 计算最佳距离
                    // 由于截取正方形，需要用较大的边距（1.5倍）确保模型完全在视野内
                    const fov = camera.fieldOfView * Math.PI / 180;
                    const distance = (effectiveSize * 0.8) / Math.tan(fov / 2);
                    
                    // 设置相机位置
                    const x = distance * Math.cos(pitch) * Math.sin(yaw);
                    const y = distance * Math.sin(pitch);
                    const z = distance * Math.cos(pitch) * Math.cos(yaw);
                    
                    camera.transform.position = new Laya.Vector3(
                        center.x + x,
                        center.y + y,
                        center.z + z
                    );
                    camera.transform.lookAt(center, new Laya.Vector3(0, 1, 0));
                }
                
                // 等待一帧渲染后截图
                Laya.timer.frameOnce(2, null, () => {
                    // 获取 canvas
                    const canvas = document.querySelector('canvas');
                    if (!canvas) {
                        console.error('Canvas not found');
                        restoreCamera();
                        return;
                    }
                    
                    // 确保 canvas 有内容
                    const ctx = canvas.getContext('webgl') || canvas.getContext('webgl2');
                    if (ctx) {
                        ctx.finish();
                    }
                    
                    // 截取正方形缩略图（取屏幕中间区域）
                    const dataUrl = captureSquareThumbnail(canvas, 512);
                    
                    // 检查是否是空白图片
                    if (dataUrl.length < 1000) {
                        console.warn('截图可能是空的，重试...');
                        restoreCamera();
                        waitFramesAndCapture(10, modelPath);
                        return;
                    }
                    
                    // 发送给父窗口
                    if (window.parent !== window) {
                        window.parent.postMessage({
                            type: 'thumbnail',
                            modelPath: modelPath,
                            dataUrl: dataUrl
                        }, '*');
                        console.log('缩略图已发送, 大小:', dataUrl.length);
                    }
                    
                    // 恢复相机位置
                    restoreCamera();
                });
                
                function restoreCamera() {
                    if (controller && savedDistance !== undefined) {
                        controller.distance = savedDistance;
                        controller.yawPitchRoll = savedYawPitchRoll;
                        controller.target = savedTarget;
                        controller.updateCamera();
                    }
                }
                
            } catch (e) {
                console.error('截图失败:', e);
            }
        }

        // 调整模型位置和缩放
        function adjustModel(model) {
            // 计算边界盒
            let bounds = null;
            findBounds(model, (renderer) => {
                if (renderer.bounds) {
                    if (!bounds) {
                        bounds = renderer.bounds.clone();
                    } else {
                        Laya.Bounds.merge(bounds, renderer.bounds, bounds);
                    }
                }
            });

            if (bounds) {
                const size = bounds.getExtent().clone();
                const maxSize = Math.max(size.x, size.y, size.z) * 2;
                
                if (maxSize > 0) {
                    const scale = 2 / maxSize;
                    model.transform.localScale = new Laya.Vector3(scale, scale, scale);
                    
                    // 重新计算边界
                    const center = new Laya.Vector3();
                    bounds.getCenter(center);
                    model.transform.position = new Laya.Vector3(
                        -center.x * scale,
                        -bounds.getMin().y * scale,
                        -center.z * scale
                    );
                    
                    // 缩放后的模型大小约为 2（因为 scale = 2 / maxSize）
                    const scaledModelSize = 2;
                    
                    // 设置相机控制器参数（根据缩放后的模型大小）
                    if (camera) {
                        const controller = camera.getComponent(CameraController);
                        if (controller) {
                            controller.setModelBounds(scaledModelSize);
                            // 重置目标点到模型中心（缩放后高度的一半）
                            controller.target = new Laya.Vector3(0, scaledModelSize * 0.25, 0);
                        }
                    }
                    
                    // 在下一帧更新地面位置（确保 transform 已更新）
                    Laya.timer.frameOnce(1, null, () => {
                        updateGroundPosition(model);
                    });
                }
            }
        }

        // 遍历查找渲染器
        function findBounds(node, callback) {
            const renderer = node.getComponent(Laya.MeshRenderer) || node.getComponent(Laya.SkinnedMeshRenderer);
            if (renderer) {
                callback(renderer);
            }
            for (let i = 0; i < node.numChildren; i++) {
                findBounds(node.getChildAt(i), callback);
            }
        }

        // 设置模型阴影（投射和接收）
        function setupModelShadow(model) {
            findBounds(model, (renderer) => {
                renderer.castShadow = true;
                renderer.receiveShadow = true;
            });
        }

        // 更新模型统计信息（顶点数、面数）
        function updateModelStats(model) {
            let totalVertices = 0;
            let totalTriangles = 0;
            
            function countMeshStats(node) {
                let mesh = null;
                
                // 从 MeshFilter 获取 mesh
                const meshFilter = node.getComponent(Laya.MeshFilter);
                if (meshFilter && meshFilter.sharedMesh) {
                    mesh = meshFilter.sharedMesh;
                }
                
                // 从 SkinnedMeshRenderer 获取 mesh
                const skinnedRenderer = node.getComponent(Laya.SkinnedMeshRenderer);
                if (!mesh && skinnedRenderer && skinnedRenderer._mesh) {
                    mesh = skinnedRenderer._mesh;
                }
                
                if (mesh) {
                    totalVertices += mesh.vertexCount || 0;
                    // 计算三角形数：索引数 / 3
                    totalTriangles += Math.floor((mesh.indexCount || 0) / 3);
                }
                
                // 递归处理子节点
                for (let i = 0; i < node.numChildren; i++) {
                    countMeshStats(node.getChildAt(i));
                }
            }
            
            countMeshStats(model);
            
            // 格式化数字显示
            const formatNumber = (num) => {
                if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
                if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                return num.toString();
            };
            
            document.getElementById('modelStats').innerHTML = 
                `顶点: ${formatNumber(totalVertices)}<br>面数: ${formatNumber(totalTriangles)}`;
        }

        // 事件监听
        modelSelect.addEventListener('change', (e) => {
            loadModel(parseInt(e.target.value));
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            if (camera) {
                const controller = camera.getComponent(CameraController);
                if (controller) {
                    controller.resetView();
                }
            }
        });

        // 显示模式：'solid' | 'wireframe' | 'both'
        let displayMode = 'solid';

        // 纯线框模式
        document.getElementById('modeWireframe').addEventListener('click', () => {
            if (!currentModel) return;
            setDisplayMode('wireframe');
        });

        // 线框+实体模式
        document.getElementById('modeBoth').addEventListener('click', () => {
            if (!currentModel) return;
            setDisplayMode('both');
        });

        // 纯实体模式
        document.getElementById('modeSolid').addEventListener('click', () => {
            if (!currentModel) return;
            setDisplayMode('solid');
        });

        // 设置显示模式
        function setDisplayMode(mode) {
            displayMode = mode;
            
            // 更新按钮状态
            document.getElementById('modeWireframe').classList.toggle('active', mode === 'wireframe');
            document.getElementById('modeBoth').classList.toggle('active', mode === 'both');
            document.getElementById('modeSolid').classList.toggle('active', mode === 'solid');
            
            // 根据模式设置显示
            const showSolid = (mode === 'solid' || mode === 'both');
            const showWireframe = (mode === 'wireframe' || mode === 'both');
            
            // 设置实体可见性
            setModelRenderersVisible(currentModel, showSolid);
            isSolidVisible = showSolid;
            
            // 设置线框可见性
            if (showWireframe && !wireframeSprite) {
                createWireframe(currentModel);
            } else if (!showWireframe && wireframeSprite) {
                wireframeSprite.destroy();
                wireframeSprite = null;
            }
            isWireframeVisible = showWireframe;
        }

        // 地面显示状态
        let isGroundVisible = true;

        // 地面显示切换
        document.getElementById('groundBtn').addEventListener('click', () => {
            isGroundVisible = !isGroundVisible;
            if (ground) {
                const renderer = ground.getComponent(Laya.MeshRenderer);
                if (renderer) {
                    renderer.enabled = isGroundVisible;
                }
            }
            document.getElementById('groundBtn').classList.toggle('active', isGroundVisible);
        });

        // 设置模型渲染器可见性
        function setModelRenderersVisible(model, visible) {
            findBounds(model, (renderer) => {
                renderer.enabled = visible;
            });
        }

        // 创建线框精灵
        function createWireframe(model) {
            if (wireframeSprite) {
                wireframeSprite.destroy();
            }
            
            wireframeSprite = new Laya.PixelLineSprite3D(1000000, 'wireframe');
            scene.addChild(wireframeSprite);
            
            // 线框颜色
            const lineColor = new Laya.Color(0.2, 0.8, 1.0, 1);
            
            // 遍历所有 Mesh，提取边缘
            extractEdgesFromModel(model, wireframeSprite, lineColor);
        }

        // 从模型中提取边缘并添加到线框精灵
        function extractEdgesFromModel(node, lineSprite, color) {
            let mesh = null;
            
            // 尝试从 MeshFilter 获取 mesh（普通 MeshRenderer）
            const meshFilter = node.getComponent(Laya.MeshFilter);
            if (meshFilter && meshFilter.sharedMesh) {
                mesh = meshFilter.sharedMesh;
            }
            
            // 尝试从 SkinnedMeshRenderer 获取 mesh
            const skinnedRenderer = node.getComponent(Laya.SkinnedMeshRenderer);
            if (!mesh && skinnedRenderer && skinnedRenderer._mesh) {
                mesh = skinnedRenderer._mesh;
            }
            
            if (mesh) {
                const transform = node.transform;
                // 获取顶点数据和索引数据
                extractMeshEdges(mesh, transform, lineSprite, color);
            }
            
            // 递归处理子节点
            for (let i = 0; i < node.numChildren; i++) {
                extractEdgesFromModel(node.getChildAt(i), lineSprite, color);
            }
        }

        // 提取网格边缘
        function extractMeshEdges(mesh, transform, lineSprite, color) {
            try {
                // 检查 mesh 是否可读
                if (!mesh._isReadable) {
                    console.warn('Mesh 不可读，无法提取线框');
                    return;
                }
                
                // 使用 Mesh 的高级 API 获取顶点位置
                const positions = [];
                mesh.getPositions(positions);
                if (!positions || positions.length === 0) {
                    console.warn('无法获取顶点位置数据');
                    return;
                }
                
                // 获取世界变换矩阵
                const worldMatrix = transform.worldMatrix;
                
                // 用于存储边缘的 Set（避免重复边）
                const edgeSet = new Set();
                const lines = [];
                
                // 遍历所有子网格
                for (let s = 0; s < mesh.subMeshCount; s++) {
                    const subMesh = mesh.getSubMesh(s);
                    
                    // 使用 getIndices() 获取索引数据
                    let indexData;
                    try {
                        indexData = subMesh.getIndices();
                    } catch (e) {
                        console.warn('无法获取子网格索引:', e);
                        continue;
                    }
                    if (!indexData || indexData.length === 0) continue;
                    
                    // 遍历三角形
                    for (let i = 0; i < indexData.length; i += 3) {
                        const i0 = indexData[i];
                        const i1 = indexData[i + 1];
                        const i2 = indexData[i + 2];
                        
                        // 添加三条边（使用排序后的索引作为 key 避免重复）
                        addEdgeFromPositions(edgeSet, lines, positions, i0, i1, worldMatrix, color);
                        addEdgeFromPositions(edgeSet, lines, positions, i1, i2, worldMatrix, color);
                        addEdgeFromPositions(edgeSet, lines, positions, i2, i0, worldMatrix, color);
                    }
                }
                
                // 批量添加线条
                if (lines.length > 0) {
                    lineSprite.addLines(lines);
                }
                
            } catch (e) {
                console.warn('提取网格边缘失败:', e);
            }
        }
        
        // 从位置数组添加边缘
        function addEdgeFromPositions(edgeSet, lines, positions, index1, index2, worldMatrix, color) {
            // 创建边的唯一键
            const minIdx = Math.min(index1, index2);
            const maxIdx = Math.max(index1, index2);
            const edgeKey = `${minIdx}_${maxIdx}`;
            
            // 检查边是否已存在
            if (edgeSet.has(edgeKey)) return;
            edgeSet.add(edgeKey);
            
            // 获取顶点位置（positions 是 Vector3 数组）
            const pos1 = positions[index1];
            const pos2 = positions[index2];
            
            if (!pos1 || !pos2) return;
            
            // 变换到世界坐标
            const startPos = new Laya.Vector3();
            const endPos = new Laya.Vector3();
            Laya.Vector3.transformCoordinate(pos1, worldMatrix, startPos);
            Laya.Vector3.transformCoordinate(pos2, worldMatrix, endPos);
            
            // 创建线条数据（PixelLineData 需要手动设置属性）
            const lineData = new Laya.PixelLineData();
            startPos.cloneTo(lineData.startPosition);
            endPos.cloneTo(lineData.endPosition);
            color.cloneTo(lineData.startColor);
            color.cloneTo(lineData.endColor);
            
            lines.push(lineData);
        }


        document.getElementById('updateThumbnailBtn').addEventListener('click', () => {
            if (currentModel && modelOptions.length > 0) {
                const currentIndex = modelSelect.value;
                const option = modelOptions[currentIndex];
                if (option) {
                    // 使用当前视角截图并发送
                    captureThumbnailCurrentView(option.path);
                }
            }
        });

        // 获取记录 ID（从 URL 参数）
        const recordId = getQueryParam('id');

        // 使用当前视角截图（不调整相机）
        async function captureThumbnailCurrentView(modelPath) {
            try {
                const canvas = document.querySelector('canvas');
                if (!canvas) {
                    console.error('Canvas not found');
                    return;
                }
                
                const ctx = canvas.getContext('webgl') || canvas.getContext('webgl2');
                if (ctx) {
                    ctx.finish();
                }
                
                // 截取正方形缩略图（取屏幕中间区域）
                const dataUrl = captureSquareThumbnail(canvas, 512);
                
                if (dataUrl.length < 1000) {
                    console.warn('截图可能是空的');
                    return;
                }
                
                // 发送给父窗口（嵌入模式）
                if (window.parent !== window) {
                    window.parent.postMessage({
                        type: 'thumbnail',
                        modelPath: modelPath,
                        dataUrl: dataUrl
                    }, '*');
                    console.log('缩略图已更新并发送, 大小:', dataUrl.length);
                    alert('缩略图已更新！');
                } else {
                    // 非嵌入模式，直接调用后端 API
                    if (!recordId) {
                        alert('URL 中缺少记录 ID，无法更新缩略图');
                        return;
                    }
                    
                    try {
                        const response = await fetch(`${API_BASE}/api/live-gen/${recordId}/thumbnail`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ dataUrl })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            console.log('缩略图已保存:', result.thumbnailPath);
                            alert('缩略图已更新！');
                        } else {
                            const error = await response.json();
                            console.error('保存缩略图失败:', error);
                            alert('保存缩略图失败：' + (error.error || '未知错误'));
                        }
                    } catch (e) {
                        console.error('请求失败:', e);
                        alert('请求失败：' + e.message);
                    }
                }
            } catch (e) {
                console.error('截图失败:', e);
                alert('截图失败：' + e.message);
            }
        }
    </script>
</body>
</html>
