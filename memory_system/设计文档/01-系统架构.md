# 系统架构设计

## 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                      用户界面层                              │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │ CLI工具  │  │ Web界面  │  │  API     │  │ Python SDK│   │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘   │
└───────┼─────────────┼─────────────┼─────────────┼─────────┘
        │             │             │             │
┌───────┴─────────────┴─────────────┴─────────────┴─────────┐
│                      服务层                                 │
│  ┌──────────────────────────────────────────────────┐     │
│  │           QueryService (查询服务)                 │     │
│  │  - 问答处理   - 上下文增强   - 证据追踪          │     │
│  └──────────────────────────────────────────────────┘     │
│                                                            │
│  ┌──────────────────────────────────────────────────┐     │
│  │           LearningService (学习服务)              │     │
│  │  - 文档扫描   - 实体提取   - 知识融合            │     │
│  └──────────────────────────────────────────────────┘     │
│                                                            │
│  ┌──────────────────────────────────────────────────┐     │
│  │           ConflictService (冲突检测)              │     │
│  │  - 矛盾识别   - 版本追踪   - 主动确认            │     │
│  └──────────────────────────────────────────────────┘     │
└────────────────────────────┬───────────────────────────────┘
                             │
┌────────────────────────────┴───────────────────────────────┐
│                      核心引擎层                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │  实体提取器   │  │  关系推断器   │  │  置信度引擎  │    │
│  │  EntityExtract│ │  RelationInfer│ │  Confidence  │    │
│  └──────────────┘  └──────────────┘  └──────────────┘    │
│                                                            │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │  向量检索器   │  │  知识融合器   │  │  证据推理器  │    │
│  │  VectorSearch│  │  KnowledgeFuse│ │  Evidence    │    │
│  └──────────────┘  └──────────────┘  └──────────────┘    │
└────────────────────────────┬───────────────────────────────┘
                             │
┌────────────────────────────┴───────────────────────────────┐
│                      存储层                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │  知识库      │  │  向量库       │  │  学习历史     │    │
│  │  (SQLite)    │  │  (ChromaDB)   │  │  (JSONL)     │    │
│  │              │  │               │  │              │    │
│  │ entities.db  │  │ vectors.db    │  │ learning.log │    │
│  └──────────────┘  └──────────────┘  └──────────────┘    │
│                                                            │
│  ┌──────────────────────────────────────────────────┐     │
│  │           文档索引 (Document Index)               │     │
│  │  - 文档元数据   - 修改追踪   - 版本历史          │     │
│  └──────────────────────────────────────────────────┘     │
└────────────────────────────────────────────────────────────┘
```

## 核心组件详解

### 1. QueryService（查询服务）

**职责：** 处理用户问题，提供增强的RAG回答

```python
class QueryService:
    def __init__(self):
        self.knowledge_base = KnowledgeBase()
        self.vector_store = VectorStore()
        self.evidence_engine = EvidenceEngine()

    def answer(self, question: str) -> Answer:
        # 1. 提取问题中的实体
        entities = self.extract_entities(question)

        # 2. 从知识库获取背景
        background = self.knowledge_base.get_context(entities)

        # 3. 向量检索文档
        docs = self.vector_store.search(question, top_k=5)

        # 4. 合并上下文
        context = self.merge_context(background, docs)

        # 5. 生成回答（调用LLM）
        answer = self.llm.generate(question, context)

        # 6. 证据追踪
        evidence = self.evidence_engine.track(answer, context)

        return Answer(
            content=answer,
            evidence=evidence,
            confidence=self.calculate_confidence(evidence)
        )
```

**特性：**
- 自动补充背景知识
- 多源检索（向量+知识图谱）
- 强制引用来源
- 不确定性标注

### 2. LearningService（学习服务）

**职责：** 从文档和交互中持续学习

```python
class LearningService:
    def learn_from_document(self, doc_path: str):
        # 1. 读取文档
        content = self.read_document(doc_path)

        # 2. 提取实体
        entities = self.entity_extractor.extract(content)

        # 3. 推断属性和关系
        for entity in entities:
            properties = self.infer_properties(entity, content)
            relations = self.infer_relations(entity, content)

            # 4. 知识融合
            self.knowledge_base.merge(
                entity=entity,
                properties=properties,
                relations=relations,
                source=doc_path
            )

        # 5. 检测冲突
        conflicts = self.detect_conflicts(entities)
        return conflicts

    def learn_from_interaction(self, question, answer, feedback):
        # 从对话中学习
        entities = self.extract_entities(question + answer)

        for entity in entities:
            if feedback == "correct":
                self.knowledge_base.increase_confidence(entity)
            elif feedback == "incorrect":
                self.knowledge_base.record_correction(entity, feedback)
```

**学习策略：**
- **批量学习**：初始化时扫描所有文档
- **增量学习**：文档修改时自动更新
- **交互学习**：对话中持续优化

### 3. ConflictService（冲突检测）

**职责：** 发现和解决知识冲突

```python
class ConflictService:
    def detect_conflicts(self) -> List[Conflict]:
        conflicts = []

        # 1. 检测属性冲突
        for entity in self.knowledge_base.all_entities():
            properties = entity.get_all_properties()

            for prop_name, values in properties.items():
                if len(values) > 1 and not self.is_compatible(values):
                    conflicts.append(Conflict(
                        type="property_conflict",
                        entity=entity.name,
                        property=prop_name,
                        values=values,
                        sources=[v.source for v in values]
                    ))

        # 2. 检测时间冲突
        conflicts.extend(self.detect_temporal_conflicts())

        # 3. 检测逻辑冲突
        conflicts.extend(self.detect_logical_conflicts())

        return conflicts

    def resolve_conflict(self, conflict: Conflict, resolution: str):
        # 记录解决方案
        self.knowledge_base.record_resolution(conflict, resolution)
```

**冲突类型：**
- 属性冲突：同一实体的不同描述
- 时间冲突：前后文档矛盾
- 逻辑冲突：A依赖B，但B不存在

### 4. EntityExtractor（实体提取器）

**职责：** 从文本中识别关键实体

```python
class EntityExtractor:
    def __init__(self):
        # 多种提取策略
        self.strategies = [
            RuleBasedExtractor(),    # 基于规则
            PatternExtractor(),       # 基于模式
            NERExtractor(),          # 基于NER模型（可选）
        ]

    def extract(self, text: str) -> List[Entity]:
        entities = []

        for strategy in self.strategies:
            entities.extend(strategy.extract(text))

        # 去重和合并
        return self.merge_entities(entities)
```

**提取策略：**

1. **规则提取**：固定词表
   ```python
   KNOWN_SERVERS = ["linux81", "linux21", "usa服务器"]
   KNOWN_PROJECTS = ["QAMath", "MetaGPT", "Claude Code"]
   ```

2. **模式提取**：正则匹配
   ```python
   PATTERNS = {
       "server": r"([\w]+)\s*服务器",
       "conda_env": r"\(([\w]+)\)",
       "port": r":([\d]{4,5})",
       "path": r"(/[\w/]+)",
   }
   ```

3. **NER模型**（可选）：
   ```python
   from transformers import pipeline
   ner = pipeline("ner", model="hfl/chinese-roberta-wwm-ext")
   ```

### 5. KnowledgeBase（知识库）

**职责：** 存储和管理结构化知识

```python
class KnowledgeBase:
    def __init__(self, db_path: str):
        self.db = sqlite3.connect(db_path)
        self.init_schema()

    def init_schema(self):
        self.db.execute("""
        CREATE TABLE IF NOT EXISTS entities (
            id INTEGER PRIMARY KEY,
            name TEXT UNIQUE,
            type TEXT,
            confidence REAL,
            status TEXT,
            created_at TIMESTAMP,
            updated_at TIMESTAMP
        )
        """)

        self.db.execute("""
        CREATE TABLE IF NOT EXISTS properties (
            id INTEGER PRIMARY KEY,
            entity_id INTEGER,
            key TEXT,
            value TEXT,
            source TEXT,
            confidence REAL,
            FOREIGN KEY (entity_id) REFERENCES entities(id)
        )
        """)

        self.db.execute("""
        CREATE TABLE IF NOT EXISTS relations (
            id INTEGER PRIMARY KEY,
            from_entity_id INTEGER,
            to_entity_id INTEGER,
            relation_type TEXT,
            source TEXT,
            confidence REAL,
            FOREIGN KEY (from_entity_id) REFERENCES entities(id),
            FOREIGN KEY (to_entity_id) REFERENCES entities(id)
        )
        """)

    def add_entity(self, entity: Entity):
        # 插入或更新实体
        ...

    def get_context(self, entities: List[str]) -> Dict:
        # 获取实体的完整上下文（属性+关系）
        ...
```

## 数据流详解

### 1. 初始化流程（Bootstrap）

```
用户文档目录
     ↓ 扫描
┌─────────────┐
│ 文档列表     │
└──────┬──────┘
       ↓ 逐个处理
┌─────────────┐
│ 实体提取     │ → ["linux81", "QAMath", ...]
└──────┬──────┘
       ↓ 推断
┌─────────────┐
│ 属性推断     │ → {type: "server", purpose: "推理"}
└──────┬──────┘
       ↓ 合并
┌─────────────┐
│ 知识融合     │ → 合并同一实体的多次出现
└──────┬──────┘
       ↓ 存储
┌─────────────┐
│ 知识库更新   │
└─────────────┘
       ↓ 输出
待确认列表（低置信度实体）
```

### 2. 查询流程（Query）

```
用户问题
     ↓
┌─────────────┐
│ 实体识别     │ → ["linux81", "QAMath"]
└──────┬──────┘
       ↓ 并行检索
       ├──────────────────┬──────────────────┐
       ↓                  ↓                  ↓
┌──────────┐      ┌──────────┐      ┌──────────┐
│知识库查询 │      │向量检索   │      │关系遍历   │
│ 背景信息  │      │ 文档片段  │      │ 相关实体  │
└────┬─────┘      └────┬─────┘      └────┬─────┘
     └──────────────────┴──────────────────┘
                    ↓ 合并
              ┌─────────────┐
              │ 上下文增强   │
              └──────┬──────┘
                     ↓ LLM生成
              ┌─────────────┐
              │ 生成回答     │
              └──────┬──────┘
                     ↓ 追踪
              ┌─────────────┐
              │ 证据标注     │
              └──────┬──────┘
                     ↓
              【增强的回答】
              - 回答内容
              - 引用来源
              - 置信度
              - 不确定性
```

### 3. 学习流程（Learning）

```
新文档/对话
     ↓
┌─────────────┐
│ 提取信息     │
└──────┬──────┘
       ↓
┌─────────────┐
│ 查询已有知识 │
└──────┬──────┘
       ↓
   是否存在？
   ├─ 是 → ┌─────────────┐
   │        │ 信息一致？   │
   │        ├─ 是 → 提升置信度
   │        └─ 否 → 记录冲突，待确认
   │
   └─ 否 → ┌─────────────┐
           │ 创建新实体   │
           │ 状态: draft  │
           └──────┬──────┘
                  ↓
           需要确认？
           ├─ 是 → 加入待确认列表
           └─ 否 → 自动接受（高置信度推断）
```

## 技术选型

### 核心技术栈

| 组件 | 技术选择 | 原因 |
|------|---------|------|
| 编程语言 | Python 3.9+ | AI生态丰富，易于集成 |
| 向量存储 | ChromaDB | 轻量级，无需服务器，本地化 |
| 结构化存储 | SQLite | 单文件数据库，易于备份 |
| Embedding | sentence-transformers | 本地运行，免费 |
| API框架 | FastAPI | 高性能，自动生成文档 |
| CLI工具 | Click | 功能完善，易用 |

### 可选组件

| 组件 | 技术选择 | 使用场景 |
|------|---------|----------|
| 图数据库 | Neo4j | 复杂关系查询（阶段2） |
| 实体识别 | spaCy/Transformers | 智能提取（阶段2） |
| Web界面 | Flask + Vue.js | 可视化管理（阶段2） |
| 本地LLM | Ollama/LocalAI | 完全离线（阶段3） |

### 依赖清单

```txt
# requirements.txt

# 核心依赖
chromadb>=0.4.0
sentence-transformers>=2.2.0
sqlite3  # 标准库
fastapi>=0.100.0
uvicorn>=0.23.0
click>=8.1.0
pydantic>=2.0.0

# 文档处理
pypdf>=3.0.0
python-docx>=1.0.0
markdown>=3.4.0

# LLM集成
openai>=1.50.0  # 用于NVIDIA API
python-dotenv>=1.0.0

# 可选依赖
# neo4j>=5.0.0  # 图数据库
# spacy>=3.5.0  # NER
# transformers>=4.30.0  # 深度学习
```

## 部署模式

### 模式1：命令行模式（MVP）

```bash
# 用户直接通过CLI使用
memory-cli query "问题"
```

### 模式2：API服务模式

```bash
# 启动API服务
memory-api start --port 8080

# 其他应用调用
curl http://localhost:8080/api/query -d '{"question": "..."}'
```

### 模式3：集成模式

```python
# 集成到现有应用
from memory_system import MemoryClient

memory = MemoryClient()
context = memory.get_context(question)
```

## 扩展性设计

### 插件系统

```python
# 允许自定义提取器
class CustomExtractor(BaseExtractor):
    def extract(self, text: str) -> List[Entity]:
        # 自定义逻辑
        ...

# 注册插件
memory_system.register_extractor(CustomExtractor)
```

### 多租户支持（未来）

```python
# 每个用户独立的知识库
memory = MemoryClient(user_id="user123")
```

### 知识共享（未来）

```python
# 导出知识库
memory.export("knowledge.json")

# 导入他人的知识库
memory.import_shared("team_knowledge.json", merge=True)
```

## 性能考虑

### 索引优化

```sql
-- SQLite索引
CREATE INDEX idx_entity_name ON entities(name);
CREATE INDEX idx_property_key ON properties(entity_id, key);
CREATE INDEX idx_relation_type ON relations(relation_type);
```

### 缓存策略

```python
from functools import lru_cache

@lru_cache(maxsize=1000)
def get_entity_context(entity_name: str):
    # 缓存高频查询的实体上下文
    ...
```

### 增量更新

```python
# 只更新修改的文档，避免全量重建
def update_document(doc_path: str):
    last_modified = get_last_indexed_time(doc_path)
    file_modified = os.path.getmtime(doc_path)

    if file_modified > last_modified:
        reindex_document(doc_path)
```

## 监控和日志

### 学习日志

```jsonl
{"timestamp": "2024-01-07", "action": "learn", "entity": "linux81", "confidence": 0.5}
{"timestamp": "2024-01-08", "action": "confirm", "entity": "linux81", "confidence": 0.8}
{"timestamp": "2024-01-10", "action": "correct", "entity": "linux81", "old_value": "...", "new_value": "..."}
```

### 查询日志

```jsonl
{"timestamp": "2024-01-10", "question": "...", "entities": [...], "confidence": 0.9}
```

## 下一步

继续阅读：
- [02-知识库设计.md](./02-知识库设计.md) - 详细的数据模型
- [03-学习机制.md](./03-学习机制.md) - 学习算法详解
- [04-API设计.md](./04-API设计.md) - API接口文档
