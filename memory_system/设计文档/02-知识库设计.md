# 知识库设计

## 数据模型概览

知识库由三层组成：

```
┌───────────────────────────────────────────────┐
│              实体层（Entity Layer）            │
│  存储核心概念：服务器、项目、工具、环境等      │
└───────────────────────────────────────────────┘
                     ↓
┌───────────────────────────────────────────────┐
│             属性层（Property Layer）           │
│  存储实体的属性：配置、用途、状态等           │
└───────────────────────────────────────────────┘
                     ↓
┌───────────────────────────────────────────────┐
│             关系层（Relation Layer）           │
│  存储实体间关系：部署、依赖、引用等           │
└───────────────────────────────────────────────┘
```

## 实体模型（Entity）

### 数据结构

```json
{
  "id": "ent_1234567890",
  "name": "linux81",
  "type": "server",
  "aliases": ["81", "81机器", "linux-81"],
  "confidence": 0.92,
  "status": "confirmed",  // draft | inferred | confirmed
  "created_at": "2024-01-07T10:00:00Z",
  "updated_at": "2024-01-10T15:30:00Z",
  "learned_from": [
    {
      "source": "日志/2601.md",
      "line": 32,
      "context": "~/laya/guo/AIGenTest/aiserver/test/QAMath$",
      "timestamp": "2024-01-07",
      "extraction_method": "path_pattern"
    },
    {
      "source": "对话/conv_456",
      "user_confirmed": true,
      "question": "linux81是什么",
      "timestamp": "2024-01-10"
    }
  ],
  "metadata": {
    "frequency": 32,  // 出现次数
    "last_seen": "2024-01-10",
    "tags": ["内网", "生产环境"]
  }
}
```

### 实体类型（Entity Types）

```python
class EntityType(Enum):
    SERVER = "server"           # 服务器
    PROJECT = "project"         # 项目
    TOOL = "tool"              # 工具/命令
    ENVIRONMENT = "environment" # 虚拟环境
    MODEL = "model"            # AI模型
    SERVICE = "service"        # 服务
    FILE = "file"              # 文件
    DIRECTORY = "directory"    # 目录
    PERSON = "person"          # 人员
    CONCEPT = "concept"        # 抽象概念
    OTHER = "other"            # 其他
```

### 实体状态（Entity Status）

```python
class EntityStatus(Enum):
    DRAFT = "draft"           # 草稿：刚识别，未确认
    INFERRED = "inferred"     # 推断：基于上下文推断，置信度中等
    CONFIRMED = "confirmed"   # 确认：用户确认或高置信度
    DEPRECATED = "deprecated" # 废弃：已不再使用
    CONFLICTED = "conflicted" # 冲突：存在矛盾信息
```

### SQLite Schema

```sql
CREATE TABLE entities (
    id TEXT PRIMARY KEY,
    name TEXT UNIQUE NOT NULL,
    type TEXT NOT NULL,
    confidence REAL NOT NULL DEFAULT 0.5,
    status TEXT NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    metadata TEXT  -- JSON格式
);

CREATE INDEX idx_entity_name ON entities(name);
CREATE INDEX idx_entity_type ON entities(type);
CREATE INDEX idx_entity_status ON entities(status);

-- 别名表
CREATE TABLE entity_aliases (
    entity_id TEXT,
    alias TEXT,
    PRIMARY KEY (entity_id, alias),
    FOREIGN KEY (entity_id) REFERENCES entities(id)
);

CREATE INDEX idx_alias ON entity_aliases(alias);
```

## 属性模型（Property）

### 数据结构

```json
{
  "id": "prop_9876543210",
  "entity_id": "ent_1234567890",
  "key": "config",
  "value": "8核CPU + 64GB RAM",
  "value_type": "text",  // text | number | boolean | json
  "confidence": 0.85,
  "source": "日志/2601.md",
  "source_quote": "...文档中的原文...",
  "learned_at": "2024-01-07T10:00:00Z",
  "confirmed": false,
  "metadata": {
    "extraction_method": "llm_inference",
    "user_provided": false
  }
}
```

### 常见属性键（Property Keys）

不同实体类型有不同的属性模式：

#### Server属性
```python
SERVER_PROPERTIES = {
    "ip": "IP地址",
    "hostname": "主机名",
    "config": "配置（CPU、内存等）",
    "location": "物理位置（内网/云端）",
    "purpose": "主要用途",
    "access_method": "访问方式（SSH等）",
    "status": "运行状态",
}
```

#### Project属性
```python
PROJECT_PROPERTIES = {
    "description": "项目描述",
    "function": "功能",
    "tech_stack": "技术栈",
    "repository": "代码仓库",
    "deployed_on": "部署位置",
    "port": "端口号",
    "startup_command": "启动命令",
    "status": "项目状态（开发中/生产）",
}
```

#### Environment属性
```python
ENVIRONMENT_PROPERTIES = {
    "type": "环境类型（conda/venv/docker）",
    "python_version": "Python版本",
    "purpose": "用途",
    "packages": "主要包",
}
```

### SQLite Schema

```sql
CREATE TABLE properties (
    id TEXT PRIMARY KEY,
    entity_id TEXT NOT NULL,
    key TEXT NOT NULL,
    value TEXT NOT NULL,
    value_type TEXT DEFAULT 'text',
    confidence REAL DEFAULT 0.5,
    source TEXT,
    source_quote TEXT,
    learned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    confirmed BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (entity_id) REFERENCES entities(id) ON DELETE CASCADE
);

CREATE INDEX idx_property_entity ON properties(entity_id);
CREATE INDEX idx_property_key ON properties(key);

-- 属性历史（追踪变更）
CREATE TABLE property_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    property_id TEXT,
    old_value TEXT,
    new_value TEXT,
    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    reason TEXT,  -- "user_correction" | "conflict_resolution" | "new_source"
    FOREIGN KEY (property_id) REFERENCES properties(id)
);
```

## 关系模型（Relation）

### 数据结构

```json
{
  "id": "rel_5555555555",
  "from_entity_id": "ent_1234567890",  // linux81
  "to_entity_id": "ent_0987654321",    // QAMath
  "relation_type": "hosts",
  "confidence": 0.88,
  "source": "日志/2601.md",
  "source_context": "linux81运行QAMath服务",
  "learned_at": "2024-01-07T10:00:00Z",
  "metadata": {
    "bidirectional": false,
    "strength": "strong"  // strong | weak
  }
}
```

### 关系类型（Relation Types）

```python
class RelationType(Enum):
    # 部署关系
    HOSTS = "hosts"                 # A托管B (服务器托管项目)
    DEPLOYED_ON = "deployed_on"     # B部署在A

    # 依赖关系
    DEPENDS_ON = "depends_on"       # A依赖B
    REQUIRED_BY = "required_by"     # B被A需要

    # 引用关系
    REFERENCES = "references"       # A引用B
    REFERENCED_BY = "referenced_by" # B被A引用

    # 版本关系
    SUPERSEDES = "supersedes"       # A替代B (新版本)
    SUPERSEDED_BY = "superseded_by" # B被A替代

    # 组成关系
    CONTAINS = "contains"           # A包含B
    PART_OF = "part_of"            # B是A的一部分

    # 使用关系
    USES = "uses"                  # A使用B
    USED_BY = "used_by"            # B被A使用

    # 关联关系
    RELATED_TO = "related_to"      # A和B相关

    # 所有权
    OWNED_BY = "owned_by"          # B属于A
```

### 关系示例

```
linux81 --hosts--> QAMath
QAMath --uses--> Qwen-8B
QAMath --requires--> (qwen)环境
start_8b.sh --starts--> QAMath
deploy.sh --deploys--> claude-server
claude-server --deployed_on--> usa-vps
```

### SQLite Schema

```sql
CREATE TABLE relations (
    id TEXT PRIMARY KEY,
    from_entity_id TEXT NOT NULL,
    to_entity_id TEXT NOT NULL,
    relation_type TEXT NOT NULL,
    confidence REAL DEFAULT 0.5,
    source TEXT,
    source_context TEXT,
    learned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    metadata TEXT,  -- JSON格式
    FOREIGN KEY (from_entity_id) REFERENCES entities(id) ON DELETE CASCADE,
    FOREIGN KEY (to_entity_id) REFERENCES entities(id) ON DELETE CASCADE
);

CREATE INDEX idx_relation_from ON relations(from_entity_id);
CREATE INDEX idx_relation_to ON relations(to_entity_id);
CREATE INDEX idx_relation_type ON relations(relation_type);

-- 复合索引：快速查找特定类型的关系
CREATE INDEX idx_relation_from_type ON relations(from_entity_id, relation_type);
```

## 学习历史（Learning Log）

追踪知识的演化过程。

### 数据结构（JSONL格式）

```jsonl
{"timestamp": "2024-01-07T10:00:00Z", "action": "extract", "entity": "linux81", "type": "server", "confidence": 0.5, "source": "日志/2601.md"}
{"timestamp": "2024-01-08T14:30:00Z", "action": "infer_property", "entity": "linux81", "property": "purpose", "value": "运行大模型", "confidence": 0.7}
{"timestamp": "2024-01-10T09:15:00Z", "action": "user_confirm", "entity": "linux81", "question": "linux81是内网服务器吗？", "answer": "是", "confidence_before": 0.7, "confidence_after": 0.9}
{"timestamp": "2024-01-12T16:20:00Z", "action": "detect_conflict", "entity": "QAMath", "property": "deployed_on", "old_value": "linux81", "new_value": "linux21", "status": "pending_resolution"}
{"timestamp": "2024-01-12T16:25:00Z", "action": "resolve_conflict", "entity": "QAMath", "resolution": "迁移", "final_value": "linux21", "note": "2024-01迁移到linux21"}
```

### 行为类型

```python
class LearningAction(Enum):
    EXTRACT = "extract"                 # 提取实体
    INFER_PROPERTY = "infer_property"   # 推断属性
    INFER_RELATION = "infer_relation"   # 推断关系
    USER_CONFIRM = "user_confirm"       # 用户确认
    USER_CORRECT = "user_correct"       # 用户纠正
    DETECT_CONFLICT = "detect_conflict" # 检测冲突
    RESOLVE_CONFLICT = "resolve_conflict" # 解决冲突
    INCREASE_CONFIDENCE = "increase_confidence" # 提升置信度
    DEPRECATE = "deprecate"             # 标记废弃
```

## 冲突记录（Conflicts）

### 数据结构

```json
{
  "id": "conflict_123",
  "type": "property_conflict",
  "entity_id": "ent_0987654321",
  "entity_name": "QAMath",
  "property_key": "deployed_on",
  "conflicting_values": [
    {
      "value": "linux81",
      "source": "日志/2601.md",
      "timestamp": "2024-01-07",
      "confidence": 0.8
    },
    {
      "value": "linux21",
      "source": "日志/2603.md",
      "timestamp": "2024-03-15",
      "confidence": 0.8
    }
  ],
  "status": "pending",  // pending | resolved | ignored
  "detected_at": "2024-03-15T10:00:00Z",
  "resolution": null,
  "resolved_at": null
}
```

### SQLite Schema

```sql
CREATE TABLE conflicts (
    id TEXT PRIMARY KEY,
    type TEXT NOT NULL,  -- property_conflict | relation_conflict | logical_conflict
    entity_id TEXT NOT NULL,
    details TEXT NOT NULL,  -- JSON格式
    status TEXT DEFAULT 'pending',
    detected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    resolved_at TIMESTAMP,
    resolution TEXT,
    FOREIGN KEY (entity_id) REFERENCES entities(id)
);

CREATE INDEX idx_conflict_status ON conflicts(status);
CREATE INDEX idx_conflict_entity ON conflicts(entity_id);
```

## 向量存储（Vector Store）

用于文档检索。

### ChromaDB Collection

```python
# 文档片段集合
collection = client.create_collection(
    name="documents",
    metadata={"description": "用户文档片段"}
)

# 存储格式
collection.add(
    ids=["doc_2601_chunk_1"],
    documents=["linux81上运行QAMath服务..."],
    metadatas=[{
        "source": "日志/2601.md",
        "chunk_index": 1,
        "created_at": "2024-01-07",
        "entities": ["linux81", "QAMath"]
    }],
    embeddings=[...]  # 自动生成
)
```

### 检索增强策略

```python
def enhanced_search(question: str) -> List[Document]:
    # 1. 向量检索文档片段
    vector_results = collection.query(
        query_texts=[question],
        n_results=5
    )

    # 2. 提取问题中的实体
    entities = extract_entities(question)

    # 3. 从知识库获取实体上下文
    entity_contexts = []
    for entity in entities:
        context = knowledge_base.get_entity(entity)
        if context:
            entity_contexts.append(context)

    # 4. 合并结果
    return {
        "documents": vector_results,
        "entity_contexts": entity_contexts
    }
```

## 置信度计算

### 置信度来源

```python
def calculate_confidence(entity: Entity) -> float:
    confidence = 0.0

    # 1. 出现频率 (0-0.3)
    frequency_score = min(entity.frequency / 50, 0.3)
    confidence += frequency_score

    # 2. 来源数量 (0-0.2)
    source_score = min(len(entity.learned_from) / 10, 0.2)
    confidence += source_score

    # 3. 用户确认 (0-0.4)
    if entity.has_user_confirmation():
        confidence += 0.4

    # 4. 上下文一致性 (0-0.1)
    consistency_score = calculate_consistency(entity)
    confidence += consistency_score

    return min(confidence, 1.0)
```

### 置信度等级

```python
class ConfidenceLevel(Enum):
    VERY_LOW = (0.0, 0.3)    # 需要确认
    LOW = (0.3, 0.5)         # 可能不准确
    MEDIUM = (0.5, 0.7)      # 基本可信
    HIGH = (0.7, 0.9)        # 较为确定
    VERY_HIGH = (0.9, 1.0)   # 非常确定
```

## 知识图谱（可选）

使用Neo4j构建图结构（阶段2）。

### Cypher查询示例

```cypher
// 创建实体
CREATE (server:Server {name: 'linux81', config: '8核64G'})
CREATE (project:Project {name: 'QAMath'})
CREATE (server)-[:HOSTS]->(project)

// 查询：找到所有运行在linux81上的项目
MATCH (s:Server {name: 'linux81'})-[:HOSTS]->(p:Project)
RETURN p.name

// 查询：QAMath的完整依赖链
MATCH path = (p:Project {name: 'QAMath'})-[:DEPENDS_ON*]->(dep)
RETURN path

// 查询：与usa服务器相关的所有实体（2跳内）
MATCH (s:Server {name: 'usa服务器'})-[*1..2]-(related)
RETURN DISTINCT related
```

## 数据迁移和备份

### 导出格式（JSON）

```json
{
  "version": "1.0.0",
  "exported_at": "2024-01-15T10:00:00Z",
  "statistics": {
    "total_entities": 156,
    "total_properties": 423,
    "total_relations": 89
  },
  "entities": [...],
  "properties": [...],
  "relations": [...],
  "learning_log": [...]
}
```

### 备份策略

```bash
# 自动备份（每天）
memory-cli backup --output backups/$(date +%Y%m%d).json

# 增量备份（只备份变更）
memory-cli backup --incremental --since 2024-01-10
```

## 查询优化

### 常用查询模式

```python
# 模式1：根据实体名查找完整信息
def get_entity_full_info(name: str):
    entity = db.query("SELECT * FROM entities WHERE name = ?", [name])
    properties = db.query("SELECT * FROM properties WHERE entity_id = ?", [entity.id])
    relations = db.query("SELECT * FROM relations WHERE from_entity_id = ? OR to_entity_id = ?", [entity.id, entity.id])
    return {
        "entity": entity,
        "properties": properties,
        "relations": relations
    }

# 模式2：查找高频但低置信度的实体（需要确认）
def get_uncertain_entities():
    return db.query("""
        SELECT * FROM entities
        WHERE confidence < 0.7
        AND metadata->>'frequency' > 5
        ORDER BY metadata->>'frequency' DESC
        LIMIT 10
    """)

# 模式3：查找最近学习到的知识
def get_recent_learnings(days=7):
    return db.query("""
        SELECT * FROM entities
        WHERE created_at > datetime('now', '-' || ? || ' days')
        ORDER BY created_at DESC
    """, [days])
```

## 下一步

继续阅读：
- [03-学习机制.md](./03-学习机制.md) - 详细的学习算法
- [04-API设计.md](./04-API设计.md) - API接口规范
