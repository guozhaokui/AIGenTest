# 图片文件管理系统 - 需求设计

## 概述
管理大量图片文件，支持去重、多源描述、向量搜索。

## 文件标识
- 使用 **SHA256** 哈希值作为文件唯一标识（取前32位字符，即128bit）
- 避免文件重复存储
- 碰撞处理：如发生哈希碰撞（概率极低），拒绝入库并记录日志

## 描述信息
每个文件可以附带多个描述信息，用于后续的查询：
- vlm1 自动产生的描述
- vlm2 自动产生的描述
- ...
- 人类标注的描述

## 多嵌入设计思路

### 为什么需要多嵌入？
- 不同的 VLM 模型对图片的理解角度不同
- 有的模型擅长物体识别，有的擅长场景理解
- 人工标注可能包含情感、上下文等额外信息
- 多个嵌入增加语义覆盖面，提高搜索召回率

### 一图多嵌入的关系
```
一张图片 (sha256: a1b2c3d4...)
  ├── image.npy     # 图片视觉嵌入（SigLIP-2 模型，1152维）
  ├── vlm1.npy      # "一只橙色的猫坐在窗台上"（Qwen3-Embedding，2560维）
  ├── vlm2.npy      # "室内场景，阳光，宠物猫"（Qwen3-Embedding，2560维）
  └── human.npy     # "我家的橘猫晒太阳"（Qwen3-Embedding，2560维）
```

### 嵌入模型分组原则
- **不同模型的嵌入不能混合比较**（特征空间不对齐）
- 按嵌入模型分组建立索引：
  - `siglip2_image` 索引：存放所有图片的视觉嵌入（1152维）
  - `qwen3_text` 索引：存放所有文本描述的嵌入（2560维）
- 查询时选择对应的索引进行搜索

## 目录结构
```
storage/
  xx/yy/zzzzzzzzzzzzzzzzzzzzzzzzzzzz/
  （xx + yy + zzz... 组成完整的 SHA256 前32位）
      image.png              # 原始图片
      thumbnail.jpg          # 缩略图（256x256，用于列表预览）
      description/
          vlm1.txt
          vlm2.txt
          human.txt
          background.txt
          ...
      embedding/
          image.npy          # 图片本身的嵌入向量（SigLIP-2，1152维）
          vlm1.npy           # vlm1描述的文本嵌入（Qwen3，2560维）
          vlm2.npy           # vlm2描述的文本嵌入（Qwen3，2560维）
          ...
```

## 索引数据库
使用 **SQLite** 数据库存储索引信息，便于快速查询、筛选和排序。

### 主表：images
| 字段 | 类型 | 说明 |
|------|------|------|
| sha256 | TEXT | 主键，文件哈希（前32位） |
| width | INTEGER | 图片宽度 |
| height | INTEGER | 图片高度 |
| file_size | INTEGER | 文件大小(bytes) |
| format | TEXT | 图片格式 |
| created_at | DATETIME | 入库时间 |
| source | TEXT | 来源标记 |
| status | TEXT | 状态（pending/ready/failed） |
| is_deleted | INTEGER | 软删除标记（0/1） |
| deleted_at | DATETIME | 删除时间 |

### 描述表：descriptions
| 字段 | 类型 | 说明 |
|------|------|------|
| image_sha256 | TEXT | 关联的图片哈希 |
| method | TEXT | 描述方法(vlm1/vlm2/human...) |
| has_embedding | INTEGER | 是否已计算嵌入（0/1） |
| created_at | DATETIME | 创建时间 |

> 主键：(image_sha256, method)

### 向量索引表：vector_entries（扁平化存储）
| 字段 | 类型 | 说明 |
|------|------|------|
| id | INTEGER | 自增主键，对应向量索引中的位置 |
| image_sha256 | TEXT | 关联的图片哈希 |
| method | TEXT | 嵌入来源（image/vlm1/vlm2/human...） |
| model | TEXT | 使用的嵌入模型（clip/bge...） |
| model_version | TEXT | 模型版本号 |
| index_name | TEXT | 所属索引名称（clip_image/bge_text） |

> 唯一约束：(image_sha256, method, model)

### 数据库索引
```sql
CREATE INDEX idx_images_created ON images(created_at);
CREATE INDEX idx_images_source ON images(source);
CREATE INDEX idx_images_status ON images(status);
CREATE INDEX idx_images_deleted ON images(is_deleted);
CREATE INDEX idx_desc_method ON descriptions(method);
CREATE INDEX idx_vector_index ON vector_entries(index_name, id);
CREATE INDEX idx_vector_sha256 ON vector_entries(image_sha256);
```

## 向量索引结构
```
vector_index/
├── siglip2_image_v1/        # SigLIP-2 图像嵌入索引
│   ├── embeddings_0.npy     # 分片存储（每片最多10万条）
│   ├── embeddings_1.npy
│   ├── ids.json             # 位置 -> sha256 映射
│   └── meta.json            # 索引元信息（模型版本、维度等）
│
└── qwen3_text_v1/           # Qwen3 文本嵌入索引
    ├── embeddings_0.npy     # 所有描述嵌入 (M, 2560)
    ├── ids.json             # 位置 -> (sha256, method) 映射
    └── meta.json
```

### 索引说明
- 分片存储：每个 npy 文件最多存储 10 万条向量，便于增量更新
- 版本管理：目录名包含模型版本，模型升级时可并行维护新旧索引
- 当数据量增大（>10万）时，可替换为 Faiss 索引以提升性能
- 定期执行索引重建/压缩任务

## 搜索流程

### 文本搜索流程
```
用户输入: "一只猫在晒太阳"
         ↓
1. 使用 Qwen3-Embedding-4B 模型计算查询文本的嵌入向量
         ↓
2. 在 qwen3_text 索引中搜索，返回 top_k*3 个结果
   （多取一些用于去重）
         ↓
3. 通过 vector_entries 表查询每个结果对应的 (sha256, method)
         ↓
4. 按 sha256 去重，每张图片只保留最高分的匹配
         ↓
5. 返回去重后的 top_k 张图片
   附带信息：匹配分数、匹配到的描述类型(method)
```

### 以图搜图流程
```
用户上传: query.jpg
         ↓
1. 使用 SigLIP-2 模型计算查询图片的嵌入向量
         ↓
2. 在 siglip2_image 索引中搜索，返回 top_k 个结果
         ↓
3. 通过 vector_entries 表查询每个结果对应的 sha256
         ↓
4. 返回最相似的 top_k 张图片
```

### 搜索结果示例
```json
{
  "results": [
    {
      "sha256": "a1b2c3d4...",
      "score": 0.92,
      "matched_by": "vlm1",
      "matched_text": "一只橙色的猫坐在窗台上晒太阳"
    },
    {
      "sha256": "e5f6g7h8...",
      "score": 0.87,
      "matched_by": "human",
      "matched_text": "我家的猫咪"
    }
  ]
}
```

## 添加图片流程
```
1. 计算图片 SHA256，检查是否已存在（碰撞则拒绝）
         ↓
2. 创建目录结构 storage/xx/yy/sha256/
         ↓
3. 保存原始图片，生成缩略图(thumbnail.jpg)
         ↓
4. 提取元信息（尺寸、格式等）
         ↓
5. 写入 images 表，status = 'pending'
         ↓
6. 使用 SigLIP-2 计算图片嵌入，保存到 embedding/image.npy
         ↓
7. 追加到 siglip2_image 索引，记录到 vector_entries 表
         ↓
8. 更新 images 表，status = 'ready'
         ↓
9. （异步）调用 VLM 生成描述 → 保存到 description/
         ↓
10.（异步）使用 Qwen3-Embedding-4B 计算描述嵌入 → 保存到 embedding/
         ↓
11.（异步）追加到 qwen3_text 索引，更新 vector_entries 表
```

### 失败处理
- 步骤 1-8 任一环节失败，标记 status = 'failed'，记录错误日志
- 定期清理 status = 'failed' 的残留文件
- 异步任务（9-11）失败可重试，不影响图片主流程

## 删除图片流程
```
1. 标记 images 表中 is_deleted = 1（软删除）
   或直接删除记录（硬删除）
         ↓
2. 从 vector_entries 表删除相关记录
         ↓
3. 重建向量索引（或标记为无效，定期清理）
         ↓
4. 删除文件系统中的目录（可选，可延迟执行）
```

## 嵌入服务管理

### 设计目标
- 支持多种嵌入模型（CLIP、BGE、OpenAI 等）
- 支持多种部署方式（第三方 API、自建服务）
- 统一接口，业务代码无需关心具体实现
- 支持故障转移和负载均衡

### 服务配置表：embedding_services
| 字段 | 类型 | 说明 |
|------|------|------|
| id | TEXT | 服务标识（如 clip_local, bge_api） |
| model_type | TEXT | 模型类型（clip/bge/openai...） |
| model_name | TEXT | 具体模型名（如 ViT-B-32, bge-large-zh） |
| model_version | TEXT | 模型版本号 |
| service_type | TEXT | 服务类型（local/api） |
| endpoint | TEXT | API 地址（自建服务或第三方） |
| api_key | TEXT | API 密钥（加密存储，可为空） |
| dimension | INTEGER | 嵌入维度（如 768, 1024） |
| priority | INTEGER | 优先级（数字越小优先级越高） |
| is_enabled | INTEGER | 是否启用（0/1） |
| rate_limit | INTEGER | 请求频率限制（次/分钟，0表示无限制） |
| timeout | INTEGER | 超时时间（秒） |
| created_at | DATETIME | 创建时间 |

### 配置文件示例
```yaml
# config/embedding_services.yaml

services:
  # === SigLIP2 图片嵌入（本地服务，1.14B 最强版本） ===
  siglip2_local:
    model_name: siglip2-so400m-patch16-512
    model_version: "1.0"
    service_type: local
    endpoint: http://localhost:6010/embed/image
    dimension: 1152
    priority: 1
    timeout: 30

  # === Qwen3-4B 文本嵌入（复用 Z-Image-Turbo 的 text_encoder） ===
  qwen3_embed_local:
    model_name: Qwen3-4B
    model_version: "1.0"
    service_type: local
    endpoint: http://localhost:6011/embed/text
    dimension: 2560
    priority: 1
    timeout: 10
    # 注：使用倒数第二层 hidden_states[-2] 作为嵌入
```

### 索引与模型的绑定关系
```
向量索引目录                    绑定的模型                      维度
─────────────────────────────────────────────────────────────────
siglip2_image_v1/              siglip2-so400m-patch16-512      1152
qwen3_text_v1/                 Qwen3-4B v1.0                   2560
```

查询时：
1. 确定要搜索的索引（如 `qwen3_text_v1`）
2. 从 `meta.json` 读取该索引绑定的模型信息
3. 调用 `EmbeddingManager.get_service("Qwen3-Embedding-4B", "1.0")` 获取服务
4. 该模型有两个服务提供者，按优先级尝试（本地优先，失败用 API）

### 统一接口设计
```python
class EmbeddingService:
    """统一嵌入服务接口"""
    
    def embed_image(self, image_path: str) -> np.ndarray:
        """计算图片嵌入向量"""
        pass
    
    def embed_text(self, text: str) -> np.ndarray:
        """计算文本嵌入向量"""
        pass
    
    def embed_texts_batch(self, texts: list[str]) -> np.ndarray:
        """批量计算文本嵌入"""
        pass

class EmbeddingManager:
    """嵌入服务管理器"""
    
    def __init__(self, config_path: str):
        self.services = self._load_services(config_path)
    
    def get_service(self, model_name: str, model_version: str) -> EmbeddingService:
        """
        根据模型名称和版本获取服务
        同一模型可能有多个服务提供者（本地/API），按优先级故障转移
        """
        pass
    
    def get_service_for_index(self, index_name: str) -> EmbeddingService:
        """
        根据索引名称获取对应的嵌入服务
        索引 -> 模型映射关系在 vector_index/{index_name}/meta.json 中
        """
        pass
```

### 核心原则
- **索引与模型绑定**：每个向量索引绑定特定的 (model_name, model_version)
- **查询必须匹配**：查询时必须使用与索引相同的模型计算查询向量
- **同模型可多服务**：同一模型可配置多个服务提供者（本地 + API），用于故障转移

### 服务调用流程
```
请求嵌入计算（需指定 model_name + model_version）
     ↓
1. EmbeddingManager 查找该模型的所有可用服务
     ↓
2. 按优先级排序，过滤掉 is_enabled=0 的服务
     ↓
3. 依次尝试调用：
   ├── 检查频率限制
   ├── 发送请求（带超时）
   ├── 成功 → 返回结果
   └── 失败 → 记录日志，尝试下一个同模型服务
     ↓
4. 所有服务都失败 → 抛出异常，上层处理
```

### 健康检查
```
定时任务（每分钟）：
  对每个 is_enabled=1 的服务发送心跳请求
  ├── 响应正常 → 保持启用
  └── 连续失败3次 → 自动禁用，发送告警
```

### 自建服务接口规范
为了统一管理，自建服务需要遵循以下 API 规范：

```
POST /embed/image
Content-Type: multipart/form-data
Body: image file

Response:
{
  "embedding": [0.1, 0.2, ...],  // 嵌入向量
  "dimension": 512,
  "model": "ViT-B-32"
}

---

POST /embed/text
Content-Type: application/json
Body: {"text": "一只猫"}  或  {"texts": ["文本1", "文本2"]}

Response:
{
  "embeddings": [[0.1, 0.2, ...], ...],
  "dimension": 1024,
  "model": "bge-large-zh-v1.5"
}

---

GET /health
Response: {"status": "ok", "model": "...", "version": "..."}
```

## 图片管理服务 API

图片管理服务是核心服务，提供图片上传、查询、搜索等功能。

### 服务端口
| 服务 | 端口 | 说明 |
|------|------|------|
| 图片管理服务 | 6060 | 主服务 |
| 图片嵌入服务 | 6010 | SigLIP2 |
| 文本嵌入服务 | 6011 | Qwen3-4B（高精度，2560维） |
| 文本嵌入服务 | 6012 | BGE-large-zh（轻量，1024维） |

### 多嵌入处理

上传图片或添加描述时，会**同时使用所有启用的嵌入模型**：

```
添加描述 "一只猫在晒太阳"
         ↓
同时调用:
  ├── Qwen3-4B → 生成 2560 维嵌入 → 存入 qwen3_text_v1 索引
  └── BGE-large → 生成 1024 维嵌入 → 存入 bge_text_v1 索引
```

**搜索时默认使用所有索引，融合结果**：

```
搜索 "猫咪"
     ↓
同时在所有索引中搜索:
  ├── qwen3_text_v1 → 返回 top_k 结果（带 model="Qwen3-4B"）
  └── bge_text_v1 → 返回 top_k 结果（带 model="bge-large-zh"）
     ↓
按分数排序，同一图片去重（保留最高分），取 top_k
     ↓
返回结果（每条附带 index 和 model 信息）
```

也可以**指定单个索引**：
```bash
# 只用 BGE 索引搜索
curl -X POST http://localhost:6060/api/search/text \
  -H "Content-Type: application/json" \
  -d '{"query": "猫咪", "top_k": 10, "index": "bge_text_v1"}'
```

### API 接口列表

| 接口 | 方法 | 说明 |
|------|------|------|
| `/health` | GET | 健康检查 |
| `/api/stats` | GET | 统计信息 |
| `/api/indexes` | GET | 获取可用索引列表 |
| `/api/images` | POST | 上传图片 |
| `/api/images` | GET | 列出图片 |
| `/api/images/{sha256}` | GET | 获取图片信息 |
| `/api/images/{sha256}` | DELETE | 删除图片 |
| `/api/images/{sha256}/file` | GET | 获取原图 |
| `/api/images/{sha256}/thumbnail` | GET | 获取缩略图 |
| `/api/images/{sha256}/descriptions` | POST | 添加描述（多模型嵌入） |
| `/api/images/{sha256}/descriptions` | GET | 获取描述列表 |
| `/api/search/text` | POST | 文本搜索（可指定索引） |
| `/api/search/image` | POST | 以图搜图 |
| `/api/search/image/base64` | POST | 以图搜图（Base64） |

### 使用示例

#### 1. 上传图片

```bash
curl -X POST http://localhost:6060/api/images \
  -F "file=@image.jpg" \
  -F "source=my_album"
```

返回：
```json
{
  "message": "上传成功",
  "sha256": "62a8e8b2f2c090f754c0d1099fee3574",
  "width": 256,
  "height": 256,
  "file_size": 5851,
  "format": "PNG",
  "status": "ready"
}
```

#### 2. 获取图片信息

```bash
curl http://localhost:6060/api/images/62a8e8b2f2c090f754c0d1099fee3574
```

返回：
```json
{
  "sha256": "62a8e8b2f2c090f754c0d1099fee3574",
  "width": 256,
  "height": 256,
  "file_size": 5851,
  "format": "PNG",
  "created_at": "2025-12-21 10:01:47",
  "source": "test",
  "status": "ready",
  "is_deleted": 0,
  "descriptions": []
}
```

#### 3. 添加描述（多模型嵌入）

```bash
curl -X POST http://localhost:6060/api/images/62a8e8b2.../descriptions \
  -H "Content-Type: application/json" \
  -d '{"method": "human", "content": "游戏引擎的启动画面"}'
```

返回（同时使用多个嵌入模型）：
```json
{
  "message": "描述添加成功",
  "sha256": "62a8e8b2...",
  "method": "human",
  "embeddings": [
    {"model": "Qwen3-4B", "index": "qwen3_text_v1", "dimension": 2560},
    {"model": "bge-large-zh", "index": "bge_text_v1", "dimension": 1024}
  ],
  "embedding_count": 2
}
```

#### 4. 文本搜索（多索引融合）

```bash
# 不指定索引 → 使用所有嵌入模型搜索，合并结果
curl -X POST http://localhost:6060/api/search/text \
  -H "Content-Type: application/json" \
  -d '{"query": "游戏引擎启动画面", "top_k": 10}'

# 指定单个索引（只用 BGE）
curl -X POST http://localhost:6060/api/search/text \
  -H "Content-Type: application/json" \
  -d '{"query": "游戏引擎启动画面", "top_k": 10, "index": "bge_text_v1"}'
```

返回（不指定索引时，显示所有搜索的模型）：
```json
{
  "query": "游戏引擎启动画面",
  "indexes_searched": [
    {"index": "qwen3_text_v1", "model": "Qwen3-4B", "result_count": 5},
    {"index": "bge_text_v1", "model": "bge-large-zh", "result_count": 5}
  ],
  "results": [
    {
      "sha256": "62a8e8b2f2c090f754c0d1099fee3574",
      "score": 0.9954,
      "matched_by": "human",
      "matched_text": "游戏引擎的启动画面",
      "index": "qwen3_text_v1",
      "model": "Qwen3-4B",
      "width": 256,
      "height": 256
    }
  ]
}
```

#### 5. 以图搜图

```bash
curl -X POST http://localhost:6060/api/search/image \
  -F "file=@query.jpg" \
  -F "top_k=10"
```

返回：
```json
{
  "results": [
    {
      "sha256": "62a8e8b2f2c090f754c0d1099fee3574",
      "score": 1.0,
      "matched_by": "image",
      "width": 256,
      "height": 256
    }
  ]
}
```

#### 6. 列出图片

```bash
curl "http://localhost:6060/api/images?offset=0&limit=20&status=ready"
```

返回：
```json
{
  "images": [...],
  "total": 100,
  "offset": 0,
  "limit": 20
}
```

#### 7. 删除图片

```bash
# 软删除
curl -X DELETE http://localhost:6060/api/images/62a8e8b2...

# 硬删除（同时删除文件）
curl -X DELETE "http://localhost:6060/api/images/62a8e8b2...?hard=true"
```

#### 8. 健康检查

```bash
curl http://localhost:6060/health
```

返回：
```json
{
  "status": "ok",
  "database": "ok",
  "image_embedding_service": "ok",
  "text_embedding_service": "ok",
  "image_count": 2,
  "image_index_count": 1,
  "text_index_count": 1
}
```

### Python 调用示例

```python
import requests
import numpy as np

BASE_URL = "http://localhost:6060"

# 上传图片
def upload_image(image_path: str, source: str = None) -> dict:
    with open(image_path, "rb") as f:
        response = requests.post(
            f"{BASE_URL}/api/images",
            files={"file": f},
            data={"source": source} if source else {}
        )
    return response.json()

# 文本搜索
def search_by_text(query: str, top_k: int = 10) -> list:
    response = requests.post(
        f"{BASE_URL}/api/search/text",
        json={"query": query, "top_k": top_k}
    )
    return response.json()["results"]

# 以图搜图
def search_by_image(image_path: str, top_k: int = 10) -> list:
    with open(image_path, "rb") as f:
        response = requests.post(
            f"{BASE_URL}/api/search/image",
            files={"file": f},
            data={"top_k": top_k}
        )
    return response.json()["results"]

# 添加描述
def add_description(sha256: str, method: str, content: str) -> dict:
    response = requests.post(
        f"{BASE_URL}/api/images/{sha256}/descriptions",
        json={"method": method, "content": content}
    )
    return response.json()

# 获取缩略图
def get_thumbnail(sha256: str, save_path: str):
    response = requests.get(f"{BASE_URL}/api/images/{sha256}/thumbnail")
    with open(save_path, "wb") as f:
        f.write(response.content)

# 使用示例
result = upload_image("photo.jpg", source="album_2024")
print(f"上传成功: {result['sha256']}")

# 添加描述
add_description(result["sha256"], "human", "海边的日落风景")

# 搜索
results = search_by_text("日落风景")
for r in results:
    print(f"SHA256: {r['sha256']}, 得分: {r['score']:.4f}")
```

## 服务管理

### 服务架构

```
┌─────────────────────────────────────────────────────────────┐
│                        前端 (Vue)                            │
│                      http://localhost:5173                   │
└─────────────────────────┬───────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                   Node.js 后端 (Express)                     │
│                      http://localhost:3000                   │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  /api/imagemgr/*  →  代理到图片管理服务              │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────┬───────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│               Python 图片管理服务 (FastAPI)                  │
│                      http://localhost:6060                   │
└─────────────────────────┬───────────────────────────────────┘
                          │
          ┌───────────────┴───────────────┐
          ▼                               ▼
┌───────────────────────┐     ┌───────────────────────┐
│   图片嵌入服务         │     │   文本嵌入服务         │
│   SigLIP-2            │     │   Qwen3-4B            │
│   http://localhost:6010│     │   http://localhost:6011│
└───────────────────────┘     └───────────────────────┘
```

### 服务端口列表

| 服务 | 端口 | 技术栈 | 说明 |
|------|------|--------|------|
| 前端开发服务器 | 5173 | Vue + Vite | 用户界面 |
| Node.js 后端 | 3000 | Express | API 网关 |
| 图片管理服务 | 6060 | FastAPI | 核心服务 |
| 图片嵌入服务 | 6010 | FastAPI | SigLIP-2 模型 |
| 文本嵌入服务 | 6011 | FastAPI | Qwen3-4B 模型 |

### 部署模式（分布式）

将嵌入服务部署在 GPU 服务器，其他服务部署在本地电脑。

```
┌─────────────────────────────────┐     ┌─────────────────────────────────┐
│         本地电脑 (客户端)         │     │      GPU 服务器                  │
│                                 │     │                                 │
│  ./start_client.sh              │     │  只需要 aiserver/embedding/      │
│                                 │     │  ./start_embed_server.sh        │
│  ├─ 前端 (5173)                 │     │                                 │
│  ├─ Backend (3000) ─┐           │     │  ├─ 图片嵌入 (6010)              │
│  │                  │ 调用      │◄───►│  └─ 文本嵌入 (6011)              │
│  └─ imagemgr (6060)─┘           │     │                                 │
│                                 │     │                                 │
│  图片存储 (imagemgr/storage/)    │     │                                 │
└─────────────────────────────────┘     └─────────────────────────────────┘
```

### GPU 服务器部署

GPU 服务器只需要 `aiserver/embedding/` 目录：

```bash
# 方式一：只复制需要的目录
scp -r aiserver/embedding/ gpu-server:/path/to/embedding/

# 方式二：克隆整个仓库，但只运行嵌入服务
git clone <repo>
cd AIGenTest/aiserver/embedding
./start_embed_server.sh
```

**GPU 服务器目录结构：**
```
aiserver/embedding/
├── siglip2_embed.py      # 图片嵌入服务 (端口 6010)
├── qwen3_embed.py        # 文本嵌入服务 (端口 6011)
├── start_embed_server.sh # 启动脚本
├── stop_all.sh           # 停止脚本
└── logs/                 # 日志目录
```

**启动命令：**
```bash
./start_embed_server.sh
# 脚本会显示服务器 IP 地址，记下来给客户端配置
```

### 客户端部署（本地电脑）

```bash
# 1. 克隆仓库
git clone <repo>
cd AIGenTest

# 2. 复制配置模板
cp imagemgr/config/embedding_services_remote.yaml.example \
   imagemgr/config/embedding_services.yaml

# 3. 编辑配置，将 SERVER_IP 替换为 GPU 服务器 IP
vim imagemgr/config/embedding_services.yaml
# 例如：endpoint: http://192.168.1.100:6010

# 4. 安装依赖
cd backend && npm install
cd ../frontend && npm install

# 5. 启动客户端服务
./start_client.sh
```

**说明：**
- `backend` 启动时会自动启动 Python `imagemgr` 服务
- 只需运行 `./start_client.sh` 即可启动所有本地服务

**注意事项：**
- 确保 GPU 服务器防火墙开放 6010、6011 端口
- 远程调用超时已设置为 60 秒
- 如需公网访问，建议加上 API 密钥验证或使用 VPN

### 服务管理脚本

**客户端（本地电脑）：**

| 脚本 | 用途 |
|------|------|
| `./start_client.sh` | 启动 backend + imagemgr + 前端 |
| `./stop_all.sh` | 停止所有本地服务 |
| `./status.sh` | 查看服务状态 |

**GPU 服务器：**

| 脚本 | 用途 |
|------|------|
| `aiserver/embedding/start_embed_server.sh` | 启动嵌入服务 |
| `aiserver/embedding/stop_all.sh` | 停止嵌入服务 |

### 日志目录

| 服务 | 日志位置 |
|------|----------|
| 后端/前端 | `logs/` |
| 嵌入服务 | `aiserver/embedding/logs/` |
| 图片管理 | `imagemgr/logs/` |

### 单独启动（调试用）

```bash
# GPU 服务器：启动嵌入服务
cd aiserver/embedding
./start_embed_server.sh

# 客户端：启动 Node.js 后端（会自动启动 imagemgr）
cd backend
npm run dev

# 客户端：启动前端
cd frontend
npm run dev

# 查看 API 文档
open http://localhost:6060/docs
```

### 停止服务

```bash
# 客户端：停止所有本地服务
./stop_all.sh

# GPU 服务器：停止嵌入服务
cd aiserver/embedding
./stop_all.sh
```

## 数据管理

### 数据目录

以下目录包含运行时数据，不纳入版本控制：

| 目录 | 说明 |
|------|------|
| `imagemgr/storage/` | 图片文件存储 |
| `imagemgr/data/` | SQLite 数据库 |
| `imagemgr/vector_index/` | 向量索引文件 |
| `imagemgr/logs/` | 服务日志 |

### .gitignore 配置

```gitignore
# Python
__pycache__/
*.py[cod]

# 数据目录（保留 .gitkeep）
/storage/*
!/storage/.gitkeep
/data/*
!/data/.gitkeep
/vector_index/*
!/vector_index/.gitkeep
/logs/*
!/logs/.gitkeep
```

### 数据备份建议

- 定期备份 `imagemgr/data/images.db` 数据库文件
- 图片文件可通过 SHA256 哈希去重，无需全量备份
- 向量索引可重建，但建议备份以节省重建时间
